// revision: 066600aac9f4c93f1d4c37e1bb7c559beafb2b6c
// branch:   (HEAD
// Package xdr is generated from:
//
//  xdr/SCP.x
//  xdr/ledger-entries-account-KYC.x
//  xdr/ledger-entries-account-limits.x
//  xdr/ledger-entries-account-role.x
//  xdr/ledger-entries-account-rule.x
//  xdr/ledger-entries-account-specific-rule.x
//  xdr/ledger-entries-account.x
//  xdr/ledger-entries-asset-pair.x
//  xdr/ledger-entries-asset.x
//  xdr/ledger-entries-atomic-swap-ask.x
//  xdr/ledger-entries-balance.x
//  xdr/ledger-entries-contract.x
//  xdr/ledger-entries-data.x
//  xdr/ledger-entries-deferred-payment.x
//  xdr/ledger-entries-external-system-id-pool-entry.x
//  xdr/ledger-entries-external-system-id.x
//  xdr/ledger-entries-fee.x
//  xdr/ledger-entries-key-value.x
//  xdr/ledger-entries-license.x
//  xdr/ledger-entries-limits-v2.x
//  xdr/ledger-entries-offer.x
//  xdr/ledger-entries-pending-statistics.x
//  xdr/ledger-entries-poll.x
//  xdr/ledger-entries-reference.x
//  xdr/ledger-entries-reviewable-request.x
//  xdr/ledger-entries-sale.x
//  xdr/ledger-entries-signer-role.x
//  xdr/ledger-entries-signer-rule.x
//  xdr/ledger-entries-signer.x
//  xdr/ledger-entries-stamp.x
//  xdr/ledger-entries-statistics-v2.x
//  xdr/ledger-entries-statistics.x
//  xdr/ledger-entries-swap.x
//  xdr/ledger-entries-vote.x
//  xdr/ledger-entries.x
//  xdr/ledger-keys.x
//  xdr/ledger.x
//  xdr/operation-bind-external-system-id.x
//  xdr/operation-cancel-atomic-swap-ask.x
//  xdr/operation-cancel-change-role-request.x
//  xdr/operation-cancel-close-deferred-payment-request.x
//  xdr/operation-cancel-data-creation-request.x
//  xdr/operation-cancel-data-remove-request.x
//  xdr/operation-cancel-data-update-request.x
//  xdr/operation-cancel-deferred-payment-creation-request.x
//  xdr/operation-cancel-sale-creation-request.x
//  xdr/operation-check-sale-state.x
//  xdr/operation-close-swap.x
//  xdr/operation-create-AML-alert-request.x
//  xdr/operation-create-account.x
//  xdr/operation-create-atomic-swap-ask-request.x
//  xdr/operation-create-atomic-swap-bid-request.x
//  xdr/operation-create-change-role-request.x
//  xdr/operation-create-close-deferred-payment-request.x
//  xdr/operation-create-data-creation-request.x
//  xdr/operation-create-data-remove-request.x
//  xdr/operation-create-data-update-request.x
//  xdr/operation-create-data.x
//  xdr/operation-create-deferred-payment-creation-request.x
//  xdr/operation-create-issuance-request.x
//  xdr/operation-create-kyc-recovery-request.x
//  xdr/operation-create-manage-limits-request.x
//  xdr/operation-create-manage-offer-request.x
//  xdr/operation-create-payment-request.x
//  xdr/operation-create-preissuance-request.x
//  xdr/operation-create-redemption-request.x
//  xdr/operation-create-sale-creation-request.x
//  xdr/operation-create-withdrawal-request.x
//  xdr/operation-initiate-kyc-recovery.x
//  xdr/operation-license.x
//  xdr/operation-manage-account-role.x
//  xdr/operation-manage-account-rule.x
//  xdr/operation-manage-account-specific-rule.x
//  xdr/operation-manage-asset-pair.x
//  xdr/operation-manage-asset.x
//  xdr/operation-manage-balance.x
//  xdr/operation-manage-contract-request.x
//  xdr/operation-manage-contract.x
//  xdr/operation-manage-create-poll-request.x
//  xdr/operation-manage-external-system-id-pool-entry.x
//  xdr/operation-manage-invoice-request.x
//  xdr/operation-manage-key-value.x
//  xdr/operation-manage-limits.x
//  xdr/operation-manage-offer.x
//  xdr/operation-manage-poll.x
//  xdr/operation-manage-sale.x
//  xdr/operation-manage-signer-role.x
//  xdr/operation-manage-signer-rule.x
//  xdr/operation-manage-signer.x
//  xdr/operation-manage-vote.x
//  xdr/operation-open-swap.x
//  xdr/operation-payment.x
//  xdr/operation-payout.x
//  xdr/operation-remove-asset-pair.x
//  xdr/operation-remove-asset.x
//  xdr/operation-remove-data.x
//  xdr/operation-review-request.x
//  xdr/operation-set-fees.x
//  xdr/operation-stamp.x
//  xdr/operation-update-data.x
//  xdr/overlay.x
//  xdr/resource-account-rule.x
//  xdr/resource-signer-rule.x
//  xdr/reviewable-request-AML-alert.x
//  xdr/reviewable-request-asset.x
//  xdr/reviewable-request-atomic-swap-ask.x
//  xdr/reviewable-request-atomic-swap-bid.x
//  xdr/reviewable-request-change-role.x
//  xdr/reviewable-request-close-deferred-payment.x
//  xdr/reviewable-request-contract.x
//  xdr/reviewable-request-create-data.x
//  xdr/reviewable-request-create-deferred-payment.x
//  xdr/reviewable-request-create-poll.x
//  xdr/reviewable-request-invoice.x
//  xdr/reviewable-request-issuance.x
//  xdr/reviewable-request-kyc-recovery.x
//  xdr/reviewable-request-limits-update.x
//  xdr/reviewable-request-manage-offer.x
//  xdr/reviewable-request-payment.x
//  xdr/reviewable-request-redemption.x
//  xdr/reviewable-request-remove-data.x
//  xdr/reviewable-request-sale.x
//  xdr/reviewable-request-update-data.x
//  xdr/reviewable-request-update-sale-details.x
//  xdr/reviewable-request-withdrawal.x
//  xdr/transaction.x
//  xdr/types.x
//
// DO NOT EDIT or your changes may be overwritten
package xdr

import (
	"encoding/json"
	"fmt"
	"io"

	"github.com/nullstyle/go-xdr/xdr3"
)

// Unmarshal reads an xdr element from `r` into `v`.
func Unmarshal(r io.Reader, v interface{}) (int, error) {
	// delegate to xdr package's Unmarshal
	return xdr.Unmarshal(r, v)
}

// Marshal writes an xdr element `v` into `w`.
func Marshal(w io.Writer, v interface{}) (int, error) {
	// delegate to xdr package's Marshal
	return xdr.Marshal(w, v)
}

// Value is an XDR Typedef defines as:
//
//   typedef opaque Value<>;
//
type Value []byte

// ScpBallot is an XDR Struct defines as:
//
//   struct SCPBallot
//    {
//        uint32 counter; // n
//        Value value;    // x
//    };
//
type ScpBallot struct {
	Counter Uint32 `json:"counter,omitempty"`
	Value   Value  `json:"value,omitempty"`
}

// ScpStatementType is an XDR Enum defines as:
//
//   enum SCPStatementType
//    {
//        PREPARE = 0,
//        CONFIRM = 1,
//        EXTERNALIZE = 2,
//        NOMINATE = 3
//    };
//
type ScpStatementType int32

const (
	ScpStatementTypePrepare     ScpStatementType = 0
	ScpStatementTypeConfirm     ScpStatementType = 1
	ScpStatementTypeExternalize ScpStatementType = 2
	ScpStatementTypeNominate    ScpStatementType = 3
)

var ScpStatementTypeAll = []ScpStatementType{
	ScpStatementTypePrepare,
	ScpStatementTypeConfirm,
	ScpStatementTypeExternalize,
	ScpStatementTypeNominate,
}

var scpStatementTypeMap = map[int32]string{
	0: "ScpStatementTypePrepare",
	1: "ScpStatementTypeConfirm",
	2: "ScpStatementTypeExternalize",
	3: "ScpStatementTypeNominate",
}

var scpStatementTypeShortMap = map[int32]string{
	0: "prepare",
	1: "confirm",
	2: "externalize",
	3: "nominate",
}

var scpStatementTypeRevMap = map[string]int32{
	"ScpStatementTypePrepare":     0,
	"ScpStatementTypeConfirm":     1,
	"ScpStatementTypeExternalize": 2,
	"ScpStatementTypeNominate":    3,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ScpStatementType
func (e ScpStatementType) ValidEnum(v int32) bool {
	_, ok := scpStatementTypeMap[v]
	return ok
}
func (e ScpStatementType) isFlag() bool {
	for i := len(ScpStatementTypeAll) - 1; i >= 0; i-- {
		expected := ScpStatementType(2) << uint64(len(ScpStatementTypeAll)-1) >> uint64(len(ScpStatementTypeAll)-i)
		if expected != ScpStatementTypeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ScpStatementType) String() string {
	name, _ := scpStatementTypeMap[int32(e)]
	return name
}

func (e ScpStatementType) ShortString() string {
	name, _ := scpStatementTypeShortMap[int32(e)]
	return name
}

func (e ScpStatementType) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ScpStatementTypeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ScpStatementType) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ScpStatementType(t.Value)
	return nil
}

// ScpNomination is an XDR Struct defines as:
//
//   struct SCPNomination
//    {
//        Hash quorumSetHash; // D
//        Value votes<>;      // X
//        Value accepted<>;   // Y
//    };
//
type ScpNomination struct {
	QuorumSetHash Hash    `json:"quorumSetHash,omitempty"`
	Votes         []Value `json:"votes,omitempty"`
	Accepted      []Value `json:"accepted,omitempty"`
}

// ScpStatementPrepare is an XDR NestedStruct defines as:
//
//   struct
//            {
//                Hash quorumSetHash;       // D
//                SCPBallot ballot;         // b
//                SCPBallot* prepared;      // p
//                SCPBallot* preparedPrime; // p'
//                uint32 nC;                // c.n
//                uint32 nH;                // h.n
//            }
//
type ScpStatementPrepare struct {
	QuorumSetHash Hash       `json:"quorumSetHash,omitempty"`
	Ballot        ScpBallot  `json:"ballot,omitempty"`
	Prepared      *ScpBallot `json:"prepared,omitempty"`
	PreparedPrime *ScpBallot `json:"preparedPrime,omitempty"`
	NC            Uint32     `json:"nC,omitempty"`
	NH            Uint32     `json:"nH,omitempty"`
}

// ScpStatementConfirm is an XDR NestedStruct defines as:
//
//   struct
//            {
//                SCPBallot ballot;   // b
//                uint32 nPrepared;   // p.n
//                uint32 nCommit;     // c.n
//                uint32 nH;          // h.n
//                Hash quorumSetHash; // D
//            }
//
type ScpStatementConfirm struct {
	Ballot        ScpBallot `json:"ballot,omitempty"`
	NPrepared     Uint32    `json:"nPrepared,omitempty"`
	NCommit       Uint32    `json:"nCommit,omitempty"`
	NH            Uint32    `json:"nH,omitempty"`
	QuorumSetHash Hash      `json:"quorumSetHash,omitempty"`
}

// ScpStatementExternalize is an XDR NestedStruct defines as:
//
//   struct
//            {
//                SCPBallot commit;         // c
//                uint32 nH;                // h.n
//                Hash commitQuorumSetHash; // D used before EXTERNALIZE
//            }
//
type ScpStatementExternalize struct {
	Commit              ScpBallot `json:"commit,omitempty"`
	NH                  Uint32    `json:"nH,omitempty"`
	CommitQuorumSetHash Hash      `json:"commitQuorumSetHash,omitempty"`
}

// ScpStatementPledges is an XDR NestedUnion defines as:
//
//   union switch (SCPStatementType type)
//        {
//        case PREPARE:
//            struct
//            {
//                Hash quorumSetHash;       // D
//                SCPBallot ballot;         // b
//                SCPBallot* prepared;      // p
//                SCPBallot* preparedPrime; // p'
//                uint32 nC;                // c.n
//                uint32 nH;                // h.n
//            } prepare;
//        case CONFIRM:
//            struct
//            {
//                SCPBallot ballot;   // b
//                uint32 nPrepared;   // p.n
//                uint32 nCommit;     // c.n
//                uint32 nH;          // h.n
//                Hash quorumSetHash; // D
//            } confirm;
//        case EXTERNALIZE:
//            struct
//            {
//                SCPBallot commit;         // c
//                uint32 nH;                // h.n
//                Hash commitQuorumSetHash; // D used before EXTERNALIZE
//            } externalize;
//        case NOMINATE:
//            SCPNomination nominate;
//        }
//
type ScpStatementPledges struct {
	Type        ScpStatementType         `json:"type,omitempty"`
	Prepare     *ScpStatementPrepare     `json:"prepare,omitempty"`
	Confirm     *ScpStatementConfirm     `json:"confirm,omitempty"`
	Externalize *ScpStatementExternalize `json:"externalize,omitempty"`
	Nominate    *ScpNomination           `json:"nominate,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ScpStatementPledges) SwitchFieldName() string {
	return "Type"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ScpStatementPledges
func (u ScpStatementPledges) ArmForSwitch(sw int32) (string, bool) {
	switch ScpStatementType(sw) {
	case ScpStatementTypePrepare:
		return "Prepare", true
	case ScpStatementTypeConfirm:
		return "Confirm", true
	case ScpStatementTypeExternalize:
		return "Externalize", true
	case ScpStatementTypeNominate:
		return "Nominate", true
	}
	return "-", false
}

// NewScpStatementPledges creates a new  ScpStatementPledges.
func NewScpStatementPledges(aType ScpStatementType, value interface{}) (result ScpStatementPledges, err error) {
	result.Type = aType
	switch ScpStatementType(aType) {
	case ScpStatementTypePrepare:
		tv, ok := value.(ScpStatementPrepare)
		if !ok {
			err = fmt.Errorf("invalid value, must be ScpStatementPrepare")
			return
		}
		result.Prepare = &tv
	case ScpStatementTypeConfirm:
		tv, ok := value.(ScpStatementConfirm)
		if !ok {
			err = fmt.Errorf("invalid value, must be ScpStatementConfirm")
			return
		}
		result.Confirm = &tv
	case ScpStatementTypeExternalize:
		tv, ok := value.(ScpStatementExternalize)
		if !ok {
			err = fmt.Errorf("invalid value, must be ScpStatementExternalize")
			return
		}
		result.Externalize = &tv
	case ScpStatementTypeNominate:
		tv, ok := value.(ScpNomination)
		if !ok {
			err = fmt.Errorf("invalid value, must be ScpNomination")
			return
		}
		result.Nominate = &tv
	}
	return
}

// MustPrepare retrieves the Prepare value from the union,
// panicing if the value is not set.
func (u ScpStatementPledges) MustPrepare() ScpStatementPrepare {
	val, ok := u.GetPrepare()

	if !ok {
		panic("arm Prepare is not set")
	}

	return val
}

// GetPrepare retrieves the Prepare value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ScpStatementPledges) GetPrepare() (result ScpStatementPrepare, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Prepare" {
		result = *u.Prepare
		ok = true
	}

	return
}

// MustConfirm retrieves the Confirm value from the union,
// panicing if the value is not set.
func (u ScpStatementPledges) MustConfirm() ScpStatementConfirm {
	val, ok := u.GetConfirm()

	if !ok {
		panic("arm Confirm is not set")
	}

	return val
}

// GetConfirm retrieves the Confirm value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ScpStatementPledges) GetConfirm() (result ScpStatementConfirm, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Confirm" {
		result = *u.Confirm
		ok = true
	}

	return
}

// MustExternalize retrieves the Externalize value from the union,
// panicing if the value is not set.
func (u ScpStatementPledges) MustExternalize() ScpStatementExternalize {
	val, ok := u.GetExternalize()

	if !ok {
		panic("arm Externalize is not set")
	}

	return val
}

// GetExternalize retrieves the Externalize value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ScpStatementPledges) GetExternalize() (result ScpStatementExternalize, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Externalize" {
		result = *u.Externalize
		ok = true
	}

	return
}

// MustNominate retrieves the Nominate value from the union,
// panicing if the value is not set.
func (u ScpStatementPledges) MustNominate() ScpNomination {
	val, ok := u.GetNominate()

	if !ok {
		panic("arm Nominate is not set")
	}

	return val
}

// GetNominate retrieves the Nominate value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ScpStatementPledges) GetNominate() (result ScpNomination, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Nominate" {
		result = *u.Nominate
		ok = true
	}

	return
}

// ScpStatement is an XDR Struct defines as:
//
//   struct SCPStatement
//    {
//        NodeID nodeID;    // v
//        uint64 slotIndex; // i
//
//        union switch (SCPStatementType type)
//        {
//        case PREPARE:
//            struct
//            {
//                Hash quorumSetHash;       // D
//                SCPBallot ballot;         // b
//                SCPBallot* prepared;      // p
//                SCPBallot* preparedPrime; // p'
//                uint32 nC;                // c.n
//                uint32 nH;                // h.n
//            } prepare;
//        case CONFIRM:
//            struct
//            {
//                SCPBallot ballot;   // b
//                uint32 nPrepared;   // p.n
//                uint32 nCommit;     // c.n
//                uint32 nH;          // h.n
//                Hash quorumSetHash; // D
//            } confirm;
//        case EXTERNALIZE:
//            struct
//            {
//                SCPBallot commit;         // c
//                uint32 nH;                // h.n
//                Hash commitQuorumSetHash; // D used before EXTERNALIZE
//            } externalize;
//        case NOMINATE:
//            SCPNomination nominate;
//        }
//        pledges;
//    };
//
type ScpStatement struct {
	NodeId    NodeId              `json:"nodeID,omitempty"`
	SlotIndex Uint64              `json:"slotIndex,omitempty"`
	Pledges   ScpStatementPledges `json:"pledges,omitempty"`
}

// ScpEnvelope is an XDR Struct defines as:
//
//   struct SCPEnvelope
//    {
//        SCPStatement statement;
//        Signature signature;
//    };
//
type ScpEnvelope struct {
	Statement ScpStatement `json:"statement,omitempty"`
	Signature Signature    `json:"signature,omitempty"`
}

// ScpQuorumSet is an XDR Struct defines as:
//
//   struct SCPQuorumSet
//    {
//        uint32 threshold;
//        PublicKey validators<>;
//        SCPQuorumSet innerSets<>;
//    };
//
type ScpQuorumSet struct {
	Threshold  Uint32         `json:"threshold,omitempty"`
	Validators []PublicKey    `json:"validators,omitempty"`
	InnerSets  []ScpQuorumSet `json:"innerSets,omitempty"`
}

// AccountKycEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type AccountKycEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u AccountKycEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of AccountKycEntryExt
func (u AccountKycEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewAccountKycEntryExt creates a new  AccountKycEntryExt.
func NewAccountKycEntryExt(v LedgerVersion, value interface{}) (result AccountKycEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// AccountKycEntry is an XDR Struct defines as:
//
//   struct AccountKYCEntry
//    {
//        AccountID accountID;
//        longstring KYCData;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type AccountKycEntry struct {
	AccountId AccountId          `json:"accountID,omitempty"`
	KycData   Longstring         `json:"KYCData,omitempty"`
	Ext       AccountKycEntryExt `json:"ext,omitempty"`
}

// AccountLimitsEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type AccountLimitsEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u AccountLimitsEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of AccountLimitsEntryExt
func (u AccountLimitsEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewAccountLimitsEntryExt creates a new  AccountLimitsEntryExt.
func NewAccountLimitsEntryExt(v LedgerVersion, value interface{}) (result AccountLimitsEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// AccountLimitsEntry is an XDR Struct defines as:
//
//   struct AccountLimitsEntry
//    {
//        AccountID accountID;
//        Limits limits;
//
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type AccountLimitsEntry struct {
	AccountId AccountId             `json:"accountID,omitempty"`
	Limits    Limits                `json:"limits,omitempty"`
	Ext       AccountLimitsEntryExt `json:"ext,omitempty"`
}

// AccountRoleEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type AccountRoleEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u AccountRoleEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of AccountRoleEntryExt
func (u AccountRoleEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewAccountRoleEntryExt creates a new  AccountRoleEntryExt.
func NewAccountRoleEntryExt(v LedgerVersion, value interface{}) (result AccountRoleEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// AccountRoleEntry is an XDR Struct defines as:
//
//   struct AccountRoleEntry
//    {
//        uint64 id;
//
//        uint64 ruleIDs<>;
//
//        longstring details;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type AccountRoleEntry struct {
	Id      Uint64              `json:"id,omitempty"`
	RuleIDs []Uint64            `json:"ruleIDs,omitempty"`
	Details Longstring          `json:"details,omitempty"`
	Ext     AccountRoleEntryExt `json:"ext,omitempty"`
}

// AccountRuleEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type AccountRuleEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u AccountRuleEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of AccountRuleEntryExt
func (u AccountRuleEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewAccountRuleEntryExt creates a new  AccountRuleEntryExt.
func NewAccountRuleEntryExt(v LedgerVersion, value interface{}) (result AccountRuleEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// AccountRuleEntry is an XDR Struct defines as:
//
//   struct AccountRuleEntry
//    {
//        uint64 id;
//
//        AccountRuleResource resource;
//        AccountRuleAction action;
//
//        bool forbids;
//
//        longstring details;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type AccountRuleEntry struct {
	Id       Uint64              `json:"id,omitempty"`
	Resource AccountRuleResource `json:"resource,omitempty"`
	Action   AccountRuleAction   `json:"action,omitempty"`
	Forbids  bool                `json:"forbids,omitempty"`
	Details  Longstring          `json:"details,omitempty"`
	Ext      AccountRuleEntryExt `json:"ext,omitempty"`
}

// AccountSpecificRuleEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type AccountSpecificRuleEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u AccountSpecificRuleEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of AccountSpecificRuleEntryExt
func (u AccountSpecificRuleEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewAccountSpecificRuleEntryExt creates a new  AccountSpecificRuleEntryExt.
func NewAccountSpecificRuleEntryExt(v LedgerVersion, value interface{}) (result AccountSpecificRuleEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// AccountSpecificRuleEntry is an XDR Struct defines as:
//
//   struct AccountSpecificRuleEntry
//    {
//        uint64 id;
//
//        LedgerKey ledgerKey;
//        AccountID* accountID;
//        bool forbids;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type AccountSpecificRuleEntry struct {
	Id        Uint64                      `json:"id,omitempty"`
	LedgerKey LedgerKey                   `json:"ledgerKey,omitempty"`
	AccountId *AccountId                  `json:"accountID,omitempty"`
	Forbids   bool                        `json:"forbids,omitempty"`
	Ext       AccountSpecificRuleEntryExt `json:"ext,omitempty"`
}

// LimitsExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type LimitsExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LimitsExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LimitsExt
func (u LimitsExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLimitsExt creates a new  LimitsExt.
func NewLimitsExt(v LedgerVersion, value interface{}) (result LimitsExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// Limits is an XDR Struct defines as:
//
//   struct Limits
//    {
//        int64 dailyOut;
//        int64 weeklyOut;
//        int64 monthlyOut;
//        int64 annualOut;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type Limits struct {
	DailyOut   Int64     `json:"dailyOut,omitempty"`
	WeeklyOut  Int64     `json:"weeklyOut,omitempty"`
	MonthlyOut Int64     `json:"monthlyOut,omitempty"`
	AnnualOut  Int64     `json:"annualOut,omitempty"`
	Ext        LimitsExt `json:"ext,omitempty"`
}

// AccountEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type AccountEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u AccountEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of AccountEntryExt
func (u AccountEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewAccountEntryExt creates a new  AccountEntryExt.
func NewAccountEntryExt(v LedgerVersion, value interface{}) (result AccountEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// AccountEntry is an XDR Struct defines as:
//
//   struct AccountEntry
//    {
//        AccountID accountID;      // master public key for this account
//
//        // Referral marketing
//        AccountID* referrer; // parent account
//
//        // sequenctial ID - unique identifier of the account, used by ingesting applications to
//        // identify account, while keeping size of index small
//        uint64 sequentialID;
//
//    	uint64 roleID;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type AccountEntry struct {
	AccountId    AccountId       `json:"accountID,omitempty"`
	Referrer     *AccountId      `json:"referrer,omitempty"`
	SequentialId Uint64          `json:"sequentialID,omitempty"`
	RoleId       Uint64          `json:"roleID,omitempty"`
	Ext          AccountEntryExt `json:"ext,omitempty"`
}

// AssetPairPolicy is an XDR Enum defines as:
//
//   //: Policies that could be applied to AssetPair entry and define applicable operations for AssetPair
//    enum AssetPairPolicy
//    {
//        //: If not set pair can not be traded on secondary market
//    	TRADEABLE_SECONDARY_MARKET = 1,
//    	//: If set, then prices for new offers must be greater then physical price with correction
//    	PHYSICAL_PRICE_RESTRICTION = 2,
//    	//: if set, then price for new offers must be in interval of (1 Â± maxPriceStep)*currentPrice
//    	CURRENT_PRICE_RESTRICTION = 4
//    };
//
type AssetPairPolicy int32

const (
	AssetPairPolicyTradeableSecondaryMarket AssetPairPolicy = 1
	AssetPairPolicyPhysicalPriceRestriction AssetPairPolicy = 2
	AssetPairPolicyCurrentPriceRestriction  AssetPairPolicy = 4
)

var AssetPairPolicyAll = []AssetPairPolicy{
	AssetPairPolicyTradeableSecondaryMarket,
	AssetPairPolicyPhysicalPriceRestriction,
	AssetPairPolicyCurrentPriceRestriction,
}

var assetPairPolicyMap = map[int32]string{
	1: "AssetPairPolicyTradeableSecondaryMarket",
	2: "AssetPairPolicyPhysicalPriceRestriction",
	4: "AssetPairPolicyCurrentPriceRestriction",
}

var assetPairPolicyShortMap = map[int32]string{
	1: "tradeable_secondary_market",
	2: "physical_price_restriction",
	4: "current_price_restriction",
}

var assetPairPolicyRevMap = map[string]int32{
	"AssetPairPolicyTradeableSecondaryMarket": 1,
	"AssetPairPolicyPhysicalPriceRestriction": 2,
	"AssetPairPolicyCurrentPriceRestriction":  4,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for AssetPairPolicy
func (e AssetPairPolicy) ValidEnum(v int32) bool {
	_, ok := assetPairPolicyMap[v]
	return ok
}
func (e AssetPairPolicy) isFlag() bool {
	for i := len(AssetPairPolicyAll) - 1; i >= 0; i-- {
		expected := AssetPairPolicy(2) << uint64(len(AssetPairPolicyAll)-1) >> uint64(len(AssetPairPolicyAll)-i)
		if expected != AssetPairPolicyAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e AssetPairPolicy) String() string {
	name, _ := assetPairPolicyMap[int32(e)]
	return name
}

func (e AssetPairPolicy) ShortString() string {
	name, _ := assetPairPolicyShortMap[int32(e)]
	return name
}

func (e AssetPairPolicy) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range AssetPairPolicyAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *AssetPairPolicy) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = AssetPairPolicy(t.Value)
	return nil
}

// AssetPairEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type AssetPairEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u AssetPairEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of AssetPairEntryExt
func (u AssetPairEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewAssetPairEntryExt creates a new  AssetPairEntryExt.
func NewAssetPairEntryExt(v LedgerVersion, value interface{}) (result AssetPairEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// AssetPairEntry is an XDR Struct defines as:
//
//   //: `AssetPairEntry` is used in system to group different assets into pairs and set particular policies and properties for them
//    struct AssetPairEntry
//    {
//        //: Code of base asset of the asset pair
//        AssetCode base;
//        //: Code of quote asset of the asset pair
//        AssetCode quote;
//
//        //: defines an asset pair price as quote asset divided by base asset (i.e., amount of quote asset per 1 base asset)
//        int64 currentPrice;
//        //: Price of the asset pair assigned on creation. Can only be updated by application
//        //: the `ManageAssetPair` operation with action `UPDATE_PRICE`
//        int64 physicalPrice;
//
//        //: Price of the asset pair assigned on creation. Can only be updated by application
//        //: the `ManageAssetPair` operation with action `UPDATE_PRICE`
//        int64 physicalPriceCorrection;
//
//        //: Max price step in percent. User is allowed to set offer only if both of
//        //: `price < (1 - maxPriceStep) * currentPrice` and `price > (1 + maxPriceStep) * currentPrice` are `true`
//        int64 maxPriceStep;
//
//        //: Bitmask of asset policies set by creator or corrected by `ManageAssetPair` operations
//        int32 policies;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type AssetPairEntry struct {
	Base                    AssetCode         `json:"base,omitempty"`
	Quote                   AssetCode         `json:"quote,omitempty"`
	CurrentPrice            Int64             `json:"currentPrice,omitempty"`
	PhysicalPrice           Int64             `json:"physicalPrice,omitempty"`
	PhysicalPriceCorrection Int64             `json:"physicalPriceCorrection,omitempty"`
	MaxPriceStep            Int64             `json:"maxPriceStep,omitempty"`
	Policies                Int32             `json:"policies,omitempty"`
	Ext                     AssetPairEntryExt `json:"ext,omitempty"`
}

// AssetPolicy is an XDR Enum defines as:
//
//   enum AssetPolicy
//    {
//        //: Defines whether or not asset can be transfered using payments
//    	TRANSFERABLE = 1,
//    	//: Defines whether or not asset is considered base
//    	BASE_ASSET = 2,
//    	//: [[Deprecated]]
//    	STATS_QUOTE_ASSET = 4,
//    	//: Defines whether or not asset can be withdrawed from the system
//    	WITHDRAWABLE = 8,
//    	//: Defines whether or not manual review for issuance of asset is required
//    	ISSUANCE_MANUAL_REVIEW_REQUIRED = 16,
//    	//: Defines whether or not asset can be base in atomic swap
//    	CAN_BE_BASE_IN_ATOMIC_SWAP = 32,
//    	//: Defines whether or not asset can be quote in atomic swap
//    	CAN_BE_QUOTE_IN_ATOMIC_SWAP = 64,
//        SWAPPABLE = 128
//    };
//
type AssetPolicy int32

const (
	AssetPolicyTransferable                 AssetPolicy = 1
	AssetPolicyBaseAsset                    AssetPolicy = 2
	AssetPolicyStatsQuoteAsset              AssetPolicy = 4
	AssetPolicyWithdrawable                 AssetPolicy = 8
	AssetPolicyIssuanceManualReviewRequired AssetPolicy = 16
	AssetPolicyCanBeBaseInAtomicSwap        AssetPolicy = 32
	AssetPolicyCanBeQuoteInAtomicSwap       AssetPolicy = 64
	AssetPolicySwappable                    AssetPolicy = 128
)

var AssetPolicyAll = []AssetPolicy{
	AssetPolicyTransferable,
	AssetPolicyBaseAsset,
	AssetPolicyStatsQuoteAsset,
	AssetPolicyWithdrawable,
	AssetPolicyIssuanceManualReviewRequired,
	AssetPolicyCanBeBaseInAtomicSwap,
	AssetPolicyCanBeQuoteInAtomicSwap,
	AssetPolicySwappable,
}

var assetPolicyMap = map[int32]string{
	1:   "AssetPolicyTransferable",
	2:   "AssetPolicyBaseAsset",
	4:   "AssetPolicyStatsQuoteAsset",
	8:   "AssetPolicyWithdrawable",
	16:  "AssetPolicyIssuanceManualReviewRequired",
	32:  "AssetPolicyCanBeBaseInAtomicSwap",
	64:  "AssetPolicyCanBeQuoteInAtomicSwap",
	128: "AssetPolicySwappable",
}

var assetPolicyShortMap = map[int32]string{
	1:   "transferable",
	2:   "base_asset",
	4:   "stats_quote_asset",
	8:   "withdrawable",
	16:  "issuance_manual_review_required",
	32:  "can_be_base_in_atomic_swap",
	64:  "can_be_quote_in_atomic_swap",
	128: "swappable",
}

var assetPolicyRevMap = map[string]int32{
	"AssetPolicyTransferable":                 1,
	"AssetPolicyBaseAsset":                    2,
	"AssetPolicyStatsQuoteAsset":              4,
	"AssetPolicyWithdrawable":                 8,
	"AssetPolicyIssuanceManualReviewRequired": 16,
	"AssetPolicyCanBeBaseInAtomicSwap":        32,
	"AssetPolicyCanBeQuoteInAtomicSwap":       64,
	"AssetPolicySwappable":                    128,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for AssetPolicy
func (e AssetPolicy) ValidEnum(v int32) bool {
	_, ok := assetPolicyMap[v]
	return ok
}
func (e AssetPolicy) isFlag() bool {
	for i := len(AssetPolicyAll) - 1; i >= 0; i-- {
		expected := AssetPolicy(2) << uint64(len(AssetPolicyAll)-1) >> uint64(len(AssetPolicyAll)-i)
		if expected != AssetPolicyAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e AssetPolicy) String() string {
	name, _ := assetPolicyMap[int32(e)]
	return name
}

func (e AssetPolicy) ShortString() string {
	name, _ := assetPolicyShortMap[int32(e)]
	return name
}

func (e AssetPolicy) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range AssetPolicyAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *AssetPolicy) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = AssetPolicy(t.Value)
	return nil
}

// AssetEntry is an XDR Struct defines as:
//
//   struct AssetEntry
//    {
//        //: Code of the asset
//        AssetCode code;
//        //: Owner(creator) of the asset
//    	AccountID owner;
//    	//: Account responsible for preissuance of the asset
//    	AccountID preissuedAssetSigner;
//        //: Arbitrary stringified JSON object that can be used to attach data to asset
//    	longstring details;
//    	//: Maximal amount of tokens that can be issued
//    	uint64 maxIssuanceAmount;
//    	//: Amount of tokens available for issuance
//    	uint64 availableForIssueance;
//    	//: Amount of tokens issued already
//    	uint64 issued;
//    	//: Amount of tokens to be issued which is locked. `pendingIssuance+issued <= maxIssuanceAmount`
//    	uint64 pendingIssuance;
//    	//: Policies of the asset
//        uint32 policies;
//        //: Used to restrict usage. Used in account rules
//        uint64 type;
//        //: Number of decimal places. Must be <= 6
//        uint32 trailingDigitsCount;
//
//        //: Reserved for future use
//        EmptyExt ext;
//    };
//
type AssetEntry struct {
	Code                  AssetCode  `json:"code,omitempty"`
	Owner                 AccountId  `json:"owner,omitempty"`
	PreissuedAssetSigner  AccountId  `json:"preissuedAssetSigner,omitempty"`
	Details               Longstring `json:"details,omitempty"`
	MaxIssuanceAmount     Uint64     `json:"maxIssuanceAmount,omitempty"`
	AvailableForIssueance Uint64     `json:"availableForIssueance,omitempty"`
	Issued                Uint64     `json:"issued,omitempty"`
	PendingIssuance       Uint64     `json:"pendingIssuance,omitempty"`
	Policies              Uint32     `json:"policies,omitempty"`
	Type                  Uint64     `json:"type,omitempty"`
	TrailingDigitsCount   Uint32     `json:"trailingDigitsCount,omitempty"`
	Ext                   EmptyExt   `json:"ext,omitempty"`
}

// AtomicSwapAskQuoteAssetExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type AtomicSwapAskQuoteAssetExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u AtomicSwapAskQuoteAssetExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of AtomicSwapAskQuoteAssetExt
func (u AtomicSwapAskQuoteAssetExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewAtomicSwapAskQuoteAssetExt creates a new  AtomicSwapAskQuoteAssetExt.
func NewAtomicSwapAskQuoteAssetExt(v LedgerVersion, value interface{}) (result AtomicSwapAskQuoteAssetExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// AtomicSwapAskQuoteAsset is an XDR Struct defines as:
//
//   //: AtomicSwapAskQuoteAsset represents asset with price which can be used to buy base asset
//    struct AtomicSwapAskQuoteAsset
//    {
//        //: Code of quote asset
//        AssetCode quoteAsset;
//        //: amount of quote asset which is needed to buy one base asset
//        uint64 price;
//        //: reserved for the future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type AtomicSwapAskQuoteAsset struct {
	QuoteAsset AssetCode                  `json:"quoteAsset,omitempty"`
	Price      Uint64                     `json:"price,omitempty"`
	Ext        AtomicSwapAskQuoteAssetExt `json:"ext,omitempty"`
}

// AtomicSwapAskEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type AtomicSwapAskEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u AtomicSwapAskEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of AtomicSwapAskEntryExt
func (u AtomicSwapAskEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewAtomicSwapAskEntryExt creates a new  AtomicSwapAskEntryExt.
func NewAtomicSwapAskEntryExt(v LedgerVersion, value interface{}) (result AtomicSwapAskEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// AtomicSwapAskEntry is an XDR Struct defines as:
//
//   struct AtomicSwapAskEntry
//    {
//        uint64 id;
//        AccountID ownerID;
//        AssetCode baseAsset;
//        BalanceID baseBalance;
//        uint64 amount;
//        uint64 lockedAmount;
//        uint64 createdAt;
//
//        bool isCancelled;
//
//        longstring details;
//
//        AtomicSwapAskQuoteAsset quoteAssets<>;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type AtomicSwapAskEntry struct {
	Id           Uint64                    `json:"id,omitempty"`
	OwnerId      AccountId                 `json:"ownerID,omitempty"`
	BaseAsset    AssetCode                 `json:"baseAsset,omitempty"`
	BaseBalance  BalanceId                 `json:"baseBalance,omitempty"`
	Amount       Uint64                    `json:"amount,omitempty"`
	LockedAmount Uint64                    `json:"lockedAmount,omitempty"`
	CreatedAt    Uint64                    `json:"createdAt,omitempty"`
	IsCancelled  bool                      `json:"isCancelled,omitempty"`
	Details      Longstring                `json:"details,omitempty"`
	QuoteAssets  []AtomicSwapAskQuoteAsset `json:"quoteAssets,omitempty"`
	Ext          AtomicSwapAskEntryExt     `json:"ext,omitempty"`
}

// BalanceEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type BalanceEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u BalanceEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of BalanceEntryExt
func (u BalanceEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewBalanceEntryExt creates a new  BalanceEntryExt.
func NewBalanceEntryExt(v LedgerVersion, value interface{}) (result BalanceEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// BalanceEntry is an XDR Struct defines as:
//
//   struct BalanceEntry
//    {
//        BalanceID balanceID;
//    	// sequential ID - unique identifier of the balance, used by ingesting applications to
//    	// identify account, while keeping size of index small
//        uint64 sequentialID;
//        AssetCode asset;
//        AccountID accountID;
//        uint64 amount;
//        uint64 locked;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type BalanceEntry struct {
	BalanceId    BalanceId       `json:"balanceID,omitempty"`
	SequentialId Uint64          `json:"sequentialID,omitempty"`
	Asset        AssetCode       `json:"asset,omitempty"`
	AccountId    AccountId       `json:"accountID,omitempty"`
	Amount       Uint64          `json:"amount,omitempty"`
	Locked       Uint64          `json:"locked,omitempty"`
	Ext          BalanceEntryExt `json:"ext,omitempty"`
}

// ContractState is an XDR Enum defines as:
//
//   enum ContractState
//    {
//        NO_CONFIRMATIONS = 0,
//        CUSTOMER_CONFIRMED = 1,
//        CONTRACTOR_CONFIRMED = 2,
//        DISPUTING = 4,
//        REVERTING_RESOLVE = 8,
//        NOT_REVERTING_RESOLVE = 16
//    };
//
type ContractState int32

const (
	ContractStateNoConfirmations     ContractState = 0
	ContractStateCustomerConfirmed   ContractState = 1
	ContractStateContractorConfirmed ContractState = 2
	ContractStateDisputing           ContractState = 4
	ContractStateRevertingResolve    ContractState = 8
	ContractStateNotRevertingResolve ContractState = 16
)

var ContractStateAll = []ContractState{
	ContractStateNoConfirmations,
	ContractStateCustomerConfirmed,
	ContractStateContractorConfirmed,
	ContractStateDisputing,
	ContractStateRevertingResolve,
	ContractStateNotRevertingResolve,
}

var contractStateMap = map[int32]string{
	0:  "ContractStateNoConfirmations",
	1:  "ContractStateCustomerConfirmed",
	2:  "ContractStateContractorConfirmed",
	4:  "ContractStateDisputing",
	8:  "ContractStateRevertingResolve",
	16: "ContractStateNotRevertingResolve",
}

var contractStateShortMap = map[int32]string{
	0:  "no_confirmations",
	1:  "customer_confirmed",
	2:  "contractor_confirmed",
	4:  "disputing",
	8:  "reverting_resolve",
	16: "not_reverting_resolve",
}

var contractStateRevMap = map[string]int32{
	"ContractStateNoConfirmations":     0,
	"ContractStateCustomerConfirmed":   1,
	"ContractStateContractorConfirmed": 2,
	"ContractStateDisputing":           4,
	"ContractStateRevertingResolve":    8,
	"ContractStateNotRevertingResolve": 16,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ContractState
func (e ContractState) ValidEnum(v int32) bool {
	_, ok := contractStateMap[v]
	return ok
}
func (e ContractState) isFlag() bool {
	for i := len(ContractStateAll) - 1; i >= 0; i-- {
		expected := ContractState(2) << uint64(len(ContractStateAll)-1) >> uint64(len(ContractStateAll)-i)
		if expected != ContractStateAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ContractState) String() string {
	name, _ := contractStateMap[int32(e)]
	return name
}

func (e ContractState) ShortString() string {
	name, _ := contractStateShortMap[int32(e)]
	return name
}

func (e ContractState) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ContractStateAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ContractState) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ContractState(t.Value)
	return nil
}

// ContractEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ContractEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ContractEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ContractEntryExt
func (u ContractEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewContractEntryExt creates a new  ContractEntryExt.
func NewContractEntryExt(v LedgerVersion, value interface{}) (result ContractEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ContractEntry is an XDR Struct defines as:
//
//   struct ContractEntry
//    {
//        uint64 contractID;
//
//        AccountID contractor;
//        AccountID customer;
//        AccountID escrow;
//
//        uint64 startTime;
//        uint64 endTime;
//        uint64 invoiceRequestsIDs<>;
//        longstring initialDetails;
//
//        uint32 state;
//        longstring customerDetails;
//
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ContractEntry struct {
	ContractId         Uint64           `json:"contractID,omitempty"`
	Contractor         AccountId        `json:"contractor,omitempty"`
	Customer           AccountId        `json:"customer,omitempty"`
	Escrow             AccountId        `json:"escrow,omitempty"`
	StartTime          Uint64           `json:"startTime,omitempty"`
	EndTime            Uint64           `json:"endTime,omitempty"`
	InvoiceRequestsIDs []Uint64         `json:"invoiceRequestsIDs,omitempty"`
	InitialDetails     Longstring       `json:"initialDetails,omitempty"`
	State              Uint32           `json:"state,omitempty"`
	CustomerDetails    Longstring       `json:"customerDetails,omitempty"`
	Ext                ContractEntryExt `json:"ext,omitempty"`
}

// DataEntry is an XDR Struct defines as:
//
//   struct DataEntry
//    {
//        //: ID of the data entry
//        uint64 id;
//        //: Numeric type, used for access control
//        uint64 type;
//        //: Value stored
//        longstring value;
//
//        //: Creator of the entry
//        AccountID owner;
//        //: Reserved for future extension
//        EmptyExt ext;
//    };
//
type DataEntry struct {
	Id    Uint64     `json:"id,omitempty"`
	Type  Uint64     `json:"type,omitempty"`
	Value Longstring `json:"value,omitempty"`
	Owner AccountId  `json:"owner,omitempty"`
	Ext   EmptyExt   `json:"ext,omitempty"`
}

// DeferredPaymentEntry is an XDR Struct defines as:
//
//   struct DeferredPaymentEntry
//    {
//        //: ID of the deferred payment entry
//        uint64 id;
//
//        uint64 amount;
//
//        longstring details;
//
//        //: Creator of the entry
//        AccountID source;
//        BalanceID sourceBalance;
//
//        AccountID destination;
//
//        //: Reserved for future extension
//        EmptyExt ext;
//    };
//
type DeferredPaymentEntry struct {
	Id            Uint64     `json:"id,omitempty"`
	Amount        Uint64     `json:"amount,omitempty"`
	Details       Longstring `json:"details,omitempty"`
	Source        AccountId  `json:"source,omitempty"`
	SourceBalance BalanceId  `json:"sourceBalance,omitempty"`
	Destination   AccountId  `json:"destination,omitempty"`
	Ext           EmptyExt   `json:"ext,omitempty"`
}

// ExternalSystemAccountIdPoolEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//           void;
//        }
//
type ExternalSystemAccountIdPoolEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ExternalSystemAccountIdPoolEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ExternalSystemAccountIdPoolEntryExt
func (u ExternalSystemAccountIdPoolEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewExternalSystemAccountIdPoolEntryExt creates a new  ExternalSystemAccountIdPoolEntryExt.
func NewExternalSystemAccountIdPoolEntryExt(v LedgerVersion, value interface{}) (result ExternalSystemAccountIdPoolEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ExternalSystemAccountIdPoolEntry is an XDR Struct defines as:
//
//   struct ExternalSystemAccountIDPoolEntry
//    {
//        uint64 poolEntryID;
//        int32 externalSystemType;
//        longstring data;
//        AccountID* accountID;
//        uint64 expiresAt;
//        uint64 bindedAt;
//        uint64 parent;
//        bool isDeleted;
//
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//           void;
//        }
//        ext;
//    };
//
type ExternalSystemAccountIdPoolEntry struct {
	PoolEntryId        Uint64                              `json:"poolEntryID,omitempty"`
	ExternalSystemType Int32                               `json:"externalSystemType,omitempty"`
	Data               Longstring                          `json:"data,omitempty"`
	AccountId          *AccountId                          `json:"accountID,omitempty"`
	ExpiresAt          Uint64                              `json:"expiresAt,omitempty"`
	BindedAt           Uint64                              `json:"bindedAt,omitempty"`
	Parent             Uint64                              `json:"parent,omitempty"`
	IsDeleted          bool                                `json:"isDeleted,omitempty"`
	Ext                ExternalSystemAccountIdPoolEntryExt `json:"ext,omitempty"`
}

// ExternalSystemAccountIdExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ExternalSystemAccountIdExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ExternalSystemAccountIdExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ExternalSystemAccountIdExt
func (u ExternalSystemAccountIdExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewExternalSystemAccountIdExt creates a new  ExternalSystemAccountIdExt.
func NewExternalSystemAccountIdExt(v LedgerVersion, value interface{}) (result ExternalSystemAccountIdExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ExternalSystemAccountId is an XDR Struct defines as:
//
//   struct ExternalSystemAccountID
//    {
//        AccountID accountID;
//        int32 externalSystemType;
//    	longstring data;
//
//    	 // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ExternalSystemAccountId struct {
	AccountId          AccountId                  `json:"accountID,omitempty"`
	ExternalSystemType Int32                      `json:"externalSystemType,omitempty"`
	Data               Longstring                 `json:"data,omitempty"`
	Ext                ExternalSystemAccountIdExt `json:"ext,omitempty"`
}

// FeeType is an XDR Enum defines as:
//
//   //: `FeeType` represents different types of fees for different operations (e.g. fee charged on withdrawal or on investment)
//    enum FeeType
//    {
//        PAYMENT_FEE = 0,
//        OFFER_FEE = 1,
//        WITHDRAWAL_FEE = 2,
//        ISSUANCE_FEE = 3,
//        INVEST_FEE = 4, // fee to be taken while creating the sale participation
//        CAPITAL_DEPLOYMENT_FEE = 5, // fee to be taken when the sale closes
//        OPERATION_FEE = 6,
//        PAYOUT_FEE = 7,
//        ATOMIC_SWAP_SALE_FEE = 8,
//        ATOMIC_SWAP_PURCHASE_FEE = 9,
//        SWAP_FEE = 10
//    };
//
type FeeType int32

const (
	FeeTypePaymentFee            FeeType = 0
	FeeTypeOfferFee              FeeType = 1
	FeeTypeWithdrawalFee         FeeType = 2
	FeeTypeIssuanceFee           FeeType = 3
	FeeTypeInvestFee             FeeType = 4
	FeeTypeCapitalDeploymentFee  FeeType = 5
	FeeTypeOperationFee          FeeType = 6
	FeeTypePayoutFee             FeeType = 7
	FeeTypeAtomicSwapSaleFee     FeeType = 8
	FeeTypeAtomicSwapPurchaseFee FeeType = 9
	FeeTypeSwapFee               FeeType = 10
)

var FeeTypeAll = []FeeType{
	FeeTypePaymentFee,
	FeeTypeOfferFee,
	FeeTypeWithdrawalFee,
	FeeTypeIssuanceFee,
	FeeTypeInvestFee,
	FeeTypeCapitalDeploymentFee,
	FeeTypeOperationFee,
	FeeTypePayoutFee,
	FeeTypeAtomicSwapSaleFee,
	FeeTypeAtomicSwapPurchaseFee,
	FeeTypeSwapFee,
}

var feeTypeMap = map[int32]string{
	0:  "FeeTypePaymentFee",
	1:  "FeeTypeOfferFee",
	2:  "FeeTypeWithdrawalFee",
	3:  "FeeTypeIssuanceFee",
	4:  "FeeTypeInvestFee",
	5:  "FeeTypeCapitalDeploymentFee",
	6:  "FeeTypeOperationFee",
	7:  "FeeTypePayoutFee",
	8:  "FeeTypeAtomicSwapSaleFee",
	9:  "FeeTypeAtomicSwapPurchaseFee",
	10: "FeeTypeSwapFee",
}

var feeTypeShortMap = map[int32]string{
	0:  "payment_fee",
	1:  "offer_fee",
	2:  "withdrawal_fee",
	3:  "issuance_fee",
	4:  "invest_fee",
	5:  "capital_deployment_fee",
	6:  "operation_fee",
	7:  "payout_fee",
	8:  "atomic_swap_sale_fee",
	9:  "atomic_swap_purchase_fee",
	10: "swap_fee",
}

var feeTypeRevMap = map[string]int32{
	"FeeTypePaymentFee":            0,
	"FeeTypeOfferFee":              1,
	"FeeTypeWithdrawalFee":         2,
	"FeeTypeIssuanceFee":           3,
	"FeeTypeInvestFee":             4,
	"FeeTypeCapitalDeploymentFee":  5,
	"FeeTypeOperationFee":          6,
	"FeeTypePayoutFee":             7,
	"FeeTypeAtomicSwapSaleFee":     8,
	"FeeTypeAtomicSwapPurchaseFee": 9,
	"FeeTypeSwapFee":               10,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for FeeType
func (e FeeType) ValidEnum(v int32) bool {
	_, ok := feeTypeMap[v]
	return ok
}
func (e FeeType) isFlag() bool {
	for i := len(FeeTypeAll) - 1; i >= 0; i-- {
		expected := FeeType(2) << uint64(len(FeeTypeAll)-1) >> uint64(len(FeeTypeAll)-i)
		if expected != FeeTypeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e FeeType) String() string {
	name, _ := feeTypeMap[int32(e)]
	return name
}

func (e FeeType) ShortString() string {
	name, _ := feeTypeShortMap[int32(e)]
	return name
}

func (e FeeType) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range FeeTypeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *FeeType) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = FeeType(t.Value)
	return nil
}

// EmissionFeeType is an XDR Enum defines as:
//
//   //: (not used) `EmissionFeeType` is a subtype of `ISSUANCE_FEE`
//    enum EmissionFeeType
//    {
//        PRIMARY_MARKET = 1,
//        SECONDARY_MARKET = 2
//    };
//
type EmissionFeeType int32

const (
	EmissionFeeTypePrimaryMarket   EmissionFeeType = 1
	EmissionFeeTypeSecondaryMarket EmissionFeeType = 2
)

var EmissionFeeTypeAll = []EmissionFeeType{
	EmissionFeeTypePrimaryMarket,
	EmissionFeeTypeSecondaryMarket,
}

var emissionFeeTypeMap = map[int32]string{
	1: "EmissionFeeTypePrimaryMarket",
	2: "EmissionFeeTypeSecondaryMarket",
}

var emissionFeeTypeShortMap = map[int32]string{
	1: "primary_market",
	2: "secondary_market",
}

var emissionFeeTypeRevMap = map[string]int32{
	"EmissionFeeTypePrimaryMarket":   1,
	"EmissionFeeTypeSecondaryMarket": 2,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for EmissionFeeType
func (e EmissionFeeType) ValidEnum(v int32) bool {
	_, ok := emissionFeeTypeMap[v]
	return ok
}
func (e EmissionFeeType) isFlag() bool {
	for i := len(EmissionFeeTypeAll) - 1; i >= 0; i-- {
		expected := EmissionFeeType(2) << uint64(len(EmissionFeeTypeAll)-1) >> uint64(len(EmissionFeeTypeAll)-i)
		if expected != EmissionFeeTypeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e EmissionFeeType) String() string {
	name, _ := emissionFeeTypeMap[int32(e)]
	return name
}

func (e EmissionFeeType) ShortString() string {
	name, _ := emissionFeeTypeShortMap[int32(e)]
	return name
}

func (e EmissionFeeType) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range EmissionFeeTypeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *EmissionFeeType) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = EmissionFeeType(t.Value)
	return nil
}

// PaymentFeeType is an XDR Enum defines as:
//
//   //: `PaymentFeeType` is a subtype of the Fee used for payments
//    enum PaymentFeeType
//    {
//        OUTGOING = 1,
//        INCOMING = 2
//    };
//
type PaymentFeeType int32

const (
	PaymentFeeTypeOutgoing PaymentFeeType = 1
	PaymentFeeTypeIncoming PaymentFeeType = 2
)

var PaymentFeeTypeAll = []PaymentFeeType{
	PaymentFeeTypeOutgoing,
	PaymentFeeTypeIncoming,
}

var paymentFeeTypeMap = map[int32]string{
	1: "PaymentFeeTypeOutgoing",
	2: "PaymentFeeTypeIncoming",
}

var paymentFeeTypeShortMap = map[int32]string{
	1: "outgoing",
	2: "incoming",
}

var paymentFeeTypeRevMap = map[string]int32{
	"PaymentFeeTypeOutgoing": 1,
	"PaymentFeeTypeIncoming": 2,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for PaymentFeeType
func (e PaymentFeeType) ValidEnum(v int32) bool {
	_, ok := paymentFeeTypeMap[v]
	return ok
}
func (e PaymentFeeType) isFlag() bool {
	for i := len(PaymentFeeTypeAll) - 1; i >= 0; i-- {
		expected := PaymentFeeType(2) << uint64(len(PaymentFeeTypeAll)-1) >> uint64(len(PaymentFeeTypeAll)-i)
		if expected != PaymentFeeTypeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e PaymentFeeType) String() string {
	name, _ := paymentFeeTypeMap[int32(e)]
	return name
}

func (e PaymentFeeType) ShortString() string {
	name, _ := paymentFeeTypeShortMap[int32(e)]
	return name
}

func (e PaymentFeeType) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range PaymentFeeTypeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *PaymentFeeType) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = PaymentFeeType(t.Value)
	return nil
}

// FeeEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type FeeEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u FeeEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of FeeEntryExt
func (u FeeEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewFeeEntryExt creates a new  FeeEntryExt.
func NewFeeEntryExt(v LedgerVersion, value interface{}) (result FeeEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// FeeEntry is an XDR Struct defines as:
//
//   //: `FeeEntry` is used in the system configuration to set fees for different assets, operations (according to FeeType), particular account roles, particular accounts,
//    //: or globally (only if both parameters particular account role and paticular account are not specified).
//    struct FeeEntry
//    {
//        //: Type of a particular fee depending on the operation (e.g., PAYMENT_FEE for payment operation, WITHDRAWAL_FEE for withdrawal operation, etc.)
//        FeeType feeType;
//        //: Code of an asset used in the operation for which the fee will be charged
//        AssetCode asset;
//
//        //: Fixed amount of fee that will be charged for the operation
//        int64 fixedFee;
//        //: Percent from the operation amount that will be charged for the corresponding operation
//        int64 percentFee;
//
//        //: (optional) Account for which a fee is set in the system
//        AccountID* accountID;
//        //: (optional) Account for which a fee is set in the system
//        uint64*    accountRole;
//        //: Defines a `subtype` of a fee if such exists (e.g., `OUTGOING` or `INCOMING` for `PAYMENT_FEE`)
//        int64 subtype;
//
//        //: Defines the lower bound of operation amount for which this fee is applicable
//        int64 lowerBound;
//        //: Defines the upper bound of operation amount for which this fee is applicable
//        int64 upperBound;
//
//        //: Hash of `type:<feeType>asset:<asset>subtype:<subtype>`
//        //: (Add `accountID:<accountID>` or `accountRole:<accountRole>` if corresponding fields are defined)
//        Hash hash;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type FeeEntry struct {
	FeeType     FeeType     `json:"feeType,omitempty"`
	Asset       AssetCode   `json:"asset,omitempty"`
	FixedFee    Int64       `json:"fixedFee,omitempty"`
	PercentFee  Int64       `json:"percentFee,omitempty"`
	AccountId   *AccountId  `json:"accountID,omitempty"`
	AccountRole *Uint64     `json:"accountRole,omitempty"`
	Subtype     Int64       `json:"subtype,omitempty"`
	LowerBound  Int64       `json:"lowerBound,omitempty"`
	UpperBound  Int64       `json:"upperBound,omitempty"`
	Hash        Hash        `json:"hash,omitempty"`
	Ext         FeeEntryExt `json:"ext,omitempty"`
}

// KeyValueEntryType is an XDR Enum defines as:
//
//   //: `KeyValueEntryType` defines the type of value in the key-value entry
//        enum KeyValueEntryType
//        {
//            UINT32 = 1,
//            STRING = 2,
//            UINT64 = 3
//        };
//
type KeyValueEntryType int32

const (
	KeyValueEntryTypeUint32 KeyValueEntryType = 1
	KeyValueEntryTypeString KeyValueEntryType = 2
	KeyValueEntryTypeUint64 KeyValueEntryType = 3
)

var KeyValueEntryTypeAll = []KeyValueEntryType{
	KeyValueEntryTypeUint32,
	KeyValueEntryTypeString,
	KeyValueEntryTypeUint64,
}

var keyValueEntryTypeMap = map[int32]string{
	1: "KeyValueEntryTypeUint32",
	2: "KeyValueEntryTypeString",
	3: "KeyValueEntryTypeUint64",
}

var keyValueEntryTypeShortMap = map[int32]string{
	1: "uint32",
	2: "string",
	3: "uint64",
}

var keyValueEntryTypeRevMap = map[string]int32{
	"KeyValueEntryTypeUint32": 1,
	"KeyValueEntryTypeString": 2,
	"KeyValueEntryTypeUint64": 3,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for KeyValueEntryType
func (e KeyValueEntryType) ValidEnum(v int32) bool {
	_, ok := keyValueEntryTypeMap[v]
	return ok
}
func (e KeyValueEntryType) isFlag() bool {
	for i := len(KeyValueEntryTypeAll) - 1; i >= 0; i-- {
		expected := KeyValueEntryType(2) << uint64(len(KeyValueEntryTypeAll)-1) >> uint64(len(KeyValueEntryTypeAll)-i)
		if expected != KeyValueEntryTypeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e KeyValueEntryType) String() string {
	name, _ := keyValueEntryTypeMap[int32(e)]
	return name
}

func (e KeyValueEntryType) ShortString() string {
	name, _ := keyValueEntryTypeShortMap[int32(e)]
	return name
}

func (e KeyValueEntryType) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range KeyValueEntryTypeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *KeyValueEntryType) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = KeyValueEntryType(t.Value)
	return nil
}

// KeyValueEntryValue is an XDR Union defines as:
//
//   //: `KeyValueEntryValue` represents the value based on given `KeyValueEntryType`
//        union KeyValueEntryValue switch (KeyValueEntryType type)
//        {
//            case UINT32:
//                uint32 ui32Value;
//            case STRING:
//                string stringValue<>;
//            case UINT64:
//                uint64 ui64Value;
//        };
//
type KeyValueEntryValue struct {
	Type        KeyValueEntryType `json:"type,omitempty"`
	Ui32Value   *Uint32           `json:"ui32Value,omitempty"`
	StringValue *string           `json:"stringValue,omitempty"`
	Ui64Value   *Uint64           `json:"ui64Value,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u KeyValueEntryValue) SwitchFieldName() string {
	return "Type"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of KeyValueEntryValue
func (u KeyValueEntryValue) ArmForSwitch(sw int32) (string, bool) {
	switch KeyValueEntryType(sw) {
	case KeyValueEntryTypeUint32:
		return "Ui32Value", true
	case KeyValueEntryTypeString:
		return "StringValue", true
	case KeyValueEntryTypeUint64:
		return "Ui64Value", true
	}
	return "-", false
}

// NewKeyValueEntryValue creates a new  KeyValueEntryValue.
func NewKeyValueEntryValue(aType KeyValueEntryType, value interface{}) (result KeyValueEntryValue, err error) {
	result.Type = aType
	switch KeyValueEntryType(aType) {
	case KeyValueEntryTypeUint32:
		tv, ok := value.(Uint32)
		if !ok {
			err = fmt.Errorf("invalid value, must be Uint32")
			return
		}
		result.Ui32Value = &tv
	case KeyValueEntryTypeString:
		tv, ok := value.(string)
		if !ok {
			err = fmt.Errorf("invalid value, must be string")
			return
		}
		result.StringValue = &tv
	case KeyValueEntryTypeUint64:
		tv, ok := value.(Uint64)
		if !ok {
			err = fmt.Errorf("invalid value, must be Uint64")
			return
		}
		result.Ui64Value = &tv
	}
	return
}

// MustUi32Value retrieves the Ui32Value value from the union,
// panicing if the value is not set.
func (u KeyValueEntryValue) MustUi32Value() Uint32 {
	val, ok := u.GetUi32Value()

	if !ok {
		panic("arm Ui32Value is not set")
	}

	return val
}

// GetUi32Value retrieves the Ui32Value value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u KeyValueEntryValue) GetUi32Value() (result Uint32, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Ui32Value" {
		result = *u.Ui32Value
		ok = true
	}

	return
}

// MustStringValue retrieves the StringValue value from the union,
// panicing if the value is not set.
func (u KeyValueEntryValue) MustStringValue() string {
	val, ok := u.GetStringValue()

	if !ok {
		panic("arm StringValue is not set")
	}

	return val
}

// GetStringValue retrieves the StringValue value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u KeyValueEntryValue) GetStringValue() (result string, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "StringValue" {
		result = *u.StringValue
		ok = true
	}

	return
}

// MustUi64Value retrieves the Ui64Value value from the union,
// panicing if the value is not set.
func (u KeyValueEntryValue) MustUi64Value() Uint64 {
	val, ok := u.GetUi64Value()

	if !ok {
		panic("arm Ui64Value is not set")
	}

	return val
}

// GetUi64Value retrieves the Ui64Value value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u KeyValueEntryValue) GetUi64Value() (result Uint64, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Ui64Value" {
		result = *u.Ui64Value
		ok = true
	}

	return
}

// KeyValueEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//                case EMPTY_VERSION:
//                    void;
//            }
//
type KeyValueEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u KeyValueEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of KeyValueEntryExt
func (u KeyValueEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewKeyValueEntryExt creates a new  KeyValueEntryExt.
func NewKeyValueEntryExt(v LedgerVersion, value interface{}) (result KeyValueEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// KeyValueEntry is an XDR Struct defines as:
//
//   //: `KeyValueEntry` is an entry used to store key mapped values
//        struct KeyValueEntry
//        {
//            //: String value that must be unique among other keys for kev-value pairs
//            longstring key;
//
//            //: Value that corresponds to particular key (depending on `KeyValueEntryType`,
//            //: the value can be either uint32, or uint64, or string)
//            KeyValueEntryValue value;
//
//            //: reserved for future use
//            union switch (LedgerVersion v)
//            {
//                case EMPTY_VERSION:
//                    void;
//            }
//            ext;
//        };
//
type KeyValueEntry struct {
	Key   Longstring         `json:"key,omitempty"`
	Value KeyValueEntryValue `json:"value,omitempty"`
	Ext   KeyValueEntryExt   `json:"ext,omitempty"`
}

// LicenseEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type LicenseEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LicenseEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LicenseEntryExt
func (u LicenseEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLicenseEntryExt creates a new  LicenseEntryExt.
func NewLicenseEntryExt(v LedgerVersion, value interface{}) (result LicenseEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LicenseEntry is an XDR Struct defines as:
//
//   struct LicenseEntry
//    {
//        uint64 adminCount;
//        uint64 dueDate;
//        Hash ledgerHash;
//        Hash prevLicenseHash;
//        DecoratedSignature signatures<>;
//
//         // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type LicenseEntry struct {
	AdminCount      Uint64               `json:"adminCount,omitempty"`
	DueDate         Uint64               `json:"dueDate,omitempty"`
	LedgerHash      Hash                 `json:"ledgerHash,omitempty"`
	PrevLicenseHash Hash                 `json:"prevLicenseHash,omitempty"`
	Signatures      []DecoratedSignature `json:"signatures,omitempty"`
	Ext             LicenseEntryExt      `json:"ext,omitempty"`
}

// StatsOpType is an XDR Enum defines as:
//
//   //: `StatsOpType` is a type of operation for which statistics is maintained
//    enum StatsOpType
//    {
//        PAYMENT_OUT = 1,
//        WITHDRAW = 2,
//        SPEND = 3,
//        DEPOSIT = 4,
//        PAYOUT = 5
//    };
//
type StatsOpType int32

const (
	StatsOpTypePaymentOut StatsOpType = 1
	StatsOpTypeWithdraw   StatsOpType = 2
	StatsOpTypeSpend      StatsOpType = 3
	StatsOpTypeDeposit    StatsOpType = 4
	StatsOpTypePayout     StatsOpType = 5
)

var StatsOpTypeAll = []StatsOpType{
	StatsOpTypePaymentOut,
	StatsOpTypeWithdraw,
	StatsOpTypeSpend,
	StatsOpTypeDeposit,
	StatsOpTypePayout,
}

var statsOpTypeMap = map[int32]string{
	1: "StatsOpTypePaymentOut",
	2: "StatsOpTypeWithdraw",
	3: "StatsOpTypeSpend",
	4: "StatsOpTypeDeposit",
	5: "StatsOpTypePayout",
}

var statsOpTypeShortMap = map[int32]string{
	1: "payment_out",
	2: "withdraw",
	3: "spend",
	4: "deposit",
	5: "payout",
}

var statsOpTypeRevMap = map[string]int32{
	"StatsOpTypePaymentOut": 1,
	"StatsOpTypeWithdraw":   2,
	"StatsOpTypeSpend":      3,
	"StatsOpTypeDeposit":    4,
	"StatsOpTypePayout":     5,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for StatsOpType
func (e StatsOpType) ValidEnum(v int32) bool {
	_, ok := statsOpTypeMap[v]
	return ok
}
func (e StatsOpType) isFlag() bool {
	for i := len(StatsOpTypeAll) - 1; i >= 0; i-- {
		expected := StatsOpType(2) << uint64(len(StatsOpTypeAll)-1) >> uint64(len(StatsOpTypeAll)-i)
		if expected != StatsOpTypeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e StatsOpType) String() string {
	name, _ := statsOpTypeMap[int32(e)]
	return name
}

func (e StatsOpType) ShortString() string {
	name, _ := statsOpTypeShortMap[int32(e)]
	return name
}

func (e StatsOpType) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range StatsOpTypeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *StatsOpType) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = StatsOpType(t.Value)
	return nil
}

// LimitsV2EntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type LimitsV2EntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LimitsV2EntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LimitsV2EntryExt
func (u LimitsV2EntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLimitsV2EntryExt creates a new  LimitsV2EntryExt.
func NewLimitsV2EntryExt(v LedgerVersion, value interface{}) (result LimitsV2EntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LimitsV2Entry is an XDR Struct defines as:
//
//   //: `LimitsV2Entry` is used in the system configuration to set limits (daily, weekly, montly, annual)
//    //: for different assets, operations (according to StatsOpType), particular account roles, particular accounts,
//    //: or globally (only if both parameters particular account role and paticular account are not specified),
//    struct LimitsV2Entry
//    {
//        //: ID of limits entry
//        uint64      id;
//        //: (optional) ID of an account role that will be imposed with limits
//        uint64*     accountRole;
//        //: (optional) ID of an account that will be imposed with limits
//        AccountID*  accountID;
//        //: Operation type that will be imposed with limits. See `enum StatsOpType`
//        StatsOpType statsOpType;
//        //: Asset that will be imposed with limits
//        AssetCode   assetCode;
//        //: `isConvertNeeded` indicates whether or not the asset conversion is needed for the limits entry.
//        //: If this field is `true`, limits are applied to all balances of an account (to every asset that account owns).
//        //: Otherwise, limits from particular limits entry are applied only to  balances with `AssetCode` provided by entry.
//        bool        isConvertNeeded;
//
//        //: daily out limit
//        uint64 dailyOut;
//        //: weekly out limit
//        uint64 weeklyOut;
//        //: monthly out limit
//        uint64 monthlyOut;
//        //: annual out limit
//        uint64 annualOut;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type LimitsV2Entry struct {
	Id              Uint64           `json:"id,omitempty"`
	AccountRole     *Uint64          `json:"accountRole,omitempty"`
	AccountId       *AccountId       `json:"accountID,omitempty"`
	StatsOpType     StatsOpType      `json:"statsOpType,omitempty"`
	AssetCode       AssetCode        `json:"assetCode,omitempty"`
	IsConvertNeeded bool             `json:"isConvertNeeded,omitempty"`
	DailyOut        Uint64           `json:"dailyOut,omitempty"`
	WeeklyOut       Uint64           `json:"weeklyOut,omitempty"`
	MonthlyOut      Uint64           `json:"monthlyOut,omitempty"`
	AnnualOut       Uint64           `json:"annualOut,omitempty"`
	Ext             LimitsV2EntryExt `json:"ext,omitempty"`
}

// OfferEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type OfferEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u OfferEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of OfferEntryExt
func (u OfferEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewOfferEntryExt creates a new  OfferEntryExt.
func NewOfferEntryExt(v LedgerVersion, value interface{}) (result OfferEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// OfferEntry is an XDR Struct defines as:
//
//   struct OfferEntry
//    {
//        uint64 offerID;
//    	uint64 orderBookID;
//    	AccountID ownerID;
//    	bool isBuy;
//        AssetCode base; // A
//        AssetCode quote;  // B
//    	BalanceID baseBalance;
//    	BalanceID quoteBalance;
//        int64 baseAmount;
//    	int64 quoteAmount;
//    	uint64 createdAt;
//    	int64 fee;
//
//        int64 percentFee;
//
//    	// price of A in terms of B
//        int64 price;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type OfferEntry struct {
	OfferId      Uint64        `json:"offerID,omitempty"`
	OrderBookId  Uint64        `json:"orderBookID,omitempty"`
	OwnerId      AccountId     `json:"ownerID,omitempty"`
	IsBuy        bool          `json:"isBuy,omitempty"`
	Base         AssetCode     `json:"base,omitempty"`
	Quote        AssetCode     `json:"quote,omitempty"`
	BaseBalance  BalanceId     `json:"baseBalance,omitempty"`
	QuoteBalance BalanceId     `json:"quoteBalance,omitempty"`
	BaseAmount   Int64         `json:"baseAmount,omitempty"`
	QuoteAmount  Int64         `json:"quoteAmount,omitempty"`
	CreatedAt    Uint64        `json:"createdAt,omitempty"`
	Fee          Int64         `json:"fee,omitempty"`
	PercentFee   Int64         `json:"percentFee,omitempty"`
	Price        Int64         `json:"price,omitempty"`
	Ext          OfferEntryExt `json:"ext,omitempty"`
}

// PendingStatisticsEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type PendingStatisticsEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u PendingStatisticsEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of PendingStatisticsEntryExt
func (u PendingStatisticsEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewPendingStatisticsEntryExt creates a new  PendingStatisticsEntryExt.
func NewPendingStatisticsEntryExt(v LedgerVersion, value interface{}) (result PendingStatisticsEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// PendingStatisticsEntry is an XDR Struct defines as:
//
//   struct PendingStatisticsEntry
//    {
//        uint64 statisticsID;
//        uint64 requestID;
//        uint64 amount;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type PendingStatisticsEntry struct {
	StatisticsId Uint64                    `json:"statisticsID,omitempty"`
	RequestId    Uint64                    `json:"requestID,omitempty"`
	Amount       Uint64                    `json:"amount,omitempty"`
	Ext          PendingStatisticsEntryExt `json:"ext,omitempty"`
}

// PollType is an XDR Enum defines as:
//
//   //: Functional type of poll
//    enum PollType
//    {
//        SINGLE_CHOICE = 0
//    };
//
type PollType int32

const (
	PollTypeSingleChoice PollType = 0
)

var PollTypeAll = []PollType{
	PollTypeSingleChoice,
}

var pollTypeMap = map[int32]string{
	0: "PollTypeSingleChoice",
}

var pollTypeShortMap = map[int32]string{
	0: "single_choice",
}

var pollTypeRevMap = map[string]int32{
	"PollTypeSingleChoice": 0,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for PollType
func (e PollType) ValidEnum(v int32) bool {
	_, ok := pollTypeMap[v]
	return ok
}
func (e PollType) isFlag() bool {
	for i := len(PollTypeAll) - 1; i >= 0; i-- {
		expected := PollType(2) << uint64(len(PollTypeAll)-1) >> uint64(len(PollTypeAll)-i)
		if expected != PollTypeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e PollType) String() string {
	name, _ := pollTypeMap[int32(e)]
	return name
}

func (e PollType) ShortString() string {
	name, _ := pollTypeShortMap[int32(e)]
	return name
}

func (e PollType) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range PollTypeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *PollType) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = PollType(t.Value)
	return nil
}

// PollData is an XDR Union defines as:
//
//   //: PollData is used to pass `PollType` with necessary params
//    union PollData switch (PollType type)
//    {
//    case SINGLE_CHOICE:
//        EmptyExt ext;
//    };
//
type PollData struct {
	Type PollType  `json:"type,omitempty"`
	Ext  *EmptyExt `json:"ext,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u PollData) SwitchFieldName() string {
	return "Type"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of PollData
func (u PollData) ArmForSwitch(sw int32) (string, bool) {
	switch PollType(sw) {
	case PollTypeSingleChoice:
		return "Ext", true
	}
	return "-", false
}

// NewPollData creates a new  PollData.
func NewPollData(aType PollType, value interface{}) (result PollData, err error) {
	result.Type = aType
	switch PollType(aType) {
	case PollTypeSingleChoice:
		tv, ok := value.(EmptyExt)
		if !ok {
			err = fmt.Errorf("invalid value, must be EmptyExt")
			return
		}
		result.Ext = &tv
	}
	return
}

// MustExt retrieves the Ext value from the union,
// panicing if the value is not set.
func (u PollData) MustExt() EmptyExt {
	val, ok := u.GetExt()

	if !ok {
		panic("arm Ext is not set")
	}

	return val
}

// GetExt retrieves the Ext value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u PollData) GetExt() (result EmptyExt, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Ext" {
		result = *u.Ext
		ok = true
	}

	return
}

// PollEntry is an XDR Struct defines as:
//
//   struct PollEntry
//    {
//        uint64 id;
//        uint32 permissionType;
//
//        uint32 numberOfChoices;
//        PollData data;
//
//        uint64 startTime;
//        uint64 endTime;
//
//        AccountID ownerID;
//        AccountID resultProviderID;
//
//        bool voteConfirmationRequired;
//
//        longstring details;
//
//        EmptyExt ext;
//    };
//
type PollEntry struct {
	Id                       Uint64     `json:"id,omitempty"`
	PermissionType           Uint32     `json:"permissionType,omitempty"`
	NumberOfChoices          Uint32     `json:"numberOfChoices,omitempty"`
	Data                     PollData   `json:"data,omitempty"`
	StartTime                Uint64     `json:"startTime,omitempty"`
	EndTime                  Uint64     `json:"endTime,omitempty"`
	OwnerId                  AccountId  `json:"ownerID,omitempty"`
	ResultProviderId         AccountId  `json:"resultProviderID,omitempty"`
	VoteConfirmationRequired bool       `json:"voteConfirmationRequired,omitempty"`
	Details                  Longstring `json:"details,omitempty"`
	Ext                      EmptyExt   `json:"ext,omitempty"`
}

// ReferenceEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ReferenceEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ReferenceEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ReferenceEntryExt
func (u ReferenceEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewReferenceEntryExt creates a new  ReferenceEntryExt.
func NewReferenceEntryExt(v LedgerVersion, value interface{}) (result ReferenceEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ReferenceEntry is an XDR Struct defines as:
//
//   struct ReferenceEntry
//    {
//    	AccountID sender;
//        string64 reference;
//
//    	// reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ReferenceEntry struct {
	Sender    AccountId         `json:"sender,omitempty"`
	Reference String64          `json:"reference,omitempty"`
	Ext       ReferenceEntryExt `json:"ext,omitempty"`
}

// ReviewableRequestType is an XDR Enum defines as:
//
//   enum ReviewableRequestType
//    {
//    	NONE = 0, // use this request type in ReviewRequestOp extended result if additional info is not required
//    	ANY = 1,
//    	CREATE_PRE_ISSUANCE = 2,
//    	CREATE_ISSUANCE = 3,
//    	CREATE_WITHDRAW = 4,
//    	CREATE_SALE = 5,
//    	UPDATE_LIMITS = 6,
//        CREATE_AML_ALERT = 7,
//    	CHANGE_ROLE = 8,
//    	UPDATE_SALE_DETAILS = 9,
//    	CREATE_ASSET = 10,
//    	CREATE_INVOICE = 11,
//    	MANAGE_CONTRACT = 12,
//    	UPDATE_ASSET = 13,
//    	CREATE_POLL = 14,
//    	CREATE_ATOMIC_SWAP_ASK = 16,
//    	CREATE_ATOMIC_SWAP_BID = 17,
//    	KYC_RECOVERY = 18,
//    	MANAGE_OFFER = 19,
//    	CREATE_PAYMENT = 20,
//    	PERFORM_REDEMPTION = 21,
//    	DATA_CREATION = 22,
//    	DATA_UPDATE = 23,
//    	DATA_REMOVE = 24,
//    	CREATE_DEFERRED_PAYMENT = 25,
//        CLOSE_DEFERRED_PAYMENT = 26
//    };
//
type ReviewableRequestType int32

const (
	ReviewableRequestTypeNone                  ReviewableRequestType = 0
	ReviewableRequestTypeAny                   ReviewableRequestType = 1
	ReviewableRequestTypeCreatePreIssuance     ReviewableRequestType = 2
	ReviewableRequestTypeCreateIssuance        ReviewableRequestType = 3
	ReviewableRequestTypeCreateWithdraw        ReviewableRequestType = 4
	ReviewableRequestTypeCreateSale            ReviewableRequestType = 5
	ReviewableRequestTypeUpdateLimits          ReviewableRequestType = 6
	ReviewableRequestTypeCreateAmlAlert        ReviewableRequestType = 7
	ReviewableRequestTypeChangeRole            ReviewableRequestType = 8
	ReviewableRequestTypeUpdateSaleDetails     ReviewableRequestType = 9
	ReviewableRequestTypeCreateAsset           ReviewableRequestType = 10
	ReviewableRequestTypeCreateInvoice         ReviewableRequestType = 11
	ReviewableRequestTypeManageContract        ReviewableRequestType = 12
	ReviewableRequestTypeUpdateAsset           ReviewableRequestType = 13
	ReviewableRequestTypeCreatePoll            ReviewableRequestType = 14
	ReviewableRequestTypeCreateAtomicSwapAsk   ReviewableRequestType = 16
	ReviewableRequestTypeCreateAtomicSwapBid   ReviewableRequestType = 17
	ReviewableRequestTypeKycRecovery           ReviewableRequestType = 18
	ReviewableRequestTypeManageOffer           ReviewableRequestType = 19
	ReviewableRequestTypeCreatePayment         ReviewableRequestType = 20
	ReviewableRequestTypePerformRedemption     ReviewableRequestType = 21
	ReviewableRequestTypeDataCreation          ReviewableRequestType = 22
	ReviewableRequestTypeDataUpdate            ReviewableRequestType = 23
	ReviewableRequestTypeDataRemove            ReviewableRequestType = 24
	ReviewableRequestTypeCreateDeferredPayment ReviewableRequestType = 25
	ReviewableRequestTypeCloseDeferredPayment  ReviewableRequestType = 26
)

var ReviewableRequestTypeAll = []ReviewableRequestType{
	ReviewableRequestTypeNone,
	ReviewableRequestTypeAny,
	ReviewableRequestTypeCreatePreIssuance,
	ReviewableRequestTypeCreateIssuance,
	ReviewableRequestTypeCreateWithdraw,
	ReviewableRequestTypeCreateSale,
	ReviewableRequestTypeUpdateLimits,
	ReviewableRequestTypeCreateAmlAlert,
	ReviewableRequestTypeChangeRole,
	ReviewableRequestTypeUpdateSaleDetails,
	ReviewableRequestTypeCreateAsset,
	ReviewableRequestTypeCreateInvoice,
	ReviewableRequestTypeManageContract,
	ReviewableRequestTypeUpdateAsset,
	ReviewableRequestTypeCreatePoll,
	ReviewableRequestTypeCreateAtomicSwapAsk,
	ReviewableRequestTypeCreateAtomicSwapBid,
	ReviewableRequestTypeKycRecovery,
	ReviewableRequestTypeManageOffer,
	ReviewableRequestTypeCreatePayment,
	ReviewableRequestTypePerformRedemption,
	ReviewableRequestTypeDataCreation,
	ReviewableRequestTypeDataUpdate,
	ReviewableRequestTypeDataRemove,
	ReviewableRequestTypeCreateDeferredPayment,
	ReviewableRequestTypeCloseDeferredPayment,
}

var reviewableRequestTypeMap = map[int32]string{
	0:  "ReviewableRequestTypeNone",
	1:  "ReviewableRequestTypeAny",
	2:  "ReviewableRequestTypeCreatePreIssuance",
	3:  "ReviewableRequestTypeCreateIssuance",
	4:  "ReviewableRequestTypeCreateWithdraw",
	5:  "ReviewableRequestTypeCreateSale",
	6:  "ReviewableRequestTypeUpdateLimits",
	7:  "ReviewableRequestTypeCreateAmlAlert",
	8:  "ReviewableRequestTypeChangeRole",
	9:  "ReviewableRequestTypeUpdateSaleDetails",
	10: "ReviewableRequestTypeCreateAsset",
	11: "ReviewableRequestTypeCreateInvoice",
	12: "ReviewableRequestTypeManageContract",
	13: "ReviewableRequestTypeUpdateAsset",
	14: "ReviewableRequestTypeCreatePoll",
	16: "ReviewableRequestTypeCreateAtomicSwapAsk",
	17: "ReviewableRequestTypeCreateAtomicSwapBid",
	18: "ReviewableRequestTypeKycRecovery",
	19: "ReviewableRequestTypeManageOffer",
	20: "ReviewableRequestTypeCreatePayment",
	21: "ReviewableRequestTypePerformRedemption",
	22: "ReviewableRequestTypeDataCreation",
	23: "ReviewableRequestTypeDataUpdate",
	24: "ReviewableRequestTypeDataRemove",
	25: "ReviewableRequestTypeCreateDeferredPayment",
	26: "ReviewableRequestTypeCloseDeferredPayment",
}

var reviewableRequestTypeShortMap = map[int32]string{
	0:  "none",
	1:  "any",
	2:  "create_pre_issuance",
	3:  "create_issuance",
	4:  "create_withdraw",
	5:  "create_sale",
	6:  "update_limits",
	7:  "create_aml_alert",
	8:  "change_role",
	9:  "update_sale_details",
	10: "create_asset",
	11: "create_invoice",
	12: "manage_contract",
	13: "update_asset",
	14: "create_poll",
	16: "create_atomic_swap_ask",
	17: "create_atomic_swap_bid",
	18: "kyc_recovery",
	19: "manage_offer",
	20: "create_payment",
	21: "perform_redemption",
	22: "data_creation",
	23: "data_update",
	24: "data_remove",
	25: "create_deferred_payment",
	26: "close_deferred_payment",
}

var reviewableRequestTypeRevMap = map[string]int32{
	"ReviewableRequestTypeNone":                  0,
	"ReviewableRequestTypeAny":                   1,
	"ReviewableRequestTypeCreatePreIssuance":     2,
	"ReviewableRequestTypeCreateIssuance":        3,
	"ReviewableRequestTypeCreateWithdraw":        4,
	"ReviewableRequestTypeCreateSale":            5,
	"ReviewableRequestTypeUpdateLimits":          6,
	"ReviewableRequestTypeCreateAmlAlert":        7,
	"ReviewableRequestTypeChangeRole":            8,
	"ReviewableRequestTypeUpdateSaleDetails":     9,
	"ReviewableRequestTypeCreateAsset":           10,
	"ReviewableRequestTypeCreateInvoice":         11,
	"ReviewableRequestTypeManageContract":        12,
	"ReviewableRequestTypeUpdateAsset":           13,
	"ReviewableRequestTypeCreatePoll":            14,
	"ReviewableRequestTypeCreateAtomicSwapAsk":   16,
	"ReviewableRequestTypeCreateAtomicSwapBid":   17,
	"ReviewableRequestTypeKycRecovery":           18,
	"ReviewableRequestTypeManageOffer":           19,
	"ReviewableRequestTypeCreatePayment":         20,
	"ReviewableRequestTypePerformRedemption":     21,
	"ReviewableRequestTypeDataCreation":          22,
	"ReviewableRequestTypeDataUpdate":            23,
	"ReviewableRequestTypeDataRemove":            24,
	"ReviewableRequestTypeCreateDeferredPayment": 25,
	"ReviewableRequestTypeCloseDeferredPayment":  26,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ReviewableRequestType
func (e ReviewableRequestType) ValidEnum(v int32) bool {
	_, ok := reviewableRequestTypeMap[v]
	return ok
}
func (e ReviewableRequestType) isFlag() bool {
	for i := len(ReviewableRequestTypeAll) - 1; i >= 0; i-- {
		expected := ReviewableRequestType(2) << uint64(len(ReviewableRequestTypeAll)-1) >> uint64(len(ReviewableRequestTypeAll)-i)
		if expected != ReviewableRequestTypeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ReviewableRequestType) String() string {
	name, _ := reviewableRequestTypeMap[int32(e)]
	return name
}

func (e ReviewableRequestType) ShortString() string {
	name, _ := reviewableRequestTypeShortMap[int32(e)]
	return name
}

func (e ReviewableRequestType) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ReviewableRequestTypeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ReviewableRequestType) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ReviewableRequestType(t.Value)
	return nil
}

// TasksExtExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type TasksExtExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u TasksExtExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of TasksExtExt
func (u TasksExtExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewTasksExtExt creates a new  TasksExtExt.
func NewTasksExtExt(v LedgerVersion, value interface{}) (result TasksExtExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// TasksExt is an XDR Struct defines as:
//
//   struct TasksExt {
//        // Tasks are represented by a bitmask
//        uint32 allTasks;
//        uint32 pendingTasks;
//
//        // External details vector consists of comments written by request reviewers
//        longstring externalDetails<>;
//
//        // Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type TasksExt struct {
	AllTasks        Uint32       `json:"allTasks,omitempty"`
	PendingTasks    Uint32       `json:"pendingTasks,omitempty"`
	ExternalDetails []Longstring `json:"externalDetails,omitempty"`
	Ext             TasksExtExt  `json:"ext,omitempty"`
}

// ReviewableRequestEntryBody is an XDR NestedUnion defines as:
//
//   union switch (ReviewableRequestType type) {
//    		case CREATE_ASSET:
//    			AssetCreationRequest assetCreationRequest;
//    		case UPDATE_ASSET:
//    			AssetUpdateRequest assetUpdateRequest;
//    		case CREATE_PRE_ISSUANCE:
//    			PreIssuanceRequest preIssuanceRequest;
//    		case CREATE_ISSUANCE:
//    			IssuanceRequest issuanceRequest;
//    		case CREATE_WITHDRAW:
//    			WithdrawalRequest withdrawalRequest;
//    		case CREATE_SALE:
//    			SaleCreationRequest saleCreationRequest;
//            case UPDATE_LIMITS:
//                LimitsUpdateRequest limitsUpdateRequest;
//            case CREATE_AML_ALERT:
//                AMLAlertRequest amlAlertRequest;
//            case CHANGE_ROLE:
//                ChangeRoleRequest changeRoleRequest;
//            case UPDATE_SALE_DETAILS:
//                UpdateSaleDetailsRequest updateSaleDetailsRequest;
//            case CREATE_INVOICE:
//                InvoiceRequest invoiceRequest;
//            case MANAGE_CONTRACT:
//                ContractRequest contractRequest;
//            case CREATE_ATOMIC_SWAP_ASK:
//                CreateAtomicSwapAskRequest createAtomicSwapAskRequest;
//            case CREATE_ATOMIC_SWAP_BID:
//                CreateAtomicSwapBidRequest createAtomicSwapBidRequest;
//            case CREATE_POLL:
//                CreatePollRequest createPollRequest;
//            case KYC_RECOVERY:
//                KYCRecoveryRequest kycRecoveryRequest;
//    		case MANAGE_OFFER:
//    			ManageOfferRequest manageOfferRequest;
//    		case CREATE_PAYMENT:
//    			CreatePaymentRequest createPaymentRequest;
//            case PERFORM_REDEMPTION:
//                RedemptionRequest redemptionRequest;
//            case DATA_CREATION:
//                DataCreationRequest dataCreationRequest;
//            case DATA_UPDATE:
//                DataUpdateRequest dataUpdateRequest;
//            case DATA_REMOVE:
//                DataRemoveRequest dataRemoveRequest;
//            case CREATE_DEFERRED_PAYMENT:
//                CreateDeferredPaymentRequest createDeferredPaymentRequest;
//            case CLOSE_DEFERRED_PAYMENT:
//                CloseDeferredPaymentRequest closeDeferredPaymentRequest;
//
//    	}
//
type ReviewableRequestEntryBody struct {
	Type                         ReviewableRequestType         `json:"type,omitempty"`
	AssetCreationRequest         *AssetCreationRequest         `json:"assetCreationRequest,omitempty"`
	AssetUpdateRequest           *AssetUpdateRequest           `json:"assetUpdateRequest,omitempty"`
	PreIssuanceRequest           *PreIssuanceRequest           `json:"preIssuanceRequest,omitempty"`
	IssuanceRequest              *IssuanceRequest              `json:"issuanceRequest,omitempty"`
	WithdrawalRequest            *WithdrawalRequest            `json:"withdrawalRequest,omitempty"`
	SaleCreationRequest          *SaleCreationRequest          `json:"saleCreationRequest,omitempty"`
	LimitsUpdateRequest          *LimitsUpdateRequest          `json:"limitsUpdateRequest,omitempty"`
	AmlAlertRequest              *AmlAlertRequest              `json:"amlAlertRequest,omitempty"`
	ChangeRoleRequest            *ChangeRoleRequest            `json:"changeRoleRequest,omitempty"`
	UpdateSaleDetailsRequest     *UpdateSaleDetailsRequest     `json:"updateSaleDetailsRequest,omitempty"`
	InvoiceRequest               *InvoiceRequest               `json:"invoiceRequest,omitempty"`
	ContractRequest              *ContractRequest              `json:"contractRequest,omitempty"`
	CreateAtomicSwapAskRequest   *CreateAtomicSwapAskRequest   `json:"createAtomicSwapAskRequest,omitempty"`
	CreateAtomicSwapBidRequest   *CreateAtomicSwapBidRequest   `json:"createAtomicSwapBidRequest,omitempty"`
	CreatePollRequest            *CreatePollRequest            `json:"createPollRequest,omitempty"`
	KycRecoveryRequest           *KycRecoveryRequest           `json:"kycRecoveryRequest,omitempty"`
	ManageOfferRequest           *ManageOfferRequest           `json:"manageOfferRequest,omitempty"`
	CreatePaymentRequest         *CreatePaymentRequest         `json:"createPaymentRequest,omitempty"`
	RedemptionRequest            *RedemptionRequest            `json:"redemptionRequest,omitempty"`
	DataCreationRequest          *DataCreationRequest          `json:"dataCreationRequest,omitempty"`
	DataUpdateRequest            *DataUpdateRequest            `json:"dataUpdateRequest,omitempty"`
	DataRemoveRequest            *DataRemoveRequest            `json:"dataRemoveRequest,omitempty"`
	CreateDeferredPaymentRequest *CreateDeferredPaymentRequest `json:"createDeferredPaymentRequest,omitempty"`
	CloseDeferredPaymentRequest  *CloseDeferredPaymentRequest  `json:"closeDeferredPaymentRequest,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ReviewableRequestEntryBody) SwitchFieldName() string {
	return "Type"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ReviewableRequestEntryBody
func (u ReviewableRequestEntryBody) ArmForSwitch(sw int32) (string, bool) {
	switch ReviewableRequestType(sw) {
	case ReviewableRequestTypeCreateAsset:
		return "AssetCreationRequest", true
	case ReviewableRequestTypeUpdateAsset:
		return "AssetUpdateRequest", true
	case ReviewableRequestTypeCreatePreIssuance:
		return "PreIssuanceRequest", true
	case ReviewableRequestTypeCreateIssuance:
		return "IssuanceRequest", true
	case ReviewableRequestTypeCreateWithdraw:
		return "WithdrawalRequest", true
	case ReviewableRequestTypeCreateSale:
		return "SaleCreationRequest", true
	case ReviewableRequestTypeUpdateLimits:
		return "LimitsUpdateRequest", true
	case ReviewableRequestTypeCreateAmlAlert:
		return "AmlAlertRequest", true
	case ReviewableRequestTypeChangeRole:
		return "ChangeRoleRequest", true
	case ReviewableRequestTypeUpdateSaleDetails:
		return "UpdateSaleDetailsRequest", true
	case ReviewableRequestTypeCreateInvoice:
		return "InvoiceRequest", true
	case ReviewableRequestTypeManageContract:
		return "ContractRequest", true
	case ReviewableRequestTypeCreateAtomicSwapAsk:
		return "CreateAtomicSwapAskRequest", true
	case ReviewableRequestTypeCreateAtomicSwapBid:
		return "CreateAtomicSwapBidRequest", true
	case ReviewableRequestTypeCreatePoll:
		return "CreatePollRequest", true
	case ReviewableRequestTypeKycRecovery:
		return "KycRecoveryRequest", true
	case ReviewableRequestTypeManageOffer:
		return "ManageOfferRequest", true
	case ReviewableRequestTypeCreatePayment:
		return "CreatePaymentRequest", true
	case ReviewableRequestTypePerformRedemption:
		return "RedemptionRequest", true
	case ReviewableRequestTypeDataCreation:
		return "DataCreationRequest", true
	case ReviewableRequestTypeDataUpdate:
		return "DataUpdateRequest", true
	case ReviewableRequestTypeDataRemove:
		return "DataRemoveRequest", true
	case ReviewableRequestTypeCreateDeferredPayment:
		return "CreateDeferredPaymentRequest", true
	case ReviewableRequestTypeCloseDeferredPayment:
		return "CloseDeferredPaymentRequest", true
	}
	return "-", false
}

// NewReviewableRequestEntryBody creates a new  ReviewableRequestEntryBody.
func NewReviewableRequestEntryBody(aType ReviewableRequestType, value interface{}) (result ReviewableRequestEntryBody, err error) {
	result.Type = aType
	switch ReviewableRequestType(aType) {
	case ReviewableRequestTypeCreateAsset:
		tv, ok := value.(AssetCreationRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be AssetCreationRequest")
			return
		}
		result.AssetCreationRequest = &tv
	case ReviewableRequestTypeUpdateAsset:
		tv, ok := value.(AssetUpdateRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be AssetUpdateRequest")
			return
		}
		result.AssetUpdateRequest = &tv
	case ReviewableRequestTypeCreatePreIssuance:
		tv, ok := value.(PreIssuanceRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be PreIssuanceRequest")
			return
		}
		result.PreIssuanceRequest = &tv
	case ReviewableRequestTypeCreateIssuance:
		tv, ok := value.(IssuanceRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be IssuanceRequest")
			return
		}
		result.IssuanceRequest = &tv
	case ReviewableRequestTypeCreateWithdraw:
		tv, ok := value.(WithdrawalRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be WithdrawalRequest")
			return
		}
		result.WithdrawalRequest = &tv
	case ReviewableRequestTypeCreateSale:
		tv, ok := value.(SaleCreationRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be SaleCreationRequest")
			return
		}
		result.SaleCreationRequest = &tv
	case ReviewableRequestTypeUpdateLimits:
		tv, ok := value.(LimitsUpdateRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be LimitsUpdateRequest")
			return
		}
		result.LimitsUpdateRequest = &tv
	case ReviewableRequestTypeCreateAmlAlert:
		tv, ok := value.(AmlAlertRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be AmlAlertRequest")
			return
		}
		result.AmlAlertRequest = &tv
	case ReviewableRequestTypeChangeRole:
		tv, ok := value.(ChangeRoleRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be ChangeRoleRequest")
			return
		}
		result.ChangeRoleRequest = &tv
	case ReviewableRequestTypeUpdateSaleDetails:
		tv, ok := value.(UpdateSaleDetailsRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be UpdateSaleDetailsRequest")
			return
		}
		result.UpdateSaleDetailsRequest = &tv
	case ReviewableRequestTypeCreateInvoice:
		tv, ok := value.(InvoiceRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be InvoiceRequest")
			return
		}
		result.InvoiceRequest = &tv
	case ReviewableRequestTypeManageContract:
		tv, ok := value.(ContractRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be ContractRequest")
			return
		}
		result.ContractRequest = &tv
	case ReviewableRequestTypeCreateAtomicSwapAsk:
		tv, ok := value.(CreateAtomicSwapAskRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateAtomicSwapAskRequest")
			return
		}
		result.CreateAtomicSwapAskRequest = &tv
	case ReviewableRequestTypeCreateAtomicSwapBid:
		tv, ok := value.(CreateAtomicSwapBidRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateAtomicSwapBidRequest")
			return
		}
		result.CreateAtomicSwapBidRequest = &tv
	case ReviewableRequestTypeCreatePoll:
		tv, ok := value.(CreatePollRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreatePollRequest")
			return
		}
		result.CreatePollRequest = &tv
	case ReviewableRequestTypeKycRecovery:
		tv, ok := value.(KycRecoveryRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be KycRecoveryRequest")
			return
		}
		result.KycRecoveryRequest = &tv
	case ReviewableRequestTypeManageOffer:
		tv, ok := value.(ManageOfferRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageOfferRequest")
			return
		}
		result.ManageOfferRequest = &tv
	case ReviewableRequestTypeCreatePayment:
		tv, ok := value.(CreatePaymentRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreatePaymentRequest")
			return
		}
		result.CreatePaymentRequest = &tv
	case ReviewableRequestTypePerformRedemption:
		tv, ok := value.(RedemptionRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be RedemptionRequest")
			return
		}
		result.RedemptionRequest = &tv
	case ReviewableRequestTypeDataCreation:
		tv, ok := value.(DataCreationRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be DataCreationRequest")
			return
		}
		result.DataCreationRequest = &tv
	case ReviewableRequestTypeDataUpdate:
		tv, ok := value.(DataUpdateRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be DataUpdateRequest")
			return
		}
		result.DataUpdateRequest = &tv
	case ReviewableRequestTypeDataRemove:
		tv, ok := value.(DataRemoveRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be DataRemoveRequest")
			return
		}
		result.DataRemoveRequest = &tv
	case ReviewableRequestTypeCreateDeferredPayment:
		tv, ok := value.(CreateDeferredPaymentRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateDeferredPaymentRequest")
			return
		}
		result.CreateDeferredPaymentRequest = &tv
	case ReviewableRequestTypeCloseDeferredPayment:
		tv, ok := value.(CloseDeferredPaymentRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be CloseDeferredPaymentRequest")
			return
		}
		result.CloseDeferredPaymentRequest = &tv
	}
	return
}

// MustAssetCreationRequest retrieves the AssetCreationRequest value from the union,
// panicing if the value is not set.
func (u ReviewableRequestEntryBody) MustAssetCreationRequest() AssetCreationRequest {
	val, ok := u.GetAssetCreationRequest()

	if !ok {
		panic("arm AssetCreationRequest is not set")
	}

	return val
}

// GetAssetCreationRequest retrieves the AssetCreationRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestEntryBody) GetAssetCreationRequest() (result AssetCreationRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "AssetCreationRequest" {
		result = *u.AssetCreationRequest
		ok = true
	}

	return
}

// MustAssetUpdateRequest retrieves the AssetUpdateRequest value from the union,
// panicing if the value is not set.
func (u ReviewableRequestEntryBody) MustAssetUpdateRequest() AssetUpdateRequest {
	val, ok := u.GetAssetUpdateRequest()

	if !ok {
		panic("arm AssetUpdateRequest is not set")
	}

	return val
}

// GetAssetUpdateRequest retrieves the AssetUpdateRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestEntryBody) GetAssetUpdateRequest() (result AssetUpdateRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "AssetUpdateRequest" {
		result = *u.AssetUpdateRequest
		ok = true
	}

	return
}

// MustPreIssuanceRequest retrieves the PreIssuanceRequest value from the union,
// panicing if the value is not set.
func (u ReviewableRequestEntryBody) MustPreIssuanceRequest() PreIssuanceRequest {
	val, ok := u.GetPreIssuanceRequest()

	if !ok {
		panic("arm PreIssuanceRequest is not set")
	}

	return val
}

// GetPreIssuanceRequest retrieves the PreIssuanceRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestEntryBody) GetPreIssuanceRequest() (result PreIssuanceRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "PreIssuanceRequest" {
		result = *u.PreIssuanceRequest
		ok = true
	}

	return
}

// MustIssuanceRequest retrieves the IssuanceRequest value from the union,
// panicing if the value is not set.
func (u ReviewableRequestEntryBody) MustIssuanceRequest() IssuanceRequest {
	val, ok := u.GetIssuanceRequest()

	if !ok {
		panic("arm IssuanceRequest is not set")
	}

	return val
}

// GetIssuanceRequest retrieves the IssuanceRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestEntryBody) GetIssuanceRequest() (result IssuanceRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "IssuanceRequest" {
		result = *u.IssuanceRequest
		ok = true
	}

	return
}

// MustWithdrawalRequest retrieves the WithdrawalRequest value from the union,
// panicing if the value is not set.
func (u ReviewableRequestEntryBody) MustWithdrawalRequest() WithdrawalRequest {
	val, ok := u.GetWithdrawalRequest()

	if !ok {
		panic("arm WithdrawalRequest is not set")
	}

	return val
}

// GetWithdrawalRequest retrieves the WithdrawalRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestEntryBody) GetWithdrawalRequest() (result WithdrawalRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "WithdrawalRequest" {
		result = *u.WithdrawalRequest
		ok = true
	}

	return
}

// MustSaleCreationRequest retrieves the SaleCreationRequest value from the union,
// panicing if the value is not set.
func (u ReviewableRequestEntryBody) MustSaleCreationRequest() SaleCreationRequest {
	val, ok := u.GetSaleCreationRequest()

	if !ok {
		panic("arm SaleCreationRequest is not set")
	}

	return val
}

// GetSaleCreationRequest retrieves the SaleCreationRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestEntryBody) GetSaleCreationRequest() (result SaleCreationRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "SaleCreationRequest" {
		result = *u.SaleCreationRequest
		ok = true
	}

	return
}

// MustLimitsUpdateRequest retrieves the LimitsUpdateRequest value from the union,
// panicing if the value is not set.
func (u ReviewableRequestEntryBody) MustLimitsUpdateRequest() LimitsUpdateRequest {
	val, ok := u.GetLimitsUpdateRequest()

	if !ok {
		panic("arm LimitsUpdateRequest is not set")
	}

	return val
}

// GetLimitsUpdateRequest retrieves the LimitsUpdateRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestEntryBody) GetLimitsUpdateRequest() (result LimitsUpdateRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "LimitsUpdateRequest" {
		result = *u.LimitsUpdateRequest
		ok = true
	}

	return
}

// MustAmlAlertRequest retrieves the AmlAlertRequest value from the union,
// panicing if the value is not set.
func (u ReviewableRequestEntryBody) MustAmlAlertRequest() AmlAlertRequest {
	val, ok := u.GetAmlAlertRequest()

	if !ok {
		panic("arm AmlAlertRequest is not set")
	}

	return val
}

// GetAmlAlertRequest retrieves the AmlAlertRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestEntryBody) GetAmlAlertRequest() (result AmlAlertRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "AmlAlertRequest" {
		result = *u.AmlAlertRequest
		ok = true
	}

	return
}

// MustChangeRoleRequest retrieves the ChangeRoleRequest value from the union,
// panicing if the value is not set.
func (u ReviewableRequestEntryBody) MustChangeRoleRequest() ChangeRoleRequest {
	val, ok := u.GetChangeRoleRequest()

	if !ok {
		panic("arm ChangeRoleRequest is not set")
	}

	return val
}

// GetChangeRoleRequest retrieves the ChangeRoleRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestEntryBody) GetChangeRoleRequest() (result ChangeRoleRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ChangeRoleRequest" {
		result = *u.ChangeRoleRequest
		ok = true
	}

	return
}

// MustUpdateSaleDetailsRequest retrieves the UpdateSaleDetailsRequest value from the union,
// panicing if the value is not set.
func (u ReviewableRequestEntryBody) MustUpdateSaleDetailsRequest() UpdateSaleDetailsRequest {
	val, ok := u.GetUpdateSaleDetailsRequest()

	if !ok {
		panic("arm UpdateSaleDetailsRequest is not set")
	}

	return val
}

// GetUpdateSaleDetailsRequest retrieves the UpdateSaleDetailsRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestEntryBody) GetUpdateSaleDetailsRequest() (result UpdateSaleDetailsRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "UpdateSaleDetailsRequest" {
		result = *u.UpdateSaleDetailsRequest
		ok = true
	}

	return
}

// MustInvoiceRequest retrieves the InvoiceRequest value from the union,
// panicing if the value is not set.
func (u ReviewableRequestEntryBody) MustInvoiceRequest() InvoiceRequest {
	val, ok := u.GetInvoiceRequest()

	if !ok {
		panic("arm InvoiceRequest is not set")
	}

	return val
}

// GetInvoiceRequest retrieves the InvoiceRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestEntryBody) GetInvoiceRequest() (result InvoiceRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "InvoiceRequest" {
		result = *u.InvoiceRequest
		ok = true
	}

	return
}

// MustContractRequest retrieves the ContractRequest value from the union,
// panicing if the value is not set.
func (u ReviewableRequestEntryBody) MustContractRequest() ContractRequest {
	val, ok := u.GetContractRequest()

	if !ok {
		panic("arm ContractRequest is not set")
	}

	return val
}

// GetContractRequest retrieves the ContractRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestEntryBody) GetContractRequest() (result ContractRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ContractRequest" {
		result = *u.ContractRequest
		ok = true
	}

	return
}

// MustCreateAtomicSwapAskRequest retrieves the CreateAtomicSwapAskRequest value from the union,
// panicing if the value is not set.
func (u ReviewableRequestEntryBody) MustCreateAtomicSwapAskRequest() CreateAtomicSwapAskRequest {
	val, ok := u.GetCreateAtomicSwapAskRequest()

	if !ok {
		panic("arm CreateAtomicSwapAskRequest is not set")
	}

	return val
}

// GetCreateAtomicSwapAskRequest retrieves the CreateAtomicSwapAskRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestEntryBody) GetCreateAtomicSwapAskRequest() (result CreateAtomicSwapAskRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateAtomicSwapAskRequest" {
		result = *u.CreateAtomicSwapAskRequest
		ok = true
	}

	return
}

// MustCreateAtomicSwapBidRequest retrieves the CreateAtomicSwapBidRequest value from the union,
// panicing if the value is not set.
func (u ReviewableRequestEntryBody) MustCreateAtomicSwapBidRequest() CreateAtomicSwapBidRequest {
	val, ok := u.GetCreateAtomicSwapBidRequest()

	if !ok {
		panic("arm CreateAtomicSwapBidRequest is not set")
	}

	return val
}

// GetCreateAtomicSwapBidRequest retrieves the CreateAtomicSwapBidRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestEntryBody) GetCreateAtomicSwapBidRequest() (result CreateAtomicSwapBidRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateAtomicSwapBidRequest" {
		result = *u.CreateAtomicSwapBidRequest
		ok = true
	}

	return
}

// MustCreatePollRequest retrieves the CreatePollRequest value from the union,
// panicing if the value is not set.
func (u ReviewableRequestEntryBody) MustCreatePollRequest() CreatePollRequest {
	val, ok := u.GetCreatePollRequest()

	if !ok {
		panic("arm CreatePollRequest is not set")
	}

	return val
}

// GetCreatePollRequest retrieves the CreatePollRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestEntryBody) GetCreatePollRequest() (result CreatePollRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreatePollRequest" {
		result = *u.CreatePollRequest
		ok = true
	}

	return
}

// MustKycRecoveryRequest retrieves the KycRecoveryRequest value from the union,
// panicing if the value is not set.
func (u ReviewableRequestEntryBody) MustKycRecoveryRequest() KycRecoveryRequest {
	val, ok := u.GetKycRecoveryRequest()

	if !ok {
		panic("arm KycRecoveryRequest is not set")
	}

	return val
}

// GetKycRecoveryRequest retrieves the KycRecoveryRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestEntryBody) GetKycRecoveryRequest() (result KycRecoveryRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "KycRecoveryRequest" {
		result = *u.KycRecoveryRequest
		ok = true
	}

	return
}

// MustManageOfferRequest retrieves the ManageOfferRequest value from the union,
// panicing if the value is not set.
func (u ReviewableRequestEntryBody) MustManageOfferRequest() ManageOfferRequest {
	val, ok := u.GetManageOfferRequest()

	if !ok {
		panic("arm ManageOfferRequest is not set")
	}

	return val
}

// GetManageOfferRequest retrieves the ManageOfferRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestEntryBody) GetManageOfferRequest() (result ManageOfferRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageOfferRequest" {
		result = *u.ManageOfferRequest
		ok = true
	}

	return
}

// MustCreatePaymentRequest retrieves the CreatePaymentRequest value from the union,
// panicing if the value is not set.
func (u ReviewableRequestEntryBody) MustCreatePaymentRequest() CreatePaymentRequest {
	val, ok := u.GetCreatePaymentRequest()

	if !ok {
		panic("arm CreatePaymentRequest is not set")
	}

	return val
}

// GetCreatePaymentRequest retrieves the CreatePaymentRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestEntryBody) GetCreatePaymentRequest() (result CreatePaymentRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreatePaymentRequest" {
		result = *u.CreatePaymentRequest
		ok = true
	}

	return
}

// MustRedemptionRequest retrieves the RedemptionRequest value from the union,
// panicing if the value is not set.
func (u ReviewableRequestEntryBody) MustRedemptionRequest() RedemptionRequest {
	val, ok := u.GetRedemptionRequest()

	if !ok {
		panic("arm RedemptionRequest is not set")
	}

	return val
}

// GetRedemptionRequest retrieves the RedemptionRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestEntryBody) GetRedemptionRequest() (result RedemptionRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "RedemptionRequest" {
		result = *u.RedemptionRequest
		ok = true
	}

	return
}

// MustDataCreationRequest retrieves the DataCreationRequest value from the union,
// panicing if the value is not set.
func (u ReviewableRequestEntryBody) MustDataCreationRequest() DataCreationRequest {
	val, ok := u.GetDataCreationRequest()

	if !ok {
		panic("arm DataCreationRequest is not set")
	}

	return val
}

// GetDataCreationRequest retrieves the DataCreationRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestEntryBody) GetDataCreationRequest() (result DataCreationRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "DataCreationRequest" {
		result = *u.DataCreationRequest
		ok = true
	}

	return
}

// MustDataUpdateRequest retrieves the DataUpdateRequest value from the union,
// panicing if the value is not set.
func (u ReviewableRequestEntryBody) MustDataUpdateRequest() DataUpdateRequest {
	val, ok := u.GetDataUpdateRequest()

	if !ok {
		panic("arm DataUpdateRequest is not set")
	}

	return val
}

// GetDataUpdateRequest retrieves the DataUpdateRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestEntryBody) GetDataUpdateRequest() (result DataUpdateRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "DataUpdateRequest" {
		result = *u.DataUpdateRequest
		ok = true
	}

	return
}

// MustDataRemoveRequest retrieves the DataRemoveRequest value from the union,
// panicing if the value is not set.
func (u ReviewableRequestEntryBody) MustDataRemoveRequest() DataRemoveRequest {
	val, ok := u.GetDataRemoveRequest()

	if !ok {
		panic("arm DataRemoveRequest is not set")
	}

	return val
}

// GetDataRemoveRequest retrieves the DataRemoveRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestEntryBody) GetDataRemoveRequest() (result DataRemoveRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "DataRemoveRequest" {
		result = *u.DataRemoveRequest
		ok = true
	}

	return
}

// MustCreateDeferredPaymentRequest retrieves the CreateDeferredPaymentRequest value from the union,
// panicing if the value is not set.
func (u ReviewableRequestEntryBody) MustCreateDeferredPaymentRequest() CreateDeferredPaymentRequest {
	val, ok := u.GetCreateDeferredPaymentRequest()

	if !ok {
		panic("arm CreateDeferredPaymentRequest is not set")
	}

	return val
}

// GetCreateDeferredPaymentRequest retrieves the CreateDeferredPaymentRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestEntryBody) GetCreateDeferredPaymentRequest() (result CreateDeferredPaymentRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateDeferredPaymentRequest" {
		result = *u.CreateDeferredPaymentRequest
		ok = true
	}

	return
}

// MustCloseDeferredPaymentRequest retrieves the CloseDeferredPaymentRequest value from the union,
// panicing if the value is not set.
func (u ReviewableRequestEntryBody) MustCloseDeferredPaymentRequest() CloseDeferredPaymentRequest {
	val, ok := u.GetCloseDeferredPaymentRequest()

	if !ok {
		panic("arm CloseDeferredPaymentRequest is not set")
	}

	return val
}

// GetCloseDeferredPaymentRequest retrieves the CloseDeferredPaymentRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestEntryBody) GetCloseDeferredPaymentRequest() (result CloseDeferredPaymentRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CloseDeferredPaymentRequest" {
		result = *u.CloseDeferredPaymentRequest
		ok = true
	}

	return
}

// ReviewableRequestEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//    	}
//
type ReviewableRequestEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ReviewableRequestEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ReviewableRequestEntryExt
func (u ReviewableRequestEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewReviewableRequestEntryExt creates a new  ReviewableRequestEntryExt.
func NewReviewableRequestEntryExt(v LedgerVersion, value interface{}) (result ReviewableRequestEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ReviewableRequestEntry is an XDR Struct defines as:
//
//   struct ReviewableRequestEntry {
//    	uint64 requestID;
//    	Hash hash; // hash of the request body
//    	AccountID requestor;
//    	longstring rejectReason;
//    	AccountID reviewer;
//    	string64* reference; // reference for request which will act as an unique key for the request (will reject request with the same reference from same requestor)
//    	int64 createdAt; // when request was created
//
//    	union switch (ReviewableRequestType type) {
//    		case CREATE_ASSET:
//    			AssetCreationRequest assetCreationRequest;
//    		case UPDATE_ASSET:
//    			AssetUpdateRequest assetUpdateRequest;
//    		case CREATE_PRE_ISSUANCE:
//    			PreIssuanceRequest preIssuanceRequest;
//    		case CREATE_ISSUANCE:
//    			IssuanceRequest issuanceRequest;
//    		case CREATE_WITHDRAW:
//    			WithdrawalRequest withdrawalRequest;
//    		case CREATE_SALE:
//    			SaleCreationRequest saleCreationRequest;
//            case UPDATE_LIMITS:
//                LimitsUpdateRequest limitsUpdateRequest;
//            case CREATE_AML_ALERT:
//                AMLAlertRequest amlAlertRequest;
//            case CHANGE_ROLE:
//                ChangeRoleRequest changeRoleRequest;
//            case UPDATE_SALE_DETAILS:
//                UpdateSaleDetailsRequest updateSaleDetailsRequest;
//            case CREATE_INVOICE:
//                InvoiceRequest invoiceRequest;
//            case MANAGE_CONTRACT:
//                ContractRequest contractRequest;
//            case CREATE_ATOMIC_SWAP_ASK:
//                CreateAtomicSwapAskRequest createAtomicSwapAskRequest;
//            case CREATE_ATOMIC_SWAP_BID:
//                CreateAtomicSwapBidRequest createAtomicSwapBidRequest;
//            case CREATE_POLL:
//                CreatePollRequest createPollRequest;
//            case KYC_RECOVERY:
//                KYCRecoveryRequest kycRecoveryRequest;
//    		case MANAGE_OFFER:
//    			ManageOfferRequest manageOfferRequest;
//    		case CREATE_PAYMENT:
//    			CreatePaymentRequest createPaymentRequest;
//            case PERFORM_REDEMPTION:
//                RedemptionRequest redemptionRequest;
//            case DATA_CREATION:
//                DataCreationRequest dataCreationRequest;
//            case DATA_UPDATE:
//                DataUpdateRequest dataUpdateRequest;
//            case DATA_REMOVE:
//                DataRemoveRequest dataRemoveRequest;
//            case CREATE_DEFERRED_PAYMENT:
//                CreateDeferredPaymentRequest createDeferredPaymentRequest;
//            case CLOSE_DEFERRED_PAYMENT:
//                CloseDeferredPaymentRequest closeDeferredPaymentRequest;
//
//    	} body;
//
//    	TasksExt tasks;
//
//    	// reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//    	}
//        ext;
//    };
//
type ReviewableRequestEntry struct {
	RequestId    Uint64                     `json:"requestID,omitempty"`
	Hash         Hash                       `json:"hash,omitempty"`
	Requestor    AccountId                  `json:"requestor,omitempty"`
	RejectReason Longstring                 `json:"rejectReason,omitempty"`
	Reviewer     AccountId                  `json:"reviewer,omitempty"`
	Reference    *String64                  `json:"reference,omitempty"`
	CreatedAt    Int64                      `json:"createdAt,omitempty"`
	Body         ReviewableRequestEntryBody `json:"body,omitempty"`
	Tasks        TasksExt                   `json:"tasks,omitempty"`
	Ext          ReviewableRequestEntryExt  `json:"ext,omitempty"`
}

// SaleType is an XDR Enum defines as:
//
//   enum SaleType {
//    	BASIC_SALE = 1, // sale creator specifies price for each quote asset
//    	CROWD_FUNDING = 2, // sale creator does not specify price,
//    	                  // price is defined on sale close based on amount of base asset to be sold and amount of quote assets collected
//        FIXED_PRICE=3,
//
//        IMMEDIATE=4
//    };
//
type SaleType int32

const (
	SaleTypeBasicSale    SaleType = 1
	SaleTypeCrowdFunding SaleType = 2
	SaleTypeFixedPrice   SaleType = 3
	SaleTypeImmediate    SaleType = 4
)

var SaleTypeAll = []SaleType{
	SaleTypeBasicSale,
	SaleTypeCrowdFunding,
	SaleTypeFixedPrice,
	SaleTypeImmediate,
}

var saleTypeMap = map[int32]string{
	1: "SaleTypeBasicSale",
	2: "SaleTypeCrowdFunding",
	3: "SaleTypeFixedPrice",
	4: "SaleTypeImmediate",
}

var saleTypeShortMap = map[int32]string{
	1: "basic_sale",
	2: "crowd_funding",
	3: "fixed_price",
	4: "immediate",
}

var saleTypeRevMap = map[string]int32{
	"SaleTypeBasicSale":    1,
	"SaleTypeCrowdFunding": 2,
	"SaleTypeFixedPrice":   3,
	"SaleTypeImmediate":    4,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for SaleType
func (e SaleType) ValidEnum(v int32) bool {
	_, ok := saleTypeMap[v]
	return ok
}
func (e SaleType) isFlag() bool {
	for i := len(SaleTypeAll) - 1; i >= 0; i-- {
		expected := SaleType(2) << uint64(len(SaleTypeAll)-1) >> uint64(len(SaleTypeAll)-i)
		if expected != SaleTypeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e SaleType) String() string {
	name, _ := saleTypeMap[int32(e)]
	return name
}

func (e SaleType) ShortString() string {
	name, _ := saleTypeShortMap[int32(e)]
	return name
}

func (e SaleType) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range SaleTypeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *SaleType) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = SaleType(t.Value)
	return nil
}

// FixedPriceSaleExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type FixedPriceSaleExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u FixedPriceSaleExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of FixedPriceSaleExt
func (u FixedPriceSaleExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewFixedPriceSaleExt creates a new  FixedPriceSaleExt.
func NewFixedPriceSaleExt(v LedgerVersion, value interface{}) (result FixedPriceSaleExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// FixedPriceSale is an XDR Struct defines as:
//
//   struct FixedPriceSale {
//    	union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type FixedPriceSale struct {
	Ext FixedPriceSaleExt `json:"ext,omitempty"`
}

// CrowdFundingSaleExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CrowdFundingSaleExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CrowdFundingSaleExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CrowdFundingSaleExt
func (u CrowdFundingSaleExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCrowdFundingSaleExt creates a new  CrowdFundingSaleExt.
func NewCrowdFundingSaleExt(v LedgerVersion, value interface{}) (result CrowdFundingSaleExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CrowdFundingSale is an XDR Struct defines as:
//
//   struct CrowdFundingSale {
//    	union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CrowdFundingSale struct {
	Ext CrowdFundingSaleExt `json:"ext,omitempty"`
}

// BasicSaleExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type BasicSaleExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u BasicSaleExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of BasicSaleExt
func (u BasicSaleExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewBasicSaleExt creates a new  BasicSaleExt.
func NewBasicSaleExt(v LedgerVersion, value interface{}) (result BasicSaleExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// BasicSale is an XDR Struct defines as:
//
//   struct BasicSale {
//    	union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type BasicSale struct {
	Ext BasicSaleExt `json:"ext,omitempty"`
}

// ImmediateSale is an XDR Struct defines as:
//
//   struct ImmediateSale {
//        EmptyExt ext;
//    };
//
type ImmediateSale struct {
	Ext EmptyExt `json:"ext,omitempty"`
}

// SaleTypeExt is an XDR Union defines as:
//
//   union SaleTypeExt switch (SaleType saleType)
//    {
//    	case BASIC_SALE:
//    		BasicSale basicSale;
//    	case CROWD_FUNDING:
//    		CrowdFundingSale crowdFundingSale;
//    	case FIXED_PRICE:
//    		FixedPriceSale fixedPriceSale;
//        case IMMEDIATE:
//            ImmediateSale immediateSale;
//    };
//
type SaleTypeExt struct {
	SaleType         SaleType          `json:"saleType,omitempty"`
	BasicSale        *BasicSale        `json:"basicSale,omitempty"`
	CrowdFundingSale *CrowdFundingSale `json:"crowdFundingSale,omitempty"`
	FixedPriceSale   *FixedPriceSale   `json:"fixedPriceSale,omitempty"`
	ImmediateSale    *ImmediateSale    `json:"immediateSale,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u SaleTypeExt) SwitchFieldName() string {
	return "SaleType"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of SaleTypeExt
func (u SaleTypeExt) ArmForSwitch(sw int32) (string, bool) {
	switch SaleType(sw) {
	case SaleTypeBasicSale:
		return "BasicSale", true
	case SaleTypeCrowdFunding:
		return "CrowdFundingSale", true
	case SaleTypeFixedPrice:
		return "FixedPriceSale", true
	case SaleTypeImmediate:
		return "ImmediateSale", true
	}
	return "-", false
}

// NewSaleTypeExt creates a new  SaleTypeExt.
func NewSaleTypeExt(saleType SaleType, value interface{}) (result SaleTypeExt, err error) {
	result.SaleType = saleType
	switch SaleType(saleType) {
	case SaleTypeBasicSale:
		tv, ok := value.(BasicSale)
		if !ok {
			err = fmt.Errorf("invalid value, must be BasicSale")
			return
		}
		result.BasicSale = &tv
	case SaleTypeCrowdFunding:
		tv, ok := value.(CrowdFundingSale)
		if !ok {
			err = fmt.Errorf("invalid value, must be CrowdFundingSale")
			return
		}
		result.CrowdFundingSale = &tv
	case SaleTypeFixedPrice:
		tv, ok := value.(FixedPriceSale)
		if !ok {
			err = fmt.Errorf("invalid value, must be FixedPriceSale")
			return
		}
		result.FixedPriceSale = &tv
	case SaleTypeImmediate:
		tv, ok := value.(ImmediateSale)
		if !ok {
			err = fmt.Errorf("invalid value, must be ImmediateSale")
			return
		}
		result.ImmediateSale = &tv
	}
	return
}

// MustBasicSale retrieves the BasicSale value from the union,
// panicing if the value is not set.
func (u SaleTypeExt) MustBasicSale() BasicSale {
	val, ok := u.GetBasicSale()

	if !ok {
		panic("arm BasicSale is not set")
	}

	return val
}

// GetBasicSale retrieves the BasicSale value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u SaleTypeExt) GetBasicSale() (result BasicSale, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.SaleType))

	if armName == "BasicSale" {
		result = *u.BasicSale
		ok = true
	}

	return
}

// MustCrowdFundingSale retrieves the CrowdFundingSale value from the union,
// panicing if the value is not set.
func (u SaleTypeExt) MustCrowdFundingSale() CrowdFundingSale {
	val, ok := u.GetCrowdFundingSale()

	if !ok {
		panic("arm CrowdFundingSale is not set")
	}

	return val
}

// GetCrowdFundingSale retrieves the CrowdFundingSale value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u SaleTypeExt) GetCrowdFundingSale() (result CrowdFundingSale, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.SaleType))

	if armName == "CrowdFundingSale" {
		result = *u.CrowdFundingSale
		ok = true
	}

	return
}

// MustFixedPriceSale retrieves the FixedPriceSale value from the union,
// panicing if the value is not set.
func (u SaleTypeExt) MustFixedPriceSale() FixedPriceSale {
	val, ok := u.GetFixedPriceSale()

	if !ok {
		panic("arm FixedPriceSale is not set")
	}

	return val
}

// GetFixedPriceSale retrieves the FixedPriceSale value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u SaleTypeExt) GetFixedPriceSale() (result FixedPriceSale, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.SaleType))

	if armName == "FixedPriceSale" {
		result = *u.FixedPriceSale
		ok = true
	}

	return
}

// MustImmediateSale retrieves the ImmediateSale value from the union,
// panicing if the value is not set.
func (u SaleTypeExt) MustImmediateSale() ImmediateSale {
	val, ok := u.GetImmediateSale()

	if !ok {
		panic("arm ImmediateSale is not set")
	}

	return val
}

// GetImmediateSale retrieves the ImmediateSale value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u SaleTypeExt) GetImmediateSale() (result ImmediateSale, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.SaleType))

	if armName == "ImmediateSale" {
		result = *u.ImmediateSale
		ok = true
	}

	return
}

// SaleQuoteAssetExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type SaleQuoteAssetExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u SaleQuoteAssetExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of SaleQuoteAssetExt
func (u SaleQuoteAssetExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewSaleQuoteAssetExt creates a new  SaleQuoteAssetExt.
func NewSaleQuoteAssetExt(v LedgerVersion, value interface{}) (result SaleQuoteAssetExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// SaleQuoteAsset is an XDR Struct defines as:
//
//   struct SaleQuoteAsset {
//    	AssetCode quoteAsset; // asset in which participation will be accepted
//    	uint64 price; // price for 1 baseAsset in terms of quote asset
//    	BalanceID quoteBalance;
//    	uint64 currentCap; // current capitalization
//    	union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type SaleQuoteAsset struct {
	QuoteAsset   AssetCode         `json:"quoteAsset,omitempty"`
	Price        Uint64            `json:"price,omitempty"`
	QuoteBalance BalanceId         `json:"quoteBalance,omitempty"`
	CurrentCap   Uint64            `json:"currentCap,omitempty"`
	Ext          SaleQuoteAssetExt `json:"ext,omitempty"`
}

// SaleEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        case ADD_SALE_WHITELISTS:
//            void;
//        }
//
type SaleEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u SaleEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of SaleEntryExt
func (u SaleEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	case LedgerVersionAddSaleWhitelists:
		return "", true
	}
	return "-", false
}

// NewSaleEntryExt creates a new  SaleEntryExt.
func NewSaleEntryExt(v LedgerVersion, value interface{}) (result SaleEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	case LedgerVersionAddSaleWhitelists:
		// void
	}
	return
}

// SaleEntry is an XDR Struct defines as:
//
//   struct SaleEntry
//    {
//    	uint64 saleID;
//    	uint64 saleType;
//    	AccountID ownerID;
//        AssetCode baseAsset; // asset for which sale will be performed
//    	uint64 startTime; // start time of the sale
//    	uint64 endTime; // close time of the sale
//    	AssetCode defaultQuoteAsset; // asset for soft and hard cap
//    	uint64 softCap; // minimum amount of quote asset to be received at which sale will be considered a successful
//    	uint64 hardCap; // max amount of quote asset to be received
//    	uint64 currentCapInBase;
//    	uint64 maxAmountToBeSold;
//    	longstring details; // sale specific details
//    	SaleQuoteAsset quoteAssets<100>;
//
//    	BalanceID baseBalance;
//        SaleTypeExt saleTypeExt;
//
//    	union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        case ADD_SALE_WHITELISTS:
//            void;
//        }
//        ext;
//    };
//
type SaleEntry struct {
	SaleId            Uint64           `json:"saleID,omitempty"`
	SaleType          Uint64           `json:"saleType,omitempty"`
	OwnerId           AccountId        `json:"ownerID,omitempty"`
	BaseAsset         AssetCode        `json:"baseAsset,omitempty"`
	StartTime         Uint64           `json:"startTime,omitempty"`
	EndTime           Uint64           `json:"endTime,omitempty"`
	DefaultQuoteAsset AssetCode        `json:"defaultQuoteAsset,omitempty"`
	SoftCap           Uint64           `json:"softCap,omitempty"`
	HardCap           Uint64           `json:"hardCap,omitempty"`
	CurrentCapInBase  Uint64           `json:"currentCapInBase,omitempty"`
	MaxAmountToBeSold Uint64           `json:"maxAmountToBeSold,omitempty"`
	Details           Longstring       `json:"details,omitempty"`
	QuoteAssets       []SaleQuoteAsset `json:"quoteAssets,omitempty" xdrmaxsize:"100"`
	BaseBalance       BalanceId        `json:"baseBalance,omitempty"`
	SaleTypeExt       SaleTypeExt      `json:"saleTypeExt,omitempty"`
	Ext               SaleEntryExt     `json:"ext,omitempty"`
}

// SignerRoleEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type SignerRoleEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u SignerRoleEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of SignerRoleEntryExt
func (u SignerRoleEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewSignerRoleEntryExt creates a new  SignerRoleEntryExt.
func NewSignerRoleEntryExt(v LedgerVersion, value interface{}) (result SignerRoleEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// SignerRoleEntry is an XDR Struct defines as:
//
//   struct SignerRoleEntry
//    {
//        uint64 id;
//        uint64 ruleIDs<>;
//
//        AccountID ownerID;
//
//        longstring details;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type SignerRoleEntry struct {
	Id      Uint64             `json:"id,omitempty"`
	RuleIDs []Uint64           `json:"ruleIDs,omitempty"`
	OwnerId AccountId          `json:"ownerID,omitempty"`
	Details Longstring         `json:"details,omitempty"`
	Ext     SignerRoleEntryExt `json:"ext,omitempty"`
}

// SignerRuleEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type SignerRuleEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u SignerRuleEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of SignerRuleEntryExt
func (u SignerRuleEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewSignerRuleEntryExt creates a new  SignerRuleEntryExt.
func NewSignerRuleEntryExt(v LedgerVersion, value interface{}) (result SignerRuleEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// SignerRuleEntry is an XDR Struct defines as:
//
//   struct SignerRuleEntry
//    {
//        uint64 id;
//
//        SignerRuleResource resource;
//        SignerRuleAction action;
//
//        bool forbids;
//        bool isDefault; // default rules will be in each role
//
//        longstring details;
//
//        AccountID ownerID;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type SignerRuleEntry struct {
	Id        Uint64             `json:"id,omitempty"`
	Resource  SignerRuleResource `json:"resource,omitempty"`
	Action    SignerRuleAction   `json:"action,omitempty"`
	Forbids   bool               `json:"forbids,omitempty"`
	IsDefault bool               `json:"isDefault,omitempty"`
	Details   Longstring         `json:"details,omitempty"`
	OwnerId   AccountId          `json:"ownerID,omitempty"`
	Ext       SignerRuleEntryExt `json:"ext,omitempty"`
}

// SignerEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type SignerEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u SignerEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of SignerEntryExt
func (u SignerEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewSignerEntryExt creates a new  SignerEntryExt.
func NewSignerEntryExt(v LedgerVersion, value interface{}) (result SignerEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// SignerEntry is an XDR Struct defines as:
//
//   struct SignerEntry
//    {
//        PublicKey pubKey;
//        AccountID accountID; // account to which signer had attached
//
//        uint32 weight; // threshold for all SignerRules equals 1000
//    	uint32 identity;
//
//    	longstring details;
//
//    	uint64 roleID;
//
//    	 // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type SignerEntry struct {
	PubKey    PublicKey      `json:"pubKey,omitempty"`
	AccountId AccountId      `json:"accountID,omitempty"`
	Weight    Uint32         `json:"weight,omitempty"`
	Identity  Uint32         `json:"identity,omitempty"`
	Details   Longstring     `json:"details,omitempty"`
	RoleId    Uint64         `json:"roleID,omitempty"`
	Ext       SignerEntryExt `json:"ext,omitempty"`
}

// StampEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type StampEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u StampEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of StampEntryExt
func (u StampEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewStampEntryExt creates a new  StampEntryExt.
func NewStampEntryExt(v LedgerVersion, value interface{}) (result StampEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// StampEntry is an XDR Struct defines as:
//
//   struct StampEntry
//    {
//        Hash ledgerHash;
//        Hash licenseHash;
//
//         // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type StampEntry struct {
	LedgerHash  Hash          `json:"ledgerHash,omitempty"`
	LicenseHash Hash          `json:"licenseHash,omitempty"`
	Ext         StampEntryExt `json:"ext,omitempty"`
}

// StatisticsV2EntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type StatisticsV2EntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u StatisticsV2EntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of StatisticsV2EntryExt
func (u StatisticsV2EntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewStatisticsV2EntryExt creates a new  StatisticsV2EntryExt.
func NewStatisticsV2EntryExt(v LedgerVersion, value interface{}) (result StatisticsV2EntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// StatisticsV2Entry is an XDR Struct defines as:
//
//   struct StatisticsV2Entry
//    {
//        uint64      id;
//    	AccountID   accountID;
//    	StatsOpType statsOpType;
//        AssetCode   assetCode;
//        bool        isConvertNeeded;
//
//    	uint64 dailyOutcome;
//    	uint64 weeklyOutcome;
//    	uint64 monthlyOutcome;
//    	uint64 annualOutcome;
//
//    	int64 updatedAt;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type StatisticsV2Entry struct {
	Id              Uint64               `json:"id,omitempty"`
	AccountId       AccountId            `json:"accountID,omitempty"`
	StatsOpType     StatsOpType          `json:"statsOpType,omitempty"`
	AssetCode       AssetCode            `json:"assetCode,omitempty"`
	IsConvertNeeded bool                 `json:"isConvertNeeded,omitempty"`
	DailyOutcome    Uint64               `json:"dailyOutcome,omitempty"`
	WeeklyOutcome   Uint64               `json:"weeklyOutcome,omitempty"`
	MonthlyOutcome  Uint64               `json:"monthlyOutcome,omitempty"`
	AnnualOutcome   Uint64               `json:"annualOutcome,omitempty"`
	UpdatedAt       Int64                `json:"updatedAt,omitempty"`
	Ext             StatisticsV2EntryExt `json:"ext,omitempty"`
}

// StatisticsEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type StatisticsEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u StatisticsEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of StatisticsEntryExt
func (u StatisticsEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewStatisticsEntryExt creates a new  StatisticsEntryExt.
func NewStatisticsEntryExt(v LedgerVersion, value interface{}) (result StatisticsEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// StatisticsEntry is an XDR Struct defines as:
//
//   struct StatisticsEntry
//    {
//    	AccountID accountID;
//
//    	uint64 dailyOutcome;
//    	uint64 weeklyOutcome;
//    	uint64 monthlyOutcome;
//    	uint64 annualOutcome;
//
//    	int64 updatedAt;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type StatisticsEntry struct {
	AccountId      AccountId          `json:"accountID,omitempty"`
	DailyOutcome   Uint64             `json:"dailyOutcome,omitempty"`
	WeeklyOutcome  Uint64             `json:"weeklyOutcome,omitempty"`
	MonthlyOutcome Uint64             `json:"monthlyOutcome,omitempty"`
	AnnualOutcome  Uint64             `json:"annualOutcome,omitempty"`
	UpdatedAt      Int64              `json:"updatedAt,omitempty"`
	Ext            StatisticsEntryExt `json:"ext,omitempty"`
}

// SwapEntry is an XDR Struct defines as:
//
//   struct SwapEntry
//    {
//        uint64 id;
//
//        Hash secretHash;
//
//        AccountID source;
//        BalanceID sourceBalance;
//
//        BalanceID destinationBalance;
//
//        longstring details;
//
//        uint64 amount;
//
//        int64 createdAt;
//        int64 lockTime;
//
//    	uint64 fee;
//
//        EmptyExt ext;
//    };
//
type SwapEntry struct {
	Id                 Uint64     `json:"id,omitempty"`
	SecretHash         Hash       `json:"secretHash,omitempty"`
	Source             AccountId  `json:"source,omitempty"`
	SourceBalance      BalanceId  `json:"sourceBalance,omitempty"`
	DestinationBalance BalanceId  `json:"destinationBalance,omitempty"`
	Details            Longstring `json:"details,omitempty"`
	Amount             Uint64     `json:"amount,omitempty"`
	CreatedAt          Int64      `json:"createdAt,omitempty"`
	LockTime           Int64      `json:"lockTime,omitempty"`
	Fee                Uint64     `json:"fee,omitempty"`
	Ext                EmptyExt   `json:"ext,omitempty"`
}

// SingleChoiceVote is an XDR Struct defines as:
//
//   struct SingleChoiceVote
//    {
//        uint32 choice;
//        EmptyExt ext;
//    };
//
type SingleChoiceVote struct {
	Choice Uint32   `json:"choice,omitempty"`
	Ext    EmptyExt `json:"ext,omitempty"`
}

// VoteData is an XDR Union defines as:
//
//   union VoteData switch (PollType pollType)
//    {
//    case SINGLE_CHOICE:
//        SingleChoiceVote single;
//    //case MULTIPLE_CHOICE:
//    //    MultipleChoiceVote multiple;
//    };
//
type VoteData struct {
	PollType PollType          `json:"pollType,omitempty"`
	Single   *SingleChoiceVote `json:"single,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u VoteData) SwitchFieldName() string {
	return "PollType"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of VoteData
func (u VoteData) ArmForSwitch(sw int32) (string, bool) {
	switch PollType(sw) {
	case PollTypeSingleChoice:
		return "Single", true
	}
	return "-", false
}

// NewVoteData creates a new  VoteData.
func NewVoteData(pollType PollType, value interface{}) (result VoteData, err error) {
	result.PollType = pollType
	switch PollType(pollType) {
	case PollTypeSingleChoice:
		tv, ok := value.(SingleChoiceVote)
		if !ok {
			err = fmt.Errorf("invalid value, must be SingleChoiceVote")
			return
		}
		result.Single = &tv
	}
	return
}

// MustSingle retrieves the Single value from the union,
// panicing if the value is not set.
func (u VoteData) MustSingle() SingleChoiceVote {
	val, ok := u.GetSingle()

	if !ok {
		panic("arm Single is not set")
	}

	return val
}

// GetSingle retrieves the Single value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u VoteData) GetSingle() (result SingleChoiceVote, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.PollType))

	if armName == "Single" {
		result = *u.Single
		ok = true
	}

	return
}

// VoteEntry is an XDR Struct defines as:
//
//   struct VoteEntry
//    {
//        uint64 pollID;
//
//        AccountID voterID;
//
//        VoteData data;
//
//        EmptyExt ext;
//    };
//
type VoteEntry struct {
	PollId  Uint64    `json:"pollID,omitempty"`
	VoterId AccountId `json:"voterID,omitempty"`
	Data    VoteData  `json:"data,omitempty"`
	Ext     EmptyExt  `json:"ext,omitempty"`
}

// ThresholdIndexes is an XDR Enum defines as:
//
//   enum ThresholdIndexes
//    {
//        MASTER_WEIGHT = 0,
//        LOW = 1,
//        MED = 2,
//        HIGH = 3
//    };
//
type ThresholdIndexes int32

const (
	ThresholdIndexesMasterWeight ThresholdIndexes = 0
	ThresholdIndexesLow          ThresholdIndexes = 1
	ThresholdIndexesMed          ThresholdIndexes = 2
	ThresholdIndexesHigh         ThresholdIndexes = 3
)

var ThresholdIndexesAll = []ThresholdIndexes{
	ThresholdIndexesMasterWeight,
	ThresholdIndexesLow,
	ThresholdIndexesMed,
	ThresholdIndexesHigh,
}

var thresholdIndexesMap = map[int32]string{
	0: "ThresholdIndexesMasterWeight",
	1: "ThresholdIndexesLow",
	2: "ThresholdIndexesMed",
	3: "ThresholdIndexesHigh",
}

var thresholdIndexesShortMap = map[int32]string{
	0: "master_weight",
	1: "low",
	2: "med",
	3: "high",
}

var thresholdIndexesRevMap = map[string]int32{
	"ThresholdIndexesMasterWeight": 0,
	"ThresholdIndexesLow":          1,
	"ThresholdIndexesMed":          2,
	"ThresholdIndexesHigh":         3,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ThresholdIndexes
func (e ThresholdIndexes) ValidEnum(v int32) bool {
	_, ok := thresholdIndexesMap[v]
	return ok
}
func (e ThresholdIndexes) isFlag() bool {
	for i := len(ThresholdIndexesAll) - 1; i >= 0; i-- {
		expected := ThresholdIndexes(2) << uint64(len(ThresholdIndexesAll)-1) >> uint64(len(ThresholdIndexesAll)-i)
		if expected != ThresholdIndexesAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ThresholdIndexes) String() string {
	name, _ := thresholdIndexesMap[int32(e)]
	return name
}

func (e ThresholdIndexes) ShortString() string {
	name, _ := thresholdIndexesShortMap[int32(e)]
	return name
}

func (e ThresholdIndexes) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ThresholdIndexesAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ThresholdIndexes) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ThresholdIndexes(t.Value)
	return nil
}

// LedgerEntryData is an XDR NestedUnion defines as:
//
//   union switch (LedgerEntryType type)
//        {
//        case ACCOUNT:
//            AccountEntry account;
//        case SIGNER:
//            SignerEntry signer;
//        case FEE:
//            FeeEntry feeState;
//        case BALANCE:
//            BalanceEntry balance;
//        case ASSET:
//            AssetEntry asset;
//        case REFERENCE_ENTRY:
//            ReferenceEntry reference;
//        case STATISTICS:
//            StatisticsEntry stats;
//        case ACCOUNT_LIMITS:
//            AccountLimitsEntry accountLimits;
//    	case ASSET_PAIR:
//    		AssetPairEntry assetPair;
//    	case OFFER_ENTRY:
//    		OfferEntry offer;
//    	case REVIEWABLE_REQUEST:
//    		ReviewableRequestEntry reviewableRequest;
//    	case EXTERNAL_SYSTEM_ACCOUNT_ID:
//    		ExternalSystemAccountID externalSystemAccountID;
//    	case SALE:
//    		SaleEntry sale;
//    	case KEY_VALUE:
//    	    KeyValueEntry keyValue;
//    	case ACCOUNT_KYC:
//            AccountKYCEntry accountKYC;
//        case EXTERNAL_SYSTEM_ACCOUNT_ID_POOL_ENTRY:
//            ExternalSystemAccountIDPoolEntry externalSystemAccountIDPoolEntry;
//        case LIMITS_V2:
//            LimitsV2Entry limitsV2;
//        case STATISTICS_V2:
//            StatisticsV2Entry statisticsV2;
//        case PENDING_STATISTICS:
//            PendingStatisticsEntry pendingStatistics;
//        case CONTRACT:
//            ContractEntry contract;
//        case ATOMIC_SWAP_ASK:
//            AtomicSwapAskEntry atomicSwapAsk;
//        case ACCOUNT_ROLE:
//            AccountRoleEntry accountRole;
//        case ACCOUNT_RULE:
//            AccountRuleEntry accountRule;
//        case SIGNER_RULE:
//            SignerRuleEntry signerRule;
//        case SIGNER_ROLE:
//            SignerRoleEntry signerRole;
//        case LICENSE:
//            LicenseEntry license;
//        case STAMP:
//            StampEntry stamp;
//        case POLL:
//            PollEntry poll;
//        case VOTE:
//            VoteEntry vote;
//        case ACCOUNT_SPECIFIC_RULE:
//            AccountSpecificRuleEntry accountSpecificRule;
//        case SWAP:
//            SwapEntry swap;
//        case DATA:
//            DataEntry data;
//        case DEFERRED_PAYMENT:
//            DeferredPaymentEntry deferredPayment;
//        }
//
type LedgerEntryData struct {
	Type                             LedgerEntryType                   `json:"type,omitempty"`
	Account                          *AccountEntry                     `json:"account,omitempty"`
	Signer                           *SignerEntry                      `json:"signer,omitempty"`
	FeeState                         *FeeEntry                         `json:"feeState,omitempty"`
	Balance                          *BalanceEntry                     `json:"balance,omitempty"`
	Asset                            *AssetEntry                       `json:"asset,omitempty"`
	Reference                        *ReferenceEntry                   `json:"reference,omitempty"`
	Stats                            *StatisticsEntry                  `json:"stats,omitempty"`
	AccountLimits                    *AccountLimitsEntry               `json:"accountLimits,omitempty"`
	AssetPair                        *AssetPairEntry                   `json:"assetPair,omitempty"`
	Offer                            *OfferEntry                       `json:"offer,omitempty"`
	ReviewableRequest                *ReviewableRequestEntry           `json:"reviewableRequest,omitempty"`
	ExternalSystemAccountId          *ExternalSystemAccountId          `json:"externalSystemAccountID,omitempty"`
	Sale                             *SaleEntry                        `json:"sale,omitempty"`
	KeyValue                         *KeyValueEntry                    `json:"keyValue,omitempty"`
	AccountKyc                       *AccountKycEntry                  `json:"accountKYC,omitempty"`
	ExternalSystemAccountIdPoolEntry *ExternalSystemAccountIdPoolEntry `json:"externalSystemAccountIDPoolEntry,omitempty"`
	LimitsV2                         *LimitsV2Entry                    `json:"limitsV2,omitempty"`
	StatisticsV2                     *StatisticsV2Entry                `json:"statisticsV2,omitempty"`
	PendingStatistics                *PendingStatisticsEntry           `json:"pendingStatistics,omitempty"`
	Contract                         *ContractEntry                    `json:"contract,omitempty"`
	AtomicSwapAsk                    *AtomicSwapAskEntry               `json:"atomicSwapAsk,omitempty"`
	AccountRole                      *AccountRoleEntry                 `json:"accountRole,omitempty"`
	AccountRule                      *AccountRuleEntry                 `json:"accountRule,omitempty"`
	SignerRule                       *SignerRuleEntry                  `json:"signerRule,omitempty"`
	SignerRole                       *SignerRoleEntry                  `json:"signerRole,omitempty"`
	License                          *LicenseEntry                     `json:"license,omitempty"`
	Stamp                            *StampEntry                       `json:"stamp,omitempty"`
	Poll                             *PollEntry                        `json:"poll,omitempty"`
	Vote                             *VoteEntry                        `json:"vote,omitempty"`
	AccountSpecificRule              *AccountSpecificRuleEntry         `json:"accountSpecificRule,omitempty"`
	Swap                             *SwapEntry                        `json:"swap,omitempty"`
	Data                             *DataEntry                        `json:"data,omitempty"`
	DeferredPayment                  *DeferredPaymentEntry             `json:"deferredPayment,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerEntryData) SwitchFieldName() string {
	return "Type"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerEntryData
func (u LedgerEntryData) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerEntryType(sw) {
	case LedgerEntryTypeAccount:
		return "Account", true
	case LedgerEntryTypeSigner:
		return "Signer", true
	case LedgerEntryTypeFee:
		return "FeeState", true
	case LedgerEntryTypeBalance:
		return "Balance", true
	case LedgerEntryTypeAsset:
		return "Asset", true
	case LedgerEntryTypeReferenceEntry:
		return "Reference", true
	case LedgerEntryTypeStatistics:
		return "Stats", true
	case LedgerEntryTypeAccountLimits:
		return "AccountLimits", true
	case LedgerEntryTypeAssetPair:
		return "AssetPair", true
	case LedgerEntryTypeOfferEntry:
		return "Offer", true
	case LedgerEntryTypeReviewableRequest:
		return "ReviewableRequest", true
	case LedgerEntryTypeExternalSystemAccountId:
		return "ExternalSystemAccountId", true
	case LedgerEntryTypeSale:
		return "Sale", true
	case LedgerEntryTypeKeyValue:
		return "KeyValue", true
	case LedgerEntryTypeAccountKyc:
		return "AccountKyc", true
	case LedgerEntryTypeExternalSystemAccountIdPoolEntry:
		return "ExternalSystemAccountIdPoolEntry", true
	case LedgerEntryTypeLimitsV2:
		return "LimitsV2", true
	case LedgerEntryTypeStatisticsV2:
		return "StatisticsV2", true
	case LedgerEntryTypePendingStatistics:
		return "PendingStatistics", true
	case LedgerEntryTypeContract:
		return "Contract", true
	case LedgerEntryTypeAtomicSwapAsk:
		return "AtomicSwapAsk", true
	case LedgerEntryTypeAccountRole:
		return "AccountRole", true
	case LedgerEntryTypeAccountRule:
		return "AccountRule", true
	case LedgerEntryTypeSignerRule:
		return "SignerRule", true
	case LedgerEntryTypeSignerRole:
		return "SignerRole", true
	case LedgerEntryTypeLicense:
		return "License", true
	case LedgerEntryTypeStamp:
		return "Stamp", true
	case LedgerEntryTypePoll:
		return "Poll", true
	case LedgerEntryTypeVote:
		return "Vote", true
	case LedgerEntryTypeAccountSpecificRule:
		return "AccountSpecificRule", true
	case LedgerEntryTypeSwap:
		return "Swap", true
	case LedgerEntryTypeData:
		return "Data", true
	case LedgerEntryTypeDeferredPayment:
		return "DeferredPayment", true
	}
	return "-", false
}

// NewLedgerEntryData creates a new  LedgerEntryData.
func NewLedgerEntryData(aType LedgerEntryType, value interface{}) (result LedgerEntryData, err error) {
	result.Type = aType
	switch LedgerEntryType(aType) {
	case LedgerEntryTypeAccount:
		tv, ok := value.(AccountEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be AccountEntry")
			return
		}
		result.Account = &tv
	case LedgerEntryTypeSigner:
		tv, ok := value.(SignerEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be SignerEntry")
			return
		}
		result.Signer = &tv
	case LedgerEntryTypeFee:
		tv, ok := value.(FeeEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be FeeEntry")
			return
		}
		result.FeeState = &tv
	case LedgerEntryTypeBalance:
		tv, ok := value.(BalanceEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be BalanceEntry")
			return
		}
		result.Balance = &tv
	case LedgerEntryTypeAsset:
		tv, ok := value.(AssetEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be AssetEntry")
			return
		}
		result.Asset = &tv
	case LedgerEntryTypeReferenceEntry:
		tv, ok := value.(ReferenceEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be ReferenceEntry")
			return
		}
		result.Reference = &tv
	case LedgerEntryTypeStatistics:
		tv, ok := value.(StatisticsEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be StatisticsEntry")
			return
		}
		result.Stats = &tv
	case LedgerEntryTypeAccountLimits:
		tv, ok := value.(AccountLimitsEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be AccountLimitsEntry")
			return
		}
		result.AccountLimits = &tv
	case LedgerEntryTypeAssetPair:
		tv, ok := value.(AssetPairEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be AssetPairEntry")
			return
		}
		result.AssetPair = &tv
	case LedgerEntryTypeOfferEntry:
		tv, ok := value.(OfferEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be OfferEntry")
			return
		}
		result.Offer = &tv
	case LedgerEntryTypeReviewableRequest:
		tv, ok := value.(ReviewableRequestEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be ReviewableRequestEntry")
			return
		}
		result.ReviewableRequest = &tv
	case LedgerEntryTypeExternalSystemAccountId:
		tv, ok := value.(ExternalSystemAccountId)
		if !ok {
			err = fmt.Errorf("invalid value, must be ExternalSystemAccountId")
			return
		}
		result.ExternalSystemAccountId = &tv
	case LedgerEntryTypeSale:
		tv, ok := value.(SaleEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be SaleEntry")
			return
		}
		result.Sale = &tv
	case LedgerEntryTypeKeyValue:
		tv, ok := value.(KeyValueEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be KeyValueEntry")
			return
		}
		result.KeyValue = &tv
	case LedgerEntryTypeAccountKyc:
		tv, ok := value.(AccountKycEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be AccountKycEntry")
			return
		}
		result.AccountKyc = &tv
	case LedgerEntryTypeExternalSystemAccountIdPoolEntry:
		tv, ok := value.(ExternalSystemAccountIdPoolEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be ExternalSystemAccountIdPoolEntry")
			return
		}
		result.ExternalSystemAccountIdPoolEntry = &tv
	case LedgerEntryTypeLimitsV2:
		tv, ok := value.(LimitsV2Entry)
		if !ok {
			err = fmt.Errorf("invalid value, must be LimitsV2Entry")
			return
		}
		result.LimitsV2 = &tv
	case LedgerEntryTypeStatisticsV2:
		tv, ok := value.(StatisticsV2Entry)
		if !ok {
			err = fmt.Errorf("invalid value, must be StatisticsV2Entry")
			return
		}
		result.StatisticsV2 = &tv
	case LedgerEntryTypePendingStatistics:
		tv, ok := value.(PendingStatisticsEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be PendingStatisticsEntry")
			return
		}
		result.PendingStatistics = &tv
	case LedgerEntryTypeContract:
		tv, ok := value.(ContractEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be ContractEntry")
			return
		}
		result.Contract = &tv
	case LedgerEntryTypeAtomicSwapAsk:
		tv, ok := value.(AtomicSwapAskEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be AtomicSwapAskEntry")
			return
		}
		result.AtomicSwapAsk = &tv
	case LedgerEntryTypeAccountRole:
		tv, ok := value.(AccountRoleEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be AccountRoleEntry")
			return
		}
		result.AccountRole = &tv
	case LedgerEntryTypeAccountRule:
		tv, ok := value.(AccountRuleEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be AccountRuleEntry")
			return
		}
		result.AccountRule = &tv
	case LedgerEntryTypeSignerRule:
		tv, ok := value.(SignerRuleEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be SignerRuleEntry")
			return
		}
		result.SignerRule = &tv
	case LedgerEntryTypeSignerRole:
		tv, ok := value.(SignerRoleEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be SignerRoleEntry")
			return
		}
		result.SignerRole = &tv
	case LedgerEntryTypeLicense:
		tv, ok := value.(LicenseEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be LicenseEntry")
			return
		}
		result.License = &tv
	case LedgerEntryTypeStamp:
		tv, ok := value.(StampEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be StampEntry")
			return
		}
		result.Stamp = &tv
	case LedgerEntryTypePoll:
		tv, ok := value.(PollEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be PollEntry")
			return
		}
		result.Poll = &tv
	case LedgerEntryTypeVote:
		tv, ok := value.(VoteEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be VoteEntry")
			return
		}
		result.Vote = &tv
	case LedgerEntryTypeAccountSpecificRule:
		tv, ok := value.(AccountSpecificRuleEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be AccountSpecificRuleEntry")
			return
		}
		result.AccountSpecificRule = &tv
	case LedgerEntryTypeSwap:
		tv, ok := value.(SwapEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be SwapEntry")
			return
		}
		result.Swap = &tv
	case LedgerEntryTypeData:
		tv, ok := value.(DataEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be DataEntry")
			return
		}
		result.Data = &tv
	case LedgerEntryTypeDeferredPayment:
		tv, ok := value.(DeferredPaymentEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be DeferredPaymentEntry")
			return
		}
		result.DeferredPayment = &tv
	}
	return
}

// MustAccount retrieves the Account value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustAccount() AccountEntry {
	val, ok := u.GetAccount()

	if !ok {
		panic("arm Account is not set")
	}

	return val
}

// GetAccount retrieves the Account value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetAccount() (result AccountEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Account" {
		result = *u.Account
		ok = true
	}

	return
}

// MustSigner retrieves the Signer value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustSigner() SignerEntry {
	val, ok := u.GetSigner()

	if !ok {
		panic("arm Signer is not set")
	}

	return val
}

// GetSigner retrieves the Signer value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetSigner() (result SignerEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Signer" {
		result = *u.Signer
		ok = true
	}

	return
}

// MustFeeState retrieves the FeeState value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustFeeState() FeeEntry {
	val, ok := u.GetFeeState()

	if !ok {
		panic("arm FeeState is not set")
	}

	return val
}

// GetFeeState retrieves the FeeState value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetFeeState() (result FeeEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "FeeState" {
		result = *u.FeeState
		ok = true
	}

	return
}

// MustBalance retrieves the Balance value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustBalance() BalanceEntry {
	val, ok := u.GetBalance()

	if !ok {
		panic("arm Balance is not set")
	}

	return val
}

// GetBalance retrieves the Balance value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetBalance() (result BalanceEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Balance" {
		result = *u.Balance
		ok = true
	}

	return
}

// MustAsset retrieves the Asset value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustAsset() AssetEntry {
	val, ok := u.GetAsset()

	if !ok {
		panic("arm Asset is not set")
	}

	return val
}

// GetAsset retrieves the Asset value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetAsset() (result AssetEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Asset" {
		result = *u.Asset
		ok = true
	}

	return
}

// MustReference retrieves the Reference value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustReference() ReferenceEntry {
	val, ok := u.GetReference()

	if !ok {
		panic("arm Reference is not set")
	}

	return val
}

// GetReference retrieves the Reference value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetReference() (result ReferenceEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Reference" {
		result = *u.Reference
		ok = true
	}

	return
}

// MustStats retrieves the Stats value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustStats() StatisticsEntry {
	val, ok := u.GetStats()

	if !ok {
		panic("arm Stats is not set")
	}

	return val
}

// GetStats retrieves the Stats value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetStats() (result StatisticsEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Stats" {
		result = *u.Stats
		ok = true
	}

	return
}

// MustAccountLimits retrieves the AccountLimits value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustAccountLimits() AccountLimitsEntry {
	val, ok := u.GetAccountLimits()

	if !ok {
		panic("arm AccountLimits is not set")
	}

	return val
}

// GetAccountLimits retrieves the AccountLimits value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetAccountLimits() (result AccountLimitsEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "AccountLimits" {
		result = *u.AccountLimits
		ok = true
	}

	return
}

// MustAssetPair retrieves the AssetPair value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustAssetPair() AssetPairEntry {
	val, ok := u.GetAssetPair()

	if !ok {
		panic("arm AssetPair is not set")
	}

	return val
}

// GetAssetPair retrieves the AssetPair value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetAssetPair() (result AssetPairEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "AssetPair" {
		result = *u.AssetPair
		ok = true
	}

	return
}

// MustOffer retrieves the Offer value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustOffer() OfferEntry {
	val, ok := u.GetOffer()

	if !ok {
		panic("arm Offer is not set")
	}

	return val
}

// GetOffer retrieves the Offer value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetOffer() (result OfferEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Offer" {
		result = *u.Offer
		ok = true
	}

	return
}

// MustReviewableRequest retrieves the ReviewableRequest value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustReviewableRequest() ReviewableRequestEntry {
	val, ok := u.GetReviewableRequest()

	if !ok {
		panic("arm ReviewableRequest is not set")
	}

	return val
}

// GetReviewableRequest retrieves the ReviewableRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetReviewableRequest() (result ReviewableRequestEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ReviewableRequest" {
		result = *u.ReviewableRequest
		ok = true
	}

	return
}

// MustExternalSystemAccountId retrieves the ExternalSystemAccountId value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustExternalSystemAccountId() ExternalSystemAccountId {
	val, ok := u.GetExternalSystemAccountId()

	if !ok {
		panic("arm ExternalSystemAccountId is not set")
	}

	return val
}

// GetExternalSystemAccountId retrieves the ExternalSystemAccountId value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetExternalSystemAccountId() (result ExternalSystemAccountId, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ExternalSystemAccountId" {
		result = *u.ExternalSystemAccountId
		ok = true
	}

	return
}

// MustSale retrieves the Sale value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustSale() SaleEntry {
	val, ok := u.GetSale()

	if !ok {
		panic("arm Sale is not set")
	}

	return val
}

// GetSale retrieves the Sale value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetSale() (result SaleEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Sale" {
		result = *u.Sale
		ok = true
	}

	return
}

// MustKeyValue retrieves the KeyValue value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustKeyValue() KeyValueEntry {
	val, ok := u.GetKeyValue()

	if !ok {
		panic("arm KeyValue is not set")
	}

	return val
}

// GetKeyValue retrieves the KeyValue value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetKeyValue() (result KeyValueEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "KeyValue" {
		result = *u.KeyValue
		ok = true
	}

	return
}

// MustAccountKyc retrieves the AccountKyc value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustAccountKyc() AccountKycEntry {
	val, ok := u.GetAccountKyc()

	if !ok {
		panic("arm AccountKyc is not set")
	}

	return val
}

// GetAccountKyc retrieves the AccountKyc value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetAccountKyc() (result AccountKycEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "AccountKyc" {
		result = *u.AccountKyc
		ok = true
	}

	return
}

// MustExternalSystemAccountIdPoolEntry retrieves the ExternalSystemAccountIdPoolEntry value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustExternalSystemAccountIdPoolEntry() ExternalSystemAccountIdPoolEntry {
	val, ok := u.GetExternalSystemAccountIdPoolEntry()

	if !ok {
		panic("arm ExternalSystemAccountIdPoolEntry is not set")
	}

	return val
}

// GetExternalSystemAccountIdPoolEntry retrieves the ExternalSystemAccountIdPoolEntry value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetExternalSystemAccountIdPoolEntry() (result ExternalSystemAccountIdPoolEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ExternalSystemAccountIdPoolEntry" {
		result = *u.ExternalSystemAccountIdPoolEntry
		ok = true
	}

	return
}

// MustLimitsV2 retrieves the LimitsV2 value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustLimitsV2() LimitsV2Entry {
	val, ok := u.GetLimitsV2()

	if !ok {
		panic("arm LimitsV2 is not set")
	}

	return val
}

// GetLimitsV2 retrieves the LimitsV2 value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetLimitsV2() (result LimitsV2Entry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "LimitsV2" {
		result = *u.LimitsV2
		ok = true
	}

	return
}

// MustStatisticsV2 retrieves the StatisticsV2 value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustStatisticsV2() StatisticsV2Entry {
	val, ok := u.GetStatisticsV2()

	if !ok {
		panic("arm StatisticsV2 is not set")
	}

	return val
}

// GetStatisticsV2 retrieves the StatisticsV2 value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetStatisticsV2() (result StatisticsV2Entry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "StatisticsV2" {
		result = *u.StatisticsV2
		ok = true
	}

	return
}

// MustPendingStatistics retrieves the PendingStatistics value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustPendingStatistics() PendingStatisticsEntry {
	val, ok := u.GetPendingStatistics()

	if !ok {
		panic("arm PendingStatistics is not set")
	}

	return val
}

// GetPendingStatistics retrieves the PendingStatistics value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetPendingStatistics() (result PendingStatisticsEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "PendingStatistics" {
		result = *u.PendingStatistics
		ok = true
	}

	return
}

// MustContract retrieves the Contract value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustContract() ContractEntry {
	val, ok := u.GetContract()

	if !ok {
		panic("arm Contract is not set")
	}

	return val
}

// GetContract retrieves the Contract value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetContract() (result ContractEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Contract" {
		result = *u.Contract
		ok = true
	}

	return
}

// MustAtomicSwapAsk retrieves the AtomicSwapAsk value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustAtomicSwapAsk() AtomicSwapAskEntry {
	val, ok := u.GetAtomicSwapAsk()

	if !ok {
		panic("arm AtomicSwapAsk is not set")
	}

	return val
}

// GetAtomicSwapAsk retrieves the AtomicSwapAsk value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetAtomicSwapAsk() (result AtomicSwapAskEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "AtomicSwapAsk" {
		result = *u.AtomicSwapAsk
		ok = true
	}

	return
}

// MustAccountRole retrieves the AccountRole value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustAccountRole() AccountRoleEntry {
	val, ok := u.GetAccountRole()

	if !ok {
		panic("arm AccountRole is not set")
	}

	return val
}

// GetAccountRole retrieves the AccountRole value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetAccountRole() (result AccountRoleEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "AccountRole" {
		result = *u.AccountRole
		ok = true
	}

	return
}

// MustAccountRule retrieves the AccountRule value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustAccountRule() AccountRuleEntry {
	val, ok := u.GetAccountRule()

	if !ok {
		panic("arm AccountRule is not set")
	}

	return val
}

// GetAccountRule retrieves the AccountRule value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetAccountRule() (result AccountRuleEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "AccountRule" {
		result = *u.AccountRule
		ok = true
	}

	return
}

// MustSignerRule retrieves the SignerRule value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustSignerRule() SignerRuleEntry {
	val, ok := u.GetSignerRule()

	if !ok {
		panic("arm SignerRule is not set")
	}

	return val
}

// GetSignerRule retrieves the SignerRule value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetSignerRule() (result SignerRuleEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "SignerRule" {
		result = *u.SignerRule
		ok = true
	}

	return
}

// MustSignerRole retrieves the SignerRole value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustSignerRole() SignerRoleEntry {
	val, ok := u.GetSignerRole()

	if !ok {
		panic("arm SignerRole is not set")
	}

	return val
}

// GetSignerRole retrieves the SignerRole value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetSignerRole() (result SignerRoleEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "SignerRole" {
		result = *u.SignerRole
		ok = true
	}

	return
}

// MustLicense retrieves the License value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustLicense() LicenseEntry {
	val, ok := u.GetLicense()

	if !ok {
		panic("arm License is not set")
	}

	return val
}

// GetLicense retrieves the License value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetLicense() (result LicenseEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "License" {
		result = *u.License
		ok = true
	}

	return
}

// MustStamp retrieves the Stamp value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustStamp() StampEntry {
	val, ok := u.GetStamp()

	if !ok {
		panic("arm Stamp is not set")
	}

	return val
}

// GetStamp retrieves the Stamp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetStamp() (result StampEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Stamp" {
		result = *u.Stamp
		ok = true
	}

	return
}

// MustPoll retrieves the Poll value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustPoll() PollEntry {
	val, ok := u.GetPoll()

	if !ok {
		panic("arm Poll is not set")
	}

	return val
}

// GetPoll retrieves the Poll value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetPoll() (result PollEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Poll" {
		result = *u.Poll
		ok = true
	}

	return
}

// MustVote retrieves the Vote value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustVote() VoteEntry {
	val, ok := u.GetVote()

	if !ok {
		panic("arm Vote is not set")
	}

	return val
}

// GetVote retrieves the Vote value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetVote() (result VoteEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Vote" {
		result = *u.Vote
		ok = true
	}

	return
}

// MustAccountSpecificRule retrieves the AccountSpecificRule value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustAccountSpecificRule() AccountSpecificRuleEntry {
	val, ok := u.GetAccountSpecificRule()

	if !ok {
		panic("arm AccountSpecificRule is not set")
	}

	return val
}

// GetAccountSpecificRule retrieves the AccountSpecificRule value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetAccountSpecificRule() (result AccountSpecificRuleEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "AccountSpecificRule" {
		result = *u.AccountSpecificRule
		ok = true
	}

	return
}

// MustSwap retrieves the Swap value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustSwap() SwapEntry {
	val, ok := u.GetSwap()

	if !ok {
		panic("arm Swap is not set")
	}

	return val
}

// GetSwap retrieves the Swap value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetSwap() (result SwapEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Swap" {
		result = *u.Swap
		ok = true
	}

	return
}

// MustData retrieves the Data value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustData() DataEntry {
	val, ok := u.GetData()

	if !ok {
		panic("arm Data is not set")
	}

	return val
}

// GetData retrieves the Data value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetData() (result DataEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Data" {
		result = *u.Data
		ok = true
	}

	return
}

// MustDeferredPayment retrieves the DeferredPayment value from the union,
// panicing if the value is not set.
func (u LedgerEntryData) MustDeferredPayment() DeferredPaymentEntry {
	val, ok := u.GetDeferredPayment()

	if !ok {
		panic("arm DeferredPayment is not set")
	}

	return val
}

// GetDeferredPayment retrieves the DeferredPayment value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryData) GetDeferredPayment() (result DeferredPaymentEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "DeferredPayment" {
		result = *u.DeferredPayment
		ok = true
	}

	return
}

// LedgerEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type LedgerEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerEntryExt
func (u LedgerEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerEntryExt creates a new  LedgerEntryExt.
func NewLedgerEntryExt(v LedgerVersion, value interface{}) (result LedgerEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerEntry is an XDR Struct defines as:
//
//   struct LedgerEntry
//    {
//        uint32 lastModifiedLedgerSeq; // ledger the LedgerEntry was last changed
//
//        union switch (LedgerEntryType type)
//        {
//        case ACCOUNT:
//            AccountEntry account;
//        case SIGNER:
//            SignerEntry signer;
//        case FEE:
//            FeeEntry feeState;
//        case BALANCE:
//            BalanceEntry balance;
//        case ASSET:
//            AssetEntry asset;
//        case REFERENCE_ENTRY:
//            ReferenceEntry reference;
//        case STATISTICS:
//            StatisticsEntry stats;
//        case ACCOUNT_LIMITS:
//            AccountLimitsEntry accountLimits;
//    	case ASSET_PAIR:
//    		AssetPairEntry assetPair;
//    	case OFFER_ENTRY:
//    		OfferEntry offer;
//    	case REVIEWABLE_REQUEST:
//    		ReviewableRequestEntry reviewableRequest;
//    	case EXTERNAL_SYSTEM_ACCOUNT_ID:
//    		ExternalSystemAccountID externalSystemAccountID;
//    	case SALE:
//    		SaleEntry sale;
//    	case KEY_VALUE:
//    	    KeyValueEntry keyValue;
//    	case ACCOUNT_KYC:
//            AccountKYCEntry accountKYC;
//        case EXTERNAL_SYSTEM_ACCOUNT_ID_POOL_ENTRY:
//            ExternalSystemAccountIDPoolEntry externalSystemAccountIDPoolEntry;
//        case LIMITS_V2:
//            LimitsV2Entry limitsV2;
//        case STATISTICS_V2:
//            StatisticsV2Entry statisticsV2;
//        case PENDING_STATISTICS:
//            PendingStatisticsEntry pendingStatistics;
//        case CONTRACT:
//            ContractEntry contract;
//        case ATOMIC_SWAP_ASK:
//            AtomicSwapAskEntry atomicSwapAsk;
//        case ACCOUNT_ROLE:
//            AccountRoleEntry accountRole;
//        case ACCOUNT_RULE:
//            AccountRuleEntry accountRule;
//        case SIGNER_RULE:
//            SignerRuleEntry signerRule;
//        case SIGNER_ROLE:
//            SignerRoleEntry signerRole;
//        case LICENSE:
//            LicenseEntry license;
//        case STAMP:
//            StampEntry stamp;
//        case POLL:
//            PollEntry poll;
//        case VOTE:
//            VoteEntry vote;
//        case ACCOUNT_SPECIFIC_RULE:
//            AccountSpecificRuleEntry accountSpecificRule;
//        case SWAP:
//            SwapEntry swap;
//        case DATA:
//            DataEntry data;
//        case DEFERRED_PAYMENT:
//            DeferredPaymentEntry deferredPayment;
//        }
//        data;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type LedgerEntry struct {
	LastModifiedLedgerSeq Uint32          `json:"lastModifiedLedgerSeq,omitempty"`
	Data                  LedgerEntryData `json:"data,omitempty"`
	Ext                   LedgerEntryExt  `json:"ext,omitempty"`
}

// EnvelopeType is an XDR Enum defines as:
//
//   enum EnvelopeType
//    {
//        SCP = 1,
//        TX = 2,
//        AUTH = 3
//    };
//
type EnvelopeType int32

const (
	EnvelopeTypeScp  EnvelopeType = 1
	EnvelopeTypeTx   EnvelopeType = 2
	EnvelopeTypeAuth EnvelopeType = 3
)

var EnvelopeTypeAll = []EnvelopeType{
	EnvelopeTypeScp,
	EnvelopeTypeTx,
	EnvelopeTypeAuth,
}

var envelopeTypeMap = map[int32]string{
	1: "EnvelopeTypeScp",
	2: "EnvelopeTypeTx",
	3: "EnvelopeTypeAuth",
}

var envelopeTypeShortMap = map[int32]string{
	1: "scp",
	2: "tx",
	3: "auth",
}

var envelopeTypeRevMap = map[string]int32{
	"EnvelopeTypeScp":  1,
	"EnvelopeTypeTx":   2,
	"EnvelopeTypeAuth": 3,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for EnvelopeType
func (e EnvelopeType) ValidEnum(v int32) bool {
	_, ok := envelopeTypeMap[v]
	return ok
}
func (e EnvelopeType) isFlag() bool {
	for i := len(EnvelopeTypeAll) - 1; i >= 0; i-- {
		expected := EnvelopeType(2) << uint64(len(EnvelopeTypeAll)-1) >> uint64(len(EnvelopeTypeAll)-i)
		if expected != EnvelopeTypeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e EnvelopeType) String() string {
	name, _ := envelopeTypeMap[int32(e)]
	return name
}

func (e EnvelopeType) ShortString() string {
	name, _ := envelopeTypeShortMap[int32(e)]
	return name
}

func (e EnvelopeType) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range EnvelopeTypeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *EnvelopeType) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = EnvelopeType(t.Value)
	return nil
}

// LedgerKeyAccountExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//           {
//           case EMPTY_VERSION:
//              void;
//           }
//
type LedgerKeyAccountExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKeyAccountExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKeyAccountExt
func (u LedgerKeyAccountExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerKeyAccountExt creates a new  LedgerKeyAccountExt.
func NewLedgerKeyAccountExt(v LedgerVersion, value interface{}) (result LedgerKeyAccountExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerKeyAccount is an XDR NestedStruct defines as:
//
//   struct
//        {
//            AccountID accountID;
//            union switch (LedgerVersion v)
//           {
//           case EMPTY_VERSION:
//              void;
//           }
//           ext;
//        }
//
type LedgerKeyAccount struct {
	AccountId AccountId           `json:"accountID,omitempty"`
	Ext       LedgerKeyAccountExt `json:"ext,omitempty"`
}

// LedgerKeySignerExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type LedgerKeySignerExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKeySignerExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKeySignerExt
func (u LedgerKeySignerExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerKeySignerExt creates a new  LedgerKeySignerExt.
func NewLedgerKeySignerExt(v LedgerVersion, value interface{}) (result LedgerKeySignerExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerKeySigner is an XDR NestedStruct defines as:
//
//   struct
//        {
//            PublicKey pubKey;
//            AccountID accountID;
//
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        }
//
type LedgerKeySigner struct {
	PubKey    PublicKey          `json:"pubKey,omitempty"`
	AccountId AccountId          `json:"accountID,omitempty"`
	Ext       LedgerKeySignerExt `json:"ext,omitempty"`
}

// LedgerKeyFeeStateExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type LedgerKeyFeeStateExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKeyFeeStateExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKeyFeeStateExt
func (u LedgerKeyFeeStateExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerKeyFeeStateExt creates a new  LedgerKeyFeeStateExt.
func NewLedgerKeyFeeStateExt(v LedgerVersion, value interface{}) (result LedgerKeyFeeStateExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerKeyFeeState is an XDR NestedStruct defines as:
//
//   struct {
//            Hash hash;
//            int64 lowerBound;
//            int64 upperBound;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        }
//
type LedgerKeyFeeState struct {
	Hash       Hash                 `json:"hash,omitempty"`
	LowerBound Int64                `json:"lowerBound,omitempty"`
	UpperBound Int64                `json:"upperBound,omitempty"`
	Ext        LedgerKeyFeeStateExt `json:"ext,omitempty"`
}

// LedgerKeyBalanceExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type LedgerKeyBalanceExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKeyBalanceExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKeyBalanceExt
func (u LedgerKeyBalanceExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerKeyBalanceExt creates a new  LedgerKeyBalanceExt.
func NewLedgerKeyBalanceExt(v LedgerVersion, value interface{}) (result LedgerKeyBalanceExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerKeyBalance is an XDR NestedStruct defines as:
//
//   struct
//        {
//            BalanceID balanceID;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        }
//
type LedgerKeyBalance struct {
	BalanceId BalanceId           `json:"balanceID,omitempty"`
	Ext       LedgerKeyBalanceExt `json:"ext,omitempty"`
}

// LedgerKeyAssetExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type LedgerKeyAssetExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKeyAssetExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKeyAssetExt
func (u LedgerKeyAssetExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerKeyAssetExt creates a new  LedgerKeyAssetExt.
func NewLedgerKeyAssetExt(v LedgerVersion, value interface{}) (result LedgerKeyAssetExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerKeyAsset is an XDR NestedStruct defines as:
//
//   struct
//        {
//            AssetCode code;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        }
//
type LedgerKeyAsset struct {
	Code AssetCode         `json:"code,omitempty"`
	Ext  LedgerKeyAssetExt `json:"ext,omitempty"`
}

// LedgerKeyReferenceExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//    		{
//    		case EMPTY_VERSION:
//    			void;
//    		}
//
type LedgerKeyReferenceExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKeyReferenceExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKeyReferenceExt
func (u LedgerKeyReferenceExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerKeyReferenceExt creates a new  LedgerKeyReferenceExt.
func NewLedgerKeyReferenceExt(v LedgerVersion, value interface{}) (result LedgerKeyReferenceExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerKeyReference is an XDR NestedStruct defines as:
//
//   struct
//        {
//    		AccountID sender;
//    		string64 reference;
//    		union switch (LedgerVersion v)
//    		{
//    		case EMPTY_VERSION:
//    			void;
//    		}
//    		ext;
//        }
//
type LedgerKeyReference struct {
	Sender    AccountId             `json:"sender,omitempty"`
	Reference String64              `json:"reference,omitempty"`
	Ext       LedgerKeyReferenceExt `json:"ext,omitempty"`
}

// LedgerKeyStatsExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//    		{
//    		case EMPTY_VERSION:
//    			void;
//    		}
//
type LedgerKeyStatsExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKeyStatsExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKeyStatsExt
func (u LedgerKeyStatsExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerKeyStatsExt creates a new  LedgerKeyStatsExt.
func NewLedgerKeyStatsExt(v LedgerVersion, value interface{}) (result LedgerKeyStatsExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerKeyStats is an XDR NestedStruct defines as:
//
//   struct {
//            AccountID accountID;
//    		union switch (LedgerVersion v)
//    		{
//    		case EMPTY_VERSION:
//    			void;
//    		}
//    		ext;
//        }
//
type LedgerKeyStats struct {
	AccountId AccountId         `json:"accountID,omitempty"`
	Ext       LedgerKeyStatsExt `json:"ext,omitempty"`
}

// LedgerKeyAccountLimitsExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//    		{
//    		case EMPTY_VERSION:
//    			void;
//    		}
//
type LedgerKeyAccountLimitsExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKeyAccountLimitsExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKeyAccountLimitsExt
func (u LedgerKeyAccountLimitsExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerKeyAccountLimitsExt creates a new  LedgerKeyAccountLimitsExt.
func NewLedgerKeyAccountLimitsExt(v LedgerVersion, value interface{}) (result LedgerKeyAccountLimitsExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerKeyAccountLimits is an XDR NestedStruct defines as:
//
//   struct {
//            AccountID accountID;
//    		union switch (LedgerVersion v)
//    		{
//    		case EMPTY_VERSION:
//    			void;
//    		}
//    		ext;
//        }
//
type LedgerKeyAccountLimits struct {
	AccountId AccountId                 `json:"accountID,omitempty"`
	Ext       LedgerKeyAccountLimitsExt `json:"ext,omitempty"`
}

// LedgerKeyAssetPairExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type LedgerKeyAssetPairExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKeyAssetPairExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKeyAssetPairExt
func (u LedgerKeyAssetPairExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerKeyAssetPairExt creates a new  LedgerKeyAssetPairExt.
func NewLedgerKeyAssetPairExt(v LedgerVersion, value interface{}) (result LedgerKeyAssetPairExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerKeyAssetPair is an XDR NestedStruct defines as:
//
//   struct {
//            AssetCode base;
//            AssetCode quote;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        }
//
type LedgerKeyAssetPair struct {
	Base  AssetCode             `json:"base,omitempty"`
	Quote AssetCode             `json:"quote,omitempty"`
	Ext   LedgerKeyAssetPairExt `json:"ext,omitempty"`
}

// LedgerKeyOffer is an XDR NestedStruct defines as:
//
//   struct {
//            uint64 offerID;
//            AccountID ownerID;
//        }
//
type LedgerKeyOffer struct {
	OfferId Uint64    `json:"offerID,omitempty"`
	OwnerId AccountId `json:"ownerID,omitempty"`
}

// LedgerKeyReviewableRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type LedgerKeyReviewableRequestExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKeyReviewableRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKeyReviewableRequestExt
func (u LedgerKeyReviewableRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerKeyReviewableRequestExt creates a new  LedgerKeyReviewableRequestExt.
func NewLedgerKeyReviewableRequestExt(v LedgerVersion, value interface{}) (result LedgerKeyReviewableRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerKeyReviewableRequest is an XDR NestedStruct defines as:
//
//   struct {
//            uint64 requestID;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        }
//
type LedgerKeyReviewableRequest struct {
	RequestId Uint64                        `json:"requestID,omitempty"`
	Ext       LedgerKeyReviewableRequestExt `json:"ext,omitempty"`
}

// LedgerKeyExternalSystemAccountIdExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//    		{
//    		case EMPTY_VERSION:
//    			void;
//    		}
//
type LedgerKeyExternalSystemAccountIdExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKeyExternalSystemAccountIdExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKeyExternalSystemAccountIdExt
func (u LedgerKeyExternalSystemAccountIdExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerKeyExternalSystemAccountIdExt creates a new  LedgerKeyExternalSystemAccountIdExt.
func NewLedgerKeyExternalSystemAccountIdExt(v LedgerVersion, value interface{}) (result LedgerKeyExternalSystemAccountIdExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerKeyExternalSystemAccountId is an XDR NestedStruct defines as:
//
//   struct {
//    		AccountID accountID;
//    		int32 externalSystemType;
//    		union switch (LedgerVersion v)
//    		{
//    		case EMPTY_VERSION:
//    			void;
//    		}
//    		ext;
//    	}
//
type LedgerKeyExternalSystemAccountId struct {
	AccountId          AccountId                           `json:"accountID,omitempty"`
	ExternalSystemType Int32                               `json:"externalSystemType,omitempty"`
	Ext                LedgerKeyExternalSystemAccountIdExt `json:"ext,omitempty"`
}

// LedgerKeySaleExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type LedgerKeySaleExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKeySaleExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKeySaleExt
func (u LedgerKeySaleExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerKeySaleExt creates a new  LedgerKeySaleExt.
func NewLedgerKeySaleExt(v LedgerVersion, value interface{}) (result LedgerKeySaleExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerKeySale is an XDR NestedStruct defines as:
//
//   struct {
//            uint64 saleID;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        }
//
type LedgerKeySale struct {
	SaleId Uint64           `json:"saleID,omitempty"`
	Ext    LedgerKeySaleExt `json:"ext,omitempty"`
}

// LedgerKeyKeyValueExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type LedgerKeyKeyValueExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKeyKeyValueExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKeyKeyValueExt
func (u LedgerKeyKeyValueExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerKeyKeyValueExt creates a new  LedgerKeyKeyValueExt.
func NewLedgerKeyKeyValueExt(v LedgerVersion, value interface{}) (result LedgerKeyKeyValueExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerKeyKeyValue is an XDR NestedStruct defines as:
//
//   struct {
//            longstring key;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        }
//
type LedgerKeyKeyValue struct {
	Key Longstring           `json:"key,omitempty"`
	Ext LedgerKeyKeyValueExt `json:"ext,omitempty"`
}

// LedgerKeyAccountKycExt is an XDR NestedUnion defines as:
//
//   union switch(LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type LedgerKeyAccountKycExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKeyAccountKycExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKeyAccountKycExt
func (u LedgerKeyAccountKycExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerKeyAccountKycExt creates a new  LedgerKeyAccountKycExt.
func NewLedgerKeyAccountKycExt(v LedgerVersion, value interface{}) (result LedgerKeyAccountKycExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerKeyAccountKyc is an XDR NestedStruct defines as:
//
//   struct {
//            AccountID accountID;
//            union switch(LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        }
//
type LedgerKeyAccountKyc struct {
	AccountId AccountId              `json:"accountID,omitempty"`
	Ext       LedgerKeyAccountKycExt `json:"ext,omitempty"`
}

// LedgerKeyExternalSystemAccountIdPoolEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//    		{
//    		case EMPTY_VERSION:
//    			void;
//    		}
//
type LedgerKeyExternalSystemAccountIdPoolEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKeyExternalSystemAccountIdPoolEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKeyExternalSystemAccountIdPoolEntryExt
func (u LedgerKeyExternalSystemAccountIdPoolEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerKeyExternalSystemAccountIdPoolEntryExt creates a new  LedgerKeyExternalSystemAccountIdPoolEntryExt.
func NewLedgerKeyExternalSystemAccountIdPoolEntryExt(v LedgerVersion, value interface{}) (result LedgerKeyExternalSystemAccountIdPoolEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerKeyExternalSystemAccountIdPoolEntry is an XDR NestedStruct defines as:
//
//   struct {
//    		uint64 poolEntryID;
//    		union switch (LedgerVersion v)
//    		{
//    		case EMPTY_VERSION:
//    			void;
//    		}
//    		ext;
//    	}
//
type LedgerKeyExternalSystemAccountIdPoolEntry struct {
	PoolEntryId Uint64                                       `json:"poolEntryID,omitempty"`
	Ext         LedgerKeyExternalSystemAccountIdPoolEntryExt `json:"ext,omitempty"`
}

// LedgerKeyLimitsV2Ext is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type LedgerKeyLimitsV2Ext struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKeyLimitsV2Ext) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKeyLimitsV2Ext
func (u LedgerKeyLimitsV2Ext) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerKeyLimitsV2Ext creates a new  LedgerKeyLimitsV2Ext.
func NewLedgerKeyLimitsV2Ext(v LedgerVersion, value interface{}) (result LedgerKeyLimitsV2Ext, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerKeyLimitsV2 is an XDR NestedStruct defines as:
//
//   struct {
//            uint64 id;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            } ext;
//        }
//
type LedgerKeyLimitsV2 struct {
	Id  Uint64               `json:"id,omitempty"`
	Ext LedgerKeyLimitsV2Ext `json:"ext,omitempty"`
}

// LedgerKeyStatisticsV2Ext is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type LedgerKeyStatisticsV2Ext struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKeyStatisticsV2Ext) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKeyStatisticsV2Ext
func (u LedgerKeyStatisticsV2Ext) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerKeyStatisticsV2Ext creates a new  LedgerKeyStatisticsV2Ext.
func NewLedgerKeyStatisticsV2Ext(v LedgerVersion, value interface{}) (result LedgerKeyStatisticsV2Ext, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerKeyStatisticsV2 is an XDR NestedStruct defines as:
//
//   struct {
//            uint64 id;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        }
//
type LedgerKeyStatisticsV2 struct {
	Id  Uint64                   `json:"id,omitempty"`
	Ext LedgerKeyStatisticsV2Ext `json:"ext,omitempty"`
}

// LedgerKeyPendingStatisticsExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type LedgerKeyPendingStatisticsExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKeyPendingStatisticsExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKeyPendingStatisticsExt
func (u LedgerKeyPendingStatisticsExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerKeyPendingStatisticsExt creates a new  LedgerKeyPendingStatisticsExt.
func NewLedgerKeyPendingStatisticsExt(v LedgerVersion, value interface{}) (result LedgerKeyPendingStatisticsExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerKeyPendingStatistics is an XDR NestedStruct defines as:
//
//   struct {
//            uint64 statisticsID;
//            uint64 requestID;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        }
//
type LedgerKeyPendingStatistics struct {
	StatisticsId Uint64                        `json:"statisticsID,omitempty"`
	RequestId    Uint64                        `json:"requestID,omitempty"`
	Ext          LedgerKeyPendingStatisticsExt `json:"ext,omitempty"`
}

// LedgerKeyContractExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type LedgerKeyContractExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKeyContractExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKeyContractExt
func (u LedgerKeyContractExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerKeyContractExt creates a new  LedgerKeyContractExt.
func NewLedgerKeyContractExt(v LedgerVersion, value interface{}) (result LedgerKeyContractExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerKeyContract is an XDR NestedStruct defines as:
//
//   struct {
//            uint64 contractID;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        }
//
type LedgerKeyContract struct {
	ContractId Uint64               `json:"contractID,omitempty"`
	Ext        LedgerKeyContractExt `json:"ext,omitempty"`
}

// LedgerKeyAtomicSwapAskExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type LedgerKeyAtomicSwapAskExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKeyAtomicSwapAskExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKeyAtomicSwapAskExt
func (u LedgerKeyAtomicSwapAskExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerKeyAtomicSwapAskExt creates a new  LedgerKeyAtomicSwapAskExt.
func NewLedgerKeyAtomicSwapAskExt(v LedgerVersion, value interface{}) (result LedgerKeyAtomicSwapAskExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerKeyAtomicSwapAsk is an XDR NestedStruct defines as:
//
//   struct {
//            uint64 id;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        }
//
type LedgerKeyAtomicSwapAsk struct {
	Id  Uint64                    `json:"id,omitempty"`
	Ext LedgerKeyAtomicSwapAskExt `json:"ext,omitempty"`
}

// LedgerKeyAccountRoleExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type LedgerKeyAccountRoleExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKeyAccountRoleExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKeyAccountRoleExt
func (u LedgerKeyAccountRoleExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerKeyAccountRoleExt creates a new  LedgerKeyAccountRoleExt.
func NewLedgerKeyAccountRoleExt(v LedgerVersion, value interface{}) (result LedgerKeyAccountRoleExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerKeyAccountRole is an XDR NestedStruct defines as:
//
//   struct {
//            uint64 id;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        }
//
type LedgerKeyAccountRole struct {
	Id  Uint64                  `json:"id,omitempty"`
	Ext LedgerKeyAccountRoleExt `json:"ext,omitempty"`
}

// LedgerKeyAccountRuleExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type LedgerKeyAccountRuleExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKeyAccountRuleExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKeyAccountRuleExt
func (u LedgerKeyAccountRuleExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerKeyAccountRuleExt creates a new  LedgerKeyAccountRuleExt.
func NewLedgerKeyAccountRuleExt(v LedgerVersion, value interface{}) (result LedgerKeyAccountRuleExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerKeyAccountRule is an XDR NestedStruct defines as:
//
//   struct {
//            uint64 id;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        }
//
type LedgerKeyAccountRule struct {
	Id  Uint64                  `json:"id,omitempty"`
	Ext LedgerKeyAccountRuleExt `json:"ext,omitempty"`
}

// LedgerKeySignerRoleExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type LedgerKeySignerRoleExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKeySignerRoleExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKeySignerRoleExt
func (u LedgerKeySignerRoleExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerKeySignerRoleExt creates a new  LedgerKeySignerRoleExt.
func NewLedgerKeySignerRoleExt(v LedgerVersion, value interface{}) (result LedgerKeySignerRoleExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerKeySignerRole is an XDR NestedStruct defines as:
//
//   struct {
//            uint64 id;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        }
//
type LedgerKeySignerRole struct {
	Id  Uint64                 `json:"id,omitempty"`
	Ext LedgerKeySignerRoleExt `json:"ext,omitempty"`
}

// LedgerKeySignerRuleExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type LedgerKeySignerRuleExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKeySignerRuleExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKeySignerRuleExt
func (u LedgerKeySignerRuleExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerKeySignerRuleExt creates a new  LedgerKeySignerRuleExt.
func NewLedgerKeySignerRuleExt(v LedgerVersion, value interface{}) (result LedgerKeySignerRuleExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerKeySignerRule is an XDR NestedStruct defines as:
//
//   struct {
//            uint64 id;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        }
//
type LedgerKeySignerRule struct {
	Id  Uint64                 `json:"id,omitempty"`
	Ext LedgerKeySignerRuleExt `json:"ext,omitempty"`
}

// LedgerKeyStampExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type LedgerKeyStampExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKeyStampExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKeyStampExt
func (u LedgerKeyStampExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerKeyStampExt creates a new  LedgerKeyStampExt.
func NewLedgerKeyStampExt(v LedgerVersion, value interface{}) (result LedgerKeyStampExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerKeyStamp is an XDR NestedStruct defines as:
//
//   struct {
//            Hash ledgerHash;
//            Hash licenseHash;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        }
//
type LedgerKeyStamp struct {
	LedgerHash  Hash              `json:"ledgerHash,omitempty"`
	LicenseHash Hash              `json:"licenseHash,omitempty"`
	Ext         LedgerKeyStampExt `json:"ext,omitempty"`
}

// LedgerKeyLicenseExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type LedgerKeyLicenseExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKeyLicenseExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKeyLicenseExt
func (u LedgerKeyLicenseExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerKeyLicenseExt creates a new  LedgerKeyLicenseExt.
func NewLedgerKeyLicenseExt(v LedgerVersion, value interface{}) (result LedgerKeyLicenseExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerKeyLicense is an XDR NestedStruct defines as:
//
//   struct {
//            Hash licenseHash;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            } ext;
//        }
//
type LedgerKeyLicense struct {
	LicenseHash Hash                `json:"licenseHash,omitempty"`
	Ext         LedgerKeyLicenseExt `json:"ext,omitempty"`
}

// LedgerKeyPoll is an XDR NestedStruct defines as:
//
//   struct {
//            uint64 id;
//
//            EmptyExt ext;
//        }
//
type LedgerKeyPoll struct {
	Id  Uint64   `json:"id,omitempty"`
	Ext EmptyExt `json:"ext,omitempty"`
}

// LedgerKeyVote is an XDR NestedStruct defines as:
//
//   struct {
//            uint64 pollID;
//            AccountID voterID;
//
//            EmptyExt ext;
//        }
//
type LedgerKeyVote struct {
	PollId  Uint64    `json:"pollID,omitempty"`
	VoterId AccountId `json:"voterID,omitempty"`
	Ext     EmptyExt  `json:"ext,omitempty"`
}

// LedgerKeyAccountSpecificRule is an XDR NestedStruct defines as:
//
//   struct {
//            uint64 id;
//
//            EmptyExt ext;
//        }
//
type LedgerKeyAccountSpecificRule struct {
	Id  Uint64   `json:"id,omitempty"`
	Ext EmptyExt `json:"ext,omitempty"`
}

// LedgerKeySwap is an XDR NestedStruct defines as:
//
//   struct
//        {
//            uint64 id;
//
//            EmptyExt ext;
//        }
//
type LedgerKeySwap struct {
	Id  Uint64   `json:"id,omitempty"`
	Ext EmptyExt `json:"ext,omitempty"`
}

// LedgerKeyData is an XDR NestedStruct defines as:
//
//   struct {
//            uint64 id;
//
//            EmptyExt ext;
//        }
//
type LedgerKeyData struct {
	Id  Uint64   `json:"id,omitempty"`
	Ext EmptyExt `json:"ext,omitempty"`
}

// LedgerKeyDeferredPayment is an XDR NestedStruct defines as:
//
//   struct {
//            uint64 id;
//
//            EmptyExt ext;
//        }
//
type LedgerKeyDeferredPayment struct {
	Id  Uint64   `json:"id,omitempty"`
	Ext EmptyExt `json:"ext,omitempty"`
}

// LedgerKey is an XDR Union defines as:
//
//   union LedgerKey switch (LedgerEntryType type)
//    {
//    case ACCOUNT:
//        struct
//        {
//            AccountID accountID;
//            union switch (LedgerVersion v)
//           {
//           case EMPTY_VERSION:
//              void;
//           }
//           ext;
//        } account;
//    case SIGNER:
//        struct
//        {
//            PublicKey pubKey;
//            AccountID accountID;
//
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        } signer;
//    case FEE:
//        struct {
//            Hash hash;
//            int64 lowerBound;
//            int64 upperBound;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        } feeState;
//    case BALANCE:
//        struct
//        {
//            BalanceID balanceID;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        } balance;
//    case ASSET:
//        struct
//        {
//            AssetCode code;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        } asset;
//    case REFERENCE_ENTRY:
//        struct
//        {
//    		AccountID sender;
//    		string64 reference;
//    		union switch (LedgerVersion v)
//    		{
//    		case EMPTY_VERSION:
//    			void;
//    		}
//    		ext;
//        } reference;
//    case STATISTICS:
//        struct {
//            AccountID accountID;
//    		union switch (LedgerVersion v)
//    		{
//    		case EMPTY_VERSION:
//    			void;
//    		}
//    		ext;
//        } stats;
//    case ACCOUNT_LIMITS:
//        struct {
//            AccountID accountID;
//    		union switch (LedgerVersion v)
//    		{
//    		case EMPTY_VERSION:
//    			void;
//    		}
//    		ext;
//        } accountLimits;
//    case ASSET_PAIR:
//        struct {
//            AssetCode base;
//            AssetCode quote;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        } assetPair;
//    case OFFER_ENTRY:
//        struct {
//            uint64 offerID;
//            AccountID ownerID;
//        } offer;
//    case REVIEWABLE_REQUEST:
//        struct {
//            uint64 requestID;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        } reviewableRequest;
//    case EXTERNAL_SYSTEM_ACCOUNT_ID:
//    	struct {
//    		AccountID accountID;
//    		int32 externalSystemType;
//    		union switch (LedgerVersion v)
//    		{
//    		case EMPTY_VERSION:
//    			void;
//    		}
//    		ext;
//    	} externalSystemAccountID;
//    case SALE:
//        struct {
//            uint64 saleID;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        } sale;
//    case KEY_VALUE:
//        struct {
//            longstring key;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        } keyValue;
//    case ACCOUNT_KYC:
//        struct {
//            AccountID accountID;
//            union switch(LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        } accountKYC;
//    case EXTERNAL_SYSTEM_ACCOUNT_ID_POOL_ENTRY:
//        struct {
//    		uint64 poolEntryID;
//    		union switch (LedgerVersion v)
//    		{
//    		case EMPTY_VERSION:
//    			void;
//    		}
//    		ext;
//    	} externalSystemAccountIDPoolEntry;
//    case LIMITS_V2:
//        struct {
//            uint64 id;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            } ext;
//        } limitsV2;
//    case STATISTICS_V2:
//        struct {
//            uint64 id;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        } statisticsV2;
//    case PENDING_STATISTICS:
//        struct {
//            uint64 statisticsID;
//            uint64 requestID;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        } pendingStatistics;
//    case CONTRACT:
//        struct {
//            uint64 contractID;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        } contract;
//    case ATOMIC_SWAP_ASK:
//        struct {
//            uint64 id;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        } atomicSwapAsk;
//    case ACCOUNT_ROLE:
//        struct {
//            uint64 id;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        } accountRole;
//    case ACCOUNT_RULE:
//        struct {
//            uint64 id;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        } accountRule;
//    case SIGNER_ROLE:
//        struct {
//            uint64 id;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        } signerRole;
//    case SIGNER_RULE:
//        struct {
//            uint64 id;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        } signerRule;
//    case STAMP:
//        struct {
//            Hash ledgerHash;
//            Hash licenseHash;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        } stamp;
//    case LICENSE:
//        struct {
//            Hash licenseHash;
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            } ext;
//        } license;
//    case POLL:
//        struct {
//            uint64 id;
//
//            EmptyExt ext;
//        } poll;
//    case VOTE:
//        struct {
//            uint64 pollID;
//            AccountID voterID;
//
//            EmptyExt ext;
//        } vote;
//    case ACCOUNT_SPECIFIC_RULE:
//        struct {
//            uint64 id;
//
//            EmptyExt ext;
//        } accountSpecificRule;
//    case SWAP:
//        struct
//        {
//            uint64 id;
//
//            EmptyExt ext;
//        } swap;
//    case DATA:
//        struct {
//            uint64 id;
//
//            EmptyExt ext;
//        } data;
//    case DEFERRED_PAYMENT:
//        struct {
//            uint64 id;
//
//            EmptyExt ext;
//        } deferredPayment;
//    };
//
type LedgerKey struct {
	Type                             LedgerEntryType                            `json:"type,omitempty"`
	Account                          *LedgerKeyAccount                          `json:"account,omitempty"`
	Signer                           *LedgerKeySigner                           `json:"signer,omitempty"`
	FeeState                         *LedgerKeyFeeState                         `json:"feeState,omitempty"`
	Balance                          *LedgerKeyBalance                          `json:"balance,omitempty"`
	Asset                            *LedgerKeyAsset                            `json:"asset,omitempty"`
	Reference                        *LedgerKeyReference                        `json:"reference,omitempty"`
	Stats                            *LedgerKeyStats                            `json:"stats,omitempty"`
	AccountLimits                    *LedgerKeyAccountLimits                    `json:"accountLimits,omitempty"`
	AssetPair                        *LedgerKeyAssetPair                        `json:"assetPair,omitempty"`
	Offer                            *LedgerKeyOffer                            `json:"offer,omitempty"`
	ReviewableRequest                *LedgerKeyReviewableRequest                `json:"reviewableRequest,omitempty"`
	ExternalSystemAccountId          *LedgerKeyExternalSystemAccountId          `json:"externalSystemAccountID,omitempty"`
	Sale                             *LedgerKeySale                             `json:"sale,omitempty"`
	KeyValue                         *LedgerKeyKeyValue                         `json:"keyValue,omitempty"`
	AccountKyc                       *LedgerKeyAccountKyc                       `json:"accountKYC,omitempty"`
	ExternalSystemAccountIdPoolEntry *LedgerKeyExternalSystemAccountIdPoolEntry `json:"externalSystemAccountIDPoolEntry,omitempty"`
	LimitsV2                         *LedgerKeyLimitsV2                         `json:"limitsV2,omitempty"`
	StatisticsV2                     *LedgerKeyStatisticsV2                     `json:"statisticsV2,omitempty"`
	PendingStatistics                *LedgerKeyPendingStatistics                `json:"pendingStatistics,omitempty"`
	Contract                         *LedgerKeyContract                         `json:"contract,omitempty"`
	AtomicSwapAsk                    *LedgerKeyAtomicSwapAsk                    `json:"atomicSwapAsk,omitempty"`
	AccountRole                      *LedgerKeyAccountRole                      `json:"accountRole,omitempty"`
	AccountRule                      *LedgerKeyAccountRule                      `json:"accountRule,omitempty"`
	SignerRole                       *LedgerKeySignerRole                       `json:"signerRole,omitempty"`
	SignerRule                       *LedgerKeySignerRule                       `json:"signerRule,omitempty"`
	Stamp                            *LedgerKeyStamp                            `json:"stamp,omitempty"`
	License                          *LedgerKeyLicense                          `json:"license,omitempty"`
	Poll                             *LedgerKeyPoll                             `json:"poll,omitempty"`
	Vote                             *LedgerKeyVote                             `json:"vote,omitempty"`
	AccountSpecificRule              *LedgerKeyAccountSpecificRule              `json:"accountSpecificRule,omitempty"`
	Swap                             *LedgerKeySwap                             `json:"swap,omitempty"`
	Data                             *LedgerKeyData                             `json:"data,omitempty"`
	DeferredPayment                  *LedgerKeyDeferredPayment                  `json:"deferredPayment,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerKey) SwitchFieldName() string {
	return "Type"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerKey
func (u LedgerKey) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerEntryType(sw) {
	case LedgerEntryTypeAccount:
		return "Account", true
	case LedgerEntryTypeSigner:
		return "Signer", true
	case LedgerEntryTypeFee:
		return "FeeState", true
	case LedgerEntryTypeBalance:
		return "Balance", true
	case LedgerEntryTypeAsset:
		return "Asset", true
	case LedgerEntryTypeReferenceEntry:
		return "Reference", true
	case LedgerEntryTypeStatistics:
		return "Stats", true
	case LedgerEntryTypeAccountLimits:
		return "AccountLimits", true
	case LedgerEntryTypeAssetPair:
		return "AssetPair", true
	case LedgerEntryTypeOfferEntry:
		return "Offer", true
	case LedgerEntryTypeReviewableRequest:
		return "ReviewableRequest", true
	case LedgerEntryTypeExternalSystemAccountId:
		return "ExternalSystemAccountId", true
	case LedgerEntryTypeSale:
		return "Sale", true
	case LedgerEntryTypeKeyValue:
		return "KeyValue", true
	case LedgerEntryTypeAccountKyc:
		return "AccountKyc", true
	case LedgerEntryTypeExternalSystemAccountIdPoolEntry:
		return "ExternalSystemAccountIdPoolEntry", true
	case LedgerEntryTypeLimitsV2:
		return "LimitsV2", true
	case LedgerEntryTypeStatisticsV2:
		return "StatisticsV2", true
	case LedgerEntryTypePendingStatistics:
		return "PendingStatistics", true
	case LedgerEntryTypeContract:
		return "Contract", true
	case LedgerEntryTypeAtomicSwapAsk:
		return "AtomicSwapAsk", true
	case LedgerEntryTypeAccountRole:
		return "AccountRole", true
	case LedgerEntryTypeAccountRule:
		return "AccountRule", true
	case LedgerEntryTypeSignerRole:
		return "SignerRole", true
	case LedgerEntryTypeSignerRule:
		return "SignerRule", true
	case LedgerEntryTypeStamp:
		return "Stamp", true
	case LedgerEntryTypeLicense:
		return "License", true
	case LedgerEntryTypePoll:
		return "Poll", true
	case LedgerEntryTypeVote:
		return "Vote", true
	case LedgerEntryTypeAccountSpecificRule:
		return "AccountSpecificRule", true
	case LedgerEntryTypeSwap:
		return "Swap", true
	case LedgerEntryTypeData:
		return "Data", true
	case LedgerEntryTypeDeferredPayment:
		return "DeferredPayment", true
	}
	return "-", false
}

// NewLedgerKey creates a new  LedgerKey.
func NewLedgerKey(aType LedgerEntryType, value interface{}) (result LedgerKey, err error) {
	result.Type = aType
	switch LedgerEntryType(aType) {
	case LedgerEntryTypeAccount:
		tv, ok := value.(LedgerKeyAccount)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyAccount")
			return
		}
		result.Account = &tv
	case LedgerEntryTypeSigner:
		tv, ok := value.(LedgerKeySigner)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeySigner")
			return
		}
		result.Signer = &tv
	case LedgerEntryTypeFee:
		tv, ok := value.(LedgerKeyFeeState)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyFeeState")
			return
		}
		result.FeeState = &tv
	case LedgerEntryTypeBalance:
		tv, ok := value.(LedgerKeyBalance)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyBalance")
			return
		}
		result.Balance = &tv
	case LedgerEntryTypeAsset:
		tv, ok := value.(LedgerKeyAsset)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyAsset")
			return
		}
		result.Asset = &tv
	case LedgerEntryTypeReferenceEntry:
		tv, ok := value.(LedgerKeyReference)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyReference")
			return
		}
		result.Reference = &tv
	case LedgerEntryTypeStatistics:
		tv, ok := value.(LedgerKeyStats)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyStats")
			return
		}
		result.Stats = &tv
	case LedgerEntryTypeAccountLimits:
		tv, ok := value.(LedgerKeyAccountLimits)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyAccountLimits")
			return
		}
		result.AccountLimits = &tv
	case LedgerEntryTypeAssetPair:
		tv, ok := value.(LedgerKeyAssetPair)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyAssetPair")
			return
		}
		result.AssetPair = &tv
	case LedgerEntryTypeOfferEntry:
		tv, ok := value.(LedgerKeyOffer)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyOffer")
			return
		}
		result.Offer = &tv
	case LedgerEntryTypeReviewableRequest:
		tv, ok := value.(LedgerKeyReviewableRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyReviewableRequest")
			return
		}
		result.ReviewableRequest = &tv
	case LedgerEntryTypeExternalSystemAccountId:
		tv, ok := value.(LedgerKeyExternalSystemAccountId)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyExternalSystemAccountId")
			return
		}
		result.ExternalSystemAccountId = &tv
	case LedgerEntryTypeSale:
		tv, ok := value.(LedgerKeySale)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeySale")
			return
		}
		result.Sale = &tv
	case LedgerEntryTypeKeyValue:
		tv, ok := value.(LedgerKeyKeyValue)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyKeyValue")
			return
		}
		result.KeyValue = &tv
	case LedgerEntryTypeAccountKyc:
		tv, ok := value.(LedgerKeyAccountKyc)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyAccountKyc")
			return
		}
		result.AccountKyc = &tv
	case LedgerEntryTypeExternalSystemAccountIdPoolEntry:
		tv, ok := value.(LedgerKeyExternalSystemAccountIdPoolEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyExternalSystemAccountIdPoolEntry")
			return
		}
		result.ExternalSystemAccountIdPoolEntry = &tv
	case LedgerEntryTypeLimitsV2:
		tv, ok := value.(LedgerKeyLimitsV2)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyLimitsV2")
			return
		}
		result.LimitsV2 = &tv
	case LedgerEntryTypeStatisticsV2:
		tv, ok := value.(LedgerKeyStatisticsV2)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyStatisticsV2")
			return
		}
		result.StatisticsV2 = &tv
	case LedgerEntryTypePendingStatistics:
		tv, ok := value.(LedgerKeyPendingStatistics)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyPendingStatistics")
			return
		}
		result.PendingStatistics = &tv
	case LedgerEntryTypeContract:
		tv, ok := value.(LedgerKeyContract)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyContract")
			return
		}
		result.Contract = &tv
	case LedgerEntryTypeAtomicSwapAsk:
		tv, ok := value.(LedgerKeyAtomicSwapAsk)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyAtomicSwapAsk")
			return
		}
		result.AtomicSwapAsk = &tv
	case LedgerEntryTypeAccountRole:
		tv, ok := value.(LedgerKeyAccountRole)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyAccountRole")
			return
		}
		result.AccountRole = &tv
	case LedgerEntryTypeAccountRule:
		tv, ok := value.(LedgerKeyAccountRule)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyAccountRule")
			return
		}
		result.AccountRule = &tv
	case LedgerEntryTypeSignerRole:
		tv, ok := value.(LedgerKeySignerRole)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeySignerRole")
			return
		}
		result.SignerRole = &tv
	case LedgerEntryTypeSignerRule:
		tv, ok := value.(LedgerKeySignerRule)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeySignerRule")
			return
		}
		result.SignerRule = &tv
	case LedgerEntryTypeStamp:
		tv, ok := value.(LedgerKeyStamp)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyStamp")
			return
		}
		result.Stamp = &tv
	case LedgerEntryTypeLicense:
		tv, ok := value.(LedgerKeyLicense)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyLicense")
			return
		}
		result.License = &tv
	case LedgerEntryTypePoll:
		tv, ok := value.(LedgerKeyPoll)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyPoll")
			return
		}
		result.Poll = &tv
	case LedgerEntryTypeVote:
		tv, ok := value.(LedgerKeyVote)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyVote")
			return
		}
		result.Vote = &tv
	case LedgerEntryTypeAccountSpecificRule:
		tv, ok := value.(LedgerKeyAccountSpecificRule)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyAccountSpecificRule")
			return
		}
		result.AccountSpecificRule = &tv
	case LedgerEntryTypeSwap:
		tv, ok := value.(LedgerKeySwap)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeySwap")
			return
		}
		result.Swap = &tv
	case LedgerEntryTypeData:
		tv, ok := value.(LedgerKeyData)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyData")
			return
		}
		result.Data = &tv
	case LedgerEntryTypeDeferredPayment:
		tv, ok := value.(LedgerKeyDeferredPayment)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKeyDeferredPayment")
			return
		}
		result.DeferredPayment = &tv
	}
	return
}

// MustAccount retrieves the Account value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustAccount() LedgerKeyAccount {
	val, ok := u.GetAccount()

	if !ok {
		panic("arm Account is not set")
	}

	return val
}

// GetAccount retrieves the Account value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetAccount() (result LedgerKeyAccount, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Account" {
		result = *u.Account
		ok = true
	}

	return
}

// MustSigner retrieves the Signer value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustSigner() LedgerKeySigner {
	val, ok := u.GetSigner()

	if !ok {
		panic("arm Signer is not set")
	}

	return val
}

// GetSigner retrieves the Signer value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetSigner() (result LedgerKeySigner, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Signer" {
		result = *u.Signer
		ok = true
	}

	return
}

// MustFeeState retrieves the FeeState value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustFeeState() LedgerKeyFeeState {
	val, ok := u.GetFeeState()

	if !ok {
		panic("arm FeeState is not set")
	}

	return val
}

// GetFeeState retrieves the FeeState value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetFeeState() (result LedgerKeyFeeState, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "FeeState" {
		result = *u.FeeState
		ok = true
	}

	return
}

// MustBalance retrieves the Balance value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustBalance() LedgerKeyBalance {
	val, ok := u.GetBalance()

	if !ok {
		panic("arm Balance is not set")
	}

	return val
}

// GetBalance retrieves the Balance value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetBalance() (result LedgerKeyBalance, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Balance" {
		result = *u.Balance
		ok = true
	}

	return
}

// MustAsset retrieves the Asset value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustAsset() LedgerKeyAsset {
	val, ok := u.GetAsset()

	if !ok {
		panic("arm Asset is not set")
	}

	return val
}

// GetAsset retrieves the Asset value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetAsset() (result LedgerKeyAsset, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Asset" {
		result = *u.Asset
		ok = true
	}

	return
}

// MustReference retrieves the Reference value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustReference() LedgerKeyReference {
	val, ok := u.GetReference()

	if !ok {
		panic("arm Reference is not set")
	}

	return val
}

// GetReference retrieves the Reference value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetReference() (result LedgerKeyReference, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Reference" {
		result = *u.Reference
		ok = true
	}

	return
}

// MustStats retrieves the Stats value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustStats() LedgerKeyStats {
	val, ok := u.GetStats()

	if !ok {
		panic("arm Stats is not set")
	}

	return val
}

// GetStats retrieves the Stats value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetStats() (result LedgerKeyStats, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Stats" {
		result = *u.Stats
		ok = true
	}

	return
}

// MustAccountLimits retrieves the AccountLimits value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustAccountLimits() LedgerKeyAccountLimits {
	val, ok := u.GetAccountLimits()

	if !ok {
		panic("arm AccountLimits is not set")
	}

	return val
}

// GetAccountLimits retrieves the AccountLimits value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetAccountLimits() (result LedgerKeyAccountLimits, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "AccountLimits" {
		result = *u.AccountLimits
		ok = true
	}

	return
}

// MustAssetPair retrieves the AssetPair value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustAssetPair() LedgerKeyAssetPair {
	val, ok := u.GetAssetPair()

	if !ok {
		panic("arm AssetPair is not set")
	}

	return val
}

// GetAssetPair retrieves the AssetPair value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetAssetPair() (result LedgerKeyAssetPair, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "AssetPair" {
		result = *u.AssetPair
		ok = true
	}

	return
}

// MustOffer retrieves the Offer value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustOffer() LedgerKeyOffer {
	val, ok := u.GetOffer()

	if !ok {
		panic("arm Offer is not set")
	}

	return val
}

// GetOffer retrieves the Offer value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetOffer() (result LedgerKeyOffer, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Offer" {
		result = *u.Offer
		ok = true
	}

	return
}

// MustReviewableRequest retrieves the ReviewableRequest value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustReviewableRequest() LedgerKeyReviewableRequest {
	val, ok := u.GetReviewableRequest()

	if !ok {
		panic("arm ReviewableRequest is not set")
	}

	return val
}

// GetReviewableRequest retrieves the ReviewableRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetReviewableRequest() (result LedgerKeyReviewableRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ReviewableRequest" {
		result = *u.ReviewableRequest
		ok = true
	}

	return
}

// MustExternalSystemAccountId retrieves the ExternalSystemAccountId value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustExternalSystemAccountId() LedgerKeyExternalSystemAccountId {
	val, ok := u.GetExternalSystemAccountId()

	if !ok {
		panic("arm ExternalSystemAccountId is not set")
	}

	return val
}

// GetExternalSystemAccountId retrieves the ExternalSystemAccountId value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetExternalSystemAccountId() (result LedgerKeyExternalSystemAccountId, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ExternalSystemAccountId" {
		result = *u.ExternalSystemAccountId
		ok = true
	}

	return
}

// MustSale retrieves the Sale value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustSale() LedgerKeySale {
	val, ok := u.GetSale()

	if !ok {
		panic("arm Sale is not set")
	}

	return val
}

// GetSale retrieves the Sale value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetSale() (result LedgerKeySale, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Sale" {
		result = *u.Sale
		ok = true
	}

	return
}

// MustKeyValue retrieves the KeyValue value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustKeyValue() LedgerKeyKeyValue {
	val, ok := u.GetKeyValue()

	if !ok {
		panic("arm KeyValue is not set")
	}

	return val
}

// GetKeyValue retrieves the KeyValue value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetKeyValue() (result LedgerKeyKeyValue, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "KeyValue" {
		result = *u.KeyValue
		ok = true
	}

	return
}

// MustAccountKyc retrieves the AccountKyc value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustAccountKyc() LedgerKeyAccountKyc {
	val, ok := u.GetAccountKyc()

	if !ok {
		panic("arm AccountKyc is not set")
	}

	return val
}

// GetAccountKyc retrieves the AccountKyc value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetAccountKyc() (result LedgerKeyAccountKyc, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "AccountKyc" {
		result = *u.AccountKyc
		ok = true
	}

	return
}

// MustExternalSystemAccountIdPoolEntry retrieves the ExternalSystemAccountIdPoolEntry value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustExternalSystemAccountIdPoolEntry() LedgerKeyExternalSystemAccountIdPoolEntry {
	val, ok := u.GetExternalSystemAccountIdPoolEntry()

	if !ok {
		panic("arm ExternalSystemAccountIdPoolEntry is not set")
	}

	return val
}

// GetExternalSystemAccountIdPoolEntry retrieves the ExternalSystemAccountIdPoolEntry value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetExternalSystemAccountIdPoolEntry() (result LedgerKeyExternalSystemAccountIdPoolEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ExternalSystemAccountIdPoolEntry" {
		result = *u.ExternalSystemAccountIdPoolEntry
		ok = true
	}

	return
}

// MustLimitsV2 retrieves the LimitsV2 value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustLimitsV2() LedgerKeyLimitsV2 {
	val, ok := u.GetLimitsV2()

	if !ok {
		panic("arm LimitsV2 is not set")
	}

	return val
}

// GetLimitsV2 retrieves the LimitsV2 value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetLimitsV2() (result LedgerKeyLimitsV2, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "LimitsV2" {
		result = *u.LimitsV2
		ok = true
	}

	return
}

// MustStatisticsV2 retrieves the StatisticsV2 value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustStatisticsV2() LedgerKeyStatisticsV2 {
	val, ok := u.GetStatisticsV2()

	if !ok {
		panic("arm StatisticsV2 is not set")
	}

	return val
}

// GetStatisticsV2 retrieves the StatisticsV2 value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetStatisticsV2() (result LedgerKeyStatisticsV2, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "StatisticsV2" {
		result = *u.StatisticsV2
		ok = true
	}

	return
}

// MustPendingStatistics retrieves the PendingStatistics value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustPendingStatistics() LedgerKeyPendingStatistics {
	val, ok := u.GetPendingStatistics()

	if !ok {
		panic("arm PendingStatistics is not set")
	}

	return val
}

// GetPendingStatistics retrieves the PendingStatistics value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetPendingStatistics() (result LedgerKeyPendingStatistics, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "PendingStatistics" {
		result = *u.PendingStatistics
		ok = true
	}

	return
}

// MustContract retrieves the Contract value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustContract() LedgerKeyContract {
	val, ok := u.GetContract()

	if !ok {
		panic("arm Contract is not set")
	}

	return val
}

// GetContract retrieves the Contract value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetContract() (result LedgerKeyContract, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Contract" {
		result = *u.Contract
		ok = true
	}

	return
}

// MustAtomicSwapAsk retrieves the AtomicSwapAsk value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustAtomicSwapAsk() LedgerKeyAtomicSwapAsk {
	val, ok := u.GetAtomicSwapAsk()

	if !ok {
		panic("arm AtomicSwapAsk is not set")
	}

	return val
}

// GetAtomicSwapAsk retrieves the AtomicSwapAsk value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetAtomicSwapAsk() (result LedgerKeyAtomicSwapAsk, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "AtomicSwapAsk" {
		result = *u.AtomicSwapAsk
		ok = true
	}

	return
}

// MustAccountRole retrieves the AccountRole value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustAccountRole() LedgerKeyAccountRole {
	val, ok := u.GetAccountRole()

	if !ok {
		panic("arm AccountRole is not set")
	}

	return val
}

// GetAccountRole retrieves the AccountRole value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetAccountRole() (result LedgerKeyAccountRole, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "AccountRole" {
		result = *u.AccountRole
		ok = true
	}

	return
}

// MustAccountRule retrieves the AccountRule value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustAccountRule() LedgerKeyAccountRule {
	val, ok := u.GetAccountRule()

	if !ok {
		panic("arm AccountRule is not set")
	}

	return val
}

// GetAccountRule retrieves the AccountRule value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetAccountRule() (result LedgerKeyAccountRule, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "AccountRule" {
		result = *u.AccountRule
		ok = true
	}

	return
}

// MustSignerRole retrieves the SignerRole value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustSignerRole() LedgerKeySignerRole {
	val, ok := u.GetSignerRole()

	if !ok {
		panic("arm SignerRole is not set")
	}

	return val
}

// GetSignerRole retrieves the SignerRole value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetSignerRole() (result LedgerKeySignerRole, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "SignerRole" {
		result = *u.SignerRole
		ok = true
	}

	return
}

// MustSignerRule retrieves the SignerRule value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustSignerRule() LedgerKeySignerRule {
	val, ok := u.GetSignerRule()

	if !ok {
		panic("arm SignerRule is not set")
	}

	return val
}

// GetSignerRule retrieves the SignerRule value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetSignerRule() (result LedgerKeySignerRule, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "SignerRule" {
		result = *u.SignerRule
		ok = true
	}

	return
}

// MustStamp retrieves the Stamp value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustStamp() LedgerKeyStamp {
	val, ok := u.GetStamp()

	if !ok {
		panic("arm Stamp is not set")
	}

	return val
}

// GetStamp retrieves the Stamp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetStamp() (result LedgerKeyStamp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Stamp" {
		result = *u.Stamp
		ok = true
	}

	return
}

// MustLicense retrieves the License value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustLicense() LedgerKeyLicense {
	val, ok := u.GetLicense()

	if !ok {
		panic("arm License is not set")
	}

	return val
}

// GetLicense retrieves the License value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetLicense() (result LedgerKeyLicense, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "License" {
		result = *u.License
		ok = true
	}

	return
}

// MustPoll retrieves the Poll value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustPoll() LedgerKeyPoll {
	val, ok := u.GetPoll()

	if !ok {
		panic("arm Poll is not set")
	}

	return val
}

// GetPoll retrieves the Poll value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetPoll() (result LedgerKeyPoll, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Poll" {
		result = *u.Poll
		ok = true
	}

	return
}

// MustVote retrieves the Vote value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustVote() LedgerKeyVote {
	val, ok := u.GetVote()

	if !ok {
		panic("arm Vote is not set")
	}

	return val
}

// GetVote retrieves the Vote value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetVote() (result LedgerKeyVote, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Vote" {
		result = *u.Vote
		ok = true
	}

	return
}

// MustAccountSpecificRule retrieves the AccountSpecificRule value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustAccountSpecificRule() LedgerKeyAccountSpecificRule {
	val, ok := u.GetAccountSpecificRule()

	if !ok {
		panic("arm AccountSpecificRule is not set")
	}

	return val
}

// GetAccountSpecificRule retrieves the AccountSpecificRule value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetAccountSpecificRule() (result LedgerKeyAccountSpecificRule, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "AccountSpecificRule" {
		result = *u.AccountSpecificRule
		ok = true
	}

	return
}

// MustSwap retrieves the Swap value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustSwap() LedgerKeySwap {
	val, ok := u.GetSwap()

	if !ok {
		panic("arm Swap is not set")
	}

	return val
}

// GetSwap retrieves the Swap value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetSwap() (result LedgerKeySwap, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Swap" {
		result = *u.Swap
		ok = true
	}

	return
}

// MustData retrieves the Data value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustData() LedgerKeyData {
	val, ok := u.GetData()

	if !ok {
		panic("arm Data is not set")
	}

	return val
}

// GetData retrieves the Data value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetData() (result LedgerKeyData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Data" {
		result = *u.Data
		ok = true
	}

	return
}

// MustDeferredPayment retrieves the DeferredPayment value from the union,
// panicing if the value is not set.
func (u LedgerKey) MustDeferredPayment() LedgerKeyDeferredPayment {
	val, ok := u.GetDeferredPayment()

	if !ok {
		panic("arm DeferredPayment is not set")
	}

	return val
}

// GetDeferredPayment retrieves the DeferredPayment value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerKey) GetDeferredPayment() (result LedgerKeyDeferredPayment, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "DeferredPayment" {
		result = *u.DeferredPayment
		ok = true
	}

	return
}

// UpgradeType is an XDR Typedef defines as:
//
//   typedef opaque UpgradeType<128>;
//
type UpgradeType []byte

// StellarValueExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type StellarValueExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u StellarValueExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of StellarValueExt
func (u StellarValueExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewStellarValueExt creates a new  StellarValueExt.
func NewStellarValueExt(v LedgerVersion, value interface{}) (result StellarValueExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// StellarValue is an XDR Struct defines as:
//
//   struct StellarValue
//    {
//        Hash txSetHash;   // transaction set to apply to previous ledger
//        uint64 closeTime; // network close time
//
//        // upgrades to apply to the previous ledger (usually empty)
//        // this is a vector of encoded 'LedgerUpgrade' so that nodes can drop
//        // unknown steps during consensus if needed.
//        // see notes below on 'LedgerUpgrade' for more detail
//        // max size is dictated by number of upgrade types (+ room for future)
//        UpgradeType upgrades<6>;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type StellarValue struct {
	TxSetHash Hash            `json:"txSetHash,omitempty"`
	CloseTime Uint64          `json:"closeTime,omitempty"`
	Upgrades  []UpgradeType   `json:"upgrades,omitempty" xdrmaxsize:"6"`
	Ext       StellarValueExt `json:"ext,omitempty"`
}

// IdGenerator is an XDR Struct defines as:
//
//   struct IdGenerator {
//    	LedgerEntryType entryType; // type of the entry, for which ids will be generated
//    	uint64 idPool; // last used entry specific ID, used for generating entry of specified type
//    };
//
type IdGenerator struct {
	EntryType LedgerEntryType `json:"entryType,omitempty"`
	IdPool    Uint64          `json:"idPool,omitempty"`
}

// LedgerHeaderExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type LedgerHeaderExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerHeaderExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerHeaderExt
func (u LedgerHeaderExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerHeaderExt creates a new  LedgerHeaderExt.
func NewLedgerHeaderExt(v LedgerVersion, value interface{}) (result LedgerHeaderExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerHeader is an XDR Struct defines as:
//
//   struct LedgerHeader
//    {
//        uint32 ledgerVersion;    // the protocol version of the ledger
//        Hash previousLedgerHash; // hash of the previous ledger header
//        StellarValue scpValue;   // what consensus agreed to
//        Hash txSetResultHash;    // the TransactionResultSet that led to this ledger
//        Hash bucketListHash;     // hash of the ledger state
//
//        uint32 ledgerSeq; // sequence number of this ledger
//
//        IdGenerator idGenerators<>; // generators of ids
//
//        uint32 baseFee;     // base fee per operation in stroops
//        uint32 baseReserve; // account base reserve in stroops
//
//        uint32 maxTxSetSize; // maximum size a transaction set can be
//
//        int64 txExpirationPeriod;
//
//        Hash skipList[4]; // hashes of ledgers in the past. allows you to jump back
//                          // in time without walking the chain back ledger by ledger
//                          // each slot contains the oldest ledger that is mod of
//                          // either 50  5000  50000 or 500000 depending on index
//                          // skipList[0] mod(50), skipList[1] mod(5000), etc
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type LedgerHeader struct {
	LedgerVersion      Uint32          `json:"ledgerVersion,omitempty"`
	PreviousLedgerHash Hash            `json:"previousLedgerHash,omitempty"`
	ScpValue           StellarValue    `json:"scpValue,omitempty"`
	TxSetResultHash    Hash            `json:"txSetResultHash,omitempty"`
	BucketListHash     Hash            `json:"bucketListHash,omitempty"`
	LedgerSeq          Uint32          `json:"ledgerSeq,omitempty"`
	IdGenerators       []IdGenerator   `json:"idGenerators,omitempty"`
	BaseFee            Uint32          `json:"baseFee,omitempty"`
	BaseReserve        Uint32          `json:"baseReserve,omitempty"`
	MaxTxSetSize       Uint32          `json:"maxTxSetSize,omitempty"`
	TxExpirationPeriod Int64           `json:"txExpirationPeriod,omitempty"`
	SkipList           [4]Hash         `json:"skipList,omitempty"`
	Ext                LedgerHeaderExt `json:"ext,omitempty"`
}

// LedgerUpgradeType is an XDR Enum defines as:
//
//   enum LedgerUpgradeType
//    {
//        VERSION = 1,
//        MAX_TX_SET_SIZE = 2,
//        TX_EXPIRATION_PERIOD = 3
//    };
//
type LedgerUpgradeType int32

const (
	LedgerUpgradeTypeVersion            LedgerUpgradeType = 1
	LedgerUpgradeTypeMaxTxSetSize       LedgerUpgradeType = 2
	LedgerUpgradeTypeTxExpirationPeriod LedgerUpgradeType = 3
)

var LedgerUpgradeTypeAll = []LedgerUpgradeType{
	LedgerUpgradeTypeVersion,
	LedgerUpgradeTypeMaxTxSetSize,
	LedgerUpgradeTypeTxExpirationPeriod,
}

var ledgerUpgradeTypeMap = map[int32]string{
	1: "LedgerUpgradeTypeVersion",
	2: "LedgerUpgradeTypeMaxTxSetSize",
	3: "LedgerUpgradeTypeTxExpirationPeriod",
}

var ledgerUpgradeTypeShortMap = map[int32]string{
	1: "version",
	2: "max_tx_set_size",
	3: "tx_expiration_period",
}

var ledgerUpgradeTypeRevMap = map[string]int32{
	"LedgerUpgradeTypeVersion":            1,
	"LedgerUpgradeTypeMaxTxSetSize":       2,
	"LedgerUpgradeTypeTxExpirationPeriod": 3,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for LedgerUpgradeType
func (e LedgerUpgradeType) ValidEnum(v int32) bool {
	_, ok := ledgerUpgradeTypeMap[v]
	return ok
}
func (e LedgerUpgradeType) isFlag() bool {
	for i := len(LedgerUpgradeTypeAll) - 1; i >= 0; i-- {
		expected := LedgerUpgradeType(2) << uint64(len(LedgerUpgradeTypeAll)-1) >> uint64(len(LedgerUpgradeTypeAll)-i)
		if expected != LedgerUpgradeTypeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e LedgerUpgradeType) String() string {
	name, _ := ledgerUpgradeTypeMap[int32(e)]
	return name
}

func (e LedgerUpgradeType) ShortString() string {
	name, _ := ledgerUpgradeTypeShortMap[int32(e)]
	return name
}

func (e LedgerUpgradeType) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range LedgerUpgradeTypeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *LedgerUpgradeType) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = LedgerUpgradeType(t.Value)
	return nil
}

// LedgerUpgrade is an XDR Union defines as:
//
//   union LedgerUpgrade switch (LedgerUpgradeType type)
//    {
//    case VERSION:
//        uint32 newLedgerVersion; // update ledgerVersion
//    case MAX_TX_SET_SIZE:
//        uint32 newMaxTxSetSize; // update maxTxSetSize
//    case TX_EXPIRATION_PERIOD:
//        int64 newTxExpirationPeriod;
//    };
//
type LedgerUpgrade struct {
	Type                  LedgerUpgradeType `json:"type,omitempty"`
	NewLedgerVersion      *Uint32           `json:"newLedgerVersion,omitempty"`
	NewMaxTxSetSize       *Uint32           `json:"newMaxTxSetSize,omitempty"`
	NewTxExpirationPeriod *Int64            `json:"newTxExpirationPeriod,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerUpgrade) SwitchFieldName() string {
	return "Type"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerUpgrade
func (u LedgerUpgrade) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerUpgradeType(sw) {
	case LedgerUpgradeTypeVersion:
		return "NewLedgerVersion", true
	case LedgerUpgradeTypeMaxTxSetSize:
		return "NewMaxTxSetSize", true
	case LedgerUpgradeTypeTxExpirationPeriod:
		return "NewTxExpirationPeriod", true
	}
	return "-", false
}

// NewLedgerUpgrade creates a new  LedgerUpgrade.
func NewLedgerUpgrade(aType LedgerUpgradeType, value interface{}) (result LedgerUpgrade, err error) {
	result.Type = aType
	switch LedgerUpgradeType(aType) {
	case LedgerUpgradeTypeVersion:
		tv, ok := value.(Uint32)
		if !ok {
			err = fmt.Errorf("invalid value, must be Uint32")
			return
		}
		result.NewLedgerVersion = &tv
	case LedgerUpgradeTypeMaxTxSetSize:
		tv, ok := value.(Uint32)
		if !ok {
			err = fmt.Errorf("invalid value, must be Uint32")
			return
		}
		result.NewMaxTxSetSize = &tv
	case LedgerUpgradeTypeTxExpirationPeriod:
		tv, ok := value.(Int64)
		if !ok {
			err = fmt.Errorf("invalid value, must be Int64")
			return
		}
		result.NewTxExpirationPeriod = &tv
	}
	return
}

// MustNewLedgerVersion retrieves the NewLedgerVersion value from the union,
// panicing if the value is not set.
func (u LedgerUpgrade) MustNewLedgerVersion() Uint32 {
	val, ok := u.GetNewLedgerVersion()

	if !ok {
		panic("arm NewLedgerVersion is not set")
	}

	return val
}

// GetNewLedgerVersion retrieves the NewLedgerVersion value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerUpgrade) GetNewLedgerVersion() (result Uint32, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "NewLedgerVersion" {
		result = *u.NewLedgerVersion
		ok = true
	}

	return
}

// MustNewMaxTxSetSize retrieves the NewMaxTxSetSize value from the union,
// panicing if the value is not set.
func (u LedgerUpgrade) MustNewMaxTxSetSize() Uint32 {
	val, ok := u.GetNewMaxTxSetSize()

	if !ok {
		panic("arm NewMaxTxSetSize is not set")
	}

	return val
}

// GetNewMaxTxSetSize retrieves the NewMaxTxSetSize value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerUpgrade) GetNewMaxTxSetSize() (result Uint32, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "NewMaxTxSetSize" {
		result = *u.NewMaxTxSetSize
		ok = true
	}

	return
}

// MustNewTxExpirationPeriod retrieves the NewTxExpirationPeriod value from the union,
// panicing if the value is not set.
func (u LedgerUpgrade) MustNewTxExpirationPeriod() Int64 {
	val, ok := u.GetNewTxExpirationPeriod()

	if !ok {
		panic("arm NewTxExpirationPeriod is not set")
	}

	return val
}

// GetNewTxExpirationPeriod retrieves the NewTxExpirationPeriod value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerUpgrade) GetNewTxExpirationPeriod() (result Int64, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "NewTxExpirationPeriod" {
		result = *u.NewTxExpirationPeriod
		ok = true
	}

	return
}

// BucketEntryType is an XDR Enum defines as:
//
//   enum BucketEntryType
//    {
//        LIVEENTRY = 0,
//        DEADENTRY = 1
//    };
//
type BucketEntryType int32

const (
	BucketEntryTypeLiveentry BucketEntryType = 0
	BucketEntryTypeDeadentry BucketEntryType = 1
)

var BucketEntryTypeAll = []BucketEntryType{
	BucketEntryTypeLiveentry,
	BucketEntryTypeDeadentry,
}

var bucketEntryTypeMap = map[int32]string{
	0: "BucketEntryTypeLiveentry",
	1: "BucketEntryTypeDeadentry",
}

var bucketEntryTypeShortMap = map[int32]string{
	0: "liveentry",
	1: "deadentry",
}

var bucketEntryTypeRevMap = map[string]int32{
	"BucketEntryTypeLiveentry": 0,
	"BucketEntryTypeDeadentry": 1,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for BucketEntryType
func (e BucketEntryType) ValidEnum(v int32) bool {
	_, ok := bucketEntryTypeMap[v]
	return ok
}
func (e BucketEntryType) isFlag() bool {
	for i := len(BucketEntryTypeAll) - 1; i >= 0; i-- {
		expected := BucketEntryType(2) << uint64(len(BucketEntryTypeAll)-1) >> uint64(len(BucketEntryTypeAll)-i)
		if expected != BucketEntryTypeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e BucketEntryType) String() string {
	name, _ := bucketEntryTypeMap[int32(e)]
	return name
}

func (e BucketEntryType) ShortString() string {
	name, _ := bucketEntryTypeShortMap[int32(e)]
	return name
}

func (e BucketEntryType) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range BucketEntryTypeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *BucketEntryType) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = BucketEntryType(t.Value)
	return nil
}

// BucketEntry is an XDR Union defines as:
//
//   union BucketEntry switch (BucketEntryType type)
//    {
//    case LIVEENTRY:
//        LedgerEntry liveEntry;
//
//    case DEADENTRY:
//        LedgerKey deadEntry;
//    };
//
type BucketEntry struct {
	Type      BucketEntryType `json:"type,omitempty"`
	LiveEntry *LedgerEntry    `json:"liveEntry,omitempty"`
	DeadEntry *LedgerKey      `json:"deadEntry,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u BucketEntry) SwitchFieldName() string {
	return "Type"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of BucketEntry
func (u BucketEntry) ArmForSwitch(sw int32) (string, bool) {
	switch BucketEntryType(sw) {
	case BucketEntryTypeLiveentry:
		return "LiveEntry", true
	case BucketEntryTypeDeadentry:
		return "DeadEntry", true
	}
	return "-", false
}

// NewBucketEntry creates a new  BucketEntry.
func NewBucketEntry(aType BucketEntryType, value interface{}) (result BucketEntry, err error) {
	result.Type = aType
	switch BucketEntryType(aType) {
	case BucketEntryTypeLiveentry:
		tv, ok := value.(LedgerEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerEntry")
			return
		}
		result.LiveEntry = &tv
	case BucketEntryTypeDeadentry:
		tv, ok := value.(LedgerKey)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKey")
			return
		}
		result.DeadEntry = &tv
	}
	return
}

// MustLiveEntry retrieves the LiveEntry value from the union,
// panicing if the value is not set.
func (u BucketEntry) MustLiveEntry() LedgerEntry {
	val, ok := u.GetLiveEntry()

	if !ok {
		panic("arm LiveEntry is not set")
	}

	return val
}

// GetLiveEntry retrieves the LiveEntry value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u BucketEntry) GetLiveEntry() (result LedgerEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "LiveEntry" {
		result = *u.LiveEntry
		ok = true
	}

	return
}

// MustDeadEntry retrieves the DeadEntry value from the union,
// panicing if the value is not set.
func (u BucketEntry) MustDeadEntry() LedgerKey {
	val, ok := u.GetDeadEntry()

	if !ok {
		panic("arm DeadEntry is not set")
	}

	return val
}

// GetDeadEntry retrieves the DeadEntry value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u BucketEntry) GetDeadEntry() (result LedgerKey, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "DeadEntry" {
		result = *u.DeadEntry
		ok = true
	}

	return
}

// TransactionSet is an XDR Struct defines as:
//
//   struct TransactionSet
//    {
//        Hash previousLedgerHash;
//        TransactionEnvelope txs<>;
//    };
//
type TransactionSet struct {
	PreviousLedgerHash Hash                  `json:"previousLedgerHash,omitempty"`
	Txs                []TransactionEnvelope `json:"txs,omitempty"`
}

// TransactionResultPair is an XDR Struct defines as:
//
//   struct TransactionResultPair
//    {
//        Hash transactionHash;
//        TransactionResult result; // result for the transaction
//    };
//
type TransactionResultPair struct {
	TransactionHash Hash              `json:"transactionHash,omitempty"`
	Result          TransactionResult `json:"result,omitempty"`
}

// TransactionResultSet is an XDR Struct defines as:
//
//   struct TransactionResultSet
//    {
//        TransactionResultPair results<>;
//    };
//
type TransactionResultSet struct {
	Results []TransactionResultPair `json:"results,omitempty"`
}

// TransactionHistoryEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type TransactionHistoryEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u TransactionHistoryEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of TransactionHistoryEntryExt
func (u TransactionHistoryEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewTransactionHistoryEntryExt creates a new  TransactionHistoryEntryExt.
func NewTransactionHistoryEntryExt(v LedgerVersion, value interface{}) (result TransactionHistoryEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// TransactionHistoryEntry is an XDR Struct defines as:
//
//   struct TransactionHistoryEntry
//    {
//        uint32 ledgerSeq;
//        TransactionSet txSet;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type TransactionHistoryEntry struct {
	LedgerSeq Uint32                     `json:"ledgerSeq,omitempty"`
	TxSet     TransactionSet             `json:"txSet,omitempty"`
	Ext       TransactionHistoryEntryExt `json:"ext,omitempty"`
}

// TransactionHistoryResultEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type TransactionHistoryResultEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u TransactionHistoryResultEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of TransactionHistoryResultEntryExt
func (u TransactionHistoryResultEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewTransactionHistoryResultEntryExt creates a new  TransactionHistoryResultEntryExt.
func NewTransactionHistoryResultEntryExt(v LedgerVersion, value interface{}) (result TransactionHistoryResultEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// TransactionHistoryResultEntry is an XDR Struct defines as:
//
//   struct TransactionHistoryResultEntry
//    {
//        uint32 ledgerSeq;
//        TransactionResultSet txResultSet;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type TransactionHistoryResultEntry struct {
	LedgerSeq   Uint32                           `json:"ledgerSeq,omitempty"`
	TxResultSet TransactionResultSet             `json:"txResultSet,omitempty"`
	Ext         TransactionHistoryResultEntryExt `json:"ext,omitempty"`
}

// LedgerHeaderHistoryEntryExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type LedgerHeaderHistoryEntryExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerHeaderHistoryEntryExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerHeaderHistoryEntryExt
func (u LedgerHeaderHistoryEntryExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLedgerHeaderHistoryEntryExt creates a new  LedgerHeaderHistoryEntryExt.
func NewLedgerHeaderHistoryEntryExt(v LedgerVersion, value interface{}) (result LedgerHeaderHistoryEntryExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LedgerHeaderHistoryEntry is an XDR Struct defines as:
//
//   struct LedgerHeaderHistoryEntry
//    {
//        Hash hash;
//        LedgerHeader header;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type LedgerHeaderHistoryEntry struct {
	Hash   Hash                        `json:"hash,omitempty"`
	Header LedgerHeader                `json:"header,omitempty"`
	Ext    LedgerHeaderHistoryEntryExt `json:"ext,omitempty"`
}

// LedgerScpMessages is an XDR Struct defines as:
//
//   struct LedgerSCPMessages
//    {
//        uint32 ledgerSeq;
//        SCPEnvelope messages<>;
//    };
//
type LedgerScpMessages struct {
	LedgerSeq Uint32        `json:"ledgerSeq,omitempty"`
	Messages  []ScpEnvelope `json:"messages,omitempty"`
}

// ScpHistoryEntryV0 is an XDR Struct defines as:
//
//   struct SCPHistoryEntryV0
//    {
//        SCPQuorumSet quorumSets<>; // additional quorum sets used by ledgerMessages
//        LedgerSCPMessages ledgerMessages;
//    };
//
type ScpHistoryEntryV0 struct {
	QuorumSets     []ScpQuorumSet    `json:"quorumSets,omitempty"`
	LedgerMessages LedgerScpMessages `json:"ledgerMessages,omitempty"`
}

// ScpHistoryEntry is an XDR Union defines as:
//
//   union SCPHistoryEntry switch (LedgerVersion v)
//    {
//    case EMPTY_VERSION:
//        SCPHistoryEntryV0 v0;
//    };
//
type ScpHistoryEntry struct {
	V  LedgerVersion      `json:"v,omitempty"`
	V0 *ScpHistoryEntryV0 `json:"v0,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ScpHistoryEntry) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ScpHistoryEntry
func (u ScpHistoryEntry) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "V0", true
	}
	return "-", false
}

// NewScpHistoryEntry creates a new  ScpHistoryEntry.
func NewScpHistoryEntry(v LedgerVersion, value interface{}) (result ScpHistoryEntry, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		tv, ok := value.(ScpHistoryEntryV0)
		if !ok {
			err = fmt.Errorf("invalid value, must be ScpHistoryEntryV0")
			return
		}
		result.V0 = &tv
	}
	return
}

// MustV0 retrieves the V0 value from the union,
// panicing if the value is not set.
func (u ScpHistoryEntry) MustV0() ScpHistoryEntryV0 {
	val, ok := u.GetV0()

	if !ok {
		panic("arm V0 is not set")
	}

	return val
}

// GetV0 retrieves the V0 value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ScpHistoryEntry) GetV0() (result ScpHistoryEntryV0, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.V))

	if armName == "V0" {
		result = *u.V0
		ok = true
	}

	return
}

// LedgerEntryChangeType is an XDR Enum defines as:
//
//   enum LedgerEntryChangeType
//    {
//        CREATED = 0, // entry was added to the ledger
//        UPDATED = 1, // entry was modified in the ledger
//        REMOVED = 2, // entry was removed from the ledger
//        STATE = 3    // value of the entry
//    };
//
type LedgerEntryChangeType int32

const (
	LedgerEntryChangeTypeCreated LedgerEntryChangeType = 0
	LedgerEntryChangeTypeUpdated LedgerEntryChangeType = 1
	LedgerEntryChangeTypeRemoved LedgerEntryChangeType = 2
	LedgerEntryChangeTypeState   LedgerEntryChangeType = 3
)

var LedgerEntryChangeTypeAll = []LedgerEntryChangeType{
	LedgerEntryChangeTypeCreated,
	LedgerEntryChangeTypeUpdated,
	LedgerEntryChangeTypeRemoved,
	LedgerEntryChangeTypeState,
}

var ledgerEntryChangeTypeMap = map[int32]string{
	0: "LedgerEntryChangeTypeCreated",
	1: "LedgerEntryChangeTypeUpdated",
	2: "LedgerEntryChangeTypeRemoved",
	3: "LedgerEntryChangeTypeState",
}

var ledgerEntryChangeTypeShortMap = map[int32]string{
	0: "created",
	1: "updated",
	2: "removed",
	3: "state",
}

var ledgerEntryChangeTypeRevMap = map[string]int32{
	"LedgerEntryChangeTypeCreated": 0,
	"LedgerEntryChangeTypeUpdated": 1,
	"LedgerEntryChangeTypeRemoved": 2,
	"LedgerEntryChangeTypeState":   3,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for LedgerEntryChangeType
func (e LedgerEntryChangeType) ValidEnum(v int32) bool {
	_, ok := ledgerEntryChangeTypeMap[v]
	return ok
}
func (e LedgerEntryChangeType) isFlag() bool {
	for i := len(LedgerEntryChangeTypeAll) - 1; i >= 0; i-- {
		expected := LedgerEntryChangeType(2) << uint64(len(LedgerEntryChangeTypeAll)-1) >> uint64(len(LedgerEntryChangeTypeAll)-i)
		if expected != LedgerEntryChangeTypeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e LedgerEntryChangeType) String() string {
	name, _ := ledgerEntryChangeTypeMap[int32(e)]
	return name
}

func (e LedgerEntryChangeType) ShortString() string {
	name, _ := ledgerEntryChangeTypeShortMap[int32(e)]
	return name
}

func (e LedgerEntryChangeType) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range LedgerEntryChangeTypeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *LedgerEntryChangeType) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = LedgerEntryChangeType(t.Value)
	return nil
}

// LedgerEntryChange is an XDR Union defines as:
//
//   union LedgerEntryChange switch (LedgerEntryChangeType type)
//    {
//    case CREATED:
//        LedgerEntry created;
//    case UPDATED:
//        LedgerEntry updated;
//    case REMOVED:
//        LedgerKey removed;
//    case STATE:
//        LedgerEntry state;
//    };
//
type LedgerEntryChange struct {
	Type    LedgerEntryChangeType `json:"type,omitempty"`
	Created *LedgerEntry          `json:"created,omitempty"`
	Updated *LedgerEntry          `json:"updated,omitempty"`
	Removed *LedgerKey            `json:"removed,omitempty"`
	State   *LedgerEntry          `json:"state,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LedgerEntryChange) SwitchFieldName() string {
	return "Type"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LedgerEntryChange
func (u LedgerEntryChange) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerEntryChangeType(sw) {
	case LedgerEntryChangeTypeCreated:
		return "Created", true
	case LedgerEntryChangeTypeUpdated:
		return "Updated", true
	case LedgerEntryChangeTypeRemoved:
		return "Removed", true
	case LedgerEntryChangeTypeState:
		return "State", true
	}
	return "-", false
}

// NewLedgerEntryChange creates a new  LedgerEntryChange.
func NewLedgerEntryChange(aType LedgerEntryChangeType, value interface{}) (result LedgerEntryChange, err error) {
	result.Type = aType
	switch LedgerEntryChangeType(aType) {
	case LedgerEntryChangeTypeCreated:
		tv, ok := value.(LedgerEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerEntry")
			return
		}
		result.Created = &tv
	case LedgerEntryChangeTypeUpdated:
		tv, ok := value.(LedgerEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerEntry")
			return
		}
		result.Updated = &tv
	case LedgerEntryChangeTypeRemoved:
		tv, ok := value.(LedgerKey)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerKey")
			return
		}
		result.Removed = &tv
	case LedgerEntryChangeTypeState:
		tv, ok := value.(LedgerEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerEntry")
			return
		}
		result.State = &tv
	}
	return
}

// MustCreated retrieves the Created value from the union,
// panicing if the value is not set.
func (u LedgerEntryChange) MustCreated() LedgerEntry {
	val, ok := u.GetCreated()

	if !ok {
		panic("arm Created is not set")
	}

	return val
}

// GetCreated retrieves the Created value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryChange) GetCreated() (result LedgerEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Created" {
		result = *u.Created
		ok = true
	}

	return
}

// MustUpdated retrieves the Updated value from the union,
// panicing if the value is not set.
func (u LedgerEntryChange) MustUpdated() LedgerEntry {
	val, ok := u.GetUpdated()

	if !ok {
		panic("arm Updated is not set")
	}

	return val
}

// GetUpdated retrieves the Updated value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryChange) GetUpdated() (result LedgerEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Updated" {
		result = *u.Updated
		ok = true
	}

	return
}

// MustRemoved retrieves the Removed value from the union,
// panicing if the value is not set.
func (u LedgerEntryChange) MustRemoved() LedgerKey {
	val, ok := u.GetRemoved()

	if !ok {
		panic("arm Removed is not set")
	}

	return val
}

// GetRemoved retrieves the Removed value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryChange) GetRemoved() (result LedgerKey, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Removed" {
		result = *u.Removed
		ok = true
	}

	return
}

// MustState retrieves the State value from the union,
// panicing if the value is not set.
func (u LedgerEntryChange) MustState() LedgerEntry {
	val, ok := u.GetState()

	if !ok {
		panic("arm State is not set")
	}

	return val
}

// GetState retrieves the State value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LedgerEntryChange) GetState() (result LedgerEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "State" {
		result = *u.State
		ok = true
	}

	return
}

// LedgerEntryChanges is an XDR Typedef defines as:
//
//   typedef LedgerEntryChange LedgerEntryChanges<>;
//
type LedgerEntryChanges []LedgerEntryChange

// OperationMeta is an XDR Struct defines as:
//
//   struct OperationMeta
//    {
//        LedgerEntryChanges changes;
//    };
//
type OperationMeta struct {
	Changes LedgerEntryChanges `json:"changes,omitempty"`
}

// TransactionMeta is an XDR Union defines as:
//
//   union TransactionMeta switch (LedgerVersion v)
//    {
//    case EMPTY_VERSION:
//        OperationMeta operations<>;
//    };
//
type TransactionMeta struct {
	V          LedgerVersion    `json:"v,omitempty"`
	Operations *[]OperationMeta `json:"operations,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u TransactionMeta) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of TransactionMeta
func (u TransactionMeta) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "Operations", true
	}
	return "-", false
}

// NewTransactionMeta creates a new  TransactionMeta.
func NewTransactionMeta(v LedgerVersion, value interface{}) (result TransactionMeta, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		tv, ok := value.([]OperationMeta)
		if !ok {
			err = fmt.Errorf("invalid value, must be []OperationMeta")
			return
		}
		result.Operations = &tv
	}
	return
}

// MustOperations retrieves the Operations value from the union,
// panicing if the value is not set.
func (u TransactionMeta) MustOperations() []OperationMeta {
	val, ok := u.GetOperations()

	if !ok {
		panic("arm Operations is not set")
	}

	return val
}

// GetOperations retrieves the Operations value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u TransactionMeta) GetOperations() (result []OperationMeta, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.V))

	if armName == "Operations" {
		result = *u.Operations
		ok = true
	}

	return
}

// BindExternalSystemAccountIdOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type BindExternalSystemAccountIdOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u BindExternalSystemAccountIdOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of BindExternalSystemAccountIdOpExt
func (u BindExternalSystemAccountIdOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewBindExternalSystemAccountIdOpExt creates a new  BindExternalSystemAccountIdOpExt.
func NewBindExternalSystemAccountIdOpExt(v LedgerVersion, value interface{}) (result BindExternalSystemAccountIdOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// BindExternalSystemAccountIdOp is an XDR Struct defines as:
//
//   //: BindExternalSystemAccountIdOp is used to bind a particular account to the external system account which is represented by account ID taken from the pool
//    struct BindExternalSystemAccountIdOp
//    {
//        //: Type of external system to bind
//        int32 externalSystemType;
//
//        //: Reserved for the future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type BindExternalSystemAccountIdOp struct {
	ExternalSystemType Int32                            `json:"externalSystemType,omitempty"`
	Ext                BindExternalSystemAccountIdOpExt `json:"ext,omitempty"`
}

// BindExternalSystemAccountIdResultCode is an XDR Enum defines as:
//
//   //: Result codes of BindExternalSystemAccountIdOp
//    enum BindExternalSystemAccountIdResultCode
//    {
//        // codes considered as "success" for the operation
//        //: Source account has been successfully bound to external system ID taken from the pool
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: (deprecated)
//        MALFORMED = -1,
//        //: There is no available external system account ID pool entry for such external system type
//        NO_AVAILABLE_ID = -2
//    };
//
type BindExternalSystemAccountIdResultCode int32

const (
	BindExternalSystemAccountIdResultCodeSuccess       BindExternalSystemAccountIdResultCode = 0
	BindExternalSystemAccountIdResultCodeMalformed     BindExternalSystemAccountIdResultCode = -1
	BindExternalSystemAccountIdResultCodeNoAvailableId BindExternalSystemAccountIdResultCode = -2
)

var BindExternalSystemAccountIdResultCodeAll = []BindExternalSystemAccountIdResultCode{
	BindExternalSystemAccountIdResultCodeSuccess,
	BindExternalSystemAccountIdResultCodeMalformed,
	BindExternalSystemAccountIdResultCodeNoAvailableId,
}

var bindExternalSystemAccountIdResultCodeMap = map[int32]string{
	0:  "BindExternalSystemAccountIdResultCodeSuccess",
	-1: "BindExternalSystemAccountIdResultCodeMalformed",
	-2: "BindExternalSystemAccountIdResultCodeNoAvailableId",
}

var bindExternalSystemAccountIdResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "malformed",
	-2: "no_available_id",
}

var bindExternalSystemAccountIdResultCodeRevMap = map[string]int32{
	"BindExternalSystemAccountIdResultCodeSuccess":       0,
	"BindExternalSystemAccountIdResultCodeMalformed":     -1,
	"BindExternalSystemAccountIdResultCodeNoAvailableId": -2,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for BindExternalSystemAccountIdResultCode
func (e BindExternalSystemAccountIdResultCode) ValidEnum(v int32) bool {
	_, ok := bindExternalSystemAccountIdResultCodeMap[v]
	return ok
}
func (e BindExternalSystemAccountIdResultCode) isFlag() bool {
	for i := len(BindExternalSystemAccountIdResultCodeAll) - 1; i >= 0; i-- {
		expected := BindExternalSystemAccountIdResultCode(2) << uint64(len(BindExternalSystemAccountIdResultCodeAll)-1) >> uint64(len(BindExternalSystemAccountIdResultCodeAll)-i)
		if expected != BindExternalSystemAccountIdResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e BindExternalSystemAccountIdResultCode) String() string {
	name, _ := bindExternalSystemAccountIdResultCodeMap[int32(e)]
	return name
}

func (e BindExternalSystemAccountIdResultCode) ShortString() string {
	name, _ := bindExternalSystemAccountIdResultCodeShortMap[int32(e)]
	return name
}

func (e BindExternalSystemAccountIdResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range BindExternalSystemAccountIdResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *BindExternalSystemAccountIdResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = BindExternalSystemAccountIdResultCode(t.Value)
	return nil
}

// BindExternalSystemAccountIdSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type BindExternalSystemAccountIdSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u BindExternalSystemAccountIdSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of BindExternalSystemAccountIdSuccessExt
func (u BindExternalSystemAccountIdSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewBindExternalSystemAccountIdSuccessExt creates a new  BindExternalSystemAccountIdSuccessExt.
func NewBindExternalSystemAccountIdSuccessExt(v LedgerVersion, value interface{}) (result BindExternalSystemAccountIdSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// BindExternalSystemAccountIdSuccess is an XDR Struct defines as:
//
//   //: `BindExternalSystemAccountIdSuccess` represents details of successful result of operation application
//    struct BindExternalSystemAccountIdSuccess
//    {
//        //: `data` is used to pass data about account from external system ID
//        longstring data;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type BindExternalSystemAccountIdSuccess struct {
	Data Longstring                            `json:"data,omitempty"`
	Ext  BindExternalSystemAccountIdSuccessExt `json:"ext,omitempty"`
}

// BindExternalSystemAccountIdResult is an XDR Union defines as:
//
//   //: Result of operation application
//    union BindExternalSystemAccountIdResult switch (BindExternalSystemAccountIdResultCode code)
//    {
//    case SUCCESS:
//        //: `success` is used to pass useful fields after successful operation applying
//        BindExternalSystemAccountIdSuccess success;
//    default:
//        void;
//    };
//
type BindExternalSystemAccountIdResult struct {
	Code    BindExternalSystemAccountIdResultCode `json:"code,omitempty"`
	Success *BindExternalSystemAccountIdSuccess   `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u BindExternalSystemAccountIdResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of BindExternalSystemAccountIdResult
func (u BindExternalSystemAccountIdResult) ArmForSwitch(sw int32) (string, bool) {
	switch BindExternalSystemAccountIdResultCode(sw) {
	case BindExternalSystemAccountIdResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewBindExternalSystemAccountIdResult creates a new  BindExternalSystemAccountIdResult.
func NewBindExternalSystemAccountIdResult(code BindExternalSystemAccountIdResultCode, value interface{}) (result BindExternalSystemAccountIdResult, err error) {
	result.Code = code
	switch BindExternalSystemAccountIdResultCode(code) {
	case BindExternalSystemAccountIdResultCodeSuccess:
		tv, ok := value.(BindExternalSystemAccountIdSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be BindExternalSystemAccountIdSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u BindExternalSystemAccountIdResult) MustSuccess() BindExternalSystemAccountIdSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u BindExternalSystemAccountIdResult) GetSuccess() (result BindExternalSystemAccountIdSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// CancelAtomicSwapAskOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CancelAtomicSwapAskOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CancelAtomicSwapAskOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CancelAtomicSwapAskOpExt
func (u CancelAtomicSwapAskOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCancelAtomicSwapAskOpExt creates a new  CancelAtomicSwapAskOpExt.
func NewCancelAtomicSwapAskOpExt(v LedgerVersion, value interface{}) (result CancelAtomicSwapAskOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CancelAtomicSwapAskOp is an XDR Struct defines as:
//
//   //: CancelAtomicSwapAskOp is used to cancel existing atomic swap ask
//    struct CancelAtomicSwapAskOp
//    {
//        //: id of existing atomic swap ask
//        uint64 askID;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type CancelAtomicSwapAskOp struct {
	AskId Uint64                   `json:"askID,omitempty"`
	Ext   CancelAtomicSwapAskOpExt `json:"ext,omitempty"`
}

// CancelAtomicSwapAskResultCode is an XDR Enum defines as:
//
//   //: Result codes of CancelAtomicSwapAskOp
//    enum CancelAtomicSwapAskResultCode
//    {
//        //: Atomic swap ask was successfully removed or marked as canceled
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: There is no atomic swap ask with such id
//        NOT_FOUND = -1, // atomic swap bid does not exist
//        //: Not allowed to mark canceled atomic swap ask as canceled
//        ALREADY_CANCELLED = -2 // atomic swap ask already cancelled
//    };
//
type CancelAtomicSwapAskResultCode int32

const (
	CancelAtomicSwapAskResultCodeSuccess          CancelAtomicSwapAskResultCode = 0
	CancelAtomicSwapAskResultCodeNotFound         CancelAtomicSwapAskResultCode = -1
	CancelAtomicSwapAskResultCodeAlreadyCancelled CancelAtomicSwapAskResultCode = -2
)

var CancelAtomicSwapAskResultCodeAll = []CancelAtomicSwapAskResultCode{
	CancelAtomicSwapAskResultCodeSuccess,
	CancelAtomicSwapAskResultCodeNotFound,
	CancelAtomicSwapAskResultCodeAlreadyCancelled,
}

var cancelAtomicSwapAskResultCodeMap = map[int32]string{
	0:  "CancelAtomicSwapAskResultCodeSuccess",
	-1: "CancelAtomicSwapAskResultCodeNotFound",
	-2: "CancelAtomicSwapAskResultCodeAlreadyCancelled",
}

var cancelAtomicSwapAskResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "not_found",
	-2: "already_cancelled",
}

var cancelAtomicSwapAskResultCodeRevMap = map[string]int32{
	"CancelAtomicSwapAskResultCodeSuccess":          0,
	"CancelAtomicSwapAskResultCodeNotFound":         -1,
	"CancelAtomicSwapAskResultCodeAlreadyCancelled": -2,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CancelAtomicSwapAskResultCode
func (e CancelAtomicSwapAskResultCode) ValidEnum(v int32) bool {
	_, ok := cancelAtomicSwapAskResultCodeMap[v]
	return ok
}
func (e CancelAtomicSwapAskResultCode) isFlag() bool {
	for i := len(CancelAtomicSwapAskResultCodeAll) - 1; i >= 0; i-- {
		expected := CancelAtomicSwapAskResultCode(2) << uint64(len(CancelAtomicSwapAskResultCodeAll)-1) >> uint64(len(CancelAtomicSwapAskResultCodeAll)-i)
		if expected != CancelAtomicSwapAskResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CancelAtomicSwapAskResultCode) String() string {
	name, _ := cancelAtomicSwapAskResultCodeMap[int32(e)]
	return name
}

func (e CancelAtomicSwapAskResultCode) ShortString() string {
	name, _ := cancelAtomicSwapAskResultCodeShortMap[int32(e)]
	return name
}

func (e CancelAtomicSwapAskResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CancelAtomicSwapAskResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CancelAtomicSwapAskResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CancelAtomicSwapAskResultCode(t.Value)
	return nil
}

// CancelAtomicSwapAskResultSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CancelAtomicSwapAskResultSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CancelAtomicSwapAskResultSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CancelAtomicSwapAskResultSuccessExt
func (u CancelAtomicSwapAskResultSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCancelAtomicSwapAskResultSuccessExt creates a new  CancelAtomicSwapAskResultSuccessExt.
func NewCancelAtomicSwapAskResultSuccessExt(v LedgerVersion, value interface{}) (result CancelAtomicSwapAskResultSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CancelAtomicSwapAskResultSuccess is an XDR Struct defines as:
//
//   //: Success result of CancelASwapAskOp application
//    struct CancelAtomicSwapAskResultSuccess
//    {
//        //: Sum of `CREATE_ATOMIC_SWAP_BID` requests' base amounts which are waiting for applying.
//        //: Zero means that ask successfully removed
//        uint64 lockedAmount;
//
//        //: reserved for the future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type CancelAtomicSwapAskResultSuccess struct {
	LockedAmount Uint64                              `json:"lockedAmount,omitempty"`
	Ext          CancelAtomicSwapAskResultSuccessExt `json:"ext,omitempty"`
}

// CancelAtomicSwapAskResult is an XDR Union defines as:
//
//   //: Result of CancelASwapAskOp application
//    union CancelAtomicSwapAskResult switch (CancelAtomicSwapAskResultCode code)
//    {
//    case SUCCESS:
//        //: is used to pass useful fields after successful operation applying
//        CancelAtomicSwapAskResultSuccess success;
//    default:
//        void;
//    };
//
type CancelAtomicSwapAskResult struct {
	Code    CancelAtomicSwapAskResultCode     `json:"code,omitempty"`
	Success *CancelAtomicSwapAskResultSuccess `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CancelAtomicSwapAskResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CancelAtomicSwapAskResult
func (u CancelAtomicSwapAskResult) ArmForSwitch(sw int32) (string, bool) {
	switch CancelAtomicSwapAskResultCode(sw) {
	case CancelAtomicSwapAskResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewCancelAtomicSwapAskResult creates a new  CancelAtomicSwapAskResult.
func NewCancelAtomicSwapAskResult(code CancelAtomicSwapAskResultCode, value interface{}) (result CancelAtomicSwapAskResult, err error) {
	result.Code = code
	switch CancelAtomicSwapAskResultCode(code) {
	case CancelAtomicSwapAskResultCodeSuccess:
		tv, ok := value.(CancelAtomicSwapAskResultSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CancelAtomicSwapAskResultSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CancelAtomicSwapAskResult) MustSuccess() CancelAtomicSwapAskResultSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CancelAtomicSwapAskResult) GetSuccess() (result CancelAtomicSwapAskResultSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// CancelChangeRoleRequestOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CancelChangeRoleRequestOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CancelChangeRoleRequestOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CancelChangeRoleRequestOpExt
func (u CancelChangeRoleRequestOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCancelChangeRoleRequestOpExt creates a new  CancelChangeRoleRequestOpExt.
func NewCancelChangeRoleRequestOpExt(v LedgerVersion, value interface{}) (result CancelChangeRoleRequestOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CancelChangeRoleRequestOp is an XDR Struct defines as:
//
//   //: CancelChangeRoleRequestOp is used to cancel reviwable request for changing role.
//    //: If successful, request with the corresponding ID will be deleted
//    struct CancelChangeRoleRequestOp
//    {
//        //: ID of the ChangeRoleRequest request to be canceled
//        uint64 requestID;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//
//    };
//
type CancelChangeRoleRequestOp struct {
	RequestId Uint64                       `json:"requestID,omitempty"`
	Ext       CancelChangeRoleRequestOpExt `json:"ext,omitempty"`
}

// CancelChangeRoleRequestResultCode is an XDR Enum defines as:
//
//   //: Result codes for CancelChangeRoleRequest operation
//    enum CancelChangeRoleRequestResultCode
//    {
//        // codes considered as "success" for the operation
//        //: Operation is successfully applied
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: ID of a request cannot be 0
//        REQUEST_ID_INVALID = -1, // request id can not be equal zero
//        //: ChangeRole request with provided ID is not found
//        REQUEST_NOT_FOUND = -2 // trying to cancel not existing reviewable request
//    };
//
type CancelChangeRoleRequestResultCode int32

const (
	CancelChangeRoleRequestResultCodeSuccess          CancelChangeRoleRequestResultCode = 0
	CancelChangeRoleRequestResultCodeRequestIdInvalid CancelChangeRoleRequestResultCode = -1
	CancelChangeRoleRequestResultCodeRequestNotFound  CancelChangeRoleRequestResultCode = -2
)

var CancelChangeRoleRequestResultCodeAll = []CancelChangeRoleRequestResultCode{
	CancelChangeRoleRequestResultCodeSuccess,
	CancelChangeRoleRequestResultCodeRequestIdInvalid,
	CancelChangeRoleRequestResultCodeRequestNotFound,
}

var cancelChangeRoleRequestResultCodeMap = map[int32]string{
	0:  "CancelChangeRoleRequestResultCodeSuccess",
	-1: "CancelChangeRoleRequestResultCodeRequestIdInvalid",
	-2: "CancelChangeRoleRequestResultCodeRequestNotFound",
}

var cancelChangeRoleRequestResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "request_id_invalid",
	-2: "request_not_found",
}

var cancelChangeRoleRequestResultCodeRevMap = map[string]int32{
	"CancelChangeRoleRequestResultCodeSuccess":          0,
	"CancelChangeRoleRequestResultCodeRequestIdInvalid": -1,
	"CancelChangeRoleRequestResultCodeRequestNotFound":  -2,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CancelChangeRoleRequestResultCode
func (e CancelChangeRoleRequestResultCode) ValidEnum(v int32) bool {
	_, ok := cancelChangeRoleRequestResultCodeMap[v]
	return ok
}
func (e CancelChangeRoleRequestResultCode) isFlag() bool {
	for i := len(CancelChangeRoleRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := CancelChangeRoleRequestResultCode(2) << uint64(len(CancelChangeRoleRequestResultCodeAll)-1) >> uint64(len(CancelChangeRoleRequestResultCodeAll)-i)
		if expected != CancelChangeRoleRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CancelChangeRoleRequestResultCode) String() string {
	name, _ := cancelChangeRoleRequestResultCodeMap[int32(e)]
	return name
}

func (e CancelChangeRoleRequestResultCode) ShortString() string {
	name, _ := cancelChangeRoleRequestResultCodeShortMap[int32(e)]
	return name
}

func (e CancelChangeRoleRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CancelChangeRoleRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CancelChangeRoleRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CancelChangeRoleRequestResultCode(t.Value)
	return nil
}

// CancelChangeRoleSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CancelChangeRoleSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CancelChangeRoleSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CancelChangeRoleSuccessExt
func (u CancelChangeRoleSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCancelChangeRoleSuccessExt creates a new  CancelChangeRoleSuccessExt.
func NewCancelChangeRoleSuccessExt(v LedgerVersion, value interface{}) (result CancelChangeRoleSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CancelChangeRoleSuccess is an XDR Struct defines as:
//
//   //: Result of successful `CancelChangeRoleRequestOp` application
//    struct CancelChangeRoleSuccess {
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CancelChangeRoleSuccess struct {
	Ext CancelChangeRoleSuccessExt `json:"ext,omitempty"`
}

// CancelChangeRoleRequestResult is an XDR Union defines as:
//
//   //: Result of CancelChangeRoleRequest operation application along with the result code
//    union CancelChangeRoleRequestResult switch (CancelChangeRoleRequestResultCode code)
//    {
//        case SUCCESS:
//            CancelChangeRoleSuccess success;
//        default:
//            void;
//    };
//
type CancelChangeRoleRequestResult struct {
	Code    CancelChangeRoleRequestResultCode `json:"code,omitempty"`
	Success *CancelChangeRoleSuccess          `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CancelChangeRoleRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CancelChangeRoleRequestResult
func (u CancelChangeRoleRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch CancelChangeRoleRequestResultCode(sw) {
	case CancelChangeRoleRequestResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewCancelChangeRoleRequestResult creates a new  CancelChangeRoleRequestResult.
func NewCancelChangeRoleRequestResult(code CancelChangeRoleRequestResultCode, value interface{}) (result CancelChangeRoleRequestResult, err error) {
	result.Code = code
	switch CancelChangeRoleRequestResultCode(code) {
	case CancelChangeRoleRequestResultCodeSuccess:
		tv, ok := value.(CancelChangeRoleSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CancelChangeRoleSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CancelChangeRoleRequestResult) MustSuccess() CancelChangeRoleSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CancelChangeRoleRequestResult) GetSuccess() (result CancelChangeRoleSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// CancelCloseDeferredPaymentRequestOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CancelCloseDeferredPaymentRequestOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CancelCloseDeferredPaymentRequestOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CancelCloseDeferredPaymentRequestOpExt
func (u CancelCloseDeferredPaymentRequestOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCancelCloseDeferredPaymentRequestOpExt creates a new  CancelCloseDeferredPaymentRequestOpExt.
func NewCancelCloseDeferredPaymentRequestOpExt(v LedgerVersion, value interface{}) (result CancelCloseDeferredPaymentRequestOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CancelCloseDeferredPaymentRequestOp is an XDR Struct defines as:
//
//   //: CancelCloseDeferredPaymentRequestOp is used to cancel existing deferred payment creation request
//    struct CancelCloseDeferredPaymentRequestOp
//    {
//        //: id of existing request
//        uint64 requestID;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type CancelCloseDeferredPaymentRequestOp struct {
	RequestId Uint64                                 `json:"requestID,omitempty"`
	Ext       CancelCloseDeferredPaymentRequestOpExt `json:"ext,omitempty"`
}

// CancelCloseDeferredPaymentRequestResultCode is an XDR Enum defines as:
//
//   //: Result codes of CancelCloseDeferredPaymentRequestOp
//    enum CancelCloseDeferredPaymentRequestResultCode
//    {
//        //: Atomic swap ask was successfully removed or marked as canceled
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        NOT_FOUND = -1
//    };
//
type CancelCloseDeferredPaymentRequestResultCode int32

const (
	CancelCloseDeferredPaymentRequestResultCodeSuccess  CancelCloseDeferredPaymentRequestResultCode = 0
	CancelCloseDeferredPaymentRequestResultCodeNotFound CancelCloseDeferredPaymentRequestResultCode = -1
)

var CancelCloseDeferredPaymentRequestResultCodeAll = []CancelCloseDeferredPaymentRequestResultCode{
	CancelCloseDeferredPaymentRequestResultCodeSuccess,
	CancelCloseDeferredPaymentRequestResultCodeNotFound,
}

var cancelCloseDeferredPaymentRequestResultCodeMap = map[int32]string{
	0:  "CancelCloseDeferredPaymentRequestResultCodeSuccess",
	-1: "CancelCloseDeferredPaymentRequestResultCodeNotFound",
}

var cancelCloseDeferredPaymentRequestResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "not_found",
}

var cancelCloseDeferredPaymentRequestResultCodeRevMap = map[string]int32{
	"CancelCloseDeferredPaymentRequestResultCodeSuccess":  0,
	"CancelCloseDeferredPaymentRequestResultCodeNotFound": -1,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CancelCloseDeferredPaymentRequestResultCode
func (e CancelCloseDeferredPaymentRequestResultCode) ValidEnum(v int32) bool {
	_, ok := cancelCloseDeferredPaymentRequestResultCodeMap[v]
	return ok
}
func (e CancelCloseDeferredPaymentRequestResultCode) isFlag() bool {
	for i := len(CancelCloseDeferredPaymentRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := CancelCloseDeferredPaymentRequestResultCode(2) << uint64(len(CancelCloseDeferredPaymentRequestResultCodeAll)-1) >> uint64(len(CancelCloseDeferredPaymentRequestResultCodeAll)-i)
		if expected != CancelCloseDeferredPaymentRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CancelCloseDeferredPaymentRequestResultCode) String() string {
	name, _ := cancelCloseDeferredPaymentRequestResultCodeMap[int32(e)]
	return name
}

func (e CancelCloseDeferredPaymentRequestResultCode) ShortString() string {
	name, _ := cancelCloseDeferredPaymentRequestResultCodeShortMap[int32(e)]
	return name
}

func (e CancelCloseDeferredPaymentRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CancelCloseDeferredPaymentRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CancelCloseDeferredPaymentRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CancelCloseDeferredPaymentRequestResultCode(t.Value)
	return nil
}

// CancelCloseDeferredPaymentRequestResultSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CancelCloseDeferredPaymentRequestResultSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CancelCloseDeferredPaymentRequestResultSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CancelCloseDeferredPaymentRequestResultSuccessExt
func (u CancelCloseDeferredPaymentRequestResultSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCancelCloseDeferredPaymentRequestResultSuccessExt creates a new  CancelCloseDeferredPaymentRequestResultSuccessExt.
func NewCancelCloseDeferredPaymentRequestResultSuccessExt(v LedgerVersion, value interface{}) (result CancelCloseDeferredPaymentRequestResultSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CancelCloseDeferredPaymentRequestResultSuccess is an XDR Struct defines as:
//
//   //: Success result of CancelCloseDeferredPaymentRequestOp application
//    struct CancelCloseDeferredPaymentRequestResultSuccess
//    {
//        //: reserved for the future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type CancelCloseDeferredPaymentRequestResultSuccess struct {
	Ext CancelCloseDeferredPaymentRequestResultSuccessExt `json:"ext,omitempty"`
}

// CancelCloseDeferredPaymentRequestResult is an XDR Union defines as:
//
//   //: Result of CancelCloseDeferredPaymentRequestOp application
//    union CancelCloseDeferredPaymentRequestResult switch (CancelCloseDeferredPaymentRequestResultCode code)
//    {
//    case SUCCESS:
//        //: is used to pass useful fields after successful operation applying
//        CancelCloseDeferredPaymentRequestResultSuccess success;
//    default:
//        void;
//    };
//
type CancelCloseDeferredPaymentRequestResult struct {
	Code    CancelCloseDeferredPaymentRequestResultCode     `json:"code,omitempty"`
	Success *CancelCloseDeferredPaymentRequestResultSuccess `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CancelCloseDeferredPaymentRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CancelCloseDeferredPaymentRequestResult
func (u CancelCloseDeferredPaymentRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch CancelCloseDeferredPaymentRequestResultCode(sw) {
	case CancelCloseDeferredPaymentRequestResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewCancelCloseDeferredPaymentRequestResult creates a new  CancelCloseDeferredPaymentRequestResult.
func NewCancelCloseDeferredPaymentRequestResult(code CancelCloseDeferredPaymentRequestResultCode, value interface{}) (result CancelCloseDeferredPaymentRequestResult, err error) {
	result.Code = code
	switch CancelCloseDeferredPaymentRequestResultCode(code) {
	case CancelCloseDeferredPaymentRequestResultCodeSuccess:
		tv, ok := value.(CancelCloseDeferredPaymentRequestResultSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CancelCloseDeferredPaymentRequestResultSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CancelCloseDeferredPaymentRequestResult) MustSuccess() CancelCloseDeferredPaymentRequestResultSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CancelCloseDeferredPaymentRequestResult) GetSuccess() (result CancelCloseDeferredPaymentRequestResultSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// CancelDataCreationRequestOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CancelDataCreationRequestOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CancelDataCreationRequestOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CancelDataCreationRequestOpExt
func (u CancelDataCreationRequestOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCancelDataCreationRequestOpExt creates a new  CancelDataCreationRequestOpExt.
func NewCancelDataCreationRequestOpExt(v LedgerVersion, value interface{}) (result CancelDataCreationRequestOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CancelDataCreationRequestOp is an XDR Struct defines as:
//
//   //: CancelDataCreationRequestOp is used to cancel reviwable request for data creation.
//    //: If successful, request with the corresponding ID will be deleted
//    struct CancelDataCreationRequestOp
//    {
//        //: ID of the DataCreationRequest request to be canceled
//        uint64 requestID;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//
//    };
//
type CancelDataCreationRequestOp struct {
	RequestId Uint64                         `json:"requestID,omitempty"`
	Ext       CancelDataCreationRequestOpExt `json:"ext,omitempty"`
}

// CancelDataCreationRequestResultCode is an XDR Enum defines as:
//
//   //: Result codes for CancelDataCreationRequest operation
//    enum CancelDataCreationRequestResultCode
//    {
//        // codes considered as "success" for the operation
//        //: Operation is successfully applied
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: ID of a request cannot be 0
//        REQUEST_ID_INVALID = -1, // request id can not be equal zero
//        //: request with provided ID is not found
//        REQUEST_NOT_FOUND = -2 // trying to cancel not existing reviewable request
//    };
//
type CancelDataCreationRequestResultCode int32

const (
	CancelDataCreationRequestResultCodeSuccess          CancelDataCreationRequestResultCode = 0
	CancelDataCreationRequestResultCodeRequestIdInvalid CancelDataCreationRequestResultCode = -1
	CancelDataCreationRequestResultCodeRequestNotFound  CancelDataCreationRequestResultCode = -2
)

var CancelDataCreationRequestResultCodeAll = []CancelDataCreationRequestResultCode{
	CancelDataCreationRequestResultCodeSuccess,
	CancelDataCreationRequestResultCodeRequestIdInvalid,
	CancelDataCreationRequestResultCodeRequestNotFound,
}

var cancelDataCreationRequestResultCodeMap = map[int32]string{
	0:  "CancelDataCreationRequestResultCodeSuccess",
	-1: "CancelDataCreationRequestResultCodeRequestIdInvalid",
	-2: "CancelDataCreationRequestResultCodeRequestNotFound",
}

var cancelDataCreationRequestResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "request_id_invalid",
	-2: "request_not_found",
}

var cancelDataCreationRequestResultCodeRevMap = map[string]int32{
	"CancelDataCreationRequestResultCodeSuccess":          0,
	"CancelDataCreationRequestResultCodeRequestIdInvalid": -1,
	"CancelDataCreationRequestResultCodeRequestNotFound":  -2,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CancelDataCreationRequestResultCode
func (e CancelDataCreationRequestResultCode) ValidEnum(v int32) bool {
	_, ok := cancelDataCreationRequestResultCodeMap[v]
	return ok
}
func (e CancelDataCreationRequestResultCode) isFlag() bool {
	for i := len(CancelDataCreationRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := CancelDataCreationRequestResultCode(2) << uint64(len(CancelDataCreationRequestResultCodeAll)-1) >> uint64(len(CancelDataCreationRequestResultCodeAll)-i)
		if expected != CancelDataCreationRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CancelDataCreationRequestResultCode) String() string {
	name, _ := cancelDataCreationRequestResultCodeMap[int32(e)]
	return name
}

func (e CancelDataCreationRequestResultCode) ShortString() string {
	name, _ := cancelDataCreationRequestResultCodeShortMap[int32(e)]
	return name
}

func (e CancelDataCreationRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CancelDataCreationRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CancelDataCreationRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CancelDataCreationRequestResultCode(t.Value)
	return nil
}

// CancelDataCreationSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CancelDataCreationSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CancelDataCreationSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CancelDataCreationSuccessExt
func (u CancelDataCreationSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCancelDataCreationSuccessExt creates a new  CancelDataCreationSuccessExt.
func NewCancelDataCreationSuccessExt(v LedgerVersion, value interface{}) (result CancelDataCreationSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CancelDataCreationSuccess is an XDR Struct defines as:
//
//   //: Result of successful `CancelDataCreationRequestOp` application
//    struct CancelDataCreationSuccess {
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CancelDataCreationSuccess struct {
	Ext CancelDataCreationSuccessExt `json:"ext,omitempty"`
}

// CancelDataCreationRequestResult is an XDR Union defines as:
//
//   //: Result of CancelDataCreationRequest operation application along with the result code
//    union CancelDataCreationRequestResult switch (CancelDataCreationRequestResultCode code)
//    {
//        case SUCCESS:
//            CancelDataCreationSuccess success;
//        default:
//            void;
//    };
//
type CancelDataCreationRequestResult struct {
	Code    CancelDataCreationRequestResultCode `json:"code,omitempty"`
	Success *CancelDataCreationSuccess          `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CancelDataCreationRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CancelDataCreationRequestResult
func (u CancelDataCreationRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch CancelDataCreationRequestResultCode(sw) {
	case CancelDataCreationRequestResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewCancelDataCreationRequestResult creates a new  CancelDataCreationRequestResult.
func NewCancelDataCreationRequestResult(code CancelDataCreationRequestResultCode, value interface{}) (result CancelDataCreationRequestResult, err error) {
	result.Code = code
	switch CancelDataCreationRequestResultCode(code) {
	case CancelDataCreationRequestResultCodeSuccess:
		tv, ok := value.(CancelDataCreationSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CancelDataCreationSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CancelDataCreationRequestResult) MustSuccess() CancelDataCreationSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CancelDataCreationRequestResult) GetSuccess() (result CancelDataCreationSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// CancelDataRemoveRequestOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CancelDataRemoveRequestOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CancelDataRemoveRequestOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CancelDataRemoveRequestOpExt
func (u CancelDataRemoveRequestOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCancelDataRemoveRequestOpExt creates a new  CancelDataRemoveRequestOpExt.
func NewCancelDataRemoveRequestOpExt(v LedgerVersion, value interface{}) (result CancelDataRemoveRequestOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CancelDataRemoveRequestOp is an XDR Struct defines as:
//
//   //: CancelDataRemoveRequestOp is used to cancel reviwable request for data Remove.
//    //: If successful, request with the corresponding ID will be deleted
//    struct CancelDataRemoveRequestOp
//    {
//        //: ID of the DataRemoveRequest request to be canceled
//        uint64 requestID;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//
//    };
//
type CancelDataRemoveRequestOp struct {
	RequestId Uint64                       `json:"requestID,omitempty"`
	Ext       CancelDataRemoveRequestOpExt `json:"ext,omitempty"`
}

// CancelDataRemoveRequestResultCode is an XDR Enum defines as:
//
//   //: Result codes for CancelDataRemoveRequest operation
//    enum CancelDataRemoveRequestResultCode
//    {
//        // codes considered as "success" for the operation
//        //: Operation is successfully applied
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: ID of a request cannot be 0
//        REQUEST_ID_INVALID = -1, // request id can not be equal zero
//        //: request with provided ID is not found
//        REQUEST_NOT_FOUND = -2 // trying to cancel not existing reviewable request
//    };
//
type CancelDataRemoveRequestResultCode int32

const (
	CancelDataRemoveRequestResultCodeSuccess          CancelDataRemoveRequestResultCode = 0
	CancelDataRemoveRequestResultCodeRequestIdInvalid CancelDataRemoveRequestResultCode = -1
	CancelDataRemoveRequestResultCodeRequestNotFound  CancelDataRemoveRequestResultCode = -2
)

var CancelDataRemoveRequestResultCodeAll = []CancelDataRemoveRequestResultCode{
	CancelDataRemoveRequestResultCodeSuccess,
	CancelDataRemoveRequestResultCodeRequestIdInvalid,
	CancelDataRemoveRequestResultCodeRequestNotFound,
}

var cancelDataRemoveRequestResultCodeMap = map[int32]string{
	0:  "CancelDataRemoveRequestResultCodeSuccess",
	-1: "CancelDataRemoveRequestResultCodeRequestIdInvalid",
	-2: "CancelDataRemoveRequestResultCodeRequestNotFound",
}

var cancelDataRemoveRequestResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "request_id_invalid",
	-2: "request_not_found",
}

var cancelDataRemoveRequestResultCodeRevMap = map[string]int32{
	"CancelDataRemoveRequestResultCodeSuccess":          0,
	"CancelDataRemoveRequestResultCodeRequestIdInvalid": -1,
	"CancelDataRemoveRequestResultCodeRequestNotFound":  -2,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CancelDataRemoveRequestResultCode
func (e CancelDataRemoveRequestResultCode) ValidEnum(v int32) bool {
	_, ok := cancelDataRemoveRequestResultCodeMap[v]
	return ok
}
func (e CancelDataRemoveRequestResultCode) isFlag() bool {
	for i := len(CancelDataRemoveRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := CancelDataRemoveRequestResultCode(2) << uint64(len(CancelDataRemoveRequestResultCodeAll)-1) >> uint64(len(CancelDataRemoveRequestResultCodeAll)-i)
		if expected != CancelDataRemoveRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CancelDataRemoveRequestResultCode) String() string {
	name, _ := cancelDataRemoveRequestResultCodeMap[int32(e)]
	return name
}

func (e CancelDataRemoveRequestResultCode) ShortString() string {
	name, _ := cancelDataRemoveRequestResultCodeShortMap[int32(e)]
	return name
}

func (e CancelDataRemoveRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CancelDataRemoveRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CancelDataRemoveRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CancelDataRemoveRequestResultCode(t.Value)
	return nil
}

// CancelDataRemoveSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CancelDataRemoveSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CancelDataRemoveSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CancelDataRemoveSuccessExt
func (u CancelDataRemoveSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCancelDataRemoveSuccessExt creates a new  CancelDataRemoveSuccessExt.
func NewCancelDataRemoveSuccessExt(v LedgerVersion, value interface{}) (result CancelDataRemoveSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CancelDataRemoveSuccess is an XDR Struct defines as:
//
//   //: Result of successful `CancelDataRemoveRequestOp` application
//    struct CancelDataRemoveSuccess {
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CancelDataRemoveSuccess struct {
	Ext CancelDataRemoveSuccessExt `json:"ext,omitempty"`
}

// CancelDataRemoveRequestResult is an XDR Union defines as:
//
//   //: Result of CancelDataRemoveRequest operation application along with the result code
//    union CancelDataRemoveRequestResult switch (CancelDataRemoveRequestResultCode code)
//    {
//        case SUCCESS:
//            CancelDataRemoveSuccess success;
//        default:
//            void;
//    };
//
type CancelDataRemoveRequestResult struct {
	Code    CancelDataRemoveRequestResultCode `json:"code,omitempty"`
	Success *CancelDataRemoveSuccess          `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CancelDataRemoveRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CancelDataRemoveRequestResult
func (u CancelDataRemoveRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch CancelDataRemoveRequestResultCode(sw) {
	case CancelDataRemoveRequestResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewCancelDataRemoveRequestResult creates a new  CancelDataRemoveRequestResult.
func NewCancelDataRemoveRequestResult(code CancelDataRemoveRequestResultCode, value interface{}) (result CancelDataRemoveRequestResult, err error) {
	result.Code = code
	switch CancelDataRemoveRequestResultCode(code) {
	case CancelDataRemoveRequestResultCodeSuccess:
		tv, ok := value.(CancelDataRemoveSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CancelDataRemoveSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CancelDataRemoveRequestResult) MustSuccess() CancelDataRemoveSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CancelDataRemoveRequestResult) GetSuccess() (result CancelDataRemoveSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// CancelDataUpdateRequestOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CancelDataUpdateRequestOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CancelDataUpdateRequestOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CancelDataUpdateRequestOpExt
func (u CancelDataUpdateRequestOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCancelDataUpdateRequestOpExt creates a new  CancelDataUpdateRequestOpExt.
func NewCancelDataUpdateRequestOpExt(v LedgerVersion, value interface{}) (result CancelDataUpdateRequestOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CancelDataUpdateRequestOp is an XDR Struct defines as:
//
//   //: CancelDataUpdateRequestOp is used to cancel reviwable request for data Update.
//    //: If successful, request with the corresponding ID will be deleted
//    struct CancelDataUpdateRequestOp
//    {
//        //: ID of the DataUpdateRequest request to be canceled
//        uint64 requestID;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//
//    };
//
type CancelDataUpdateRequestOp struct {
	RequestId Uint64                       `json:"requestID,omitempty"`
	Ext       CancelDataUpdateRequestOpExt `json:"ext,omitempty"`
}

// CancelDataUpdateRequestResultCode is an XDR Enum defines as:
//
//   //: Result codes for CancelDataUpdateRequest operation
//    enum CancelDataUpdateRequestResultCode
//    {
//        // codes considered as "success" for the operation
//        //: Operation is successfully applied
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: ID of a request cannot be 0
//        REQUEST_ID_INVALID = -1, // request id can not be equal zero
//        //: request with provided ID is not found
//        REQUEST_NOT_FOUND = -2 // trying to cancel not existing reviewable request
//    };
//
type CancelDataUpdateRequestResultCode int32

const (
	CancelDataUpdateRequestResultCodeSuccess          CancelDataUpdateRequestResultCode = 0
	CancelDataUpdateRequestResultCodeRequestIdInvalid CancelDataUpdateRequestResultCode = -1
	CancelDataUpdateRequestResultCodeRequestNotFound  CancelDataUpdateRequestResultCode = -2
)

var CancelDataUpdateRequestResultCodeAll = []CancelDataUpdateRequestResultCode{
	CancelDataUpdateRequestResultCodeSuccess,
	CancelDataUpdateRequestResultCodeRequestIdInvalid,
	CancelDataUpdateRequestResultCodeRequestNotFound,
}

var cancelDataUpdateRequestResultCodeMap = map[int32]string{
	0:  "CancelDataUpdateRequestResultCodeSuccess",
	-1: "CancelDataUpdateRequestResultCodeRequestIdInvalid",
	-2: "CancelDataUpdateRequestResultCodeRequestNotFound",
}

var cancelDataUpdateRequestResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "request_id_invalid",
	-2: "request_not_found",
}

var cancelDataUpdateRequestResultCodeRevMap = map[string]int32{
	"CancelDataUpdateRequestResultCodeSuccess":          0,
	"CancelDataUpdateRequestResultCodeRequestIdInvalid": -1,
	"CancelDataUpdateRequestResultCodeRequestNotFound":  -2,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CancelDataUpdateRequestResultCode
func (e CancelDataUpdateRequestResultCode) ValidEnum(v int32) bool {
	_, ok := cancelDataUpdateRequestResultCodeMap[v]
	return ok
}
func (e CancelDataUpdateRequestResultCode) isFlag() bool {
	for i := len(CancelDataUpdateRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := CancelDataUpdateRequestResultCode(2) << uint64(len(CancelDataUpdateRequestResultCodeAll)-1) >> uint64(len(CancelDataUpdateRequestResultCodeAll)-i)
		if expected != CancelDataUpdateRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CancelDataUpdateRequestResultCode) String() string {
	name, _ := cancelDataUpdateRequestResultCodeMap[int32(e)]
	return name
}

func (e CancelDataUpdateRequestResultCode) ShortString() string {
	name, _ := cancelDataUpdateRequestResultCodeShortMap[int32(e)]
	return name
}

func (e CancelDataUpdateRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CancelDataUpdateRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CancelDataUpdateRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CancelDataUpdateRequestResultCode(t.Value)
	return nil
}

// CancelDataUpdateSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CancelDataUpdateSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CancelDataUpdateSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CancelDataUpdateSuccessExt
func (u CancelDataUpdateSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCancelDataUpdateSuccessExt creates a new  CancelDataUpdateSuccessExt.
func NewCancelDataUpdateSuccessExt(v LedgerVersion, value interface{}) (result CancelDataUpdateSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CancelDataUpdateSuccess is an XDR Struct defines as:
//
//   //: Result of successful `CancelDataUpdateRequestOp` application
//    struct CancelDataUpdateSuccess {
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CancelDataUpdateSuccess struct {
	Ext CancelDataUpdateSuccessExt `json:"ext,omitempty"`
}

// CancelDataUpdateRequestResult is an XDR Union defines as:
//
//   //: Result of CancelDataUpdateRequest operation application along with the result code
//    union CancelDataUpdateRequestResult switch (CancelDataUpdateRequestResultCode code)
//    {
//        case SUCCESS:
//            CancelDataUpdateSuccess success;
//        default:
//            void;
//    };
//
type CancelDataUpdateRequestResult struct {
	Code    CancelDataUpdateRequestResultCode `json:"code,omitempty"`
	Success *CancelDataUpdateSuccess          `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CancelDataUpdateRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CancelDataUpdateRequestResult
func (u CancelDataUpdateRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch CancelDataUpdateRequestResultCode(sw) {
	case CancelDataUpdateRequestResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewCancelDataUpdateRequestResult creates a new  CancelDataUpdateRequestResult.
func NewCancelDataUpdateRequestResult(code CancelDataUpdateRequestResultCode, value interface{}) (result CancelDataUpdateRequestResult, err error) {
	result.Code = code
	switch CancelDataUpdateRequestResultCode(code) {
	case CancelDataUpdateRequestResultCodeSuccess:
		tv, ok := value.(CancelDataUpdateSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CancelDataUpdateSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CancelDataUpdateRequestResult) MustSuccess() CancelDataUpdateSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CancelDataUpdateRequestResult) GetSuccess() (result CancelDataUpdateSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// CancelDeferredPaymentCreationRequestOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CancelDeferredPaymentCreationRequestOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CancelDeferredPaymentCreationRequestOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CancelDeferredPaymentCreationRequestOpExt
func (u CancelDeferredPaymentCreationRequestOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCancelDeferredPaymentCreationRequestOpExt creates a new  CancelDeferredPaymentCreationRequestOpExt.
func NewCancelDeferredPaymentCreationRequestOpExt(v LedgerVersion, value interface{}) (result CancelDeferredPaymentCreationRequestOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CancelDeferredPaymentCreationRequestOp is an XDR Struct defines as:
//
//   //: CancelDeferredPaymentCreationRequestOp is used to cancel existing deferred payment creation request
//    struct CancelDeferredPaymentCreationRequestOp
//    {
//        //: id of existing request
//        uint64 requestID;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type CancelDeferredPaymentCreationRequestOp struct {
	RequestId Uint64                                    `json:"requestID,omitempty"`
	Ext       CancelDeferredPaymentCreationRequestOpExt `json:"ext,omitempty"`
}

// CancelDeferredPaymentCreationRequestResultCode is an XDR Enum defines as:
//
//   //: Result codes of CancelDeferredPaymentCreationRequestOp
//    enum CancelDeferredPaymentCreationRequestResultCode
//    {
//        //: Atomic swap ask was successfully removed or marked as canceled
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: There is no atomic swap ask with such id
//        NOT_FOUND = -1, // request does not exist
//        REQUEST_ID_INVALID = -2,
//        LINE_FULL = -3
//    };
//
type CancelDeferredPaymentCreationRequestResultCode int32

const (
	CancelDeferredPaymentCreationRequestResultCodeSuccess          CancelDeferredPaymentCreationRequestResultCode = 0
	CancelDeferredPaymentCreationRequestResultCodeNotFound         CancelDeferredPaymentCreationRequestResultCode = -1
	CancelDeferredPaymentCreationRequestResultCodeRequestIdInvalid CancelDeferredPaymentCreationRequestResultCode = -2
	CancelDeferredPaymentCreationRequestResultCodeLineFull         CancelDeferredPaymentCreationRequestResultCode = -3
)

var CancelDeferredPaymentCreationRequestResultCodeAll = []CancelDeferredPaymentCreationRequestResultCode{
	CancelDeferredPaymentCreationRequestResultCodeSuccess,
	CancelDeferredPaymentCreationRequestResultCodeNotFound,
	CancelDeferredPaymentCreationRequestResultCodeRequestIdInvalid,
	CancelDeferredPaymentCreationRequestResultCodeLineFull,
}

var cancelDeferredPaymentCreationRequestResultCodeMap = map[int32]string{
	0:  "CancelDeferredPaymentCreationRequestResultCodeSuccess",
	-1: "CancelDeferredPaymentCreationRequestResultCodeNotFound",
	-2: "CancelDeferredPaymentCreationRequestResultCodeRequestIdInvalid",
	-3: "CancelDeferredPaymentCreationRequestResultCodeLineFull",
}

var cancelDeferredPaymentCreationRequestResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "not_found",
	-2: "request_id_invalid",
	-3: "line_full",
}

var cancelDeferredPaymentCreationRequestResultCodeRevMap = map[string]int32{
	"CancelDeferredPaymentCreationRequestResultCodeSuccess":          0,
	"CancelDeferredPaymentCreationRequestResultCodeNotFound":         -1,
	"CancelDeferredPaymentCreationRequestResultCodeRequestIdInvalid": -2,
	"CancelDeferredPaymentCreationRequestResultCodeLineFull":         -3,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CancelDeferredPaymentCreationRequestResultCode
func (e CancelDeferredPaymentCreationRequestResultCode) ValidEnum(v int32) bool {
	_, ok := cancelDeferredPaymentCreationRequestResultCodeMap[v]
	return ok
}
func (e CancelDeferredPaymentCreationRequestResultCode) isFlag() bool {
	for i := len(CancelDeferredPaymentCreationRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := CancelDeferredPaymentCreationRequestResultCode(2) << uint64(len(CancelDeferredPaymentCreationRequestResultCodeAll)-1) >> uint64(len(CancelDeferredPaymentCreationRequestResultCodeAll)-i)
		if expected != CancelDeferredPaymentCreationRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CancelDeferredPaymentCreationRequestResultCode) String() string {
	name, _ := cancelDeferredPaymentCreationRequestResultCodeMap[int32(e)]
	return name
}

func (e CancelDeferredPaymentCreationRequestResultCode) ShortString() string {
	name, _ := cancelDeferredPaymentCreationRequestResultCodeShortMap[int32(e)]
	return name
}

func (e CancelDeferredPaymentCreationRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CancelDeferredPaymentCreationRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CancelDeferredPaymentCreationRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CancelDeferredPaymentCreationRequestResultCode(t.Value)
	return nil
}

// CancelDeferredPaymentCreationRequestResultSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CancelDeferredPaymentCreationRequestResultSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CancelDeferredPaymentCreationRequestResultSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CancelDeferredPaymentCreationRequestResultSuccessExt
func (u CancelDeferredPaymentCreationRequestResultSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCancelDeferredPaymentCreationRequestResultSuccessExt creates a new  CancelDeferredPaymentCreationRequestResultSuccessExt.
func NewCancelDeferredPaymentCreationRequestResultSuccessExt(v LedgerVersion, value interface{}) (result CancelDeferredPaymentCreationRequestResultSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CancelDeferredPaymentCreationRequestResultSuccess is an XDR Struct defines as:
//
//   //: Success result of CancelDeferredPaymentCreationRequestOp application
//    struct CancelDeferredPaymentCreationRequestResultSuccess
//    {
//        //: reserved for the future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type CancelDeferredPaymentCreationRequestResultSuccess struct {
	Ext CancelDeferredPaymentCreationRequestResultSuccessExt `json:"ext,omitempty"`
}

// CancelDeferredPaymentCreationRequestResult is an XDR Union defines as:
//
//   //: Result of CancelDeferredPaymentCreationRequestOp application
//    union CancelDeferredPaymentCreationRequestResult switch (CancelDeferredPaymentCreationRequestResultCode code)
//    {
//    case SUCCESS:
//        //: is used to pass useful fields after successful operation applying
//        CancelDeferredPaymentCreationRequestResultSuccess success;
//    default:
//        void;
//    };
//
type CancelDeferredPaymentCreationRequestResult struct {
	Code    CancelDeferredPaymentCreationRequestResultCode     `json:"code,omitempty"`
	Success *CancelDeferredPaymentCreationRequestResultSuccess `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CancelDeferredPaymentCreationRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CancelDeferredPaymentCreationRequestResult
func (u CancelDeferredPaymentCreationRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch CancelDeferredPaymentCreationRequestResultCode(sw) {
	case CancelDeferredPaymentCreationRequestResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewCancelDeferredPaymentCreationRequestResult creates a new  CancelDeferredPaymentCreationRequestResult.
func NewCancelDeferredPaymentCreationRequestResult(code CancelDeferredPaymentCreationRequestResultCode, value interface{}) (result CancelDeferredPaymentCreationRequestResult, err error) {
	result.Code = code
	switch CancelDeferredPaymentCreationRequestResultCode(code) {
	case CancelDeferredPaymentCreationRequestResultCodeSuccess:
		tv, ok := value.(CancelDeferredPaymentCreationRequestResultSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CancelDeferredPaymentCreationRequestResultSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CancelDeferredPaymentCreationRequestResult) MustSuccess() CancelDeferredPaymentCreationRequestResultSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CancelDeferredPaymentCreationRequestResult) GetSuccess() (result CancelDeferredPaymentCreationRequestResultSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// CancelSaleCreationRequestOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CancelSaleCreationRequestOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CancelSaleCreationRequestOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CancelSaleCreationRequestOpExt
func (u CancelSaleCreationRequestOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCancelSaleCreationRequestOpExt creates a new  CancelSaleCreationRequestOpExt.
func NewCancelSaleCreationRequestOpExt(v LedgerVersion, value interface{}) (result CancelSaleCreationRequestOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CancelSaleCreationRequestOp is an XDR Struct defines as:
//
//   //: CancelSaleCreationRequest operation is used to cancel sale creation request.
//    //: If successful, request with the corresponding ID will be deleted
//    //: SaleCreationRequest with provided ID
//    struct CancelSaleCreationRequestOp
//    {
//        //: ID of the SaleCreation request to be canceled
//        uint64 requestID;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//
//    };
//
type CancelSaleCreationRequestOp struct {
	RequestId Uint64                         `json:"requestID,omitempty"`
	Ext       CancelSaleCreationRequestOpExt `json:"ext,omitempty"`
}

// CancelSaleCreationRequestResultCode is an XDR Enum defines as:
//
//   //: Result codes for CancelSaleCreationRequest operation
//    enum CancelSaleCreationRequestResultCode
//    {
//        // codes considered as "success" for the operation
//        //: Operation is successfully applied
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: ID of a request cannot be 0
//        REQUEST_ID_INVALID = -1, // request id can not be equal zero
//        //: SaleCreation request with provided ID is not found
//        REQUEST_NOT_FOUND = -2 // trying to cancel not existing reviewable request
//    };
//
type CancelSaleCreationRequestResultCode int32

const (
	CancelSaleCreationRequestResultCodeSuccess          CancelSaleCreationRequestResultCode = 0
	CancelSaleCreationRequestResultCodeRequestIdInvalid CancelSaleCreationRequestResultCode = -1
	CancelSaleCreationRequestResultCodeRequestNotFound  CancelSaleCreationRequestResultCode = -2
)

var CancelSaleCreationRequestResultCodeAll = []CancelSaleCreationRequestResultCode{
	CancelSaleCreationRequestResultCodeSuccess,
	CancelSaleCreationRequestResultCodeRequestIdInvalid,
	CancelSaleCreationRequestResultCodeRequestNotFound,
}

var cancelSaleCreationRequestResultCodeMap = map[int32]string{
	0:  "CancelSaleCreationRequestResultCodeSuccess",
	-1: "CancelSaleCreationRequestResultCodeRequestIdInvalid",
	-2: "CancelSaleCreationRequestResultCodeRequestNotFound",
}

var cancelSaleCreationRequestResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "request_id_invalid",
	-2: "request_not_found",
}

var cancelSaleCreationRequestResultCodeRevMap = map[string]int32{
	"CancelSaleCreationRequestResultCodeSuccess":          0,
	"CancelSaleCreationRequestResultCodeRequestIdInvalid": -1,
	"CancelSaleCreationRequestResultCodeRequestNotFound":  -2,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CancelSaleCreationRequestResultCode
func (e CancelSaleCreationRequestResultCode) ValidEnum(v int32) bool {
	_, ok := cancelSaleCreationRequestResultCodeMap[v]
	return ok
}
func (e CancelSaleCreationRequestResultCode) isFlag() bool {
	for i := len(CancelSaleCreationRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := CancelSaleCreationRequestResultCode(2) << uint64(len(CancelSaleCreationRequestResultCodeAll)-1) >> uint64(len(CancelSaleCreationRequestResultCodeAll)-i)
		if expected != CancelSaleCreationRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CancelSaleCreationRequestResultCode) String() string {
	name, _ := cancelSaleCreationRequestResultCodeMap[int32(e)]
	return name
}

func (e CancelSaleCreationRequestResultCode) ShortString() string {
	name, _ := cancelSaleCreationRequestResultCodeShortMap[int32(e)]
	return name
}

func (e CancelSaleCreationRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CancelSaleCreationRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CancelSaleCreationRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CancelSaleCreationRequestResultCode(t.Value)
	return nil
}

// CancelSaleCreationSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CancelSaleCreationSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CancelSaleCreationSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CancelSaleCreationSuccessExt
func (u CancelSaleCreationSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCancelSaleCreationSuccessExt creates a new  CancelSaleCreationSuccessExt.
func NewCancelSaleCreationSuccessExt(v LedgerVersion, value interface{}) (result CancelSaleCreationSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CancelSaleCreationSuccess is an XDR Struct defines as:
//
//   //: Result of successful `CancelSaleCreationRequestOp` application
//    struct CancelSaleCreationSuccess {
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CancelSaleCreationSuccess struct {
	Ext CancelSaleCreationSuccessExt `json:"ext,omitempty"`
}

// CancelSaleCreationRequestResult is an XDR Union defines as:
//
//   //: Result of CancelSaleCreationRequest operation application along with the result code
//    union CancelSaleCreationRequestResult switch (CancelSaleCreationRequestResultCode code)
//    {
//        case SUCCESS:
//            CancelSaleCreationSuccess success;
//        default:
//            void;
//    };
//
type CancelSaleCreationRequestResult struct {
	Code    CancelSaleCreationRequestResultCode `json:"code,omitempty"`
	Success *CancelSaleCreationSuccess          `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CancelSaleCreationRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CancelSaleCreationRequestResult
func (u CancelSaleCreationRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch CancelSaleCreationRequestResultCode(sw) {
	case CancelSaleCreationRequestResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewCancelSaleCreationRequestResult creates a new  CancelSaleCreationRequestResult.
func NewCancelSaleCreationRequestResult(code CancelSaleCreationRequestResultCode, value interface{}) (result CancelSaleCreationRequestResult, err error) {
	result.Code = code
	switch CancelSaleCreationRequestResultCode(code) {
	case CancelSaleCreationRequestResultCodeSuccess:
		tv, ok := value.(CancelSaleCreationSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CancelSaleCreationSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CancelSaleCreationRequestResult) MustSuccess() CancelSaleCreationSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CancelSaleCreationRequestResult) GetSuccess() (result CancelSaleCreationSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// CheckSaleStateOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CheckSaleStateOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CheckSaleStateOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CheckSaleStateOpExt
func (u CheckSaleStateOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCheckSaleStateOpExt creates a new  CheckSaleStateOpExt.
func NewCheckSaleStateOpExt(v LedgerVersion, value interface{}) (result CheckSaleStateOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CheckSaleStateOp is an XDR Struct defines as:
//
//   //: CheckSaleState operation is used to perform check on sale state - whether the sale was successful or not
//    struct CheckSaleStateOp
//    {
//        //:ID of the sale to check
//        uint64 saleID;
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CheckSaleStateOp struct {
	SaleId Uint64              `json:"saleID,omitempty"`
	Ext    CheckSaleStateOpExt `json:"ext,omitempty"`
}

// CheckSaleStateResultCode is an XDR Enum defines as:
//
//   //: Result codes of CheckSaleState operation
//    enum CheckSaleStateResultCode
//    {
//        // codes considered as "success" for the operation
//        //: CheckSaleState operation was successfully applied
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: Sale with provided ID not found
//        NOT_FOUND = -1,
//        //: Sale was not processed, because it's still active
//        NOT_READY = -2
//    };
//
type CheckSaleStateResultCode int32

const (
	CheckSaleStateResultCodeSuccess  CheckSaleStateResultCode = 0
	CheckSaleStateResultCodeNotFound CheckSaleStateResultCode = -1
	CheckSaleStateResultCodeNotReady CheckSaleStateResultCode = -2
)

var CheckSaleStateResultCodeAll = []CheckSaleStateResultCode{
	CheckSaleStateResultCodeSuccess,
	CheckSaleStateResultCodeNotFound,
	CheckSaleStateResultCodeNotReady,
}

var checkSaleStateResultCodeMap = map[int32]string{
	0:  "CheckSaleStateResultCodeSuccess",
	-1: "CheckSaleStateResultCodeNotFound",
	-2: "CheckSaleStateResultCodeNotReady",
}

var checkSaleStateResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "not_found",
	-2: "not_ready",
}

var checkSaleStateResultCodeRevMap = map[string]int32{
	"CheckSaleStateResultCodeSuccess":  0,
	"CheckSaleStateResultCodeNotFound": -1,
	"CheckSaleStateResultCodeNotReady": -2,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CheckSaleStateResultCode
func (e CheckSaleStateResultCode) ValidEnum(v int32) bool {
	_, ok := checkSaleStateResultCodeMap[v]
	return ok
}
func (e CheckSaleStateResultCode) isFlag() bool {
	for i := len(CheckSaleStateResultCodeAll) - 1; i >= 0; i-- {
		expected := CheckSaleStateResultCode(2) << uint64(len(CheckSaleStateResultCodeAll)-1) >> uint64(len(CheckSaleStateResultCodeAll)-i)
		if expected != CheckSaleStateResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CheckSaleStateResultCode) String() string {
	name, _ := checkSaleStateResultCodeMap[int32(e)]
	return name
}

func (e CheckSaleStateResultCode) ShortString() string {
	name, _ := checkSaleStateResultCodeShortMap[int32(e)]
	return name
}

func (e CheckSaleStateResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CheckSaleStateResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CheckSaleStateResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CheckSaleStateResultCode(t.Value)
	return nil
}

// CheckSaleStateEffect is an XDR Enum defines as:
//
//   //: Effect of performed check sale state operation
//    enum CheckSaleStateEffect {
//        //: Sale hasn't reached the soft cap before end time
//        CANCELED = 1,
//        //: Sale has either reached the soft cap and ended or reached hard cap
//        CLOSED = 2,
//        //: Crowdfunding sale was successfully closed and the price for the base asset was updated according to participants contribution
//        UPDATED = 3
//    };
//
type CheckSaleStateEffect int32

const (
	CheckSaleStateEffectCanceled CheckSaleStateEffect = 1
	CheckSaleStateEffectClosed   CheckSaleStateEffect = 2
	CheckSaleStateEffectUpdated  CheckSaleStateEffect = 3
)

var CheckSaleStateEffectAll = []CheckSaleStateEffect{
	CheckSaleStateEffectCanceled,
	CheckSaleStateEffectClosed,
	CheckSaleStateEffectUpdated,
}

var checkSaleStateEffectMap = map[int32]string{
	1: "CheckSaleStateEffectCanceled",
	2: "CheckSaleStateEffectClosed",
	3: "CheckSaleStateEffectUpdated",
}

var checkSaleStateEffectShortMap = map[int32]string{
	1: "canceled",
	2: "closed",
	3: "updated",
}

var checkSaleStateEffectRevMap = map[string]int32{
	"CheckSaleStateEffectCanceled": 1,
	"CheckSaleStateEffectClosed":   2,
	"CheckSaleStateEffectUpdated":  3,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CheckSaleStateEffect
func (e CheckSaleStateEffect) ValidEnum(v int32) bool {
	_, ok := checkSaleStateEffectMap[v]
	return ok
}
func (e CheckSaleStateEffect) isFlag() bool {
	for i := len(CheckSaleStateEffectAll) - 1; i >= 0; i-- {
		expected := CheckSaleStateEffect(2) << uint64(len(CheckSaleStateEffectAll)-1) >> uint64(len(CheckSaleStateEffectAll)-i)
		if expected != CheckSaleStateEffectAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CheckSaleStateEffect) String() string {
	name, _ := checkSaleStateEffectMap[int32(e)]
	return name
}

func (e CheckSaleStateEffect) ShortString() string {
	name, _ := checkSaleStateEffectShortMap[int32(e)]
	return name
}

func (e CheckSaleStateEffect) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CheckSaleStateEffectAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CheckSaleStateEffect) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CheckSaleStateEffect(t.Value)
	return nil
}

// SaleCanceledExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type SaleCanceledExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u SaleCanceledExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of SaleCanceledExt
func (u SaleCanceledExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewSaleCanceledExt creates a new  SaleCanceledExt.
func NewSaleCanceledExt(v LedgerVersion, value interface{}) (result SaleCanceledExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// SaleCanceled is an XDR Struct defines as:
//
//   //: Entry for additional information regarding sale cancel
//    struct SaleCanceled {
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type SaleCanceled struct {
	Ext SaleCanceledExt `json:"ext,omitempty"`
}

// SaleUpdatedExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type SaleUpdatedExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u SaleUpdatedExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of SaleUpdatedExt
func (u SaleUpdatedExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewSaleUpdatedExt creates a new  SaleUpdatedExt.
func NewSaleUpdatedExt(v LedgerVersion, value interface{}) (result SaleUpdatedExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// SaleUpdated is an XDR Struct defines as:
//
//   //: Entry for additional information regarding sale update
//    struct SaleUpdated {
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type SaleUpdated struct {
	Ext SaleUpdatedExt `json:"ext,omitempty"`
}

// CheckSubSaleClosedResultExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//          void;
//        }
//
type CheckSubSaleClosedResultExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CheckSubSaleClosedResultExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CheckSubSaleClosedResultExt
func (u CheckSubSaleClosedResultExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCheckSubSaleClosedResultExt creates a new  CheckSubSaleClosedResultExt.
func NewCheckSubSaleClosedResultExt(v LedgerVersion, value interface{}) (result CheckSubSaleClosedResultExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CheckSubSaleClosedResult is an XDR Struct defines as:
//
//   //: Entry for additional information regarding sub sale closing
//    struct CheckSubSaleClosedResult {
//        //: Balance in base asset of the closed sale
//        BalanceID saleBaseBalance;
//        //: Balance in one of the quote assets of the closed sale
//        BalanceID saleQuoteBalance;
//        //: Result of an individual offer made during the sale and completed on its close
//        ManageOfferSuccessResult saleDetails;
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//          void;
//        }
//        ext;
//    };
//
type CheckSubSaleClosedResult struct {
	SaleBaseBalance  BalanceId                   `json:"saleBaseBalance,omitempty"`
	SaleQuoteBalance BalanceId                   `json:"saleQuoteBalance,omitempty"`
	SaleDetails      ManageOfferSuccessResult    `json:"saleDetails,omitempty"`
	Ext              CheckSubSaleClosedResultExt `json:"ext,omitempty"`
}

// CheckSaleClosedResultExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//          case EMPTY_VERSION:
//            void;
//        }
//
type CheckSaleClosedResultExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CheckSaleClosedResultExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CheckSaleClosedResultExt
func (u CheckSaleClosedResultExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCheckSaleClosedResultExt creates a new  CheckSaleClosedResultExt.
func NewCheckSaleClosedResultExt(v LedgerVersion, value interface{}) (result CheckSaleClosedResultExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CheckSaleClosedResult is an XDR Struct defines as:
//
//   //: Entry for additional information regarding sale closing
//    struct CheckSaleClosedResult {
//        //: AccountID of the sale owner
//        AccountID saleOwner;
//        //: Array of individual's contribution details
//        CheckSubSaleClosedResult results<>;
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//          case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CheckSaleClosedResult struct {
	SaleOwner AccountId                  `json:"saleOwner,omitempty"`
	Results   []CheckSubSaleClosedResult `json:"results,omitempty"`
	Ext       CheckSaleClosedResultExt   `json:"ext,omitempty"`
}

// CheckSaleStateSuccessEffect is an XDR NestedUnion defines as:
//
//   union switch (CheckSaleStateEffect effect)
//        {
//        case CANCELED:
//            SaleCanceled saleCanceled;
//        case CLOSED:
//            CheckSaleClosedResult saleClosed;
//        case UPDATED:
//            SaleUpdated saleUpdated;
//        }
//
type CheckSaleStateSuccessEffect struct {
	Effect       CheckSaleStateEffect   `json:"effect,omitempty"`
	SaleCanceled *SaleCanceled          `json:"saleCanceled,omitempty"`
	SaleClosed   *CheckSaleClosedResult `json:"saleClosed,omitempty"`
	SaleUpdated  *SaleUpdated           `json:"saleUpdated,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CheckSaleStateSuccessEffect) SwitchFieldName() string {
	return "Effect"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CheckSaleStateSuccessEffect
func (u CheckSaleStateSuccessEffect) ArmForSwitch(sw int32) (string, bool) {
	switch CheckSaleStateEffect(sw) {
	case CheckSaleStateEffectCanceled:
		return "SaleCanceled", true
	case CheckSaleStateEffectClosed:
		return "SaleClosed", true
	case CheckSaleStateEffectUpdated:
		return "SaleUpdated", true
	}
	return "-", false
}

// NewCheckSaleStateSuccessEffect creates a new  CheckSaleStateSuccessEffect.
func NewCheckSaleStateSuccessEffect(effect CheckSaleStateEffect, value interface{}) (result CheckSaleStateSuccessEffect, err error) {
	result.Effect = effect
	switch CheckSaleStateEffect(effect) {
	case CheckSaleStateEffectCanceled:
		tv, ok := value.(SaleCanceled)
		if !ok {
			err = fmt.Errorf("invalid value, must be SaleCanceled")
			return
		}
		result.SaleCanceled = &tv
	case CheckSaleStateEffectClosed:
		tv, ok := value.(CheckSaleClosedResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CheckSaleClosedResult")
			return
		}
		result.SaleClosed = &tv
	case CheckSaleStateEffectUpdated:
		tv, ok := value.(SaleUpdated)
		if !ok {
			err = fmt.Errorf("invalid value, must be SaleUpdated")
			return
		}
		result.SaleUpdated = &tv
	}
	return
}

// MustSaleCanceled retrieves the SaleCanceled value from the union,
// panicing if the value is not set.
func (u CheckSaleStateSuccessEffect) MustSaleCanceled() SaleCanceled {
	val, ok := u.GetSaleCanceled()

	if !ok {
		panic("arm SaleCanceled is not set")
	}

	return val
}

// GetSaleCanceled retrieves the SaleCanceled value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CheckSaleStateSuccessEffect) GetSaleCanceled() (result SaleCanceled, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Effect))

	if armName == "SaleCanceled" {
		result = *u.SaleCanceled
		ok = true
	}

	return
}

// MustSaleClosed retrieves the SaleClosed value from the union,
// panicing if the value is not set.
func (u CheckSaleStateSuccessEffect) MustSaleClosed() CheckSaleClosedResult {
	val, ok := u.GetSaleClosed()

	if !ok {
		panic("arm SaleClosed is not set")
	}

	return val
}

// GetSaleClosed retrieves the SaleClosed value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CheckSaleStateSuccessEffect) GetSaleClosed() (result CheckSaleClosedResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Effect))

	if armName == "SaleClosed" {
		result = *u.SaleClosed
		ok = true
	}

	return
}

// MustSaleUpdated retrieves the SaleUpdated value from the union,
// panicing if the value is not set.
func (u CheckSaleStateSuccessEffect) MustSaleUpdated() SaleUpdated {
	val, ok := u.GetSaleUpdated()

	if !ok {
		panic("arm SaleUpdated is not set")
	}

	return val
}

// GetSaleUpdated retrieves the SaleUpdated value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CheckSaleStateSuccessEffect) GetSaleUpdated() (result SaleUpdated, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Effect))

	if armName == "SaleUpdated" {
		result = *u.SaleUpdated
		ok = true
	}

	return
}

// CheckSaleStateSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//          case EMPTY_VERSION:
//            void;
//        }
//
type CheckSaleStateSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CheckSaleStateSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CheckSaleStateSuccessExt
func (u CheckSaleStateSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCheckSaleStateSuccessExt creates a new  CheckSaleStateSuccessExt.
func NewCheckSaleStateSuccessExt(v LedgerVersion, value interface{}) (result CheckSaleStateSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CheckSaleStateSuccess is an XDR Struct defines as:
//
//   //: Result of the successful application of CheckSaleState operation
//    struct CheckSaleStateSuccess
//    {
//        //: ID of the sale being checked
//        uint64 saleID;
//        //: Additional information regarding eventual result
//        union switch (CheckSaleStateEffect effect)
//        {
//        case CANCELED:
//            SaleCanceled saleCanceled;
//        case CLOSED:
//            CheckSaleClosedResult saleClosed;
//        case UPDATED:
//            SaleUpdated saleUpdated;
//        }
//        effect;
//         //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//          case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CheckSaleStateSuccess struct {
	SaleId Uint64                      `json:"saleID,omitempty"`
	Effect CheckSaleStateSuccessEffect `json:"effect,omitempty"`
	Ext    CheckSaleStateSuccessExt    `json:"ext,omitempty"`
}

// CheckSaleStateResult is an XDR Union defines as:
//
//   //: Result of the CheckSaleState operation along with the result code
//    union CheckSaleStateResult switch (CheckSaleStateResultCode code)
//    {
//    case SUCCESS:
//        CheckSaleStateSuccess success;
//    default:
//        void;
//    };
//
type CheckSaleStateResult struct {
	Code    CheckSaleStateResultCode `json:"code,omitempty"`
	Success *CheckSaleStateSuccess   `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CheckSaleStateResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CheckSaleStateResult
func (u CheckSaleStateResult) ArmForSwitch(sw int32) (string, bool) {
	switch CheckSaleStateResultCode(sw) {
	case CheckSaleStateResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewCheckSaleStateResult creates a new  CheckSaleStateResult.
func NewCheckSaleStateResult(code CheckSaleStateResultCode, value interface{}) (result CheckSaleStateResult, err error) {
	result.Code = code
	switch CheckSaleStateResultCode(code) {
	case CheckSaleStateResultCodeSuccess:
		tv, ok := value.(CheckSaleStateSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CheckSaleStateSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CheckSaleStateResult) MustSuccess() CheckSaleStateSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CheckSaleStateResult) GetSuccess() (result CheckSaleStateSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// CloseSwapOp is an XDR Struct defines as:
//
//   struct CloseSwapOp
//    {
//        //: ID of the swap to close
//        uint64 swapID;
//        //: (optional) Secret of the swap. Must be provided in order for destination of the swap to receive funds
//        Hash* secret;
//
//        //: reserved for future extension
//        EmptyExt ext;
//    };
//
type CloseSwapOp struct {
	SwapId Uint64   `json:"swapID,omitempty"`
	Secret *Hash    `json:"secret,omitempty"`
	Ext    EmptyExt `json:"ext,omitempty"`
}

// CloseSwapResultCode is an XDR Enum defines as:
//
//   enum CloseSwapResultCode
//    {
//        //: CloseSwap was successful
//        SUCCESS = 0,
//        //: Too late to close swap
//        SWAP_EXPIRED = -1,
//        //: Provided secret is invalid
//        INVALID_SECRET = -2,
//        //: After the swap fulfillment, the destination balance will exceed the limit (total amount on the balance will be greater than UINT64_MAX)
//        LINE_FULL = -3,
//        //: Source account is not authorized to close swap
//        NOT_AUTHORIZED = -4
//    };
//
type CloseSwapResultCode int32

const (
	CloseSwapResultCodeSuccess       CloseSwapResultCode = 0
	CloseSwapResultCodeSwapExpired   CloseSwapResultCode = -1
	CloseSwapResultCodeInvalidSecret CloseSwapResultCode = -2
	CloseSwapResultCodeLineFull      CloseSwapResultCode = -3
	CloseSwapResultCodeNotAuthorized CloseSwapResultCode = -4
)

var CloseSwapResultCodeAll = []CloseSwapResultCode{
	CloseSwapResultCodeSuccess,
	CloseSwapResultCodeSwapExpired,
	CloseSwapResultCodeInvalidSecret,
	CloseSwapResultCodeLineFull,
	CloseSwapResultCodeNotAuthorized,
}

var closeSwapResultCodeMap = map[int32]string{
	0:  "CloseSwapResultCodeSuccess",
	-1: "CloseSwapResultCodeSwapExpired",
	-2: "CloseSwapResultCodeInvalidSecret",
	-3: "CloseSwapResultCodeLineFull",
	-4: "CloseSwapResultCodeNotAuthorized",
}

var closeSwapResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "swap_expired",
	-2: "invalid_secret",
	-3: "line_full",
	-4: "not_authorized",
}

var closeSwapResultCodeRevMap = map[string]int32{
	"CloseSwapResultCodeSuccess":       0,
	"CloseSwapResultCodeSwapExpired":   -1,
	"CloseSwapResultCodeInvalidSecret": -2,
	"CloseSwapResultCodeLineFull":      -3,
	"CloseSwapResultCodeNotAuthorized": -4,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CloseSwapResultCode
func (e CloseSwapResultCode) ValidEnum(v int32) bool {
	_, ok := closeSwapResultCodeMap[v]
	return ok
}
func (e CloseSwapResultCode) isFlag() bool {
	for i := len(CloseSwapResultCodeAll) - 1; i >= 0; i-- {
		expected := CloseSwapResultCode(2) << uint64(len(CloseSwapResultCodeAll)-1) >> uint64(len(CloseSwapResultCodeAll)-i)
		if expected != CloseSwapResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CloseSwapResultCode) String() string {
	name, _ := closeSwapResultCodeMap[int32(e)]
	return name
}

func (e CloseSwapResultCode) ShortString() string {
	name, _ := closeSwapResultCodeShortMap[int32(e)]
	return name
}

func (e CloseSwapResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CloseSwapResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CloseSwapResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CloseSwapResultCode(t.Value)
	return nil
}

// CloseSwapEffect is an XDR Enum defines as:
//
//   enum CloseSwapEffect
//    {
//        //: Swap closed
//        CLOSED = 0,
//        //: Swap cancelled
//        CANCELLED = 1
//    };
//
type CloseSwapEffect int32

const (
	CloseSwapEffectClosed    CloseSwapEffect = 0
	CloseSwapEffectCancelled CloseSwapEffect = 1
)

var CloseSwapEffectAll = []CloseSwapEffect{
	CloseSwapEffectClosed,
	CloseSwapEffectCancelled,
}

var closeSwapEffectMap = map[int32]string{
	0: "CloseSwapEffectClosed",
	1: "CloseSwapEffectCancelled",
}

var closeSwapEffectShortMap = map[int32]string{
	0: "closed",
	1: "cancelled",
}

var closeSwapEffectRevMap = map[string]int32{
	"CloseSwapEffectClosed":    0,
	"CloseSwapEffectCancelled": 1,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CloseSwapEffect
func (e CloseSwapEffect) ValidEnum(v int32) bool {
	_, ok := closeSwapEffectMap[v]
	return ok
}
func (e CloseSwapEffect) isFlag() bool {
	for i := len(CloseSwapEffectAll) - 1; i >= 0; i-- {
		expected := CloseSwapEffect(2) << uint64(len(CloseSwapEffectAll)-1) >> uint64(len(CloseSwapEffectAll)-i)
		if expected != CloseSwapEffectAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CloseSwapEffect) String() string {
	name, _ := closeSwapEffectMap[int32(e)]
	return name
}

func (e CloseSwapEffect) ShortString() string {
	name, _ := closeSwapEffectShortMap[int32(e)]
	return name
}

func (e CloseSwapEffect) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CloseSwapEffectAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CloseSwapEffect) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CloseSwapEffect(t.Value)
	return nil
}

// CloseSwapSuccess is an XDR Struct defines as:
//
//   //: CloseSwapSuccess is used to pass saved ledger hash and license hash
//    struct CloseSwapSuccess {
//        //: Effect of CloseSwap application
//        CloseSwapEffect effect;
//
//        EmptyExt ext;
//    };
//
type CloseSwapSuccess struct {
	Effect CloseSwapEffect `json:"effect,omitempty"`
	Ext    EmptyExt        `json:"ext,omitempty"`
}

// CloseSwapResult is an XDR Union defines as:
//
//   //: CloseSwapResult is a result of CloseSwap operation application
//    union CloseSwapResult switch (CloseSwapResultCode code)
//    {
//    case SUCCESS:
//        CloseSwapSuccess success;
//    default:
//        void;
//    };
//
type CloseSwapResult struct {
	Code    CloseSwapResultCode `json:"code,omitempty"`
	Success *CloseSwapSuccess   `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CloseSwapResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CloseSwapResult
func (u CloseSwapResult) ArmForSwitch(sw int32) (string, bool) {
	switch CloseSwapResultCode(sw) {
	case CloseSwapResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewCloseSwapResult creates a new  CloseSwapResult.
func NewCloseSwapResult(code CloseSwapResultCode, value interface{}) (result CloseSwapResult, err error) {
	result.Code = code
	switch CloseSwapResultCode(code) {
	case CloseSwapResultCodeSuccess:
		tv, ok := value.(CloseSwapSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CloseSwapSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CloseSwapResult) MustSuccess() CloseSwapSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CloseSwapResult) GetSuccess() (result CloseSwapSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// CreateAmlAlertRequestOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateAmlAlertRequestOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateAmlAlertRequestOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateAmlAlertRequestOpExt
func (u CreateAmlAlertRequestOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateAmlAlertRequestOpExt creates a new  CreateAmlAlertRequestOpExt.
func NewCreateAmlAlertRequestOpExt(v LedgerVersion, value interface{}) (result CreateAmlAlertRequestOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateAmlAlertRequestOp is an XDR Struct defines as:
//
//   //: CreateAMLAlertRequest operation creates a reviewable request
//    //: that will void the specified amount from target balance after the reviewer's approval
//    struct CreateAMLAlertRequestOp
//    {
//        //: Reference of AMLAlertRequest
//        string64 reference; // TODO longstring ?
//        //: Parameters of AMLAlertRequest
//        AMLAlertRequest amlAlertRequest;
//        //: (optional) Bit mask whose flags must be cleared in order for AMLAlertRequest to be approved, which will be used by key aml_alert_tasks:<asset_code>
//        //: instead of key-value
//        uint32* allTasks;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//
//    };
//
type CreateAmlAlertRequestOp struct {
	Reference       String64                   `json:"reference,omitempty"`
	AmlAlertRequest AmlAlertRequest            `json:"amlAlertRequest,omitempty"`
	AllTasks        *Uint32                    `json:"allTasks,omitempty"`
	Ext             CreateAmlAlertRequestOpExt `json:"ext,omitempty"`
}

// CreateAmlAlertRequestResultCode is an XDR Enum defines as:
//
//   //: Result codes for CreateAMLAlert operation
//    enum CreateAMLAlertRequestResultCode
//    {
//        // codes considered as "success" for the operation
//        //: Operation has been successfully performed
//        SUCCESS = 0,
//        //: DEPRECATED: Balance with provided balance ID does not exist
//        OLD_BALANCE_NOT_EXIST = 1, // balance doesn't exist
//        //: DEPRECATED: Creator details are not in a valid JSON format
//        OLD_INVALID_CREATOR_DETAILS = 2, //invalid reason for request
//        //: DEPRECATED: Specified amount is greater than the amount on the balance
//        OLD_UNDERFUNDED = 3, //when couldn't lock balance
//        //: DEPRECATED: AML Alert request with the same reference already exists
//        OLD_REFERENCE_DUPLICATION = 4, // reference already exists
//        //: DEPRECATED: Amount must be positive
//        OLD_INVALID_AMOUNT = 5, // amount must be positive
//        //: DEPRECATED: Amount precision and asset precision set in the system are mismatched
//        OLD_INCORRECT_PRECISION = 6,
//
//        //codes considered as "failure" for the operation
//        //: Update aml alert tasks are not set in the system, i.e. it's not allowed to perform aml alert
//        AML_ALERT_TASKS_NOT_FOUND = -1,
//        //: Balance with provided balance ID does not exist
//        BALANCE_NOT_EXIST = -2, // balance doesn't exist
//        //: Creator details are not in a valid JSON format
//        INVALID_CREATOR_DETAILS = -3, //invalid reason for request
//        //: Specified amount is greater than the amount on the balance
//        UNDERFUNDED = -4, //when couldn't lock balance
//        //: AML Alert request with the same reference already exists
//        REFERENCE_DUPLICATION = -5, // reference already exists
//        //: Amount must be positive
//        INVALID_AMOUNT = -6, // amount must be positive
//        //: Amount precision and asset precision set in the system are mismatched
//        INCORRECT_PRECISION = -7
//
//    };
//
type CreateAmlAlertRequestResultCode int32

const (
	CreateAmlAlertRequestResultCodeSuccess                  CreateAmlAlertRequestResultCode = 0
	CreateAmlAlertRequestResultCodeOldBalanceNotExist       CreateAmlAlertRequestResultCode = 1
	CreateAmlAlertRequestResultCodeOldInvalidCreatorDetails CreateAmlAlertRequestResultCode = 2
	CreateAmlAlertRequestResultCodeOldUnderfunded           CreateAmlAlertRequestResultCode = 3
	CreateAmlAlertRequestResultCodeOldReferenceDuplication  CreateAmlAlertRequestResultCode = 4
	CreateAmlAlertRequestResultCodeOldInvalidAmount         CreateAmlAlertRequestResultCode = 5
	CreateAmlAlertRequestResultCodeOldIncorrectPrecision    CreateAmlAlertRequestResultCode = 6
	CreateAmlAlertRequestResultCodeAmlAlertTasksNotFound    CreateAmlAlertRequestResultCode = -1
	CreateAmlAlertRequestResultCodeBalanceNotExist          CreateAmlAlertRequestResultCode = -2
	CreateAmlAlertRequestResultCodeInvalidCreatorDetails    CreateAmlAlertRequestResultCode = -3
	CreateAmlAlertRequestResultCodeUnderfunded              CreateAmlAlertRequestResultCode = -4
	CreateAmlAlertRequestResultCodeReferenceDuplication     CreateAmlAlertRequestResultCode = -5
	CreateAmlAlertRequestResultCodeInvalidAmount            CreateAmlAlertRequestResultCode = -6
	CreateAmlAlertRequestResultCodeIncorrectPrecision       CreateAmlAlertRequestResultCode = -7
)

var CreateAmlAlertRequestResultCodeAll = []CreateAmlAlertRequestResultCode{
	CreateAmlAlertRequestResultCodeSuccess,
	CreateAmlAlertRequestResultCodeOldBalanceNotExist,
	CreateAmlAlertRequestResultCodeOldInvalidCreatorDetails,
	CreateAmlAlertRequestResultCodeOldUnderfunded,
	CreateAmlAlertRequestResultCodeOldReferenceDuplication,
	CreateAmlAlertRequestResultCodeOldInvalidAmount,
	CreateAmlAlertRequestResultCodeOldIncorrectPrecision,
	CreateAmlAlertRequestResultCodeAmlAlertTasksNotFound,
	CreateAmlAlertRequestResultCodeBalanceNotExist,
	CreateAmlAlertRequestResultCodeInvalidCreatorDetails,
	CreateAmlAlertRequestResultCodeUnderfunded,
	CreateAmlAlertRequestResultCodeReferenceDuplication,
	CreateAmlAlertRequestResultCodeInvalidAmount,
	CreateAmlAlertRequestResultCodeIncorrectPrecision,
}

var createAmlAlertRequestResultCodeMap = map[int32]string{
	0:  "CreateAmlAlertRequestResultCodeSuccess",
	1:  "CreateAmlAlertRequestResultCodeOldBalanceNotExist",
	2:  "CreateAmlAlertRequestResultCodeOldInvalidCreatorDetails",
	3:  "CreateAmlAlertRequestResultCodeOldUnderfunded",
	4:  "CreateAmlAlertRequestResultCodeOldReferenceDuplication",
	5:  "CreateAmlAlertRequestResultCodeOldInvalidAmount",
	6:  "CreateAmlAlertRequestResultCodeOldIncorrectPrecision",
	-1: "CreateAmlAlertRequestResultCodeAmlAlertTasksNotFound",
	-2: "CreateAmlAlertRequestResultCodeBalanceNotExist",
	-3: "CreateAmlAlertRequestResultCodeInvalidCreatorDetails",
	-4: "CreateAmlAlertRequestResultCodeUnderfunded",
	-5: "CreateAmlAlertRequestResultCodeReferenceDuplication",
	-6: "CreateAmlAlertRequestResultCodeInvalidAmount",
	-7: "CreateAmlAlertRequestResultCodeIncorrectPrecision",
}

var createAmlAlertRequestResultCodeShortMap = map[int32]string{
	0:  "success",
	1:  "old_balance_not_exist",
	2:  "old_invalid_creator_details",
	3:  "old_underfunded",
	4:  "old_reference_duplication",
	5:  "old_invalid_amount",
	6:  "old_incorrect_precision",
	-1: "aml_alert_tasks_not_found",
	-2: "balance_not_exist",
	-3: "invalid_creator_details",
	-4: "underfunded",
	-5: "reference_duplication",
	-6: "invalid_amount",
	-7: "incorrect_precision",
}

var createAmlAlertRequestResultCodeRevMap = map[string]int32{
	"CreateAmlAlertRequestResultCodeSuccess":                  0,
	"CreateAmlAlertRequestResultCodeOldBalanceNotExist":       1,
	"CreateAmlAlertRequestResultCodeOldInvalidCreatorDetails": 2,
	"CreateAmlAlertRequestResultCodeOldUnderfunded":           3,
	"CreateAmlAlertRequestResultCodeOldReferenceDuplication":  4,
	"CreateAmlAlertRequestResultCodeOldInvalidAmount":         5,
	"CreateAmlAlertRequestResultCodeOldIncorrectPrecision":    6,
	"CreateAmlAlertRequestResultCodeAmlAlertTasksNotFound":    -1,
	"CreateAmlAlertRequestResultCodeBalanceNotExist":          -2,
	"CreateAmlAlertRequestResultCodeInvalidCreatorDetails":    -3,
	"CreateAmlAlertRequestResultCodeUnderfunded":              -4,
	"CreateAmlAlertRequestResultCodeReferenceDuplication":     -5,
	"CreateAmlAlertRequestResultCodeInvalidAmount":            -6,
	"CreateAmlAlertRequestResultCodeIncorrectPrecision":       -7,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CreateAmlAlertRequestResultCode
func (e CreateAmlAlertRequestResultCode) ValidEnum(v int32) bool {
	_, ok := createAmlAlertRequestResultCodeMap[v]
	return ok
}
func (e CreateAmlAlertRequestResultCode) isFlag() bool {
	for i := len(CreateAmlAlertRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := CreateAmlAlertRequestResultCode(2) << uint64(len(CreateAmlAlertRequestResultCodeAll)-1) >> uint64(len(CreateAmlAlertRequestResultCodeAll)-i)
		if expected != CreateAmlAlertRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CreateAmlAlertRequestResultCode) String() string {
	name, _ := createAmlAlertRequestResultCodeMap[int32(e)]
	return name
}

func (e CreateAmlAlertRequestResultCode) ShortString() string {
	name, _ := createAmlAlertRequestResultCodeShortMap[int32(e)]
	return name
}

func (e CreateAmlAlertRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CreateAmlAlertRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CreateAmlAlertRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CreateAmlAlertRequestResultCode(t.Value)
	return nil
}

// CreateAmlAlertRequestSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateAmlAlertRequestSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateAmlAlertRequestSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateAmlAlertRequestSuccessExt
func (u CreateAmlAlertRequestSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateAmlAlertRequestSuccessExt creates a new  CreateAmlAlertRequestSuccessExt.
func NewCreateAmlAlertRequestSuccessExt(v LedgerVersion, value interface{}) (result CreateAmlAlertRequestSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateAmlAlertRequestSuccess is an XDR Struct defines as:
//
//   //: Result of successful application of `CreateAMLAlertRequest` operation
//    struct CreateAMLAlertRequestSuccess {
//        //: ID of a newly created reviewable request
//        uint64 requestID;
//        //: Indicates  whether or not the AMLAlert request was auto approved and fulfilled
//        bool fulfilled;
//        //: Reserved for future use
//         union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CreateAmlAlertRequestSuccess struct {
	RequestId Uint64                          `json:"requestID,omitempty"`
	Fulfilled bool                            `json:"fulfilled,omitempty"`
	Ext       CreateAmlAlertRequestSuccessExt `json:"ext,omitempty"`
}

// CreateAmlAlertRequestResult is an XDR Union defines as:
//
//   //: Result of `CreateAMLAlertRequest` operation application along with the result code
//    union CreateAMLAlertRequestResult switch (CreateAMLAlertRequestResultCode code)
//    {
//        case SUCCESS:
//            CreateAMLAlertRequestSuccess success;
//        default:
//            void;
//    };
//
type CreateAmlAlertRequestResult struct {
	Code    CreateAmlAlertRequestResultCode `json:"code,omitempty"`
	Success *CreateAmlAlertRequestSuccess   `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateAmlAlertRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateAmlAlertRequestResult
func (u CreateAmlAlertRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch CreateAmlAlertRequestResultCode(sw) {
	case CreateAmlAlertRequestResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewCreateAmlAlertRequestResult creates a new  CreateAmlAlertRequestResult.
func NewCreateAmlAlertRequestResult(code CreateAmlAlertRequestResultCode, value interface{}) (result CreateAmlAlertRequestResult, err error) {
	result.Code = code
	switch CreateAmlAlertRequestResultCode(code) {
	case CreateAmlAlertRequestResultCodeSuccess:
		tv, ok := value.(CreateAmlAlertRequestSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateAmlAlertRequestSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CreateAmlAlertRequestResult) MustSuccess() CreateAmlAlertRequestSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CreateAmlAlertRequestResult) GetSuccess() (result CreateAmlAlertRequestSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// CreateAccountOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateAccountOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateAccountOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateAccountOpExt
func (u CreateAccountOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateAccountOpExt creates a new  CreateAccountOpExt.
func NewCreateAccountOpExt(v LedgerVersion, value interface{}) (result CreateAccountOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateAccountOp is an XDR Struct defines as:
//
//   //: CreateAccountOp is used to create new account
//    struct CreateAccountOp
//    {
//        //: ID of account to be created
//        AccountID destination;
//        //: ID of an another account that introduced this account into the system.
//        //: If account with such ID does not exist or it's Admin Account. Referrer won't be set.
//        AccountID* referrer;
//        //: ID of the role that will be attached to an account
//        uint64 roleID;
//
//        //: Array of data about 'destination' account signers to be created
//        UpdateSignerData signersData<>;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CreateAccountOp struct {
	Destination AccountId          `json:"destination,omitempty"`
	Referrer    *AccountId         `json:"referrer,omitempty"`
	RoleId      Uint64             `json:"roleID,omitempty"`
	SignersData []UpdateSignerData `json:"signersData,omitempty"`
	Ext         CreateAccountOpExt `json:"ext,omitempty"`
}

// CreateAccountResultCode is an XDR Enum defines as:
//
//   //: Result codes of CreateAccountOp
//    enum CreateAccountResultCode
//    {
//        //: Means that `destination` account has been successfully created with signers specified in `signersData`
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: Source account cannot be the same as the destination account
//        INVALID_DESTINATION = -1,
//        //: Account with such an ID already exists
//        ALREADY_EXISTS = -2, // account already exist
//        //: Sum of weights of signers with different identities must exceed the threshold (for now, 1000)
//        INVALID_WEIGHT = -3,
//        //: There is no role with such an ID
//        NO_SUCH_ROLE = -4,
//        //: Creation of a signer for an account is failed because `signersData` is invalid.
//        //: See `createSignerErrorCode`
//        INVALID_SIGNER_DATA = -5,
//        //: It is not allowed to create accounts without signers
//        NO_SIGNER_DATA = -6 // empty signer data array not allowed
//    };
//
type CreateAccountResultCode int32

const (
	CreateAccountResultCodeSuccess            CreateAccountResultCode = 0
	CreateAccountResultCodeInvalidDestination CreateAccountResultCode = -1
	CreateAccountResultCodeAlreadyExists      CreateAccountResultCode = -2
	CreateAccountResultCodeInvalidWeight      CreateAccountResultCode = -3
	CreateAccountResultCodeNoSuchRole         CreateAccountResultCode = -4
	CreateAccountResultCodeInvalidSignerData  CreateAccountResultCode = -5
	CreateAccountResultCodeNoSignerData       CreateAccountResultCode = -6
)

var CreateAccountResultCodeAll = []CreateAccountResultCode{
	CreateAccountResultCodeSuccess,
	CreateAccountResultCodeInvalidDestination,
	CreateAccountResultCodeAlreadyExists,
	CreateAccountResultCodeInvalidWeight,
	CreateAccountResultCodeNoSuchRole,
	CreateAccountResultCodeInvalidSignerData,
	CreateAccountResultCodeNoSignerData,
}

var createAccountResultCodeMap = map[int32]string{
	0:  "CreateAccountResultCodeSuccess",
	-1: "CreateAccountResultCodeInvalidDestination",
	-2: "CreateAccountResultCodeAlreadyExists",
	-3: "CreateAccountResultCodeInvalidWeight",
	-4: "CreateAccountResultCodeNoSuchRole",
	-5: "CreateAccountResultCodeInvalidSignerData",
	-6: "CreateAccountResultCodeNoSignerData",
}

var createAccountResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "invalid_destination",
	-2: "already_exists",
	-3: "invalid_weight",
	-4: "no_such_role",
	-5: "invalid_signer_data",
	-6: "no_signer_data",
}

var createAccountResultCodeRevMap = map[string]int32{
	"CreateAccountResultCodeSuccess":            0,
	"CreateAccountResultCodeInvalidDestination": -1,
	"CreateAccountResultCodeAlreadyExists":      -2,
	"CreateAccountResultCodeInvalidWeight":      -3,
	"CreateAccountResultCodeNoSuchRole":         -4,
	"CreateAccountResultCodeInvalidSignerData":  -5,
	"CreateAccountResultCodeNoSignerData":       -6,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CreateAccountResultCode
func (e CreateAccountResultCode) ValidEnum(v int32) bool {
	_, ok := createAccountResultCodeMap[v]
	return ok
}
func (e CreateAccountResultCode) isFlag() bool {
	for i := len(CreateAccountResultCodeAll) - 1; i >= 0; i-- {
		expected := CreateAccountResultCode(2) << uint64(len(CreateAccountResultCodeAll)-1) >> uint64(len(CreateAccountResultCodeAll)-i)
		if expected != CreateAccountResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CreateAccountResultCode) String() string {
	name, _ := createAccountResultCodeMap[int32(e)]
	return name
}

func (e CreateAccountResultCode) ShortString() string {
	name, _ := createAccountResultCodeShortMap[int32(e)]
	return name
}

func (e CreateAccountResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CreateAccountResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CreateAccountResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CreateAccountResultCode(t.Value)
	return nil
}

// CreateAccountSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateAccountSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateAccountSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateAccountSuccessExt
func (u CreateAccountSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateAccountSuccessExt creates a new  CreateAccountSuccessExt.
func NewCreateAccountSuccessExt(v LedgerVersion, value interface{}) (result CreateAccountSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateAccountSuccess is an XDR Struct defines as:
//
//   //: Result of successful application of `CreateAccount` operation
//    struct CreateAccountSuccess
//    {
//        //: Unique unsigned integer identifier of the new account
//        uint64 sequentialID;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CreateAccountSuccess struct {
	SequentialId Uint64                  `json:"sequentialID,omitempty"`
	Ext          CreateAccountSuccessExt `json:"ext,omitempty"`
}

// CreateAccountResult is an XDR Union defines as:
//
//   //: Result of operation application
//    union CreateAccountResult switch (CreateAccountResultCode code)
//    {
//    case SUCCESS:
//        CreateAccountSuccess success;
//    case INVALID_SIGNER_DATA:
//        //: `createSignerErrorCode` is used to determine the reason of signer creation failure
//        ManageSignerResultCode createSignerErrorCode;
//    default:
//        void;
//    };
//
type CreateAccountResult struct {
	Code                  CreateAccountResultCode `json:"code,omitempty"`
	Success               *CreateAccountSuccess   `json:"success,omitempty"`
	CreateSignerErrorCode *ManageSignerResultCode `json:"createSignerErrorCode,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateAccountResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateAccountResult
func (u CreateAccountResult) ArmForSwitch(sw int32) (string, bool) {
	switch CreateAccountResultCode(sw) {
	case CreateAccountResultCodeSuccess:
		return "Success", true
	case CreateAccountResultCodeInvalidSignerData:
		return "CreateSignerErrorCode", true
	default:
		return "", true
	}
}

// NewCreateAccountResult creates a new  CreateAccountResult.
func NewCreateAccountResult(code CreateAccountResultCode, value interface{}) (result CreateAccountResult, err error) {
	result.Code = code
	switch CreateAccountResultCode(code) {
	case CreateAccountResultCodeSuccess:
		tv, ok := value.(CreateAccountSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateAccountSuccess")
			return
		}
		result.Success = &tv
	case CreateAccountResultCodeInvalidSignerData:
		tv, ok := value.(ManageSignerResultCode)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageSignerResultCode")
			return
		}
		result.CreateSignerErrorCode = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CreateAccountResult) MustSuccess() CreateAccountSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CreateAccountResult) GetSuccess() (result CreateAccountSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// MustCreateSignerErrorCode retrieves the CreateSignerErrorCode value from the union,
// panicing if the value is not set.
func (u CreateAccountResult) MustCreateSignerErrorCode() ManageSignerResultCode {
	val, ok := u.GetCreateSignerErrorCode()

	if !ok {
		panic("arm CreateSignerErrorCode is not set")
	}

	return val
}

// GetCreateSignerErrorCode retrieves the CreateSignerErrorCode value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CreateAccountResult) GetCreateSignerErrorCode() (result ManageSignerResultCode, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "CreateSignerErrorCode" {
		result = *u.CreateSignerErrorCode
		ok = true
	}

	return
}

// CreateAtomicSwapAskRequestOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateAtomicSwapAskRequestOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateAtomicSwapAskRequestOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateAtomicSwapAskRequestOpExt
func (u CreateAtomicSwapAskRequestOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateAtomicSwapAskRequestOpExt creates a new  CreateAtomicSwapAskRequestOpExt.
func NewCreateAtomicSwapAskRequestOpExt(v LedgerVersion, value interface{}) (result CreateAtomicSwapAskRequestOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateAtomicSwapAskRequestOp is an XDR Struct defines as:
//
//   //: CreateAtomicSwapAskRequestOp is used to create `CREATE_ATOMIC_SWAP_ASK` request
//    struct CreateAtomicSwapAskRequestOp
//    {
//        //: Body of request which will be created
//        CreateAtomicSwapAskRequest request;
//
//        //: (optional) Bit mask whose flags must be cleared in order for `CREATE_ATOMIC_SWAP_BID` request to be approved,
//        //: which will be used instead of key-value by `atomic_swap_bid_tasks` key
//        uint32* allTasks;
//        //: reserved for the future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CreateAtomicSwapAskRequestOp struct {
	Request  CreateAtomicSwapAskRequest      `json:"request,omitempty"`
	AllTasks *Uint32                         `json:"allTasks,omitempty"`
	Ext      CreateAtomicSwapAskRequestOpExt `json:"ext,omitempty"`
}

// CreateAtomicSwapAskRequestResultCode is an XDR Enum defines as:
//
//   //: Result codes of CreateAtomicSwapBidRequestOp
//    enum CreateAtomicSwapAskRequestResultCode
//    {
//        //: `CREATE_ATOMIC_SWAP_BID` request has either been successfully created
//        //: or auto approved
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: Not allowed to create atomic swap bid with zero amount
//        INVALID_AMOUNT = -1, // amount is equal to 0
//        //: Not allowed to create atomic swap bid with quote asset price equals zero
//        INVALID_PRICE = -2, // price is equal to 0
//        //: Not allowed to create atomic swap bid with json invalid details
//        INVALID_DETAILS = -3,
//        //: Not allowed to create atomic swap bid in which product of baseAmount precision does not matched precision of base asset
//        INCORRECT_PRECISION = -4,
//        //: There is no asset with such code
//        BASE_ASSET_NOT_FOUND = -5, // base asset does not exist
//        //: Not allowed to use asset as base asset for atomic swap bid which has not `CAN_BE_BASE_IN_ATOMIC_SWAP` policy
//        BASE_ASSET_CANNOT_BE_SWAPPED = -6,
//        //: There is no asset with such code
//        QUOTE_ASSET_NOT_FOUND = -7, // quote asset does not exist
//        //: Not allowed to use asset as base asset for atomic swap bid which has not `CAN_BE_QUOTE_IN_ATOMIC_SWAP` policy
//        QUOTE_ASSET_CANNOT_BE_SWAPPED = -8,
//        //: There is no balance with such id and source account as owner
//        BASE_BALANCE_NOT_FOUND = -9,
//        //: Not allowed to create atomic swap bid in which base and quote assets are the same
//        ASSETS_ARE_EQUAL = -10, // base and quote assets are the same
//        //: There is not enough amount on `baseBalance` or `baseAmount` precision does not fit asset precision
//        BASE_BALANCE_UNDERFUNDED = -11,
//        //: Not allowed to pass invalid or duplicated quote asset codes
//        INVALID_QUOTE_ASSET = -12, // one of the quote assets is invalid
//        //: There is no key-value entry by `atomic_swap_ask_tasks` key in the system;
//        //: configuration does not allow create atomic swap asks
//        ATOMIC_SWAP_ASK_TASKS_NOT_FOUND = -13
//    };
//
type CreateAtomicSwapAskRequestResultCode int32

const (
	CreateAtomicSwapAskRequestResultCodeSuccess                    CreateAtomicSwapAskRequestResultCode = 0
	CreateAtomicSwapAskRequestResultCodeInvalidAmount              CreateAtomicSwapAskRequestResultCode = -1
	CreateAtomicSwapAskRequestResultCodeInvalidPrice               CreateAtomicSwapAskRequestResultCode = -2
	CreateAtomicSwapAskRequestResultCodeInvalidDetails             CreateAtomicSwapAskRequestResultCode = -3
	CreateAtomicSwapAskRequestResultCodeIncorrectPrecision         CreateAtomicSwapAskRequestResultCode = -4
	CreateAtomicSwapAskRequestResultCodeBaseAssetNotFound          CreateAtomicSwapAskRequestResultCode = -5
	CreateAtomicSwapAskRequestResultCodeBaseAssetCannotBeSwapped   CreateAtomicSwapAskRequestResultCode = -6
	CreateAtomicSwapAskRequestResultCodeQuoteAssetNotFound         CreateAtomicSwapAskRequestResultCode = -7
	CreateAtomicSwapAskRequestResultCodeQuoteAssetCannotBeSwapped  CreateAtomicSwapAskRequestResultCode = -8
	CreateAtomicSwapAskRequestResultCodeBaseBalanceNotFound        CreateAtomicSwapAskRequestResultCode = -9
	CreateAtomicSwapAskRequestResultCodeAssetsAreEqual             CreateAtomicSwapAskRequestResultCode = -10
	CreateAtomicSwapAskRequestResultCodeBaseBalanceUnderfunded     CreateAtomicSwapAskRequestResultCode = -11
	CreateAtomicSwapAskRequestResultCodeInvalidQuoteAsset          CreateAtomicSwapAskRequestResultCode = -12
	CreateAtomicSwapAskRequestResultCodeAtomicSwapAskTasksNotFound CreateAtomicSwapAskRequestResultCode = -13
)

var CreateAtomicSwapAskRequestResultCodeAll = []CreateAtomicSwapAskRequestResultCode{
	CreateAtomicSwapAskRequestResultCodeSuccess,
	CreateAtomicSwapAskRequestResultCodeInvalidAmount,
	CreateAtomicSwapAskRequestResultCodeInvalidPrice,
	CreateAtomicSwapAskRequestResultCodeInvalidDetails,
	CreateAtomicSwapAskRequestResultCodeIncorrectPrecision,
	CreateAtomicSwapAskRequestResultCodeBaseAssetNotFound,
	CreateAtomicSwapAskRequestResultCodeBaseAssetCannotBeSwapped,
	CreateAtomicSwapAskRequestResultCodeQuoteAssetNotFound,
	CreateAtomicSwapAskRequestResultCodeQuoteAssetCannotBeSwapped,
	CreateAtomicSwapAskRequestResultCodeBaseBalanceNotFound,
	CreateAtomicSwapAskRequestResultCodeAssetsAreEqual,
	CreateAtomicSwapAskRequestResultCodeBaseBalanceUnderfunded,
	CreateAtomicSwapAskRequestResultCodeInvalidQuoteAsset,
	CreateAtomicSwapAskRequestResultCodeAtomicSwapAskTasksNotFound,
}

var createAtomicSwapAskRequestResultCodeMap = map[int32]string{
	0:   "CreateAtomicSwapAskRequestResultCodeSuccess",
	-1:  "CreateAtomicSwapAskRequestResultCodeInvalidAmount",
	-2:  "CreateAtomicSwapAskRequestResultCodeInvalidPrice",
	-3:  "CreateAtomicSwapAskRequestResultCodeInvalidDetails",
	-4:  "CreateAtomicSwapAskRequestResultCodeIncorrectPrecision",
	-5:  "CreateAtomicSwapAskRequestResultCodeBaseAssetNotFound",
	-6:  "CreateAtomicSwapAskRequestResultCodeBaseAssetCannotBeSwapped",
	-7:  "CreateAtomicSwapAskRequestResultCodeQuoteAssetNotFound",
	-8:  "CreateAtomicSwapAskRequestResultCodeQuoteAssetCannotBeSwapped",
	-9:  "CreateAtomicSwapAskRequestResultCodeBaseBalanceNotFound",
	-10: "CreateAtomicSwapAskRequestResultCodeAssetsAreEqual",
	-11: "CreateAtomicSwapAskRequestResultCodeBaseBalanceUnderfunded",
	-12: "CreateAtomicSwapAskRequestResultCodeInvalidQuoteAsset",
	-13: "CreateAtomicSwapAskRequestResultCodeAtomicSwapAskTasksNotFound",
}

var createAtomicSwapAskRequestResultCodeShortMap = map[int32]string{
	0:   "success",
	-1:  "invalid_amount",
	-2:  "invalid_price",
	-3:  "invalid_details",
	-4:  "incorrect_precision",
	-5:  "base_asset_not_found",
	-6:  "base_asset_cannot_be_swapped",
	-7:  "quote_asset_not_found",
	-8:  "quote_asset_cannot_be_swapped",
	-9:  "base_balance_not_found",
	-10: "assets_are_equal",
	-11: "base_balance_underfunded",
	-12: "invalid_quote_asset",
	-13: "atomic_swap_ask_tasks_not_found",
}

var createAtomicSwapAskRequestResultCodeRevMap = map[string]int32{
	"CreateAtomicSwapAskRequestResultCodeSuccess":                    0,
	"CreateAtomicSwapAskRequestResultCodeInvalidAmount":              -1,
	"CreateAtomicSwapAskRequestResultCodeInvalidPrice":               -2,
	"CreateAtomicSwapAskRequestResultCodeInvalidDetails":             -3,
	"CreateAtomicSwapAskRequestResultCodeIncorrectPrecision":         -4,
	"CreateAtomicSwapAskRequestResultCodeBaseAssetNotFound":          -5,
	"CreateAtomicSwapAskRequestResultCodeBaseAssetCannotBeSwapped":   -6,
	"CreateAtomicSwapAskRequestResultCodeQuoteAssetNotFound":         -7,
	"CreateAtomicSwapAskRequestResultCodeQuoteAssetCannotBeSwapped":  -8,
	"CreateAtomicSwapAskRequestResultCodeBaseBalanceNotFound":        -9,
	"CreateAtomicSwapAskRequestResultCodeAssetsAreEqual":             -10,
	"CreateAtomicSwapAskRequestResultCodeBaseBalanceUnderfunded":     -11,
	"CreateAtomicSwapAskRequestResultCodeInvalidQuoteAsset":          -12,
	"CreateAtomicSwapAskRequestResultCodeAtomicSwapAskTasksNotFound": -13,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CreateAtomicSwapAskRequestResultCode
func (e CreateAtomicSwapAskRequestResultCode) ValidEnum(v int32) bool {
	_, ok := createAtomicSwapAskRequestResultCodeMap[v]
	return ok
}
func (e CreateAtomicSwapAskRequestResultCode) isFlag() bool {
	for i := len(CreateAtomicSwapAskRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := CreateAtomicSwapAskRequestResultCode(2) << uint64(len(CreateAtomicSwapAskRequestResultCodeAll)-1) >> uint64(len(CreateAtomicSwapAskRequestResultCodeAll)-i)
		if expected != CreateAtomicSwapAskRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CreateAtomicSwapAskRequestResultCode) String() string {
	name, _ := createAtomicSwapAskRequestResultCodeMap[int32(e)]
	return name
}

func (e CreateAtomicSwapAskRequestResultCode) ShortString() string {
	name, _ := createAtomicSwapAskRequestResultCodeShortMap[int32(e)]
	return name
}

func (e CreateAtomicSwapAskRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CreateAtomicSwapAskRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CreateAtomicSwapAskRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CreateAtomicSwapAskRequestResultCode(t.Value)
	return nil
}

// CreateAtomicSwapAskRequestSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateAtomicSwapAskRequestSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateAtomicSwapAskRequestSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateAtomicSwapAskRequestSuccessExt
func (u CreateAtomicSwapAskRequestSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateAtomicSwapAskRequestSuccessExt creates a new  CreateAtomicSwapAskRequestSuccessExt.
func NewCreateAtomicSwapAskRequestSuccessExt(v LedgerVersion, value interface{}) (result CreateAtomicSwapAskRequestSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateAtomicSwapAskRequestSuccess is an XDR Struct defines as:
//
//   //: Success result of CreateASwapAskCreationRequestOp application
//    struct CreateAtomicSwapAskRequestSuccess
//    {
//        //: id of created request
//        uint64 requestID;
//        //: Indicates whether or not the `CREATE_ATOMIC_SWAP_ASK` request was auto approved and fulfilled
//        bool fulfilled;
//        //: ID of a newly created ask (if the ask  creation request has been auto approved)
//        uint64 askID;
//
//        //: reserved for the future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type CreateAtomicSwapAskRequestSuccess struct {
	RequestId Uint64                               `json:"requestID,omitempty"`
	Fulfilled bool                                 `json:"fulfilled,omitempty"`
	AskId     Uint64                               `json:"askID,omitempty"`
	Ext       CreateAtomicSwapAskRequestSuccessExt `json:"ext,omitempty"`
}

// CreateAtomicSwapAskRequestResult is an XDR Union defines as:
//
//   //: Result of CreateAtomicSwapAskRequestOp application
//    union CreateAtomicSwapAskRequestResult switch (CreateAtomicSwapAskRequestResultCode code)
//    {
//    case SUCCESS:
//        //: is used to pass useful fields after successful operation applying
//        CreateAtomicSwapAskRequestSuccess success;
//    default:
//        void;
//    };
//
type CreateAtomicSwapAskRequestResult struct {
	Code    CreateAtomicSwapAskRequestResultCode `json:"code,omitempty"`
	Success *CreateAtomicSwapAskRequestSuccess   `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateAtomicSwapAskRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateAtomicSwapAskRequestResult
func (u CreateAtomicSwapAskRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch CreateAtomicSwapAskRequestResultCode(sw) {
	case CreateAtomicSwapAskRequestResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewCreateAtomicSwapAskRequestResult creates a new  CreateAtomicSwapAskRequestResult.
func NewCreateAtomicSwapAskRequestResult(code CreateAtomicSwapAskRequestResultCode, value interface{}) (result CreateAtomicSwapAskRequestResult, err error) {
	result.Code = code
	switch CreateAtomicSwapAskRequestResultCode(code) {
	case CreateAtomicSwapAskRequestResultCodeSuccess:
		tv, ok := value.(CreateAtomicSwapAskRequestSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateAtomicSwapAskRequestSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CreateAtomicSwapAskRequestResult) MustSuccess() CreateAtomicSwapAskRequestSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CreateAtomicSwapAskRequestResult) GetSuccess() (result CreateAtomicSwapAskRequestSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// CreateAtomicSwapBidRequestOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateAtomicSwapBidRequestOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateAtomicSwapBidRequestOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateAtomicSwapBidRequestOpExt
func (u CreateAtomicSwapBidRequestOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateAtomicSwapBidRequestOpExt creates a new  CreateAtomicSwapBidRequestOpExt.
func NewCreateAtomicSwapBidRequestOpExt(v LedgerVersion, value interface{}) (result CreateAtomicSwapBidRequestOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateAtomicSwapBidRequestOp is an XDR Struct defines as:
//
//   //: CreateAtomicSwapBidRequestOp is used to create `CREATE_ATOMIC_SWAP_BID` request
//    struct CreateAtomicSwapBidRequestOp
//    {
//        //: Body of request which will be created
//        CreateAtomicSwapBidRequest request;
//
//        //: reserved for the future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type CreateAtomicSwapBidRequestOp struct {
	Request CreateAtomicSwapBidRequest      `json:"request,omitempty"`
	Ext     CreateAtomicSwapBidRequestOpExt `json:"ext,omitempty"`
}

// CreateAtomicSwapBidRequestResultCode is an XDR Enum defines as:
//
//   //: Result codes of CreateAtomicSwapBidRequestOp
//    enum CreateAtomicSwapBidRequestResultCode
//    {
//        //: request was successfully created
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: Not allowed to create `CREATE_ATOMIC_SWAP` request with zero base amount
//        INVALID_BASE_AMOUNT = -1,
//        //: Not allowed to pass invalid quote asset code
//        INVALID_QUOTE_ASSET = -2,
//        //: There is no atomic swap bid with such id
//        ASK_NOT_FOUND = -3,
//        //: There is no quote asset with such code
//        QUOTE_ASSET_NOT_FOUND = -4,
//        //: Not allowed to create `CREATE_ATOMIC_SWAP_BID` request with amount which exceeds available amount of atomic swap ask
//        ASK_UNDERFUNDED = -5, // ask has not enough base amount available for lock
//        //: There is no key-value entry by `atomic_swap_bid_tasks` key in the system;
//        //: configuration does not allow create `CREATE_ATOMIC_SWAP_BID` request
//        ATOMIC_SWAP_BID_TASKS_NOT_FOUND = -6,
//        //: Base amount precision and asset precision are mismatched
//        INCORRECT_PRECISION = -7,
//        //: Not allowed to create `CREATE_ATOMIC_SWAP_BID` request for atomic swap ask which is marked as `canceled`
//        ASK_IS_CANCELLED = -8,
//        //: Not allowed to create `CREATE_ATOMIC_SWAP_BID` request for own atomic swap ask
//        SOURCE_ACCOUNT_EQUALS_ASK_OWNER = -9,
//        //: 0 value is received from key value entry by `atomic_swap_bid_tasks` key
//        ATOMIC_SWAP_BID_ZERO_TASKS_NOT_ALLOWED = -10,
//        //: Not allowed to create atomic swap ask in which product of `baseAmount` and price of the `quoteAsset` exceeds MAX_INT64 value
//        QUOTE_AMOUNT_OVERFLOWS = -11
//    };
//
type CreateAtomicSwapBidRequestResultCode int32

const (
	CreateAtomicSwapBidRequestResultCodeSuccess                          CreateAtomicSwapBidRequestResultCode = 0
	CreateAtomicSwapBidRequestResultCodeInvalidBaseAmount                CreateAtomicSwapBidRequestResultCode = -1
	CreateAtomicSwapBidRequestResultCodeInvalidQuoteAsset                CreateAtomicSwapBidRequestResultCode = -2
	CreateAtomicSwapBidRequestResultCodeAskNotFound                      CreateAtomicSwapBidRequestResultCode = -3
	CreateAtomicSwapBidRequestResultCodeQuoteAssetNotFound               CreateAtomicSwapBidRequestResultCode = -4
	CreateAtomicSwapBidRequestResultCodeAskUnderfunded                   CreateAtomicSwapBidRequestResultCode = -5
	CreateAtomicSwapBidRequestResultCodeAtomicSwapBidTasksNotFound       CreateAtomicSwapBidRequestResultCode = -6
	CreateAtomicSwapBidRequestResultCodeIncorrectPrecision               CreateAtomicSwapBidRequestResultCode = -7
	CreateAtomicSwapBidRequestResultCodeAskIsCancelled                   CreateAtomicSwapBidRequestResultCode = -8
	CreateAtomicSwapBidRequestResultCodeSourceAccountEqualsAskOwner      CreateAtomicSwapBidRequestResultCode = -9
	CreateAtomicSwapBidRequestResultCodeAtomicSwapBidZeroTasksNotAllowed CreateAtomicSwapBidRequestResultCode = -10
	CreateAtomicSwapBidRequestResultCodeQuoteAmountOverflows             CreateAtomicSwapBidRequestResultCode = -11
)

var CreateAtomicSwapBidRequestResultCodeAll = []CreateAtomicSwapBidRequestResultCode{
	CreateAtomicSwapBidRequestResultCodeSuccess,
	CreateAtomicSwapBidRequestResultCodeInvalidBaseAmount,
	CreateAtomicSwapBidRequestResultCodeInvalidQuoteAsset,
	CreateAtomicSwapBidRequestResultCodeAskNotFound,
	CreateAtomicSwapBidRequestResultCodeQuoteAssetNotFound,
	CreateAtomicSwapBidRequestResultCodeAskUnderfunded,
	CreateAtomicSwapBidRequestResultCodeAtomicSwapBidTasksNotFound,
	CreateAtomicSwapBidRequestResultCodeIncorrectPrecision,
	CreateAtomicSwapBidRequestResultCodeAskIsCancelled,
	CreateAtomicSwapBidRequestResultCodeSourceAccountEqualsAskOwner,
	CreateAtomicSwapBidRequestResultCodeAtomicSwapBidZeroTasksNotAllowed,
	CreateAtomicSwapBidRequestResultCodeQuoteAmountOverflows,
}

var createAtomicSwapBidRequestResultCodeMap = map[int32]string{
	0:   "CreateAtomicSwapBidRequestResultCodeSuccess",
	-1:  "CreateAtomicSwapBidRequestResultCodeInvalidBaseAmount",
	-2:  "CreateAtomicSwapBidRequestResultCodeInvalidQuoteAsset",
	-3:  "CreateAtomicSwapBidRequestResultCodeAskNotFound",
	-4:  "CreateAtomicSwapBidRequestResultCodeQuoteAssetNotFound",
	-5:  "CreateAtomicSwapBidRequestResultCodeAskUnderfunded",
	-6:  "CreateAtomicSwapBidRequestResultCodeAtomicSwapBidTasksNotFound",
	-7:  "CreateAtomicSwapBidRequestResultCodeIncorrectPrecision",
	-8:  "CreateAtomicSwapBidRequestResultCodeAskIsCancelled",
	-9:  "CreateAtomicSwapBidRequestResultCodeSourceAccountEqualsAskOwner",
	-10: "CreateAtomicSwapBidRequestResultCodeAtomicSwapBidZeroTasksNotAllowed",
	-11: "CreateAtomicSwapBidRequestResultCodeQuoteAmountOverflows",
}

var createAtomicSwapBidRequestResultCodeShortMap = map[int32]string{
	0:   "success",
	-1:  "invalid_base_amount",
	-2:  "invalid_quote_asset",
	-3:  "ask_not_found",
	-4:  "quote_asset_not_found",
	-5:  "ask_underfunded",
	-6:  "atomic_swap_bid_tasks_not_found",
	-7:  "incorrect_precision",
	-8:  "ask_is_cancelled",
	-9:  "source_account_equals_ask_owner",
	-10: "atomic_swap_bid_zero_tasks_not_allowed",
	-11: "quote_amount_overflows",
}

var createAtomicSwapBidRequestResultCodeRevMap = map[string]int32{
	"CreateAtomicSwapBidRequestResultCodeSuccess":                          0,
	"CreateAtomicSwapBidRequestResultCodeInvalidBaseAmount":                -1,
	"CreateAtomicSwapBidRequestResultCodeInvalidQuoteAsset":                -2,
	"CreateAtomicSwapBidRequestResultCodeAskNotFound":                      -3,
	"CreateAtomicSwapBidRequestResultCodeQuoteAssetNotFound":               -4,
	"CreateAtomicSwapBidRequestResultCodeAskUnderfunded":                   -5,
	"CreateAtomicSwapBidRequestResultCodeAtomicSwapBidTasksNotFound":       -6,
	"CreateAtomicSwapBidRequestResultCodeIncorrectPrecision":               -7,
	"CreateAtomicSwapBidRequestResultCodeAskIsCancelled":                   -8,
	"CreateAtomicSwapBidRequestResultCodeSourceAccountEqualsAskOwner":      -9,
	"CreateAtomicSwapBidRequestResultCodeAtomicSwapBidZeroTasksNotAllowed": -10,
	"CreateAtomicSwapBidRequestResultCodeQuoteAmountOverflows":             -11,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CreateAtomicSwapBidRequestResultCode
func (e CreateAtomicSwapBidRequestResultCode) ValidEnum(v int32) bool {
	_, ok := createAtomicSwapBidRequestResultCodeMap[v]
	return ok
}
func (e CreateAtomicSwapBidRequestResultCode) isFlag() bool {
	for i := len(CreateAtomicSwapBidRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := CreateAtomicSwapBidRequestResultCode(2) << uint64(len(CreateAtomicSwapBidRequestResultCodeAll)-1) >> uint64(len(CreateAtomicSwapBidRequestResultCodeAll)-i)
		if expected != CreateAtomicSwapBidRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CreateAtomicSwapBidRequestResultCode) String() string {
	name, _ := createAtomicSwapBidRequestResultCodeMap[int32(e)]
	return name
}

func (e CreateAtomicSwapBidRequestResultCode) ShortString() string {
	name, _ := createAtomicSwapBidRequestResultCodeShortMap[int32(e)]
	return name
}

func (e CreateAtomicSwapBidRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CreateAtomicSwapBidRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CreateAtomicSwapBidRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CreateAtomicSwapBidRequestResultCode(t.Value)
	return nil
}

// CreateAtomicSwapBidRequestSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateAtomicSwapBidRequestSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateAtomicSwapBidRequestSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateAtomicSwapBidRequestSuccessExt
func (u CreateAtomicSwapBidRequestSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateAtomicSwapBidRequestSuccessExt creates a new  CreateAtomicSwapBidRequestSuccessExt.
func NewCreateAtomicSwapBidRequestSuccessExt(v LedgerVersion, value interface{}) (result CreateAtomicSwapBidRequestSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateAtomicSwapBidRequestSuccess is an XDR Struct defines as:
//
//   //: Success request of CreateAtomicSwapBidRequestOp application
//    struct CreateAtomicSwapBidRequestSuccess
//    {
//        //: id of created request
//        uint64 requestID;
//        //: id of ask owner
//        AccountID askOwnerID;
//        //: amount in quote asset which required for request applying
//        uint64 quoteAmount;
//
//        //: reserved for the future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type CreateAtomicSwapBidRequestSuccess struct {
	RequestId   Uint64                               `json:"requestID,omitempty"`
	AskOwnerId  AccountId                            `json:"askOwnerID,omitempty"`
	QuoteAmount Uint64                               `json:"quoteAmount,omitempty"`
	Ext         CreateAtomicSwapBidRequestSuccessExt `json:"ext,omitempty"`
}

// CreateAtomicSwapBidRequestResult is an XDR Union defines as:
//
//   //: Result of CreateAtomicSwapBidRequestOp application
//    union CreateAtomicSwapBidRequestResult switch (CreateAtomicSwapBidRequestResultCode code)
//    {
//    case SUCCESS:
//        //: is used to pass useful fields after successful operation applying
//        CreateAtomicSwapBidRequestSuccess success;
//    default:
//        void;
//    };
//
type CreateAtomicSwapBidRequestResult struct {
	Code    CreateAtomicSwapBidRequestResultCode `json:"code,omitempty"`
	Success *CreateAtomicSwapBidRequestSuccess   `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateAtomicSwapBidRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateAtomicSwapBidRequestResult
func (u CreateAtomicSwapBidRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch CreateAtomicSwapBidRequestResultCode(sw) {
	case CreateAtomicSwapBidRequestResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewCreateAtomicSwapBidRequestResult creates a new  CreateAtomicSwapBidRequestResult.
func NewCreateAtomicSwapBidRequestResult(code CreateAtomicSwapBidRequestResultCode, value interface{}) (result CreateAtomicSwapBidRequestResult, err error) {
	result.Code = code
	switch CreateAtomicSwapBidRequestResultCode(code) {
	case CreateAtomicSwapBidRequestResultCodeSuccess:
		tv, ok := value.(CreateAtomicSwapBidRequestSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateAtomicSwapBidRequestSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CreateAtomicSwapBidRequestResult) MustSuccess() CreateAtomicSwapBidRequestSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CreateAtomicSwapBidRequestResult) GetSuccess() (result CreateAtomicSwapBidRequestSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// CreateChangeRoleRequestOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateChangeRoleRequestOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateChangeRoleRequestOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateChangeRoleRequestOpExt
func (u CreateChangeRoleRequestOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateChangeRoleRequestOpExt creates a new  CreateChangeRoleRequestOpExt.
func NewCreateChangeRoleRequestOpExt(v LedgerVersion, value interface{}) (result CreateChangeRoleRequestOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateChangeRoleRequestOp is an XDR Struct defines as:
//
//   //: `CreateChangeRoleRequestOp` is used to create reviewable requests
//    //: that, with admin's approval, will change the role of `destinationAccount`
//    //: from current role to `accountRoleToSet`
//    struct CreateChangeRoleRequestOp
//    {
//        //: Set zero to create new request, set non zero to update existing request
//        uint64 requestID;
//
//        //: AccountID of an account whose role will be changed
//        AccountID destinationAccount;
//        //: ID of account role that will be attached to `destinationAccount`
//        uint64 accountRoleToSet;
//        //: Arbitrary stringified json object that can be used to attach data to be reviewed by an admin
//        longstring creatorDetails;
//
//        //: Bit mask that will be used instead of the value from key-value entry by
//        //: `change_role_tasks:<currentRoleID>:<accountRoleToSet>` key
//        uint32* allTasks;
//
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CreateChangeRoleRequestOp struct {
	RequestId          Uint64                       `json:"requestID,omitempty"`
	DestinationAccount AccountId                    `json:"destinationAccount,omitempty"`
	AccountRoleToSet   Uint64                       `json:"accountRoleToSet,omitempty"`
	CreatorDetails     Longstring                   `json:"creatorDetails,omitempty"`
	AllTasks           *Uint32                      `json:"allTasks,omitempty"`
	Ext                CreateChangeRoleRequestOpExt `json:"ext,omitempty"`
}

// CreateChangeRoleRequestResultCode is an XDR Enum defines as:
//
//   //: Result codes of CreateChangeRoleRequestOp
//    enum CreateChangeRoleRequestResultCode
//    {
//        //: Change role request has either been successfully created
//        //: or auto approved
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: There is no destination account with such accountID
//        ACC_TO_UPDATE_DOES_NOT_EXIST = -1,
//        //: There is another change role request for such destination account
//        REQUEST_ALREADY_EXISTS = -2,
//        //: There is no request with such `requestID`
//        REQUEST_DOES_NOT_EXIST = -4,
//        //: Only `destinationAccount` can update change role request
//        //: `destinationAccount` must be equal source Account
//        NOT_ALLOWED_TO_UPDATE_REQUEST = -6,
//        //: It is not allowed to change `destinationAccount`, `accountRoleToSet`
//        //: or set `allTasks` on update change role request
//        INVALID_CHANGE_ROLE_REQUEST_DATA = -7,
//        //: `creatorDetails` must be in a valid JSON format
//        INVALID_CREATOR_DETAILS = -8,
//        //: There is no key-value entry by `change_role_tasks` key in the system;
//        //: configuration does not allow changing the role from current to `accountRoleToSet`
//        CHANGE_ROLE_TASKS_NOT_FOUND = -9,
//        //: There is no account role with provided id
//        ACCOUNT_ROLE_TO_SET_DOES_NOT_EXIST = -10
//    };
//
type CreateChangeRoleRequestResultCode int32

const (
	CreateChangeRoleRequestResultCodeSuccess                      CreateChangeRoleRequestResultCode = 0
	CreateChangeRoleRequestResultCodeAccToUpdateDoesNotExist      CreateChangeRoleRequestResultCode = -1
	CreateChangeRoleRequestResultCodeRequestAlreadyExists         CreateChangeRoleRequestResultCode = -2
	CreateChangeRoleRequestResultCodeRequestDoesNotExist          CreateChangeRoleRequestResultCode = -4
	CreateChangeRoleRequestResultCodeNotAllowedToUpdateRequest    CreateChangeRoleRequestResultCode = -6
	CreateChangeRoleRequestResultCodeInvalidChangeRoleRequestData CreateChangeRoleRequestResultCode = -7
	CreateChangeRoleRequestResultCodeInvalidCreatorDetails        CreateChangeRoleRequestResultCode = -8
	CreateChangeRoleRequestResultCodeChangeRoleTasksNotFound      CreateChangeRoleRequestResultCode = -9
	CreateChangeRoleRequestResultCodeAccountRoleToSetDoesNotExist CreateChangeRoleRequestResultCode = -10
)

var CreateChangeRoleRequestResultCodeAll = []CreateChangeRoleRequestResultCode{
	CreateChangeRoleRequestResultCodeSuccess,
	CreateChangeRoleRequestResultCodeAccToUpdateDoesNotExist,
	CreateChangeRoleRequestResultCodeRequestAlreadyExists,
	CreateChangeRoleRequestResultCodeRequestDoesNotExist,
	CreateChangeRoleRequestResultCodeNotAllowedToUpdateRequest,
	CreateChangeRoleRequestResultCodeInvalidChangeRoleRequestData,
	CreateChangeRoleRequestResultCodeInvalidCreatorDetails,
	CreateChangeRoleRequestResultCodeChangeRoleTasksNotFound,
	CreateChangeRoleRequestResultCodeAccountRoleToSetDoesNotExist,
}

var createChangeRoleRequestResultCodeMap = map[int32]string{
	0:   "CreateChangeRoleRequestResultCodeSuccess",
	-1:  "CreateChangeRoleRequestResultCodeAccToUpdateDoesNotExist",
	-2:  "CreateChangeRoleRequestResultCodeRequestAlreadyExists",
	-4:  "CreateChangeRoleRequestResultCodeRequestDoesNotExist",
	-6:  "CreateChangeRoleRequestResultCodeNotAllowedToUpdateRequest",
	-7:  "CreateChangeRoleRequestResultCodeInvalidChangeRoleRequestData",
	-8:  "CreateChangeRoleRequestResultCodeInvalidCreatorDetails",
	-9:  "CreateChangeRoleRequestResultCodeChangeRoleTasksNotFound",
	-10: "CreateChangeRoleRequestResultCodeAccountRoleToSetDoesNotExist",
}

var createChangeRoleRequestResultCodeShortMap = map[int32]string{
	0:   "success",
	-1:  "acc_to_update_does_not_exist",
	-2:  "request_already_exists",
	-4:  "request_does_not_exist",
	-6:  "not_allowed_to_update_request",
	-7:  "invalid_change_role_request_data",
	-8:  "invalid_creator_details",
	-9:  "change_role_tasks_not_found",
	-10: "account_role_to_set_does_not_exist",
}

var createChangeRoleRequestResultCodeRevMap = map[string]int32{
	"CreateChangeRoleRequestResultCodeSuccess":                      0,
	"CreateChangeRoleRequestResultCodeAccToUpdateDoesNotExist":      -1,
	"CreateChangeRoleRequestResultCodeRequestAlreadyExists":         -2,
	"CreateChangeRoleRequestResultCodeRequestDoesNotExist":          -4,
	"CreateChangeRoleRequestResultCodeNotAllowedToUpdateRequest":    -6,
	"CreateChangeRoleRequestResultCodeInvalidChangeRoleRequestData": -7,
	"CreateChangeRoleRequestResultCodeInvalidCreatorDetails":        -8,
	"CreateChangeRoleRequestResultCodeChangeRoleTasksNotFound":      -9,
	"CreateChangeRoleRequestResultCodeAccountRoleToSetDoesNotExist": -10,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CreateChangeRoleRequestResultCode
func (e CreateChangeRoleRequestResultCode) ValidEnum(v int32) bool {
	_, ok := createChangeRoleRequestResultCodeMap[v]
	return ok
}
func (e CreateChangeRoleRequestResultCode) isFlag() bool {
	for i := len(CreateChangeRoleRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := CreateChangeRoleRequestResultCode(2) << uint64(len(CreateChangeRoleRequestResultCodeAll)-1) >> uint64(len(CreateChangeRoleRequestResultCodeAll)-i)
		if expected != CreateChangeRoleRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CreateChangeRoleRequestResultCode) String() string {
	name, _ := createChangeRoleRequestResultCodeMap[int32(e)]
	return name
}

func (e CreateChangeRoleRequestResultCode) ShortString() string {
	name, _ := createChangeRoleRequestResultCodeShortMap[int32(e)]
	return name
}

func (e CreateChangeRoleRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CreateChangeRoleRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CreateChangeRoleRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CreateChangeRoleRequestResultCode(t.Value)
	return nil
}

// CreateChangeRoleRequestResultSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type CreateChangeRoleRequestResultSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateChangeRoleRequestResultSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateChangeRoleRequestResultSuccessExt
func (u CreateChangeRoleRequestResultSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateChangeRoleRequestResultSuccessExt creates a new  CreateChangeRoleRequestResultSuccessExt.
func NewCreateChangeRoleRequestResultSuccessExt(v LedgerVersion, value interface{}) (result CreateChangeRoleRequestResultSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateChangeRoleRequestResultSuccess is an XDR NestedStruct defines as:
//
//   struct {
//            //: ID of a created or updated request
//            uint64 requestID;
//            //: True if request was auto approved (pending tasks == 0),
//            //: `destinationAccount` must have new account role
//            bool fulfilled;
//            // Reserved for future use
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//    	}
//
type CreateChangeRoleRequestResultSuccess struct {
	RequestId Uint64                                  `json:"requestID,omitempty"`
	Fulfilled bool                                    `json:"fulfilled,omitempty"`
	Ext       CreateChangeRoleRequestResultSuccessExt `json:"ext,omitempty"`
}

// CreateChangeRoleRequestResult is an XDR Union defines as:
//
//   //: Result of operation application
//    union CreateChangeRoleRequestResult switch (CreateChangeRoleRequestResultCode code)
//    {
//    case SUCCESS:
//        struct {
//            //: ID of a created or updated request
//            uint64 requestID;
//            //: True if request was auto approved (pending tasks == 0),
//            //: `destinationAccount` must have new account role
//            bool fulfilled;
//            // Reserved for future use
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//    	} success;
//    default:
//        void;
//    };
//
type CreateChangeRoleRequestResult struct {
	Code    CreateChangeRoleRequestResultCode     `json:"code,omitempty"`
	Success *CreateChangeRoleRequestResultSuccess `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateChangeRoleRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateChangeRoleRequestResult
func (u CreateChangeRoleRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch CreateChangeRoleRequestResultCode(sw) {
	case CreateChangeRoleRequestResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewCreateChangeRoleRequestResult creates a new  CreateChangeRoleRequestResult.
func NewCreateChangeRoleRequestResult(code CreateChangeRoleRequestResultCode, value interface{}) (result CreateChangeRoleRequestResult, err error) {
	result.Code = code
	switch CreateChangeRoleRequestResultCode(code) {
	case CreateChangeRoleRequestResultCodeSuccess:
		tv, ok := value.(CreateChangeRoleRequestResultSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateChangeRoleRequestResultSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CreateChangeRoleRequestResult) MustSuccess() CreateChangeRoleRequestResultSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CreateChangeRoleRequestResult) GetSuccess() (result CreateChangeRoleRequestResultSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// CreateCloseDeferredPaymentRequestOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateCloseDeferredPaymentRequestOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateCloseDeferredPaymentRequestOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateCloseDeferredPaymentRequestOpExt
func (u CreateCloseDeferredPaymentRequestOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateCloseDeferredPaymentRequestOpExt creates a new  CreateCloseDeferredPaymentRequestOpExt.
func NewCreateCloseDeferredPaymentRequestOpExt(v LedgerVersion, value interface{}) (result CreateCloseDeferredPaymentRequestOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateCloseDeferredPaymentRequestOp is an XDR Struct defines as:
//
//   //: CreateCloseDeferredPaymentRequestOp is used to create `CLOSE_DEFERRED_PAYMENT` request
//    struct CreateCloseDeferredPaymentRequestOp
//    {
//
//        uint64 requestID;
//
//        //: Body of request which will be created
//        CloseDeferredPaymentRequest request;
//
//        uint32* allTasks;
//        //: reserved for the future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CreateCloseDeferredPaymentRequestOp struct {
	RequestId Uint64                                 `json:"requestID,omitempty"`
	Request   CloseDeferredPaymentRequest            `json:"request,omitempty"`
	AllTasks  *Uint32                                `json:"allTasks,omitempty"`
	Ext       CreateCloseDeferredPaymentRequestOpExt `json:"ext,omitempty"`
}

// CreateCloseDeferredPaymentRequestResultCode is an XDR Enum defines as:
//
//   //: Result codes of CreateAtomicSwapBidRequestOp
//    enum CreateCloseDeferredPaymentRequestResultCode
//    {
//        //: `CLOSE_DEFERRED_PAYMENT` request has either been successfully created
//        //: or auto approved
//        SUCCESS = 0,
//
//        UNDERFUNDED = -1,
//        INVALID_CREATOR_DETAILS = -2,
//        NOT_AUTHORIZED = -3,
//        DESTINATION_ACCOUNT_NOT_FOUND = -4,
//        INCORRECT_PRECISION = -5,
//        ASSET_MISMATCH = -6,
//        LINE_FULL = -7,
//        TASKS_NOT_FOUND = -8,
//        INVALID_AMOUNT = -9,
//        DESTINATION_BALANCE_NOT_FOUND = -10,
//        REQUEST_NOT_FOUND = -11
//    };
//
type CreateCloseDeferredPaymentRequestResultCode int32

const (
	CreateCloseDeferredPaymentRequestResultCodeSuccess                    CreateCloseDeferredPaymentRequestResultCode = 0
	CreateCloseDeferredPaymentRequestResultCodeUnderfunded                CreateCloseDeferredPaymentRequestResultCode = -1
	CreateCloseDeferredPaymentRequestResultCodeInvalidCreatorDetails      CreateCloseDeferredPaymentRequestResultCode = -2
	CreateCloseDeferredPaymentRequestResultCodeNotAuthorized              CreateCloseDeferredPaymentRequestResultCode = -3
	CreateCloseDeferredPaymentRequestResultCodeDestinationAccountNotFound CreateCloseDeferredPaymentRequestResultCode = -4
	CreateCloseDeferredPaymentRequestResultCodeIncorrectPrecision         CreateCloseDeferredPaymentRequestResultCode = -5
	CreateCloseDeferredPaymentRequestResultCodeAssetMismatch              CreateCloseDeferredPaymentRequestResultCode = -6
	CreateCloseDeferredPaymentRequestResultCodeLineFull                   CreateCloseDeferredPaymentRequestResultCode = -7
	CreateCloseDeferredPaymentRequestResultCodeTasksNotFound              CreateCloseDeferredPaymentRequestResultCode = -8
	CreateCloseDeferredPaymentRequestResultCodeInvalidAmount              CreateCloseDeferredPaymentRequestResultCode = -9
	CreateCloseDeferredPaymentRequestResultCodeDestinationBalanceNotFound CreateCloseDeferredPaymentRequestResultCode = -10
	CreateCloseDeferredPaymentRequestResultCodeRequestNotFound            CreateCloseDeferredPaymentRequestResultCode = -11
)

var CreateCloseDeferredPaymentRequestResultCodeAll = []CreateCloseDeferredPaymentRequestResultCode{
	CreateCloseDeferredPaymentRequestResultCodeSuccess,
	CreateCloseDeferredPaymentRequestResultCodeUnderfunded,
	CreateCloseDeferredPaymentRequestResultCodeInvalidCreatorDetails,
	CreateCloseDeferredPaymentRequestResultCodeNotAuthorized,
	CreateCloseDeferredPaymentRequestResultCodeDestinationAccountNotFound,
	CreateCloseDeferredPaymentRequestResultCodeIncorrectPrecision,
	CreateCloseDeferredPaymentRequestResultCodeAssetMismatch,
	CreateCloseDeferredPaymentRequestResultCodeLineFull,
	CreateCloseDeferredPaymentRequestResultCodeTasksNotFound,
	CreateCloseDeferredPaymentRequestResultCodeInvalidAmount,
	CreateCloseDeferredPaymentRequestResultCodeDestinationBalanceNotFound,
	CreateCloseDeferredPaymentRequestResultCodeRequestNotFound,
}

var createCloseDeferredPaymentRequestResultCodeMap = map[int32]string{
	0:   "CreateCloseDeferredPaymentRequestResultCodeSuccess",
	-1:  "CreateCloseDeferredPaymentRequestResultCodeUnderfunded",
	-2:  "CreateCloseDeferredPaymentRequestResultCodeInvalidCreatorDetails",
	-3:  "CreateCloseDeferredPaymentRequestResultCodeNotAuthorized",
	-4:  "CreateCloseDeferredPaymentRequestResultCodeDestinationAccountNotFound",
	-5:  "CreateCloseDeferredPaymentRequestResultCodeIncorrectPrecision",
	-6:  "CreateCloseDeferredPaymentRequestResultCodeAssetMismatch",
	-7:  "CreateCloseDeferredPaymentRequestResultCodeLineFull",
	-8:  "CreateCloseDeferredPaymentRequestResultCodeTasksNotFound",
	-9:  "CreateCloseDeferredPaymentRequestResultCodeInvalidAmount",
	-10: "CreateCloseDeferredPaymentRequestResultCodeDestinationBalanceNotFound",
	-11: "CreateCloseDeferredPaymentRequestResultCodeRequestNotFound",
}

var createCloseDeferredPaymentRequestResultCodeShortMap = map[int32]string{
	0:   "success",
	-1:  "underfunded",
	-2:  "invalid_creator_details",
	-3:  "not_authorized",
	-4:  "destination_account_not_found",
	-5:  "incorrect_precision",
	-6:  "asset_mismatch",
	-7:  "line_full",
	-8:  "tasks_not_found",
	-9:  "invalid_amount",
	-10: "destination_balance_not_found",
	-11: "request_not_found",
}

var createCloseDeferredPaymentRequestResultCodeRevMap = map[string]int32{
	"CreateCloseDeferredPaymentRequestResultCodeSuccess":                    0,
	"CreateCloseDeferredPaymentRequestResultCodeUnderfunded":                -1,
	"CreateCloseDeferredPaymentRequestResultCodeInvalidCreatorDetails":      -2,
	"CreateCloseDeferredPaymentRequestResultCodeNotAuthorized":              -3,
	"CreateCloseDeferredPaymentRequestResultCodeDestinationAccountNotFound": -4,
	"CreateCloseDeferredPaymentRequestResultCodeIncorrectPrecision":         -5,
	"CreateCloseDeferredPaymentRequestResultCodeAssetMismatch":              -6,
	"CreateCloseDeferredPaymentRequestResultCodeLineFull":                   -7,
	"CreateCloseDeferredPaymentRequestResultCodeTasksNotFound":              -8,
	"CreateCloseDeferredPaymentRequestResultCodeInvalidAmount":              -9,
	"CreateCloseDeferredPaymentRequestResultCodeDestinationBalanceNotFound": -10,
	"CreateCloseDeferredPaymentRequestResultCodeRequestNotFound":            -11,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CreateCloseDeferredPaymentRequestResultCode
func (e CreateCloseDeferredPaymentRequestResultCode) ValidEnum(v int32) bool {
	_, ok := createCloseDeferredPaymentRequestResultCodeMap[v]
	return ok
}
func (e CreateCloseDeferredPaymentRequestResultCode) isFlag() bool {
	for i := len(CreateCloseDeferredPaymentRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := CreateCloseDeferredPaymentRequestResultCode(2) << uint64(len(CreateCloseDeferredPaymentRequestResultCodeAll)-1) >> uint64(len(CreateCloseDeferredPaymentRequestResultCodeAll)-i)
		if expected != CreateCloseDeferredPaymentRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CreateCloseDeferredPaymentRequestResultCode) String() string {
	name, _ := createCloseDeferredPaymentRequestResultCodeMap[int32(e)]
	return name
}

func (e CreateCloseDeferredPaymentRequestResultCode) ShortString() string {
	name, _ := createCloseDeferredPaymentRequestResultCodeShortMap[int32(e)]
	return name
}

func (e CreateCloseDeferredPaymentRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CreateCloseDeferredPaymentRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CreateCloseDeferredPaymentRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CreateCloseDeferredPaymentRequestResultCode(t.Value)
	return nil
}

// CloseDeferredPaymentEffect is an XDR Enum defines as:
//
//   enum CloseDeferredPaymentEffect
//    {
//        CHARGED = 0,
//        DELETED = 1
//    };
//
type CloseDeferredPaymentEffect int32

const (
	CloseDeferredPaymentEffectCharged CloseDeferredPaymentEffect = 0
	CloseDeferredPaymentEffectDeleted CloseDeferredPaymentEffect = 1
)

var CloseDeferredPaymentEffectAll = []CloseDeferredPaymentEffect{
	CloseDeferredPaymentEffectCharged,
	CloseDeferredPaymentEffectDeleted,
}

var closeDeferredPaymentEffectMap = map[int32]string{
	0: "CloseDeferredPaymentEffectCharged",
	1: "CloseDeferredPaymentEffectDeleted",
}

var closeDeferredPaymentEffectShortMap = map[int32]string{
	0: "charged",
	1: "deleted",
}

var closeDeferredPaymentEffectRevMap = map[string]int32{
	"CloseDeferredPaymentEffectCharged": 0,
	"CloseDeferredPaymentEffectDeleted": 1,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CloseDeferredPaymentEffect
func (e CloseDeferredPaymentEffect) ValidEnum(v int32) bool {
	_, ok := closeDeferredPaymentEffectMap[v]
	return ok
}
func (e CloseDeferredPaymentEffect) isFlag() bool {
	for i := len(CloseDeferredPaymentEffectAll) - 1; i >= 0; i-- {
		expected := CloseDeferredPaymentEffect(2) << uint64(len(CloseDeferredPaymentEffectAll)-1) >> uint64(len(CloseDeferredPaymentEffectAll)-i)
		if expected != CloseDeferredPaymentEffectAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CloseDeferredPaymentEffect) String() string {
	name, _ := closeDeferredPaymentEffectMap[int32(e)]
	return name
}

func (e CloseDeferredPaymentEffect) ShortString() string {
	name, _ := closeDeferredPaymentEffectShortMap[int32(e)]
	return name
}

func (e CloseDeferredPaymentEffect) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CloseDeferredPaymentEffectAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CloseDeferredPaymentEffect) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CloseDeferredPaymentEffect(t.Value)
	return nil
}

// CloseDeferredPaymentResult is an XDR Struct defines as:
//
//   struct CloseDeferredPaymentResult
//    {
//        uint64 deferredPaymentID;
//
//        AccountID destination;
//        BalanceID destinationBalance;
//
//        CloseDeferredPaymentEffect effect;
//
//        EmptyExt ext;
//    };
//
type CloseDeferredPaymentResult struct {
	DeferredPaymentId  Uint64                     `json:"deferredPaymentID,omitempty"`
	Destination        AccountId                  `json:"destination,omitempty"`
	DestinationBalance BalanceId                  `json:"destinationBalance,omitempty"`
	Effect             CloseDeferredPaymentEffect `json:"effect,omitempty"`
	Ext                EmptyExt                   `json:"ext,omitempty"`
}

// CreateCloseDeferredPaymentRequestSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateCloseDeferredPaymentRequestSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateCloseDeferredPaymentRequestSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateCloseDeferredPaymentRequestSuccessExt
func (u CreateCloseDeferredPaymentRequestSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateCloseDeferredPaymentRequestSuccessExt creates a new  CreateCloseDeferredPaymentRequestSuccessExt.
func NewCreateCloseDeferredPaymentRequestSuccessExt(v LedgerVersion, value interface{}) (result CreateCloseDeferredPaymentRequestSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateCloseDeferredPaymentRequestSuccess is an XDR Struct defines as:
//
//   //: Success result of CreateASwapAskCreationRequestOp application
//    struct CreateCloseDeferredPaymentRequestSuccess
//    {
//        uint64 requestID;
//        bool fulfilled;
//        uint64 deferredPaymentID;
//
//        CloseDeferredPaymentResult* extendedResult;
//
//        //: reserved for the future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type CreateCloseDeferredPaymentRequestSuccess struct {
	RequestId         Uint64                                      `json:"requestID,omitempty"`
	Fulfilled         bool                                        `json:"fulfilled,omitempty"`
	DeferredPaymentId Uint64                                      `json:"deferredPaymentID,omitempty"`
	ExtendedResult    *CloseDeferredPaymentResult                 `json:"extendedResult,omitempty"`
	Ext               CreateCloseDeferredPaymentRequestSuccessExt `json:"ext,omitempty"`
}

// CreateCloseDeferredPaymentRequestResult is an XDR Union defines as:
//
//   //: Result of CreateCloseDeferredPaymentRequestOp application
//    union CreateCloseDeferredPaymentRequestResult switch (CreateCloseDeferredPaymentRequestResultCode code)
//    {
//    case SUCCESS:
//        //: is used to pass useful fields after successful operation applying
//        CreateCloseDeferredPaymentRequestSuccess success;
//    default:
//        void;
//    };
//
type CreateCloseDeferredPaymentRequestResult struct {
	Code    CreateCloseDeferredPaymentRequestResultCode `json:"code,omitempty"`
	Success *CreateCloseDeferredPaymentRequestSuccess   `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateCloseDeferredPaymentRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateCloseDeferredPaymentRequestResult
func (u CreateCloseDeferredPaymentRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch CreateCloseDeferredPaymentRequestResultCode(sw) {
	case CreateCloseDeferredPaymentRequestResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewCreateCloseDeferredPaymentRequestResult creates a new  CreateCloseDeferredPaymentRequestResult.
func NewCreateCloseDeferredPaymentRequestResult(code CreateCloseDeferredPaymentRequestResultCode, value interface{}) (result CreateCloseDeferredPaymentRequestResult, err error) {
	result.Code = code
	switch CreateCloseDeferredPaymentRequestResultCode(code) {
	case CreateCloseDeferredPaymentRequestResultCodeSuccess:
		tv, ok := value.(CreateCloseDeferredPaymentRequestSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateCloseDeferredPaymentRequestSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CreateCloseDeferredPaymentRequestResult) MustSuccess() CreateCloseDeferredPaymentRequestSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CreateCloseDeferredPaymentRequestResult) GetSuccess() (result CreateCloseDeferredPaymentRequestSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// CreateDataCreationRequestOp is an XDR Struct defines as:
//
//   struct CreateDataCreationRequestOp
//    {
//        //: ID of the DataCreationRequest. If set to 0, a new request is created
//        uint64 requestID;
//
//        DataCreationRequest dataCreationRequest;
//
//        uint32* allTasks;
//
//        //: Reserved for future extension
//        EmptyExt ext;
//    };
//
type CreateDataCreationRequestOp struct {
	RequestId           Uint64              `json:"requestID,omitempty"`
	DataCreationRequest DataCreationRequest `json:"dataCreationRequest,omitempty"`
	AllTasks            *Uint32             `json:"allTasks,omitempty"`
	Ext                 EmptyExt            `json:"ext,omitempty"`
}

// CreateDataCreationRequestResultCode is an XDR Enum defines as:
//
//   enum CreateDataCreationRequestResultCode
//    {
//        SUCCESS = 0,
//        INVALID_VALUE = -1,
//        CREATE_DATA_TASKS_NOT_FOUND = -2,
//        REQUEST_NOT_FOUND = -3,
//        INVALID_CREATOR_DETAILS = -4
//    };
//
type CreateDataCreationRequestResultCode int32

const (
	CreateDataCreationRequestResultCodeSuccess                 CreateDataCreationRequestResultCode = 0
	CreateDataCreationRequestResultCodeInvalidValue            CreateDataCreationRequestResultCode = -1
	CreateDataCreationRequestResultCodeCreateDataTasksNotFound CreateDataCreationRequestResultCode = -2
	CreateDataCreationRequestResultCodeRequestNotFound         CreateDataCreationRequestResultCode = -3
	CreateDataCreationRequestResultCodeInvalidCreatorDetails   CreateDataCreationRequestResultCode = -4
)

var CreateDataCreationRequestResultCodeAll = []CreateDataCreationRequestResultCode{
	CreateDataCreationRequestResultCodeSuccess,
	CreateDataCreationRequestResultCodeInvalidValue,
	CreateDataCreationRequestResultCodeCreateDataTasksNotFound,
	CreateDataCreationRequestResultCodeRequestNotFound,
	CreateDataCreationRequestResultCodeInvalidCreatorDetails,
}

var createDataCreationRequestResultCodeMap = map[int32]string{
	0:  "CreateDataCreationRequestResultCodeSuccess",
	-1: "CreateDataCreationRequestResultCodeInvalidValue",
	-2: "CreateDataCreationRequestResultCodeCreateDataTasksNotFound",
	-3: "CreateDataCreationRequestResultCodeRequestNotFound",
	-4: "CreateDataCreationRequestResultCodeInvalidCreatorDetails",
}

var createDataCreationRequestResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "invalid_value",
	-2: "create_data_tasks_not_found",
	-3: "request_not_found",
	-4: "invalid_creator_details",
}

var createDataCreationRequestResultCodeRevMap = map[string]int32{
	"CreateDataCreationRequestResultCodeSuccess":                 0,
	"CreateDataCreationRequestResultCodeInvalidValue":            -1,
	"CreateDataCreationRequestResultCodeCreateDataTasksNotFound": -2,
	"CreateDataCreationRequestResultCodeRequestNotFound":         -3,
	"CreateDataCreationRequestResultCodeInvalidCreatorDetails":   -4,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CreateDataCreationRequestResultCode
func (e CreateDataCreationRequestResultCode) ValidEnum(v int32) bool {
	_, ok := createDataCreationRequestResultCodeMap[v]
	return ok
}
func (e CreateDataCreationRequestResultCode) isFlag() bool {
	for i := len(CreateDataCreationRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := CreateDataCreationRequestResultCode(2) << uint64(len(CreateDataCreationRequestResultCodeAll)-1) >> uint64(len(CreateDataCreationRequestResultCodeAll)-i)
		if expected != CreateDataCreationRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CreateDataCreationRequestResultCode) String() string {
	name, _ := createDataCreationRequestResultCodeMap[int32(e)]
	return name
}

func (e CreateDataCreationRequestResultCode) ShortString() string {
	name, _ := createDataCreationRequestResultCodeShortMap[int32(e)]
	return name
}

func (e CreateDataCreationRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CreateDataCreationRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CreateDataCreationRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CreateDataCreationRequestResultCode(t.Value)
	return nil
}

// CreateDataCreationRequestSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateDataCreationRequestSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateDataCreationRequestSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateDataCreationRequestSuccessExt
func (u CreateDataCreationRequestSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateDataCreationRequestSuccessExt creates a new  CreateDataCreationRequestSuccessExt.
func NewCreateDataCreationRequestSuccessExt(v LedgerVersion, value interface{}) (result CreateDataCreationRequestSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateDataCreationRequestSuccess is an XDR Struct defines as:
//
//   struct CreateDataCreationRequestSuccess {
//        uint64 requestID;
//        bool fulfilled;
//        AccountID owner;
//        uint64 id;
//        uint64 type;
//        longstring value;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CreateDataCreationRequestSuccess struct {
	RequestId Uint64                              `json:"requestID,omitempty"`
	Fulfilled bool                                `json:"fulfilled,omitempty"`
	Owner     AccountId                           `json:"owner,omitempty"`
	Id        Uint64                              `json:"id,omitempty"`
	Type      Uint64                              `json:"type,omitempty"`
	Value     Longstring                          `json:"value,omitempty"`
	Ext       CreateDataCreationRequestSuccessExt `json:"ext,omitempty"`
}

// CreateDataCreationRequestResult is an XDR Union defines as:
//
//   union CreateDataCreationRequestResult switch (CreateDataCreationRequestResultCode code)
//    {
//    case SUCCESS:
//        CreateDataCreationRequestSuccess success;
//    default:
//        void;
//    };
//
type CreateDataCreationRequestResult struct {
	Code    CreateDataCreationRequestResultCode `json:"code,omitempty"`
	Success *CreateDataCreationRequestSuccess   `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateDataCreationRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateDataCreationRequestResult
func (u CreateDataCreationRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch CreateDataCreationRequestResultCode(sw) {
	case CreateDataCreationRequestResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewCreateDataCreationRequestResult creates a new  CreateDataCreationRequestResult.
func NewCreateDataCreationRequestResult(code CreateDataCreationRequestResultCode, value interface{}) (result CreateDataCreationRequestResult, err error) {
	result.Code = code
	switch CreateDataCreationRequestResultCode(code) {
	case CreateDataCreationRequestResultCodeSuccess:
		tv, ok := value.(CreateDataCreationRequestSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateDataCreationRequestSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CreateDataCreationRequestResult) MustSuccess() CreateDataCreationRequestSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CreateDataCreationRequestResult) GetSuccess() (result CreateDataCreationRequestSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// CreateDataRemoveRequestOp is an XDR Struct defines as:
//
//   struct CreateDataRemoveRequestOp
//    {
//        //: ID of the DataRemoveRequest. If set to 0, a new request is created
//        uint64 requestID;
//
//        DataRemoveRequest dataRemoveRequest;
//
//        uint32* allTasks;
//
//        //: Reserved for future extension
//        EmptyExt ext;
//    };
//
type CreateDataRemoveRequestOp struct {
	RequestId         Uint64            `json:"requestID,omitempty"`
	DataRemoveRequest DataRemoveRequest `json:"dataRemoveRequest,omitempty"`
	AllTasks          *Uint32           `json:"allTasks,omitempty"`
	Ext               EmptyExt          `json:"ext,omitempty"`
}

// CreateDataRemoveRequestResultCode is an XDR Enum defines as:
//
//   enum CreateDataRemoveRequestResultCode
//    {
//        SUCCESS = 0,
//        REMOVE_DATA_TASKS_NOT_FOUND = -1,
//        DATA_NOT_FOUND = -2,
//        INVALID_CREATOR_DETAILS = -3,
//        REQUEST_NOT_FOUND = -4
//    };
//
type CreateDataRemoveRequestResultCode int32

const (
	CreateDataRemoveRequestResultCodeSuccess                 CreateDataRemoveRequestResultCode = 0
	CreateDataRemoveRequestResultCodeRemoveDataTasksNotFound CreateDataRemoveRequestResultCode = -1
	CreateDataRemoveRequestResultCodeDataNotFound            CreateDataRemoveRequestResultCode = -2
	CreateDataRemoveRequestResultCodeInvalidCreatorDetails   CreateDataRemoveRequestResultCode = -3
	CreateDataRemoveRequestResultCodeRequestNotFound         CreateDataRemoveRequestResultCode = -4
)

var CreateDataRemoveRequestResultCodeAll = []CreateDataRemoveRequestResultCode{
	CreateDataRemoveRequestResultCodeSuccess,
	CreateDataRemoveRequestResultCodeRemoveDataTasksNotFound,
	CreateDataRemoveRequestResultCodeDataNotFound,
	CreateDataRemoveRequestResultCodeInvalidCreatorDetails,
	CreateDataRemoveRequestResultCodeRequestNotFound,
}

var createDataRemoveRequestResultCodeMap = map[int32]string{
	0:  "CreateDataRemoveRequestResultCodeSuccess",
	-1: "CreateDataRemoveRequestResultCodeRemoveDataTasksNotFound",
	-2: "CreateDataRemoveRequestResultCodeDataNotFound",
	-3: "CreateDataRemoveRequestResultCodeInvalidCreatorDetails",
	-4: "CreateDataRemoveRequestResultCodeRequestNotFound",
}

var createDataRemoveRequestResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "remove_data_tasks_not_found",
	-2: "data_not_found",
	-3: "invalid_creator_details",
	-4: "request_not_found",
}

var createDataRemoveRequestResultCodeRevMap = map[string]int32{
	"CreateDataRemoveRequestResultCodeSuccess":                 0,
	"CreateDataRemoveRequestResultCodeRemoveDataTasksNotFound": -1,
	"CreateDataRemoveRequestResultCodeDataNotFound":            -2,
	"CreateDataRemoveRequestResultCodeInvalidCreatorDetails":   -3,
	"CreateDataRemoveRequestResultCodeRequestNotFound":         -4,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CreateDataRemoveRequestResultCode
func (e CreateDataRemoveRequestResultCode) ValidEnum(v int32) bool {
	_, ok := createDataRemoveRequestResultCodeMap[v]
	return ok
}
func (e CreateDataRemoveRequestResultCode) isFlag() bool {
	for i := len(CreateDataRemoveRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := CreateDataRemoveRequestResultCode(2) << uint64(len(CreateDataRemoveRequestResultCodeAll)-1) >> uint64(len(CreateDataRemoveRequestResultCodeAll)-i)
		if expected != CreateDataRemoveRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CreateDataRemoveRequestResultCode) String() string {
	name, _ := createDataRemoveRequestResultCodeMap[int32(e)]
	return name
}

func (e CreateDataRemoveRequestResultCode) ShortString() string {
	name, _ := createDataRemoveRequestResultCodeShortMap[int32(e)]
	return name
}

func (e CreateDataRemoveRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CreateDataRemoveRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CreateDataRemoveRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CreateDataRemoveRequestResultCode(t.Value)
	return nil
}

// CreateDataRemoveRequestSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateDataRemoveRequestSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateDataRemoveRequestSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateDataRemoveRequestSuccessExt
func (u CreateDataRemoveRequestSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateDataRemoveRequestSuccessExt creates a new  CreateDataRemoveRequestSuccessExt.
func NewCreateDataRemoveRequestSuccessExt(v LedgerVersion, value interface{}) (result CreateDataRemoveRequestSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateDataRemoveRequestSuccess is an XDR Struct defines as:
//
//   struct CreateDataRemoveRequestSuccess {
//        uint64 requestID;
//        bool fulfilled;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CreateDataRemoveRequestSuccess struct {
	RequestId Uint64                            `json:"requestID,omitempty"`
	Fulfilled bool                              `json:"fulfilled,omitempty"`
	Ext       CreateDataRemoveRequestSuccessExt `json:"ext,omitempty"`
}

// CreateDataRemoveRequestResult is an XDR Union defines as:
//
//   union CreateDataRemoveRequestResult switch (CreateDataRemoveRequestResultCode code)
//    {
//    case SUCCESS:
//        CreateDataRemoveRequestSuccess success;
//    default:
//        void;
//    };
//
type CreateDataRemoveRequestResult struct {
	Code    CreateDataRemoveRequestResultCode `json:"code,omitempty"`
	Success *CreateDataRemoveRequestSuccess   `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateDataRemoveRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateDataRemoveRequestResult
func (u CreateDataRemoveRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch CreateDataRemoveRequestResultCode(sw) {
	case CreateDataRemoveRequestResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewCreateDataRemoveRequestResult creates a new  CreateDataRemoveRequestResult.
func NewCreateDataRemoveRequestResult(code CreateDataRemoveRequestResultCode, value interface{}) (result CreateDataRemoveRequestResult, err error) {
	result.Code = code
	switch CreateDataRemoveRequestResultCode(code) {
	case CreateDataRemoveRequestResultCodeSuccess:
		tv, ok := value.(CreateDataRemoveRequestSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateDataRemoveRequestSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CreateDataRemoveRequestResult) MustSuccess() CreateDataRemoveRequestSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CreateDataRemoveRequestResult) GetSuccess() (result CreateDataRemoveRequestSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// CreateDataUpdateRequestOp is an XDR Struct defines as:
//
//   struct CreateDataUpdateRequestOp
//    {
//        //: ID of the DataUpdateRequest. If set to 0, a new request is created
//        uint64 requestID;
//
//        DataUpdateRequest dataUpdateRequest;
//
//        uint32* allTasks;
//
//        //: Reserved for future extension
//        EmptyExt ext;
//    };
//
type CreateDataUpdateRequestOp struct {
	RequestId         Uint64            `json:"requestID,omitempty"`
	DataUpdateRequest DataUpdateRequest `json:"dataUpdateRequest,omitempty"`
	AllTasks          *Uint32           `json:"allTasks,omitempty"`
	Ext               EmptyExt          `json:"ext,omitempty"`
}

// CreateDataUpdateRequestResultCode is an XDR Enum defines as:
//
//   enum CreateDataUpdateRequestResultCode
//    {
//        SUCCESS = 0,
//        INVALID_VALUE = -1,
//        UPDATE_DATA_TASKS_NOT_FOUND = -2,
//        DATA_NOT_FOUND = -3,
//        INVALID_CREATOR_DETAILS = -4,
//        REQUEST_NOT_FOUND = -5
//    };
//
type CreateDataUpdateRequestResultCode int32

const (
	CreateDataUpdateRequestResultCodeSuccess                 CreateDataUpdateRequestResultCode = 0
	CreateDataUpdateRequestResultCodeInvalidValue            CreateDataUpdateRequestResultCode = -1
	CreateDataUpdateRequestResultCodeUpdateDataTasksNotFound CreateDataUpdateRequestResultCode = -2
	CreateDataUpdateRequestResultCodeDataNotFound            CreateDataUpdateRequestResultCode = -3
	CreateDataUpdateRequestResultCodeInvalidCreatorDetails   CreateDataUpdateRequestResultCode = -4
	CreateDataUpdateRequestResultCodeRequestNotFound         CreateDataUpdateRequestResultCode = -5
)

var CreateDataUpdateRequestResultCodeAll = []CreateDataUpdateRequestResultCode{
	CreateDataUpdateRequestResultCodeSuccess,
	CreateDataUpdateRequestResultCodeInvalidValue,
	CreateDataUpdateRequestResultCodeUpdateDataTasksNotFound,
	CreateDataUpdateRequestResultCodeDataNotFound,
	CreateDataUpdateRequestResultCodeInvalidCreatorDetails,
	CreateDataUpdateRequestResultCodeRequestNotFound,
}

var createDataUpdateRequestResultCodeMap = map[int32]string{
	0:  "CreateDataUpdateRequestResultCodeSuccess",
	-1: "CreateDataUpdateRequestResultCodeInvalidValue",
	-2: "CreateDataUpdateRequestResultCodeUpdateDataTasksNotFound",
	-3: "CreateDataUpdateRequestResultCodeDataNotFound",
	-4: "CreateDataUpdateRequestResultCodeInvalidCreatorDetails",
	-5: "CreateDataUpdateRequestResultCodeRequestNotFound",
}

var createDataUpdateRequestResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "invalid_value",
	-2: "update_data_tasks_not_found",
	-3: "data_not_found",
	-4: "invalid_creator_details",
	-5: "request_not_found",
}

var createDataUpdateRequestResultCodeRevMap = map[string]int32{
	"CreateDataUpdateRequestResultCodeSuccess":                 0,
	"CreateDataUpdateRequestResultCodeInvalidValue":            -1,
	"CreateDataUpdateRequestResultCodeUpdateDataTasksNotFound": -2,
	"CreateDataUpdateRequestResultCodeDataNotFound":            -3,
	"CreateDataUpdateRequestResultCodeInvalidCreatorDetails":   -4,
	"CreateDataUpdateRequestResultCodeRequestNotFound":         -5,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CreateDataUpdateRequestResultCode
func (e CreateDataUpdateRequestResultCode) ValidEnum(v int32) bool {
	_, ok := createDataUpdateRequestResultCodeMap[v]
	return ok
}
func (e CreateDataUpdateRequestResultCode) isFlag() bool {
	for i := len(CreateDataUpdateRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := CreateDataUpdateRequestResultCode(2) << uint64(len(CreateDataUpdateRequestResultCodeAll)-1) >> uint64(len(CreateDataUpdateRequestResultCodeAll)-i)
		if expected != CreateDataUpdateRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CreateDataUpdateRequestResultCode) String() string {
	name, _ := createDataUpdateRequestResultCodeMap[int32(e)]
	return name
}

func (e CreateDataUpdateRequestResultCode) ShortString() string {
	name, _ := createDataUpdateRequestResultCodeShortMap[int32(e)]
	return name
}

func (e CreateDataUpdateRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CreateDataUpdateRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CreateDataUpdateRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CreateDataUpdateRequestResultCode(t.Value)
	return nil
}

// CreateDataUpdateRequestSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateDataUpdateRequestSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateDataUpdateRequestSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateDataUpdateRequestSuccessExt
func (u CreateDataUpdateRequestSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateDataUpdateRequestSuccessExt creates a new  CreateDataUpdateRequestSuccessExt.
func NewCreateDataUpdateRequestSuccessExt(v LedgerVersion, value interface{}) (result CreateDataUpdateRequestSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateDataUpdateRequestSuccess is an XDR Struct defines as:
//
//   struct CreateDataUpdateRequestSuccess {
//        uint64 requestID;
//        bool fulfilled;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CreateDataUpdateRequestSuccess struct {
	RequestId Uint64                            `json:"requestID,omitempty"`
	Fulfilled bool                              `json:"fulfilled,omitempty"`
	Ext       CreateDataUpdateRequestSuccessExt `json:"ext,omitempty"`
}

// CreateDataUpdateRequestResult is an XDR Union defines as:
//
//   union CreateDataUpdateRequestResult switch (CreateDataUpdateRequestResultCode code)
//    {
//    case SUCCESS:
//        CreateDataUpdateRequestSuccess success;
//    default:
//        void;
//    };
//
type CreateDataUpdateRequestResult struct {
	Code    CreateDataUpdateRequestResultCode `json:"code,omitempty"`
	Success *CreateDataUpdateRequestSuccess   `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateDataUpdateRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateDataUpdateRequestResult
func (u CreateDataUpdateRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch CreateDataUpdateRequestResultCode(sw) {
	case CreateDataUpdateRequestResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewCreateDataUpdateRequestResult creates a new  CreateDataUpdateRequestResult.
func NewCreateDataUpdateRequestResult(code CreateDataUpdateRequestResultCode, value interface{}) (result CreateDataUpdateRequestResult, err error) {
	result.Code = code
	switch CreateDataUpdateRequestResultCode(code) {
	case CreateDataUpdateRequestResultCodeSuccess:
		tv, ok := value.(CreateDataUpdateRequestSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateDataUpdateRequestSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CreateDataUpdateRequestResult) MustSuccess() CreateDataUpdateRequestSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CreateDataUpdateRequestResult) GetSuccess() (result CreateDataUpdateRequestSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// CreateDataOp is an XDR Struct defines as:
//
//   struct CreateDataOp
//    {
//        //: Numeric type, used for access control
//        uint64 type;
//        //: Value to store
//        longstring value;
//
//        //: Reserved for future extension
//        EmptyExt ext;
//    };
//
type CreateDataOp struct {
	Type  Uint64     `json:"type,omitempty"`
	Value Longstring `json:"value,omitempty"`
	Ext   EmptyExt   `json:"ext,omitempty"`
}

// CreateDataResultCode is an XDR Enum defines as:
//
//   enum CreateDataResultCode
//    {
//        //: Data entry was successfully created
//        SUCCESS = 0,
//        //: `value` must be in a valid JSON format
//        INVALID_DATA = -1
//    };
//
type CreateDataResultCode int32

const (
	CreateDataResultCodeSuccess     CreateDataResultCode = 0
	CreateDataResultCodeInvalidData CreateDataResultCode = -1
)

var CreateDataResultCodeAll = []CreateDataResultCode{
	CreateDataResultCodeSuccess,
	CreateDataResultCodeInvalidData,
}

var createDataResultCodeMap = map[int32]string{
	0:  "CreateDataResultCodeSuccess",
	-1: "CreateDataResultCodeInvalidData",
}

var createDataResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "invalid_data",
}

var createDataResultCodeRevMap = map[string]int32{
	"CreateDataResultCodeSuccess":     0,
	"CreateDataResultCodeInvalidData": -1,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CreateDataResultCode
func (e CreateDataResultCode) ValidEnum(v int32) bool {
	_, ok := createDataResultCodeMap[v]
	return ok
}
func (e CreateDataResultCode) isFlag() bool {
	for i := len(CreateDataResultCodeAll) - 1; i >= 0; i-- {
		expected := CreateDataResultCode(2) << uint64(len(CreateDataResultCodeAll)-1) >> uint64(len(CreateDataResultCodeAll)-i)
		if expected != CreateDataResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CreateDataResultCode) String() string {
	name, _ := createDataResultCodeMap[int32(e)]
	return name
}

func (e CreateDataResultCode) ShortString() string {
	name, _ := createDataResultCodeShortMap[int32(e)]
	return name
}

func (e CreateDataResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CreateDataResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CreateDataResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CreateDataResultCode(t.Value)
	return nil
}

// CreateDataSuccess is an XDR Struct defines as:
//
//   struct CreateDataSuccess
//    {
//        //: ID of created data entry
//        uint64 dataID;
//        //: Reserved for future extension
//        EmptyExt ext;
//    };
//
type CreateDataSuccess struct {
	DataId Uint64   `json:"dataID,omitempty"`
	Ext    EmptyExt `json:"ext,omitempty"`
}

// CreateDataResult is an XDR Union defines as:
//
//   //: Result of operation application
//    union CreateDataResult switch (CreateDataResultCode code)
//    {
//        case SUCCESS:
//            //: Result of successful operation application
//            CreateDataSuccess success;
//        default:
//            void;
//    };
//
type CreateDataResult struct {
	Code    CreateDataResultCode `json:"code,omitempty"`
	Success *CreateDataSuccess   `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateDataResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateDataResult
func (u CreateDataResult) ArmForSwitch(sw int32) (string, bool) {
	switch CreateDataResultCode(sw) {
	case CreateDataResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewCreateDataResult creates a new  CreateDataResult.
func NewCreateDataResult(code CreateDataResultCode, value interface{}) (result CreateDataResult, err error) {
	result.Code = code
	switch CreateDataResultCode(code) {
	case CreateDataResultCodeSuccess:
		tv, ok := value.(CreateDataSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateDataSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CreateDataResult) MustSuccess() CreateDataSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CreateDataResult) GetSuccess() (result CreateDataSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// CreateDeferredPaymentCreationRequestOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateDeferredPaymentCreationRequestOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateDeferredPaymentCreationRequestOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateDeferredPaymentCreationRequestOpExt
func (u CreateDeferredPaymentCreationRequestOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateDeferredPaymentCreationRequestOpExt creates a new  CreateDeferredPaymentCreationRequestOpExt.
func NewCreateDeferredPaymentCreationRequestOpExt(v LedgerVersion, value interface{}) (result CreateDeferredPaymentCreationRequestOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateDeferredPaymentCreationRequestOp is an XDR Struct defines as:
//
//   //: CreateDeferredPaymentCreationRequestOp is used to create `CREATE_DEFERRED_PAYMENT` request
//    struct CreateDeferredPaymentCreationRequestOp
//    {
//
//        uint64 requestID;
//        //: Body of request which will be created
//        CreateDeferredPaymentRequest request;
//
//        //: (optional) Bit mask whose flags must be cleared in order for `CREATE_ATOMIC_SWAP_BID` request to be approved,
//        //: which will be used instead of key-value by `create_deferred_payment_creation_request_tasks` key
//        uint32* allTasks;
//        //: reserved for the future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CreateDeferredPaymentCreationRequestOp struct {
	RequestId Uint64                                    `json:"requestID,omitempty"`
	Request   CreateDeferredPaymentRequest              `json:"request,omitempty"`
	AllTasks  *Uint32                                   `json:"allTasks,omitempty"`
	Ext       CreateDeferredPaymentCreationRequestOpExt `json:"ext,omitempty"`
}

// CreateDeferredPaymentCreationRequestResultCode is an XDR Enum defines as:
//
//   //: Result codes of CreateAtomicSwapBidRequestOp
//    enum CreateDeferredPaymentCreationRequestResultCode
//    {
//        //: `CREATE_DEFERRED_PAYMENT` request has either been successfully created
//        //: or auto approved
//        SUCCESS = 0,
//
//        SOURCE_BALANCE_NOT_FOUND = -1,
//        DESTINATION_ACCOUNT_NOT_FOUND = -2,
//        INCORRECT_PRECISION = -3,
//        UNDERFUNDED = -4,
//        TASKS_NOT_FOUND = -5,
//        INVALID_CREATOR_DETAILS = -6,
//        INVALID_AMOUNT = -7,
//        REQUEST_NOT_FOUND = -8
//    };
//
type CreateDeferredPaymentCreationRequestResultCode int32

const (
	CreateDeferredPaymentCreationRequestResultCodeSuccess                    CreateDeferredPaymentCreationRequestResultCode = 0
	CreateDeferredPaymentCreationRequestResultCodeSourceBalanceNotFound      CreateDeferredPaymentCreationRequestResultCode = -1
	CreateDeferredPaymentCreationRequestResultCodeDestinationAccountNotFound CreateDeferredPaymentCreationRequestResultCode = -2
	CreateDeferredPaymentCreationRequestResultCodeIncorrectPrecision         CreateDeferredPaymentCreationRequestResultCode = -3
	CreateDeferredPaymentCreationRequestResultCodeUnderfunded                CreateDeferredPaymentCreationRequestResultCode = -4
	CreateDeferredPaymentCreationRequestResultCodeTasksNotFound              CreateDeferredPaymentCreationRequestResultCode = -5
	CreateDeferredPaymentCreationRequestResultCodeInvalidCreatorDetails      CreateDeferredPaymentCreationRequestResultCode = -6
	CreateDeferredPaymentCreationRequestResultCodeInvalidAmount              CreateDeferredPaymentCreationRequestResultCode = -7
	CreateDeferredPaymentCreationRequestResultCodeRequestNotFound            CreateDeferredPaymentCreationRequestResultCode = -8
)

var CreateDeferredPaymentCreationRequestResultCodeAll = []CreateDeferredPaymentCreationRequestResultCode{
	CreateDeferredPaymentCreationRequestResultCodeSuccess,
	CreateDeferredPaymentCreationRequestResultCodeSourceBalanceNotFound,
	CreateDeferredPaymentCreationRequestResultCodeDestinationAccountNotFound,
	CreateDeferredPaymentCreationRequestResultCodeIncorrectPrecision,
	CreateDeferredPaymentCreationRequestResultCodeUnderfunded,
	CreateDeferredPaymentCreationRequestResultCodeTasksNotFound,
	CreateDeferredPaymentCreationRequestResultCodeInvalidCreatorDetails,
	CreateDeferredPaymentCreationRequestResultCodeInvalidAmount,
	CreateDeferredPaymentCreationRequestResultCodeRequestNotFound,
}

var createDeferredPaymentCreationRequestResultCodeMap = map[int32]string{
	0:  "CreateDeferredPaymentCreationRequestResultCodeSuccess",
	-1: "CreateDeferredPaymentCreationRequestResultCodeSourceBalanceNotFound",
	-2: "CreateDeferredPaymentCreationRequestResultCodeDestinationAccountNotFound",
	-3: "CreateDeferredPaymentCreationRequestResultCodeIncorrectPrecision",
	-4: "CreateDeferredPaymentCreationRequestResultCodeUnderfunded",
	-5: "CreateDeferredPaymentCreationRequestResultCodeTasksNotFound",
	-6: "CreateDeferredPaymentCreationRequestResultCodeInvalidCreatorDetails",
	-7: "CreateDeferredPaymentCreationRequestResultCodeInvalidAmount",
	-8: "CreateDeferredPaymentCreationRequestResultCodeRequestNotFound",
}

var createDeferredPaymentCreationRequestResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "source_balance_not_found",
	-2: "destination_account_not_found",
	-3: "incorrect_precision",
	-4: "underfunded",
	-5: "tasks_not_found",
	-6: "invalid_creator_details",
	-7: "invalid_amount",
	-8: "request_not_found",
}

var createDeferredPaymentCreationRequestResultCodeRevMap = map[string]int32{
	"CreateDeferredPaymentCreationRequestResultCodeSuccess":                    0,
	"CreateDeferredPaymentCreationRequestResultCodeSourceBalanceNotFound":      -1,
	"CreateDeferredPaymentCreationRequestResultCodeDestinationAccountNotFound": -2,
	"CreateDeferredPaymentCreationRequestResultCodeIncorrectPrecision":         -3,
	"CreateDeferredPaymentCreationRequestResultCodeUnderfunded":                -4,
	"CreateDeferredPaymentCreationRequestResultCodeTasksNotFound":              -5,
	"CreateDeferredPaymentCreationRequestResultCodeInvalidCreatorDetails":      -6,
	"CreateDeferredPaymentCreationRequestResultCodeInvalidAmount":              -7,
	"CreateDeferredPaymentCreationRequestResultCodeRequestNotFound":            -8,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CreateDeferredPaymentCreationRequestResultCode
func (e CreateDeferredPaymentCreationRequestResultCode) ValidEnum(v int32) bool {
	_, ok := createDeferredPaymentCreationRequestResultCodeMap[v]
	return ok
}
func (e CreateDeferredPaymentCreationRequestResultCode) isFlag() bool {
	for i := len(CreateDeferredPaymentCreationRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := CreateDeferredPaymentCreationRequestResultCode(2) << uint64(len(CreateDeferredPaymentCreationRequestResultCodeAll)-1) >> uint64(len(CreateDeferredPaymentCreationRequestResultCodeAll)-i)
		if expected != CreateDeferredPaymentCreationRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CreateDeferredPaymentCreationRequestResultCode) String() string {
	name, _ := createDeferredPaymentCreationRequestResultCodeMap[int32(e)]
	return name
}

func (e CreateDeferredPaymentCreationRequestResultCode) ShortString() string {
	name, _ := createDeferredPaymentCreationRequestResultCodeShortMap[int32(e)]
	return name
}

func (e CreateDeferredPaymentCreationRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CreateDeferredPaymentCreationRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CreateDeferredPaymentCreationRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CreateDeferredPaymentCreationRequestResultCode(t.Value)
	return nil
}

// CreateDeferredPaymentCreationRequestSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateDeferredPaymentCreationRequestSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateDeferredPaymentCreationRequestSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateDeferredPaymentCreationRequestSuccessExt
func (u CreateDeferredPaymentCreationRequestSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateDeferredPaymentCreationRequestSuccessExt creates a new  CreateDeferredPaymentCreationRequestSuccessExt.
func NewCreateDeferredPaymentCreationRequestSuccessExt(v LedgerVersion, value interface{}) (result CreateDeferredPaymentCreationRequestSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateDeferredPaymentCreationRequestSuccess is an XDR Struct defines as:
//
//   //: Success result of CreateASwapAskCreationRequestOp application
//    struct CreateDeferredPaymentCreationRequestSuccess
//    {
//        //: id of created request
//        uint64 requestID;
//        //: Indicates whether or not the `CREATE_ATOMIC_SWAP_ASK` request was auto approved and fulfilled
//        bool fulfilled;
//        //: ID of a newly created ask (if the ask  creation request has been auto approved)
//        uint64 deferredPaymentID;
//
//        //: reserved for the future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type CreateDeferredPaymentCreationRequestSuccess struct {
	RequestId         Uint64                                         `json:"requestID,omitempty"`
	Fulfilled         bool                                           `json:"fulfilled,omitempty"`
	DeferredPaymentId Uint64                                         `json:"deferredPaymentID,omitempty"`
	Ext               CreateDeferredPaymentCreationRequestSuccessExt `json:"ext,omitempty"`
}

// CreateDeferredPaymentCreationRequestResult is an XDR Union defines as:
//
//   //: Result of CreateDeferredPaymentCreationRequestOp application
//    union CreateDeferredPaymentCreationRequestResult switch (CreateDeferredPaymentCreationRequestResultCode code)
//    {
//    case SUCCESS:
//        //: is used to pass useful fields after successful operation applying
//        CreateDeferredPaymentCreationRequestSuccess success;
//    default:
//        void;
//    };
//
type CreateDeferredPaymentCreationRequestResult struct {
	Code    CreateDeferredPaymentCreationRequestResultCode `json:"code,omitempty"`
	Success *CreateDeferredPaymentCreationRequestSuccess   `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateDeferredPaymentCreationRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateDeferredPaymentCreationRequestResult
func (u CreateDeferredPaymentCreationRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch CreateDeferredPaymentCreationRequestResultCode(sw) {
	case CreateDeferredPaymentCreationRequestResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewCreateDeferredPaymentCreationRequestResult creates a new  CreateDeferredPaymentCreationRequestResult.
func NewCreateDeferredPaymentCreationRequestResult(code CreateDeferredPaymentCreationRequestResultCode, value interface{}) (result CreateDeferredPaymentCreationRequestResult, err error) {
	result.Code = code
	switch CreateDeferredPaymentCreationRequestResultCode(code) {
	case CreateDeferredPaymentCreationRequestResultCodeSuccess:
		tv, ok := value.(CreateDeferredPaymentCreationRequestSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateDeferredPaymentCreationRequestSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CreateDeferredPaymentCreationRequestResult) MustSuccess() CreateDeferredPaymentCreationRequestSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CreateDeferredPaymentCreationRequestResult) GetSuccess() (result CreateDeferredPaymentCreationRequestSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// CreateIssuanceRequestOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateIssuanceRequestOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateIssuanceRequestOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateIssuanceRequestOpExt
func (u CreateIssuanceRequestOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateIssuanceRequestOpExt creates a new  CreateIssuanceRequestOpExt.
func NewCreateIssuanceRequestOpExt(v LedgerVersion, value interface{}) (result CreateIssuanceRequestOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateIssuanceRequestOp is an XDR Struct defines as:
//
//   //: CreateIssuanceRequestOp is used to create a reviewable request that, after reviewer's approval,
//    //: will issue the specified amount of asset to a receiver's balance
//    struct CreateIssuanceRequestOp
//    {
//        //: Issuance request to create
//        IssuanceRequest request;
//        //: Reference of the request
//        string64 reference;
//        //: (optional) Bit mask whose flags must be cleared in order for IssuanceRequest to be approved, which will be used by key issuance_tasks:<asset_code>
//        //: instead of key-value
//        uint32* allTasks;
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CreateIssuanceRequestOp struct {
	Request   IssuanceRequest            `json:"request,omitempty"`
	Reference String64                   `json:"reference,omitempty"`
	AllTasks  *Uint32                    `json:"allTasks,omitempty"`
	Ext       CreateIssuanceRequestOpExt `json:"ext,omitempty"`
}

// CreateIssuanceRequestResultCode is an XDR Enum defines as:
//
//   //: Result codes of the CreateIssuanceRequestOp
//    enum CreateIssuanceRequestResultCode
//    {
//        // codes considered as "success" for the operation
//        //: CreateIssuanceRequest operation application was successful
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: Asset to issue is not found
//        ASSET_NOT_FOUND = -1,
//        //: Trying to create an issuance request with negative/zero amount
//        INVALID_AMOUNT = -2,
//        //: Request with the same reference already exists
//        REFERENCE_DUPLICATION = -3,
//        //: Either the target balance is not found or there is a mismatch between the target balance asset and an asset in the request
//        NO_COUNTERPARTY = -4,
//        //: Source of operation is not an owner of the asset
//        NOT_AUTHORIZED = -5,
//        //: Issued amount plus amount to issue will exceed max issuance amount
//        EXCEEDS_MAX_ISSUANCE_AMOUNT = -6,
//        //: Amount to issue plus amount on balance would exceed UINT64_MAX
//        RECEIVER_FULL_LINE = -7,
//        //: Creator details are not valid JSON
//        INVALID_CREATOR_DETAILS = -8,
//        //: Fee is greater than the amount to issue
//        FEE_EXCEEDS_AMOUNT = -9,
//        //: Deprecated
//        REQUIRES_KYC = -10,
//        //: Deprecated
//        REQUIRES_VERIFICATION = -11, //asset requires receiver to be verified
//        //: Issuance tasks are not set in the system (i.e. performing issuance is not allowed)
//        ISSUANCE_TASKS_NOT_FOUND = -12,
//        //: It is not allowed to set system tasks: 1, 2, 4
//        SYSTEM_TASKS_NOT_ALLOWED = -13,
//        //: Amount precision and asset precision are mismatched
//        INVALID_AMOUNT_PRECISION = -14
//    };
//
type CreateIssuanceRequestResultCode int32

const (
	CreateIssuanceRequestResultCodeSuccess                  CreateIssuanceRequestResultCode = 0
	CreateIssuanceRequestResultCodeAssetNotFound            CreateIssuanceRequestResultCode = -1
	CreateIssuanceRequestResultCodeInvalidAmount            CreateIssuanceRequestResultCode = -2
	CreateIssuanceRequestResultCodeReferenceDuplication     CreateIssuanceRequestResultCode = -3
	CreateIssuanceRequestResultCodeNoCounterparty           CreateIssuanceRequestResultCode = -4
	CreateIssuanceRequestResultCodeNotAuthorized            CreateIssuanceRequestResultCode = -5
	CreateIssuanceRequestResultCodeExceedsMaxIssuanceAmount CreateIssuanceRequestResultCode = -6
	CreateIssuanceRequestResultCodeReceiverFullLine         CreateIssuanceRequestResultCode = -7
	CreateIssuanceRequestResultCodeInvalidCreatorDetails    CreateIssuanceRequestResultCode = -8
	CreateIssuanceRequestResultCodeFeeExceedsAmount         CreateIssuanceRequestResultCode = -9
	CreateIssuanceRequestResultCodeRequiresKyc              CreateIssuanceRequestResultCode = -10
	CreateIssuanceRequestResultCodeRequiresVerification     CreateIssuanceRequestResultCode = -11
	CreateIssuanceRequestResultCodeIssuanceTasksNotFound    CreateIssuanceRequestResultCode = -12
	CreateIssuanceRequestResultCodeSystemTasksNotAllowed    CreateIssuanceRequestResultCode = -13
	CreateIssuanceRequestResultCodeInvalidAmountPrecision   CreateIssuanceRequestResultCode = -14
)

var CreateIssuanceRequestResultCodeAll = []CreateIssuanceRequestResultCode{
	CreateIssuanceRequestResultCodeSuccess,
	CreateIssuanceRequestResultCodeAssetNotFound,
	CreateIssuanceRequestResultCodeInvalidAmount,
	CreateIssuanceRequestResultCodeReferenceDuplication,
	CreateIssuanceRequestResultCodeNoCounterparty,
	CreateIssuanceRequestResultCodeNotAuthorized,
	CreateIssuanceRequestResultCodeExceedsMaxIssuanceAmount,
	CreateIssuanceRequestResultCodeReceiverFullLine,
	CreateIssuanceRequestResultCodeInvalidCreatorDetails,
	CreateIssuanceRequestResultCodeFeeExceedsAmount,
	CreateIssuanceRequestResultCodeRequiresKyc,
	CreateIssuanceRequestResultCodeRequiresVerification,
	CreateIssuanceRequestResultCodeIssuanceTasksNotFound,
	CreateIssuanceRequestResultCodeSystemTasksNotAllowed,
	CreateIssuanceRequestResultCodeInvalidAmountPrecision,
}

var createIssuanceRequestResultCodeMap = map[int32]string{
	0:   "CreateIssuanceRequestResultCodeSuccess",
	-1:  "CreateIssuanceRequestResultCodeAssetNotFound",
	-2:  "CreateIssuanceRequestResultCodeInvalidAmount",
	-3:  "CreateIssuanceRequestResultCodeReferenceDuplication",
	-4:  "CreateIssuanceRequestResultCodeNoCounterparty",
	-5:  "CreateIssuanceRequestResultCodeNotAuthorized",
	-6:  "CreateIssuanceRequestResultCodeExceedsMaxIssuanceAmount",
	-7:  "CreateIssuanceRequestResultCodeReceiverFullLine",
	-8:  "CreateIssuanceRequestResultCodeInvalidCreatorDetails",
	-9:  "CreateIssuanceRequestResultCodeFeeExceedsAmount",
	-10: "CreateIssuanceRequestResultCodeRequiresKyc",
	-11: "CreateIssuanceRequestResultCodeRequiresVerification",
	-12: "CreateIssuanceRequestResultCodeIssuanceTasksNotFound",
	-13: "CreateIssuanceRequestResultCodeSystemTasksNotAllowed",
	-14: "CreateIssuanceRequestResultCodeInvalidAmountPrecision",
}

var createIssuanceRequestResultCodeShortMap = map[int32]string{
	0:   "success",
	-1:  "asset_not_found",
	-2:  "invalid_amount",
	-3:  "reference_duplication",
	-4:  "no_counterparty",
	-5:  "not_authorized",
	-6:  "exceeds_max_issuance_amount",
	-7:  "receiver_full_line",
	-8:  "invalid_creator_details",
	-9:  "fee_exceeds_amount",
	-10: "requires_kyc",
	-11: "requires_verification",
	-12: "issuance_tasks_not_found",
	-13: "system_tasks_not_allowed",
	-14: "invalid_amount_precision",
}

var createIssuanceRequestResultCodeRevMap = map[string]int32{
	"CreateIssuanceRequestResultCodeSuccess":                  0,
	"CreateIssuanceRequestResultCodeAssetNotFound":            -1,
	"CreateIssuanceRequestResultCodeInvalidAmount":            -2,
	"CreateIssuanceRequestResultCodeReferenceDuplication":     -3,
	"CreateIssuanceRequestResultCodeNoCounterparty":           -4,
	"CreateIssuanceRequestResultCodeNotAuthorized":            -5,
	"CreateIssuanceRequestResultCodeExceedsMaxIssuanceAmount": -6,
	"CreateIssuanceRequestResultCodeReceiverFullLine":         -7,
	"CreateIssuanceRequestResultCodeInvalidCreatorDetails":    -8,
	"CreateIssuanceRequestResultCodeFeeExceedsAmount":         -9,
	"CreateIssuanceRequestResultCodeRequiresKyc":              -10,
	"CreateIssuanceRequestResultCodeRequiresVerification":     -11,
	"CreateIssuanceRequestResultCodeIssuanceTasksNotFound":    -12,
	"CreateIssuanceRequestResultCodeSystemTasksNotAllowed":    -13,
	"CreateIssuanceRequestResultCodeInvalidAmountPrecision":   -14,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CreateIssuanceRequestResultCode
func (e CreateIssuanceRequestResultCode) ValidEnum(v int32) bool {
	_, ok := createIssuanceRequestResultCodeMap[v]
	return ok
}
func (e CreateIssuanceRequestResultCode) isFlag() bool {
	for i := len(CreateIssuanceRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := CreateIssuanceRequestResultCode(2) << uint64(len(CreateIssuanceRequestResultCodeAll)-1) >> uint64(len(CreateIssuanceRequestResultCodeAll)-i)
		if expected != CreateIssuanceRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CreateIssuanceRequestResultCode) String() string {
	name, _ := createIssuanceRequestResultCodeMap[int32(e)]
	return name
}

func (e CreateIssuanceRequestResultCode) ShortString() string {
	name, _ := createIssuanceRequestResultCodeShortMap[int32(e)]
	return name
}

func (e CreateIssuanceRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CreateIssuanceRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CreateIssuanceRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CreateIssuanceRequestResultCode(t.Value)
	return nil
}

// CreateIssuanceRequestSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateIssuanceRequestSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateIssuanceRequestSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateIssuanceRequestSuccessExt
func (u CreateIssuanceRequestSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateIssuanceRequestSuccessExt creates a new  CreateIssuanceRequestSuccessExt.
func NewCreateIssuanceRequestSuccessExt(v LedgerVersion, value interface{}) (result CreateIssuanceRequestSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateIssuanceRequestSuccess is an XDR Struct defines as:
//
//   //:Result of successful application of CreateIssuanceRequest operation
//    struct CreateIssuanceRequestSuccess {
//        //: ID of a newly created issuance request
//        uint64 requestID;
//        //: Account address of the receiver
//        AccountID receiver;
//        //: Indicates whether or not the Issuance request was auto approved and fulfilled
//        bool fulfilled;
//        //: Paid fee
//        Fee fee;
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CreateIssuanceRequestSuccess struct {
	RequestId Uint64                          `json:"requestID,omitempty"`
	Receiver  AccountId                       `json:"receiver,omitempty"`
	Fulfilled bool                            `json:"fulfilled,omitempty"`
	Fee       Fee                             `json:"fee,omitempty"`
	Ext       CreateIssuanceRequestSuccessExt `json:"ext,omitempty"`
}

// CreateIssuanceRequestResult is an XDR Union defines as:
//
//   //: Create issuance request result with result code
//    union CreateIssuanceRequestResult switch (CreateIssuanceRequestResultCode code)
//    {
//    case SUCCESS:
//        CreateIssuanceRequestSuccess success;
//    default:
//        void;
//    };
//
type CreateIssuanceRequestResult struct {
	Code    CreateIssuanceRequestResultCode `json:"code,omitempty"`
	Success *CreateIssuanceRequestSuccess   `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateIssuanceRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateIssuanceRequestResult
func (u CreateIssuanceRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch CreateIssuanceRequestResultCode(sw) {
	case CreateIssuanceRequestResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewCreateIssuanceRequestResult creates a new  CreateIssuanceRequestResult.
func NewCreateIssuanceRequestResult(code CreateIssuanceRequestResultCode, value interface{}) (result CreateIssuanceRequestResult, err error) {
	result.Code = code
	switch CreateIssuanceRequestResultCode(code) {
	case CreateIssuanceRequestResultCodeSuccess:
		tv, ok := value.(CreateIssuanceRequestSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateIssuanceRequestSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CreateIssuanceRequestResult) MustSuccess() CreateIssuanceRequestSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CreateIssuanceRequestResult) GetSuccess() (result CreateIssuanceRequestSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// CreateKycRecoveryRequestOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateKycRecoveryRequestOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateKycRecoveryRequestOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateKycRecoveryRequestOpExt
func (u CreateKycRecoveryRequestOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateKycRecoveryRequestOpExt creates a new  CreateKycRecoveryRequestOpExt.
func NewCreateKycRecoveryRequestOpExt(v LedgerVersion, value interface{}) (result CreateKycRecoveryRequestOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateKycRecoveryRequestOp is an XDR Struct defines as:
//
//   //: CreateKYCRecoveryRequestOp to create KYC recovery request and set new signers for account
//    struct CreateKYCRecoveryRequestOp
//    {
//        //: ID of a reviewable request. If set 0, request is created, else - request is updated
//        uint64 requestID;
//        //: Account for which signers will be set
//        AccountID targetAccount;
//        //: New signers to set
//        UpdateSignerData signersData<>;
//
//         //: Arbitrary stringified json object that can be used to attach data to be reviewed by an admin
//        longstring creatorDetails; // details set by requester
//
//        //: (optional) Bit mask whose flags must be cleared in order for KYC recovery request to be approved, which will be used by key `create_kyc_recovery_tasks`
//        //: instead of key-value
//        uint32* allTasks;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type CreateKycRecoveryRequestOp struct {
	RequestId      Uint64                        `json:"requestID,omitempty"`
	TargetAccount  AccountId                     `json:"targetAccount,omitempty"`
	SignersData    []UpdateSignerData            `json:"signersData,omitempty"`
	CreatorDetails Longstring                    `json:"creatorDetails,omitempty"`
	AllTasks       *Uint32                       `json:"allTasks,omitempty"`
	Ext            CreateKycRecoveryRequestOpExt `json:"ext,omitempty"`
}

// CreateKycRecoveryRequestResultCode is an XDR Enum defines as:
//
//   //: Result codes of CreateKYCRecoveryRequestOp
//    enum CreateKYCRecoveryRequestResultCode
//    {
//        //: KYC Recovery request was successfully created
//        SUCCESS = 0,
//
//        //: Creator details are not in a valid JSON format
//        INVALID_CREATOR_DETAILS = -1,
//        //: KYC recovery tasks are not set in the system
//        KYC_RECOVERY_TASKS_NOT_FOUND = -2,
//        //: Not allowed to provide empty slice of signers
//        NO_SIGNER_DATA = -3,
//        //: SignerData contains duplicates
//        SIGNER_DUPLICATION = -4,
//        //: Signer has weight > threshold
//        INVALID_WEIGHT = -5,
//        //: Signer has invalid details
//        INVALID_DETAILS = -6,
//        //: Request with provided parameters already exists
//        REQUEST_ALREADY_EXISTS = -7,
//        //: Account with provided account address does not exist
//        TARGET_ACCOUNT_NOT_FOUND = -8,
//        //: System configuration forbids KYC recovery
//        RECOVERY_NOT_ALLOWED = -10,
//        //: Only target account can update request
//        NOT_ALLOWED_TO_UPDATE_REQUEST = -11,
//        //: There is no request with such ID
//        REQUEST_NOT_FOUND = -12,
//        //: It is forbidden to change target account on update
//        INVALID_UPDATE_DATA = -13,
//        //: It is forbidden to set `allTasks` on update
//        NOT_ALLOWED_TO_SET_TASKS_ON_UPDATE = -14
//    };
//
type CreateKycRecoveryRequestResultCode int32

const (
	CreateKycRecoveryRequestResultCodeSuccess                      CreateKycRecoveryRequestResultCode = 0
	CreateKycRecoveryRequestResultCodeInvalidCreatorDetails        CreateKycRecoveryRequestResultCode = -1
	CreateKycRecoveryRequestResultCodeKycRecoveryTasksNotFound     CreateKycRecoveryRequestResultCode = -2
	CreateKycRecoveryRequestResultCodeNoSignerData                 CreateKycRecoveryRequestResultCode = -3
	CreateKycRecoveryRequestResultCodeSignerDuplication            CreateKycRecoveryRequestResultCode = -4
	CreateKycRecoveryRequestResultCodeInvalidWeight                CreateKycRecoveryRequestResultCode = -5
	CreateKycRecoveryRequestResultCodeInvalidDetails               CreateKycRecoveryRequestResultCode = -6
	CreateKycRecoveryRequestResultCodeRequestAlreadyExists         CreateKycRecoveryRequestResultCode = -7
	CreateKycRecoveryRequestResultCodeTargetAccountNotFound        CreateKycRecoveryRequestResultCode = -8
	CreateKycRecoveryRequestResultCodeRecoveryNotAllowed           CreateKycRecoveryRequestResultCode = -10
	CreateKycRecoveryRequestResultCodeNotAllowedToUpdateRequest    CreateKycRecoveryRequestResultCode = -11
	CreateKycRecoveryRequestResultCodeRequestNotFound              CreateKycRecoveryRequestResultCode = -12
	CreateKycRecoveryRequestResultCodeInvalidUpdateData            CreateKycRecoveryRequestResultCode = -13
	CreateKycRecoveryRequestResultCodeNotAllowedToSetTasksOnUpdate CreateKycRecoveryRequestResultCode = -14
)

var CreateKycRecoveryRequestResultCodeAll = []CreateKycRecoveryRequestResultCode{
	CreateKycRecoveryRequestResultCodeSuccess,
	CreateKycRecoveryRequestResultCodeInvalidCreatorDetails,
	CreateKycRecoveryRequestResultCodeKycRecoveryTasksNotFound,
	CreateKycRecoveryRequestResultCodeNoSignerData,
	CreateKycRecoveryRequestResultCodeSignerDuplication,
	CreateKycRecoveryRequestResultCodeInvalidWeight,
	CreateKycRecoveryRequestResultCodeInvalidDetails,
	CreateKycRecoveryRequestResultCodeRequestAlreadyExists,
	CreateKycRecoveryRequestResultCodeTargetAccountNotFound,
	CreateKycRecoveryRequestResultCodeRecoveryNotAllowed,
	CreateKycRecoveryRequestResultCodeNotAllowedToUpdateRequest,
	CreateKycRecoveryRequestResultCodeRequestNotFound,
	CreateKycRecoveryRequestResultCodeInvalidUpdateData,
	CreateKycRecoveryRequestResultCodeNotAllowedToSetTasksOnUpdate,
}

var createKycRecoveryRequestResultCodeMap = map[int32]string{
	0:   "CreateKycRecoveryRequestResultCodeSuccess",
	-1:  "CreateKycRecoveryRequestResultCodeInvalidCreatorDetails",
	-2:  "CreateKycRecoveryRequestResultCodeKycRecoveryTasksNotFound",
	-3:  "CreateKycRecoveryRequestResultCodeNoSignerData",
	-4:  "CreateKycRecoveryRequestResultCodeSignerDuplication",
	-5:  "CreateKycRecoveryRequestResultCodeInvalidWeight",
	-6:  "CreateKycRecoveryRequestResultCodeInvalidDetails",
	-7:  "CreateKycRecoveryRequestResultCodeRequestAlreadyExists",
	-8:  "CreateKycRecoveryRequestResultCodeTargetAccountNotFound",
	-10: "CreateKycRecoveryRequestResultCodeRecoveryNotAllowed",
	-11: "CreateKycRecoveryRequestResultCodeNotAllowedToUpdateRequest",
	-12: "CreateKycRecoveryRequestResultCodeRequestNotFound",
	-13: "CreateKycRecoveryRequestResultCodeInvalidUpdateData",
	-14: "CreateKycRecoveryRequestResultCodeNotAllowedToSetTasksOnUpdate",
}

var createKycRecoveryRequestResultCodeShortMap = map[int32]string{
	0:   "success",
	-1:  "invalid_creator_details",
	-2:  "kyc_recovery_tasks_not_found",
	-3:  "no_signer_data",
	-4:  "signer_duplication",
	-5:  "invalid_weight",
	-6:  "invalid_details",
	-7:  "request_already_exists",
	-8:  "target_account_not_found",
	-10: "recovery_not_allowed",
	-11: "not_allowed_to_update_request",
	-12: "request_not_found",
	-13: "invalid_update_data",
	-14: "not_allowed_to_set_tasks_on_update",
}

var createKycRecoveryRequestResultCodeRevMap = map[string]int32{
	"CreateKycRecoveryRequestResultCodeSuccess":                      0,
	"CreateKycRecoveryRequestResultCodeInvalidCreatorDetails":        -1,
	"CreateKycRecoveryRequestResultCodeKycRecoveryTasksNotFound":     -2,
	"CreateKycRecoveryRequestResultCodeNoSignerData":                 -3,
	"CreateKycRecoveryRequestResultCodeSignerDuplication":            -4,
	"CreateKycRecoveryRequestResultCodeInvalidWeight":                -5,
	"CreateKycRecoveryRequestResultCodeInvalidDetails":               -6,
	"CreateKycRecoveryRequestResultCodeRequestAlreadyExists":         -7,
	"CreateKycRecoveryRequestResultCodeTargetAccountNotFound":        -8,
	"CreateKycRecoveryRequestResultCodeRecoveryNotAllowed":           -10,
	"CreateKycRecoveryRequestResultCodeNotAllowedToUpdateRequest":    -11,
	"CreateKycRecoveryRequestResultCodeRequestNotFound":              -12,
	"CreateKycRecoveryRequestResultCodeInvalidUpdateData":            -13,
	"CreateKycRecoveryRequestResultCodeNotAllowedToSetTasksOnUpdate": -14,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CreateKycRecoveryRequestResultCode
func (e CreateKycRecoveryRequestResultCode) ValidEnum(v int32) bool {
	_, ok := createKycRecoveryRequestResultCodeMap[v]
	return ok
}
func (e CreateKycRecoveryRequestResultCode) isFlag() bool {
	for i := len(CreateKycRecoveryRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := CreateKycRecoveryRequestResultCode(2) << uint64(len(CreateKycRecoveryRequestResultCodeAll)-1) >> uint64(len(CreateKycRecoveryRequestResultCodeAll)-i)
		if expected != CreateKycRecoveryRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CreateKycRecoveryRequestResultCode) String() string {
	name, _ := createKycRecoveryRequestResultCodeMap[int32(e)]
	return name
}

func (e CreateKycRecoveryRequestResultCode) ShortString() string {
	name, _ := createKycRecoveryRequestResultCodeShortMap[int32(e)]
	return name
}

func (e CreateKycRecoveryRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CreateKycRecoveryRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CreateKycRecoveryRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CreateKycRecoveryRequestResultCode(t.Value)
	return nil
}

// CreateKycRecoveryRequestResultSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type CreateKycRecoveryRequestResultSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateKycRecoveryRequestResultSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateKycRecoveryRequestResultSuccessExt
func (u CreateKycRecoveryRequestResultSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateKycRecoveryRequestResultSuccessExt creates a new  CreateKycRecoveryRequestResultSuccessExt.
func NewCreateKycRecoveryRequestResultSuccessExt(v LedgerVersion, value interface{}) (result CreateKycRecoveryRequestResultSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateKycRecoveryRequestResultSuccess is an XDR NestedStruct defines as:
//
//   struct {
//            //: id of the created request
//            uint64 requestID;
//
//            //: Indicates whether or not the KYC Recovery request was auto approved and fulfilled
//            bool fulfilled;
//
//            //: reserved for future use
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        }
//
type CreateKycRecoveryRequestResultSuccess struct {
	RequestId Uint64                                   `json:"requestID,omitempty"`
	Fulfilled bool                                     `json:"fulfilled,omitempty"`
	Ext       CreateKycRecoveryRequestResultSuccessExt `json:"ext,omitempty"`
}

// CreateKycRecoveryRequestResult is an XDR Union defines as:
//
//   //: Result of operation applying
//    union CreateKYCRecoveryRequestResult switch (CreateKYCRecoveryRequestResultCode code)
//    {
//    case SUCCESS:
//        //: Is used to pass useful params if operation is success
//        struct {
//            //: id of the created request
//            uint64 requestID;
//
//            //: Indicates whether or not the KYC Recovery request was auto approved and fulfilled
//            bool fulfilled;
//
//            //: reserved for future use
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        } success;
//    default:
//        void;
//    };
//
type CreateKycRecoveryRequestResult struct {
	Code    CreateKycRecoveryRequestResultCode     `json:"code,omitempty"`
	Success *CreateKycRecoveryRequestResultSuccess `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateKycRecoveryRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateKycRecoveryRequestResult
func (u CreateKycRecoveryRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch CreateKycRecoveryRequestResultCode(sw) {
	case CreateKycRecoveryRequestResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewCreateKycRecoveryRequestResult creates a new  CreateKycRecoveryRequestResult.
func NewCreateKycRecoveryRequestResult(code CreateKycRecoveryRequestResultCode, value interface{}) (result CreateKycRecoveryRequestResult, err error) {
	result.Code = code
	switch CreateKycRecoveryRequestResultCode(code) {
	case CreateKycRecoveryRequestResultCodeSuccess:
		tv, ok := value.(CreateKycRecoveryRequestResultSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateKycRecoveryRequestResultSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CreateKycRecoveryRequestResult) MustSuccess() CreateKycRecoveryRequestResultSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CreateKycRecoveryRequestResult) GetSuccess() (result CreateKycRecoveryRequestResultSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// CreateManageLimitsRequestOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateManageLimitsRequestOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateManageLimitsRequestOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateManageLimitsRequestOpExt
func (u CreateManageLimitsRequestOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateManageLimitsRequestOpExt creates a new  CreateManageLimitsRequestOpExt.
func NewCreateManageLimitsRequestOpExt(v LedgerVersion, value interface{}) (result CreateManageLimitsRequestOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateManageLimitsRequestOp is an XDR Struct defines as:
//
//   //: CreateManageLimitsRequestOp is used to create a reviewable request which, after approval, will update the limits set in the system
//    struct CreateManageLimitsRequestOp
//    {
//        //: Body of the `UpdateLimits` reviewable request to be created
//        LimitsUpdateRequest manageLimitsRequest;
//
//        //: (optional) Bit mask whose flags must be cleared in order for ManageLimits request to be approved, which will be used instead of value from the key-value pair
//        //: by key `limits_update_tasks`
//        uint32* allTasks;
//        //: ID of the LimitsUpdateRequest
//        //: If `requestID == 0`, operation creates a new limits entry; otherwise, it updates the existing one
//        uint64 requestID;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type CreateManageLimitsRequestOp struct {
	ManageLimitsRequest LimitsUpdateRequest            `json:"manageLimitsRequest,omitempty"`
	AllTasks            *Uint32                        `json:"allTasks,omitempty"`
	RequestId           Uint64                         `json:"requestID,omitempty"`
	Ext                 CreateManageLimitsRequestOpExt `json:"ext,omitempty"`
}

// CreateManageLimitsRequestResultCode is an XDR Enum defines as:
//
//   //: Result codes for CreateManageLimitsRequest operation
//    enum CreateManageLimitsRequestResultCode
//    {
//        // codes considered as "success" for the operation
//        //: Operation was successfully applied and ManageLimitsRequest was successfully created
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: There is another manage limits request for the source account
//        MANAGE_LIMITS_REQUEST_REFERENCE_DUPLICATION = -1,
//        //: There is no request with such ID
//        MANAGE_LIMITS_REQUEST_NOT_FOUND = -2,
//        //: Details must be in a valid JSON format
//        INVALID_CREATOR_DETAILS = -3,
//        //: Tasks are not set in the system (i.e., it is not allowed to perform the limits update request)
//        LIMITS_UPDATE_TASKS_NOT_FOUND = -5,
//        //: Cannot set allTasks on the rejected request update
//        NOT_ALLOWED_TO_SET_TASKS_ON_UPDATE = -6,
//        //: 0 value is either not allowed for `allTasks` or for the value entry received by key `limits_update_tasks`
//        LIMITS_UPDATE_ZERO_TASKS_NOT_ALLOWED = -7
//    };
//
type CreateManageLimitsRequestResultCode int32

const (
	CreateManageLimitsRequestResultCodeSuccess                                 CreateManageLimitsRequestResultCode = 0
	CreateManageLimitsRequestResultCodeManageLimitsRequestReferenceDuplication CreateManageLimitsRequestResultCode = -1
	CreateManageLimitsRequestResultCodeManageLimitsRequestNotFound             CreateManageLimitsRequestResultCode = -2
	CreateManageLimitsRequestResultCodeInvalidCreatorDetails                   CreateManageLimitsRequestResultCode = -3
	CreateManageLimitsRequestResultCodeLimitsUpdateTasksNotFound               CreateManageLimitsRequestResultCode = -5
	CreateManageLimitsRequestResultCodeNotAllowedToSetTasksOnUpdate            CreateManageLimitsRequestResultCode = -6
	CreateManageLimitsRequestResultCodeLimitsUpdateZeroTasksNotAllowed         CreateManageLimitsRequestResultCode = -7
)

var CreateManageLimitsRequestResultCodeAll = []CreateManageLimitsRequestResultCode{
	CreateManageLimitsRequestResultCodeSuccess,
	CreateManageLimitsRequestResultCodeManageLimitsRequestReferenceDuplication,
	CreateManageLimitsRequestResultCodeManageLimitsRequestNotFound,
	CreateManageLimitsRequestResultCodeInvalidCreatorDetails,
	CreateManageLimitsRequestResultCodeLimitsUpdateTasksNotFound,
	CreateManageLimitsRequestResultCodeNotAllowedToSetTasksOnUpdate,
	CreateManageLimitsRequestResultCodeLimitsUpdateZeroTasksNotAllowed,
}

var createManageLimitsRequestResultCodeMap = map[int32]string{
	0:  "CreateManageLimitsRequestResultCodeSuccess",
	-1: "CreateManageLimitsRequestResultCodeManageLimitsRequestReferenceDuplication",
	-2: "CreateManageLimitsRequestResultCodeManageLimitsRequestNotFound",
	-3: "CreateManageLimitsRequestResultCodeInvalidCreatorDetails",
	-5: "CreateManageLimitsRequestResultCodeLimitsUpdateTasksNotFound",
	-6: "CreateManageLimitsRequestResultCodeNotAllowedToSetTasksOnUpdate",
	-7: "CreateManageLimitsRequestResultCodeLimitsUpdateZeroTasksNotAllowed",
}

var createManageLimitsRequestResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "manage_limits_request_reference_duplication",
	-2: "manage_limits_request_not_found",
	-3: "invalid_creator_details",
	-5: "limits_update_tasks_not_found",
	-6: "not_allowed_to_set_tasks_on_update",
	-7: "limits_update_zero_tasks_not_allowed",
}

var createManageLimitsRequestResultCodeRevMap = map[string]int32{
	"CreateManageLimitsRequestResultCodeSuccess":                                 0,
	"CreateManageLimitsRequestResultCodeManageLimitsRequestReferenceDuplication": -1,
	"CreateManageLimitsRequestResultCodeManageLimitsRequestNotFound":             -2,
	"CreateManageLimitsRequestResultCodeInvalidCreatorDetails":                   -3,
	"CreateManageLimitsRequestResultCodeLimitsUpdateTasksNotFound":               -5,
	"CreateManageLimitsRequestResultCodeNotAllowedToSetTasksOnUpdate":            -6,
	"CreateManageLimitsRequestResultCodeLimitsUpdateZeroTasksNotAllowed":         -7,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CreateManageLimitsRequestResultCode
func (e CreateManageLimitsRequestResultCode) ValidEnum(v int32) bool {
	_, ok := createManageLimitsRequestResultCodeMap[v]
	return ok
}
func (e CreateManageLimitsRequestResultCode) isFlag() bool {
	for i := len(CreateManageLimitsRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := CreateManageLimitsRequestResultCode(2) << uint64(len(CreateManageLimitsRequestResultCodeAll)-1) >> uint64(len(CreateManageLimitsRequestResultCodeAll)-i)
		if expected != CreateManageLimitsRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CreateManageLimitsRequestResultCode) String() string {
	name, _ := createManageLimitsRequestResultCodeMap[int32(e)]
	return name
}

func (e CreateManageLimitsRequestResultCode) ShortString() string {
	name, _ := createManageLimitsRequestResultCodeShortMap[int32(e)]
	return name
}

func (e CreateManageLimitsRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CreateManageLimitsRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CreateManageLimitsRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CreateManageLimitsRequestResultCode(t.Value)
	return nil
}

// CreateManageLimitsRequestResultSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type CreateManageLimitsRequestResultSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateManageLimitsRequestResultSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateManageLimitsRequestResultSuccessExt
func (u CreateManageLimitsRequestResultSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateManageLimitsRequestResultSuccessExt creates a new  CreateManageLimitsRequestResultSuccessExt.
func NewCreateManageLimitsRequestResultSuccessExt(v LedgerVersion, value interface{}) (result CreateManageLimitsRequestResultSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateManageLimitsRequestResultSuccess is an XDR NestedStruct defines as:
//
//   struct {
//            //: ID of the created manage limits request
//            uint64 manageLimitsRequestID;
//            //: Indicates whether or not the `limits update request` request was auto approved and fulfilled
//            bool fulfilled;
//            //: reserved for future use
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        }
//
type CreateManageLimitsRequestResultSuccess struct {
	ManageLimitsRequestId Uint64                                    `json:"manageLimitsRequestID,omitempty"`
	Fulfilled             bool                                      `json:"fulfilled,omitempty"`
	Ext                   CreateManageLimitsRequestResultSuccessExt `json:"ext,omitempty"`
}

// CreateManageLimitsRequestResult is an XDR Union defines as:
//
//   //: `CreateManageLimitsRequestResult` represents the result of the `CreateManageLimitsRequestOp` with corresponding details based on given `CreateManageLimitsRequestResultCode`
//    union CreateManageLimitsRequestResult switch (CreateManageLimitsRequestResultCode code)
//    {
//    case SUCCESS:
//        struct {
//            //: ID of the created manage limits request
//            uint64 manageLimitsRequestID;
//            //: Indicates whether or not the `limits update request` request was auto approved and fulfilled
//            bool fulfilled;
//            //: reserved for future use
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        } success;
//    default:
//        void;
//    };
//
type CreateManageLimitsRequestResult struct {
	Code    CreateManageLimitsRequestResultCode     `json:"code,omitempty"`
	Success *CreateManageLimitsRequestResultSuccess `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateManageLimitsRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateManageLimitsRequestResult
func (u CreateManageLimitsRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch CreateManageLimitsRequestResultCode(sw) {
	case CreateManageLimitsRequestResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewCreateManageLimitsRequestResult creates a new  CreateManageLimitsRequestResult.
func NewCreateManageLimitsRequestResult(code CreateManageLimitsRequestResultCode, value interface{}) (result CreateManageLimitsRequestResult, err error) {
	result.Code = code
	switch CreateManageLimitsRequestResultCode(code) {
	case CreateManageLimitsRequestResultCodeSuccess:
		tv, ok := value.(CreateManageLimitsRequestResultSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateManageLimitsRequestResultSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CreateManageLimitsRequestResult) MustSuccess() CreateManageLimitsRequestResultSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CreateManageLimitsRequestResult) GetSuccess() (result CreateManageLimitsRequestResultSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// CreateManageOfferRequestOp is an XDR Struct defines as:
//
//   struct CreateManageOfferRequestOp
//    {
//        //: ManageOfferRequest details
//        ManageOfferRequest request;
//
//        //: (optional) Bit mask whose flags must be cleared in order for CreateSale request to be approved, which will be used by key sale_create_tasks:<asset_code>
//        //: instead of key-value
//        uint32* allTasks;
//
//        //: reserved for future extension
//        EmptyExt ext;
//    };
//
type CreateManageOfferRequestOp struct {
	Request  ManageOfferRequest `json:"request,omitempty"`
	AllTasks *Uint32            `json:"allTasks,omitempty"`
	Ext      EmptyExt           `json:"ext,omitempty"`
}

// CreateManageOfferRequestResultCode is an XDR Enum defines as:
//
//   enum CreateManageOfferRequestResultCode
//    {
//        //: CreateManageOfferRequestOp was successfully applied
//        SUCCESS = 0,
//
//        //: Offer is invalid
//        INVALID_OFFER = -1,
//        //: Tasks for the manage offer request were neither provided in the request nor loaded through KeyValue
//        MANAGE_OFFER_TASKS_NOT_FOUND = -2,
//        //: Creator details are not in a valid JSON format
//        INVALID_CREATOR_DETAILS = -3
//    };
//
type CreateManageOfferRequestResultCode int32

const (
	CreateManageOfferRequestResultCodeSuccess                  CreateManageOfferRequestResultCode = 0
	CreateManageOfferRequestResultCodeInvalidOffer             CreateManageOfferRequestResultCode = -1
	CreateManageOfferRequestResultCodeManageOfferTasksNotFound CreateManageOfferRequestResultCode = -2
	CreateManageOfferRequestResultCodeInvalidCreatorDetails    CreateManageOfferRequestResultCode = -3
)

var CreateManageOfferRequestResultCodeAll = []CreateManageOfferRequestResultCode{
	CreateManageOfferRequestResultCodeSuccess,
	CreateManageOfferRequestResultCodeInvalidOffer,
	CreateManageOfferRequestResultCodeManageOfferTasksNotFound,
	CreateManageOfferRequestResultCodeInvalidCreatorDetails,
}

var createManageOfferRequestResultCodeMap = map[int32]string{
	0:  "CreateManageOfferRequestResultCodeSuccess",
	-1: "CreateManageOfferRequestResultCodeInvalidOffer",
	-2: "CreateManageOfferRequestResultCodeManageOfferTasksNotFound",
	-3: "CreateManageOfferRequestResultCodeInvalidCreatorDetails",
}

var createManageOfferRequestResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "invalid_offer",
	-2: "manage_offer_tasks_not_found",
	-3: "invalid_creator_details",
}

var createManageOfferRequestResultCodeRevMap = map[string]int32{
	"CreateManageOfferRequestResultCodeSuccess":                  0,
	"CreateManageOfferRequestResultCodeInvalidOffer":             -1,
	"CreateManageOfferRequestResultCodeManageOfferTasksNotFound": -2,
	"CreateManageOfferRequestResultCodeInvalidCreatorDetails":    -3,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CreateManageOfferRequestResultCode
func (e CreateManageOfferRequestResultCode) ValidEnum(v int32) bool {
	_, ok := createManageOfferRequestResultCodeMap[v]
	return ok
}
func (e CreateManageOfferRequestResultCode) isFlag() bool {
	for i := len(CreateManageOfferRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := CreateManageOfferRequestResultCode(2) << uint64(len(CreateManageOfferRequestResultCodeAll)-1) >> uint64(len(CreateManageOfferRequestResultCodeAll)-i)
		if expected != CreateManageOfferRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CreateManageOfferRequestResultCode) String() string {
	name, _ := createManageOfferRequestResultCodeMap[int32(e)]
	return name
}

func (e CreateManageOfferRequestResultCode) ShortString() string {
	name, _ := createManageOfferRequestResultCodeShortMap[int32(e)]
	return name
}

func (e CreateManageOfferRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CreateManageOfferRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CreateManageOfferRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CreateManageOfferRequestResultCode(t.Value)
	return nil
}

// CreateManagerOfferRequestSuccessResult is an XDR Struct defines as:
//
//   struct CreateManagerOfferRequestSuccessResult
//    {
//        //: ID of the ManageOfferRequest
//        uint64 requestID;
//        //: Indicates whether or not the manage offer request was auto approved
//        bool fulfilled;
//
//        //: Result of manage offer application
//        ManageOfferResult* manageOfferResult;
//
//        //: Reserved for future extension
//        EmptyExt ext;
//    };
//
type CreateManagerOfferRequestSuccessResult struct {
	RequestId         Uint64             `json:"requestID,omitempty"`
	Fulfilled         bool               `json:"fulfilled,omitempty"`
	ManageOfferResult *ManageOfferResult `json:"manageOfferResult,omitempty"`
	Ext               EmptyExt           `json:"ext,omitempty"`
}

// CreateManageOfferRequestResult is an XDR Union defines as:
//
//   union CreateManageOfferRequestResult switch (CreateManageOfferRequestResultCode code)
//    {
//    case SUCCESS:
//        CreateManagerOfferRequestSuccessResult success;
//    case INVALID_OFFER:
//        ManageOfferResultCode manageOfferCode;
//    default:
//        void;
//    };
//
type CreateManageOfferRequestResult struct {
	Code            CreateManageOfferRequestResultCode      `json:"code,omitempty"`
	Success         *CreateManagerOfferRequestSuccessResult `json:"success,omitempty"`
	ManageOfferCode *ManageOfferResultCode                  `json:"manageOfferCode,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateManageOfferRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateManageOfferRequestResult
func (u CreateManageOfferRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch CreateManageOfferRequestResultCode(sw) {
	case CreateManageOfferRequestResultCodeSuccess:
		return "Success", true
	case CreateManageOfferRequestResultCodeInvalidOffer:
		return "ManageOfferCode", true
	default:
		return "", true
	}
}

// NewCreateManageOfferRequestResult creates a new  CreateManageOfferRequestResult.
func NewCreateManageOfferRequestResult(code CreateManageOfferRequestResultCode, value interface{}) (result CreateManageOfferRequestResult, err error) {
	result.Code = code
	switch CreateManageOfferRequestResultCode(code) {
	case CreateManageOfferRequestResultCodeSuccess:
		tv, ok := value.(CreateManagerOfferRequestSuccessResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateManagerOfferRequestSuccessResult")
			return
		}
		result.Success = &tv
	case CreateManageOfferRequestResultCodeInvalidOffer:
		tv, ok := value.(ManageOfferResultCode)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageOfferResultCode")
			return
		}
		result.ManageOfferCode = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CreateManageOfferRequestResult) MustSuccess() CreateManagerOfferRequestSuccessResult {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CreateManageOfferRequestResult) GetSuccess() (result CreateManagerOfferRequestSuccessResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// MustManageOfferCode retrieves the ManageOfferCode value from the union,
// panicing if the value is not set.
func (u CreateManageOfferRequestResult) MustManageOfferCode() ManageOfferResultCode {
	val, ok := u.GetManageOfferCode()

	if !ok {
		panic("arm ManageOfferCode is not set")
	}

	return val
}

// GetManageOfferCode retrieves the ManageOfferCode value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CreateManageOfferRequestResult) GetManageOfferCode() (result ManageOfferResultCode, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "ManageOfferCode" {
		result = *u.ManageOfferCode
		ok = true
	}

	return
}

// CreatePaymentRequestOp is an XDR Struct defines as:
//
//   struct CreatePaymentRequestOp
//    {
//        //: Payment request details
//        CreatePaymentRequest request;
//
//        //: (optional) Bit mask whose flags must be cleared in order for CreateSale request to be approved, which will be used by key sale_create_tasks:<asset_code>
//        //: instead of key-value
//        uint32* allTasks;
//
//        //: reserved for future extension
//        EmptyExt ext;
//    };
//
type CreatePaymentRequestOp struct {
	Request  CreatePaymentRequest `json:"request,omitempty"`
	AllTasks *Uint32              `json:"allTasks,omitempty"`
	Ext      EmptyExt             `json:"ext,omitempty"`
}

// CreatePaymentRequestResultCode is an XDR Enum defines as:
//
//   enum CreatePaymentRequestResultCode
//    {
//        //: CreatePaymentRequestOp was successfully applied
//        SUCCESS = 0,
//
//        //: Payment is invalid
//        INVALID_PAYMENT = -1,
//        //: Tasks for the payment request were neither provided in the request nor loaded through KeyValue
//        PAYMENT_TASKS_NOT_FOUND = -2,
//        //: Creator details are not in a valid JSON format
//        INVALID_CREATOR_DETAILS = -3
//    };
//
type CreatePaymentRequestResultCode int32

const (
	CreatePaymentRequestResultCodeSuccess               CreatePaymentRequestResultCode = 0
	CreatePaymentRequestResultCodeInvalidPayment        CreatePaymentRequestResultCode = -1
	CreatePaymentRequestResultCodePaymentTasksNotFound  CreatePaymentRequestResultCode = -2
	CreatePaymentRequestResultCodeInvalidCreatorDetails CreatePaymentRequestResultCode = -3
)

var CreatePaymentRequestResultCodeAll = []CreatePaymentRequestResultCode{
	CreatePaymentRequestResultCodeSuccess,
	CreatePaymentRequestResultCodeInvalidPayment,
	CreatePaymentRequestResultCodePaymentTasksNotFound,
	CreatePaymentRequestResultCodeInvalidCreatorDetails,
}

var createPaymentRequestResultCodeMap = map[int32]string{
	0:  "CreatePaymentRequestResultCodeSuccess",
	-1: "CreatePaymentRequestResultCodeInvalidPayment",
	-2: "CreatePaymentRequestResultCodePaymentTasksNotFound",
	-3: "CreatePaymentRequestResultCodeInvalidCreatorDetails",
}

var createPaymentRequestResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "invalid_payment",
	-2: "payment_tasks_not_found",
	-3: "invalid_creator_details",
}

var createPaymentRequestResultCodeRevMap = map[string]int32{
	"CreatePaymentRequestResultCodeSuccess":               0,
	"CreatePaymentRequestResultCodeInvalidPayment":        -1,
	"CreatePaymentRequestResultCodePaymentTasksNotFound":  -2,
	"CreatePaymentRequestResultCodeInvalidCreatorDetails": -3,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CreatePaymentRequestResultCode
func (e CreatePaymentRequestResultCode) ValidEnum(v int32) bool {
	_, ok := createPaymentRequestResultCodeMap[v]
	return ok
}
func (e CreatePaymentRequestResultCode) isFlag() bool {
	for i := len(CreatePaymentRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := CreatePaymentRequestResultCode(2) << uint64(len(CreatePaymentRequestResultCodeAll)-1) >> uint64(len(CreatePaymentRequestResultCodeAll)-i)
		if expected != CreatePaymentRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CreatePaymentRequestResultCode) String() string {
	name, _ := createPaymentRequestResultCodeMap[int32(e)]
	return name
}

func (e CreatePaymentRequestResultCode) ShortString() string {
	name, _ := createPaymentRequestResultCodeShortMap[int32(e)]
	return name
}

func (e CreatePaymentRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CreatePaymentRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CreatePaymentRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CreatePaymentRequestResultCode(t.Value)
	return nil
}

// CreatePaymentRequestSuccessResult is an XDR Struct defines as:
//
//   //: Result of the successful payment request creation
//    struct CreatePaymentRequestSuccessResult
//    {
//        //: ID of the Payment request
//        uint64 requestID;
//        //: Indicates whether or not the payment request was auto approved
//        bool fulfilled;
//
//        //: Result of the payment application
//        PaymentResult* paymentResult;
//
//        //: reserved for future extension
//        EmptyExt ext;
//    };
//
type CreatePaymentRequestSuccessResult struct {
	RequestId     Uint64         `json:"requestID,omitempty"`
	Fulfilled     bool           `json:"fulfilled,omitempty"`
	PaymentResult *PaymentResult `json:"paymentResult,omitempty"`
	Ext           EmptyExt       `json:"ext,omitempty"`
}

// CreatePaymentRequestResult is an XDR Union defines as:
//
//   //: Result of CreatePaymentRequestOp application
//    union CreatePaymentRequestResult switch (CreatePaymentRequestResultCode code)
//    {
//    case SUCCESS:
//        CreatePaymentRequestSuccessResult success;
//    case INVALID_PAYMENT:
//        PaymentResultCode paymentCode;
//    default:
//        void;
//    };
//
type CreatePaymentRequestResult struct {
	Code        CreatePaymentRequestResultCode     `json:"code,omitempty"`
	Success     *CreatePaymentRequestSuccessResult `json:"success,omitempty"`
	PaymentCode *PaymentResultCode                 `json:"paymentCode,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreatePaymentRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreatePaymentRequestResult
func (u CreatePaymentRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch CreatePaymentRequestResultCode(sw) {
	case CreatePaymentRequestResultCodeSuccess:
		return "Success", true
	case CreatePaymentRequestResultCodeInvalidPayment:
		return "PaymentCode", true
	default:
		return "", true
	}
}

// NewCreatePaymentRequestResult creates a new  CreatePaymentRequestResult.
func NewCreatePaymentRequestResult(code CreatePaymentRequestResultCode, value interface{}) (result CreatePaymentRequestResult, err error) {
	result.Code = code
	switch CreatePaymentRequestResultCode(code) {
	case CreatePaymentRequestResultCodeSuccess:
		tv, ok := value.(CreatePaymentRequestSuccessResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreatePaymentRequestSuccessResult")
			return
		}
		result.Success = &tv
	case CreatePaymentRequestResultCodeInvalidPayment:
		tv, ok := value.(PaymentResultCode)
		if !ok {
			err = fmt.Errorf("invalid value, must be PaymentResultCode")
			return
		}
		result.PaymentCode = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CreatePaymentRequestResult) MustSuccess() CreatePaymentRequestSuccessResult {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CreatePaymentRequestResult) GetSuccess() (result CreatePaymentRequestSuccessResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// MustPaymentCode retrieves the PaymentCode value from the union,
// panicing if the value is not set.
func (u CreatePaymentRequestResult) MustPaymentCode() PaymentResultCode {
	val, ok := u.GetPaymentCode()

	if !ok {
		panic("arm PaymentCode is not set")
	}

	return val
}

// GetPaymentCode retrieves the PaymentCode value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CreatePaymentRequestResult) GetPaymentCode() (result PaymentResultCode, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "PaymentCode" {
		result = *u.PaymentCode
		ok = true
	}

	return
}

// CreatePreIssuanceRequestOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreatePreIssuanceRequestOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreatePreIssuanceRequestOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreatePreIssuanceRequestOpExt
func (u CreatePreIssuanceRequestOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreatePreIssuanceRequestOpExt creates a new  CreatePreIssuanceRequestOpExt.
func NewCreatePreIssuanceRequestOpExt(v LedgerVersion, value interface{}) (result CreatePreIssuanceRequestOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreatePreIssuanceRequestOp is an XDR Struct defines as:
//
//   //: CreatePreIssuanceRequestOp is used to create a reviewable request,
//    //: which, after admin's approval, will change `availableForIssuance` amount of asset
//    struct CreatePreIssuanceRequestOp
//    {
//        //: Body of PreIssuanceRequest to be created
//        PreIssuanceRequest request;
//
//        //: (optional) Bit mask whose flags must be cleared in order for PreIssuanceRequest to be approved, which will be used by key `preissuance_tasks`
//        //: instead of key-value
//        uint32* allTasks;
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CreatePreIssuanceRequestOp struct {
	Request  PreIssuanceRequest            `json:"request,omitempty"`
	AllTasks *Uint32                       `json:"allTasks,omitempty"`
	Ext      CreatePreIssuanceRequestOpExt `json:"ext,omitempty"`
}

// CreatePreIssuanceRequestResultCode is an XDR Enum defines as:
//
//   //: Result codes of CreatePreIssuanceRequestOp
//    enum CreatePreIssuanceRequestResultCode
//    {
//        //: Preissuance request is either successfully created
//        //: or auto approved if pending tasks of requests is equal to 0
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: There is no asset with such an asset code
//        ASSET_NOT_FOUND = -1,
//        //: Preissuance request with such reference already exists
//        REFERENCE_DUPLICATION = -2,      // reference is already used
//        //: Source of operation must be the owner of the asset
//        NOT_AUTHORIZED_UPLOAD = -3,      // tries to preissue asset for not owned asset
//        //: Only current preissuer can perform preissuance
//        INVALID_SIGNATURE = -4,
//        //: The summ of preissue, issued, pendingIssuance, available for issuance amounts must not exceed max issued amount
//        EXCEEDED_MAX_AMOUNT = -5,
//        //: The preissue amount in the preissuance request must exceed 0
//        INVALID_AMOUNT = -6,             // amount is 0
//        //: The reference field must not be empty
//        INVALID_REFERENCE = -7,
//        //: Preissue amount must fit the precision of an asset to be issued
//        INCORRECT_AMOUNT_PRECISION = -8,  // amount does not fit this asset's precision
//        //: Preissuance tasks are not set in the system (i.e., it is not allowed to perform the preissuance)
//        PREISSUANCE_TASKS_NOT_FOUND = -9,
//        //: `creatorDetails` must be valid json structure
//        INVALID_CREATOR_DETAILS = -10
//    };
//
type CreatePreIssuanceRequestResultCode int32

const (
	CreatePreIssuanceRequestResultCodeSuccess                  CreatePreIssuanceRequestResultCode = 0
	CreatePreIssuanceRequestResultCodeAssetNotFound            CreatePreIssuanceRequestResultCode = -1
	CreatePreIssuanceRequestResultCodeReferenceDuplication     CreatePreIssuanceRequestResultCode = -2
	CreatePreIssuanceRequestResultCodeNotAuthorizedUpload      CreatePreIssuanceRequestResultCode = -3
	CreatePreIssuanceRequestResultCodeInvalidSignature         CreatePreIssuanceRequestResultCode = -4
	CreatePreIssuanceRequestResultCodeExceededMaxAmount        CreatePreIssuanceRequestResultCode = -5
	CreatePreIssuanceRequestResultCodeInvalidAmount            CreatePreIssuanceRequestResultCode = -6
	CreatePreIssuanceRequestResultCodeInvalidReference         CreatePreIssuanceRequestResultCode = -7
	CreatePreIssuanceRequestResultCodeIncorrectAmountPrecision CreatePreIssuanceRequestResultCode = -8
	CreatePreIssuanceRequestResultCodePreissuanceTasksNotFound CreatePreIssuanceRequestResultCode = -9
	CreatePreIssuanceRequestResultCodeInvalidCreatorDetails    CreatePreIssuanceRequestResultCode = -10
)

var CreatePreIssuanceRequestResultCodeAll = []CreatePreIssuanceRequestResultCode{
	CreatePreIssuanceRequestResultCodeSuccess,
	CreatePreIssuanceRequestResultCodeAssetNotFound,
	CreatePreIssuanceRequestResultCodeReferenceDuplication,
	CreatePreIssuanceRequestResultCodeNotAuthorizedUpload,
	CreatePreIssuanceRequestResultCodeInvalidSignature,
	CreatePreIssuanceRequestResultCodeExceededMaxAmount,
	CreatePreIssuanceRequestResultCodeInvalidAmount,
	CreatePreIssuanceRequestResultCodeInvalidReference,
	CreatePreIssuanceRequestResultCodeIncorrectAmountPrecision,
	CreatePreIssuanceRequestResultCodePreissuanceTasksNotFound,
	CreatePreIssuanceRequestResultCodeInvalidCreatorDetails,
}

var createPreIssuanceRequestResultCodeMap = map[int32]string{
	0:   "CreatePreIssuanceRequestResultCodeSuccess",
	-1:  "CreatePreIssuanceRequestResultCodeAssetNotFound",
	-2:  "CreatePreIssuanceRequestResultCodeReferenceDuplication",
	-3:  "CreatePreIssuanceRequestResultCodeNotAuthorizedUpload",
	-4:  "CreatePreIssuanceRequestResultCodeInvalidSignature",
	-5:  "CreatePreIssuanceRequestResultCodeExceededMaxAmount",
	-6:  "CreatePreIssuanceRequestResultCodeInvalidAmount",
	-7:  "CreatePreIssuanceRequestResultCodeInvalidReference",
	-8:  "CreatePreIssuanceRequestResultCodeIncorrectAmountPrecision",
	-9:  "CreatePreIssuanceRequestResultCodePreissuanceTasksNotFound",
	-10: "CreatePreIssuanceRequestResultCodeInvalidCreatorDetails",
}

var createPreIssuanceRequestResultCodeShortMap = map[int32]string{
	0:   "success",
	-1:  "asset_not_found",
	-2:  "reference_duplication",
	-3:  "not_authorized_upload",
	-4:  "invalid_signature",
	-5:  "exceeded_max_amount",
	-6:  "invalid_amount",
	-7:  "invalid_reference",
	-8:  "incorrect_amount_precision",
	-9:  "preissuance_tasks_not_found",
	-10: "invalid_creator_details",
}

var createPreIssuanceRequestResultCodeRevMap = map[string]int32{
	"CreatePreIssuanceRequestResultCodeSuccess":                  0,
	"CreatePreIssuanceRequestResultCodeAssetNotFound":            -1,
	"CreatePreIssuanceRequestResultCodeReferenceDuplication":     -2,
	"CreatePreIssuanceRequestResultCodeNotAuthorizedUpload":      -3,
	"CreatePreIssuanceRequestResultCodeInvalidSignature":         -4,
	"CreatePreIssuanceRequestResultCodeExceededMaxAmount":        -5,
	"CreatePreIssuanceRequestResultCodeInvalidAmount":            -6,
	"CreatePreIssuanceRequestResultCodeInvalidReference":         -7,
	"CreatePreIssuanceRequestResultCodeIncorrectAmountPrecision": -8,
	"CreatePreIssuanceRequestResultCodePreissuanceTasksNotFound": -9,
	"CreatePreIssuanceRequestResultCodeInvalidCreatorDetails":    -10,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CreatePreIssuanceRequestResultCode
func (e CreatePreIssuanceRequestResultCode) ValidEnum(v int32) bool {
	_, ok := createPreIssuanceRequestResultCodeMap[v]
	return ok
}
func (e CreatePreIssuanceRequestResultCode) isFlag() bool {
	for i := len(CreatePreIssuanceRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := CreatePreIssuanceRequestResultCode(2) << uint64(len(CreatePreIssuanceRequestResultCodeAll)-1) >> uint64(len(CreatePreIssuanceRequestResultCodeAll)-i)
		if expected != CreatePreIssuanceRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CreatePreIssuanceRequestResultCode) String() string {
	name, _ := createPreIssuanceRequestResultCodeMap[int32(e)]
	return name
}

func (e CreatePreIssuanceRequestResultCode) ShortString() string {
	name, _ := createPreIssuanceRequestResultCodeShortMap[int32(e)]
	return name
}

func (e CreatePreIssuanceRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CreatePreIssuanceRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CreatePreIssuanceRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CreatePreIssuanceRequestResultCode(t.Value)
	return nil
}

// CreatePreIssuanceRequestResultSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type CreatePreIssuanceRequestResultSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreatePreIssuanceRequestResultSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreatePreIssuanceRequestResultSuccessExt
func (u CreatePreIssuanceRequestResultSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreatePreIssuanceRequestResultSuccessExt creates a new  CreatePreIssuanceRequestResultSuccessExt.
func NewCreatePreIssuanceRequestResultSuccessExt(v LedgerVersion, value interface{}) (result CreatePreIssuanceRequestResultSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreatePreIssuanceRequestResultSuccess is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: ID of created or updated request
//            uint64 requestID;
//            //: Indicates whether or not the request was auto approved and fulfilled
//            bool fulfilled;
//            //: reserved for future use
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//    	}
//
type CreatePreIssuanceRequestResultSuccess struct {
	RequestId Uint64                                   `json:"requestID,omitempty"`
	Fulfilled bool                                     `json:"fulfilled,omitempty"`
	Ext       CreatePreIssuanceRequestResultSuccessExt `json:"ext,omitempty"`
}

// CreatePreIssuanceRequestResult is an XDR Union defines as:
//
//   //: Result of `CreatePreIssuanceRequest` operation application along with the result code
//    union CreatePreIssuanceRequestResult switch (CreatePreIssuanceRequestResultCode code)
//    {
//    case SUCCESS:
//        //: Result of successful application of `CreatePreIssuanceRequest` operation
//        struct
//        {
//            //: ID of created or updated request
//            uint64 requestID;
//            //: Indicates whether or not the request was auto approved and fulfilled
//            bool fulfilled;
//            //: reserved for future use
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//    	} success;
//    default:
//        void;
//    };
//
type CreatePreIssuanceRequestResult struct {
	Code    CreatePreIssuanceRequestResultCode     `json:"code,omitempty"`
	Success *CreatePreIssuanceRequestResultSuccess `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreatePreIssuanceRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreatePreIssuanceRequestResult
func (u CreatePreIssuanceRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch CreatePreIssuanceRequestResultCode(sw) {
	case CreatePreIssuanceRequestResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewCreatePreIssuanceRequestResult creates a new  CreatePreIssuanceRequestResult.
func NewCreatePreIssuanceRequestResult(code CreatePreIssuanceRequestResultCode, value interface{}) (result CreatePreIssuanceRequestResult, err error) {
	result.Code = code
	switch CreatePreIssuanceRequestResultCode(code) {
	case CreatePreIssuanceRequestResultCodeSuccess:
		tv, ok := value.(CreatePreIssuanceRequestResultSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreatePreIssuanceRequestResultSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CreatePreIssuanceRequestResult) MustSuccess() CreatePreIssuanceRequestResultSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CreatePreIssuanceRequestResult) GetSuccess() (result CreatePreIssuanceRequestResultSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// CreateRedemptionRequestOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateRedemptionRequestOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateRedemptionRequestOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateRedemptionRequestOpExt
func (u CreateRedemptionRequestOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateRedemptionRequestOpExt creates a new  CreateRedemptionRequestOpExt.
func NewCreateRedemptionRequestOpExt(v LedgerVersion, value interface{}) (result CreateRedemptionRequestOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateRedemptionRequestOp is an XDR Struct defines as:
//
//   //: CreateRedemptionRequest operation creates a reviewable request
//    //: that will transfer the specified amount from current holder's balance to destination balance after the reviewer's approval
//    struct CreateRedemptionRequestOp
//    {
//        //: Reference of RedemptionRequest
//        string64 reference; // TODO longstring ?
//        //: Parameters of RedemptionRequest
//        RedemptionRequest redemptionRequest;
//        //: (optional) Bit mask whose flags must be cleared in order for RedemptionRequest to be approved, which will be used by key redemption_tasks
//        //: instead of key-value
//        uint32* allTasks;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//
//    };
//
type CreateRedemptionRequestOp struct {
	Reference         String64                     `json:"reference,omitempty"`
	RedemptionRequest RedemptionRequest            `json:"redemptionRequest,omitempty"`
	AllTasks          *Uint32                      `json:"allTasks,omitempty"`
	Ext               CreateRedemptionRequestOpExt `json:"ext,omitempty"`
}

// CreateRedemptionRequestResultCode is an XDR Enum defines as:
//
//   //: Result codes for CreateRedemption operation
//    enum CreateRedemptionRequestResultCode
//    {
//        // codes considered as "success" for the operation
//        //: Operation has been successfully performed
//        SUCCESS = 0,
//
//        //codes considered as "failure" for the operation
//        //: Redemption is invalid
//        INVALID_REDEMPTION = -1,
//        //: Tasks for the redemption request were neither provided in the request nor loaded through KeyValue
//        REDEMPTION_TASKS_NOT_FOUND = -2,
//        //: Creator details must not be empty
//        INVALID_CREATOR_DETAILS = -3,
//        //: Amount must be greater then 0
//        INVALID_AMOUNT = -4,
//        //: Reference must not be longer then 64 bytes
//        INVALID_REFERENCE = -5,
//        //: Source balance with provided balance ID does not exist
//        SOURCE_BALANCE_NOT_EXIST = -6, // balance doesn't exist
//        //: Amount has incorrect precision
//        INCORRECT_PRECISION = -7,
//        //: Balance underfunded
//        UNDERFUNDED = -8,
//        //: Duplicated references are not allowed
//        REFERENCE_DUPLICATION = -9,
//        //: No destination with provided account ID
//        DST_ACCOUNT_NOT_FOUND = -10,
//        //: Not allowed to set zero tasks for request
//        REDEMPTION_ZERO_TASKS_NOT_ALLOWED = -11,
//        //: Not allowed to redeem non-owned asset
//        REDEMPTION_NON_OWNED_ASSET_FORBIDDEN = -12
//    };
//
type CreateRedemptionRequestResultCode int32

const (
	CreateRedemptionRequestResultCodeSuccess                          CreateRedemptionRequestResultCode = 0
	CreateRedemptionRequestResultCodeInvalidRedemption                CreateRedemptionRequestResultCode = -1
	CreateRedemptionRequestResultCodeRedemptionTasksNotFound          CreateRedemptionRequestResultCode = -2
	CreateRedemptionRequestResultCodeInvalidCreatorDetails            CreateRedemptionRequestResultCode = -3
	CreateRedemptionRequestResultCodeInvalidAmount                    CreateRedemptionRequestResultCode = -4
	CreateRedemptionRequestResultCodeInvalidReference                 CreateRedemptionRequestResultCode = -5
	CreateRedemptionRequestResultCodeSourceBalanceNotExist            CreateRedemptionRequestResultCode = -6
	CreateRedemptionRequestResultCodeIncorrectPrecision               CreateRedemptionRequestResultCode = -7
	CreateRedemptionRequestResultCodeUnderfunded                      CreateRedemptionRequestResultCode = -8
	CreateRedemptionRequestResultCodeReferenceDuplication             CreateRedemptionRequestResultCode = -9
	CreateRedemptionRequestResultCodeDstAccountNotFound               CreateRedemptionRequestResultCode = -10
	CreateRedemptionRequestResultCodeRedemptionZeroTasksNotAllowed    CreateRedemptionRequestResultCode = -11
	CreateRedemptionRequestResultCodeRedemptionNonOwnedAssetForbidden CreateRedemptionRequestResultCode = -12
)

var CreateRedemptionRequestResultCodeAll = []CreateRedemptionRequestResultCode{
	CreateRedemptionRequestResultCodeSuccess,
	CreateRedemptionRequestResultCodeInvalidRedemption,
	CreateRedemptionRequestResultCodeRedemptionTasksNotFound,
	CreateRedemptionRequestResultCodeInvalidCreatorDetails,
	CreateRedemptionRequestResultCodeInvalidAmount,
	CreateRedemptionRequestResultCodeInvalidReference,
	CreateRedemptionRequestResultCodeSourceBalanceNotExist,
	CreateRedemptionRequestResultCodeIncorrectPrecision,
	CreateRedemptionRequestResultCodeUnderfunded,
	CreateRedemptionRequestResultCodeReferenceDuplication,
	CreateRedemptionRequestResultCodeDstAccountNotFound,
	CreateRedemptionRequestResultCodeRedemptionZeroTasksNotAllowed,
	CreateRedemptionRequestResultCodeRedemptionNonOwnedAssetForbidden,
}

var createRedemptionRequestResultCodeMap = map[int32]string{
	0:   "CreateRedemptionRequestResultCodeSuccess",
	-1:  "CreateRedemptionRequestResultCodeInvalidRedemption",
	-2:  "CreateRedemptionRequestResultCodeRedemptionTasksNotFound",
	-3:  "CreateRedemptionRequestResultCodeInvalidCreatorDetails",
	-4:  "CreateRedemptionRequestResultCodeInvalidAmount",
	-5:  "CreateRedemptionRequestResultCodeInvalidReference",
	-6:  "CreateRedemptionRequestResultCodeSourceBalanceNotExist",
	-7:  "CreateRedemptionRequestResultCodeIncorrectPrecision",
	-8:  "CreateRedemptionRequestResultCodeUnderfunded",
	-9:  "CreateRedemptionRequestResultCodeReferenceDuplication",
	-10: "CreateRedemptionRequestResultCodeDstAccountNotFound",
	-11: "CreateRedemptionRequestResultCodeRedemptionZeroTasksNotAllowed",
	-12: "CreateRedemptionRequestResultCodeRedemptionNonOwnedAssetForbidden",
}

var createRedemptionRequestResultCodeShortMap = map[int32]string{
	0:   "success",
	-1:  "invalid_redemption",
	-2:  "redemption_tasks_not_found",
	-3:  "invalid_creator_details",
	-4:  "invalid_amount",
	-5:  "invalid_reference",
	-6:  "source_balance_not_exist",
	-7:  "incorrect_precision",
	-8:  "underfunded",
	-9:  "reference_duplication",
	-10: "dst_account_not_found",
	-11: "redemption_zero_tasks_not_allowed",
	-12: "redemption_non_owned_asset_forbidden",
}

var createRedemptionRequestResultCodeRevMap = map[string]int32{
	"CreateRedemptionRequestResultCodeSuccess":                          0,
	"CreateRedemptionRequestResultCodeInvalidRedemption":                -1,
	"CreateRedemptionRequestResultCodeRedemptionTasksNotFound":          -2,
	"CreateRedemptionRequestResultCodeInvalidCreatorDetails":            -3,
	"CreateRedemptionRequestResultCodeInvalidAmount":                    -4,
	"CreateRedemptionRequestResultCodeInvalidReference":                 -5,
	"CreateRedemptionRequestResultCodeSourceBalanceNotExist":            -6,
	"CreateRedemptionRequestResultCodeIncorrectPrecision":               -7,
	"CreateRedemptionRequestResultCodeUnderfunded":                      -8,
	"CreateRedemptionRequestResultCodeReferenceDuplication":             -9,
	"CreateRedemptionRequestResultCodeDstAccountNotFound":               -10,
	"CreateRedemptionRequestResultCodeRedemptionZeroTasksNotAllowed":    -11,
	"CreateRedemptionRequestResultCodeRedemptionNonOwnedAssetForbidden": -12,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CreateRedemptionRequestResultCode
func (e CreateRedemptionRequestResultCode) ValidEnum(v int32) bool {
	_, ok := createRedemptionRequestResultCodeMap[v]
	return ok
}
func (e CreateRedemptionRequestResultCode) isFlag() bool {
	for i := len(CreateRedemptionRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := CreateRedemptionRequestResultCode(2) << uint64(len(CreateRedemptionRequestResultCodeAll)-1) >> uint64(len(CreateRedemptionRequestResultCodeAll)-i)
		if expected != CreateRedemptionRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CreateRedemptionRequestResultCode) String() string {
	name, _ := createRedemptionRequestResultCodeMap[int32(e)]
	return name
}

func (e CreateRedemptionRequestResultCode) ShortString() string {
	name, _ := createRedemptionRequestResultCodeShortMap[int32(e)]
	return name
}

func (e CreateRedemptionRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CreateRedemptionRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CreateRedemptionRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CreateRedemptionRequestResultCode(t.Value)
	return nil
}

// RedemptionRequestResponseExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type RedemptionRequestResponseExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u RedemptionRequestResponseExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of RedemptionRequestResponseExt
func (u RedemptionRequestResponseExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewRedemptionRequestResponseExt creates a new  RedemptionRequestResponseExt.
func NewRedemptionRequestResponseExt(v LedgerVersion, value interface{}) (result RedemptionRequestResponseExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// RedemptionRequestResponse is an XDR Struct defines as:
//
//   //: Result of successful application of `CreateRedemptionRequest` operation
//    struct RedemptionRequestResponse {
//        //: ID of a newly created reviewable request
//        uint64 requestID;
//        //: Indicates  whether or not the Redemption request was auto approved and fulfilled
//        bool fulfilled;
//
//        //: ID of destination balance (may be freshly created)
//        BalanceID destinationBalanceID;
//        //: Code of an asset used in payment
//        AssetCode asset;
//        //: Amount sent by the sender
//        uint64 sourceSentUniversal;
//        //: Reserved for future use
//         union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type RedemptionRequestResponse struct {
	RequestId            Uint64                       `json:"requestID,omitempty"`
	Fulfilled            bool                         `json:"fulfilled,omitempty"`
	DestinationBalanceId BalanceId                    `json:"destinationBalanceID,omitempty"`
	Asset                AssetCode                    `json:"asset,omitempty"`
	SourceSentUniversal  Uint64                       `json:"sourceSentUniversal,omitempty"`
	Ext                  RedemptionRequestResponseExt `json:"ext,omitempty"`
}

// CreateRedemptionRequestResult is an XDR Union defines as:
//
//   //: Result of `CreateRedemptionRequest` operation application along with the result code
//    union CreateRedemptionRequestResult switch (CreateRedemptionRequestResultCode code)
//    {
//        case SUCCESS:
//            RedemptionRequestResponse redemptionResponse;
//        default:
//            void;
//    };
//
type CreateRedemptionRequestResult struct {
	Code               CreateRedemptionRequestResultCode `json:"code,omitempty"`
	RedemptionResponse *RedemptionRequestResponse        `json:"redemptionResponse,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateRedemptionRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateRedemptionRequestResult
func (u CreateRedemptionRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch CreateRedemptionRequestResultCode(sw) {
	case CreateRedemptionRequestResultCodeSuccess:
		return "RedemptionResponse", true
	default:
		return "", true
	}
}

// NewCreateRedemptionRequestResult creates a new  CreateRedemptionRequestResult.
func NewCreateRedemptionRequestResult(code CreateRedemptionRequestResultCode, value interface{}) (result CreateRedemptionRequestResult, err error) {
	result.Code = code
	switch CreateRedemptionRequestResultCode(code) {
	case CreateRedemptionRequestResultCodeSuccess:
		tv, ok := value.(RedemptionRequestResponse)
		if !ok {
			err = fmt.Errorf("invalid value, must be RedemptionRequestResponse")
			return
		}
		result.RedemptionResponse = &tv
	default:
		// void
	}
	return
}

// MustRedemptionResponse retrieves the RedemptionResponse value from the union,
// panicing if the value is not set.
func (u CreateRedemptionRequestResult) MustRedemptionResponse() RedemptionRequestResponse {
	val, ok := u.GetRedemptionResponse()

	if !ok {
		panic("arm RedemptionResponse is not set")
	}

	return val
}

// GetRedemptionResponse retrieves the RedemptionResponse value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CreateRedemptionRequestResult) GetRedemptionResponse() (result RedemptionRequestResponse, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "RedemptionResponse" {
		result = *u.RedemptionResponse
		ok = true
	}

	return
}

// CreateSaleCreationRequestOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateSaleCreationRequestOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateSaleCreationRequestOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateSaleCreationRequestOpExt
func (u CreateSaleCreationRequestOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateSaleCreationRequestOpExt creates a new  CreateSaleCreationRequestOpExt.
func NewCreateSaleCreationRequestOpExt(v LedgerVersion, value interface{}) (result CreateSaleCreationRequestOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateSaleCreationRequestOp is an XDR Struct defines as:
//
//   //: CreateSaleCreationRequest operation creates SaleCreationRequest or updates the rejected request
//    struct CreateSaleCreationRequestOp
//    {
//        //: ID of the SaleCreationRequest. If set to 0, a new request is created
//        uint64 requestID;
//        //: SaleCreationRequest details
//        SaleCreationRequest request;
//        //: (optional) Bit mask whose flags must be cleared in order for CreateSale request to be approved, which will be used by key sale_create_tasks:<asset_code>
//        //: instead of key-value
//        uint32* allTasks;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//
//    };
//
type CreateSaleCreationRequestOp struct {
	RequestId Uint64                         `json:"requestID,omitempty"`
	Request   SaleCreationRequest            `json:"request,omitempty"`
	AllTasks  *Uint32                        `json:"allTasks,omitempty"`
	Ext       CreateSaleCreationRequestOpExt `json:"ext,omitempty"`
}

// CreateSaleCreationRequestResultCode is an XDR Enum defines as:
//
//   //: CreateSaleCreationRequest result codes
//    enum CreateSaleCreationRequestResultCode
//    {
//        // codes considered as "success" for the operation
//        //: CreateSaleCreationRequest operation was successfully applied
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: Trying to update a reviewable request that does not exist
//        REQUEST_NOT_FOUND = -1,
//        //: Trying to create a sale for an asset that does not exist
//        BASE_ASSET_OR_ASSET_REQUEST_NOT_FOUND = -2,
//        //: Trying to create a sale either for a non-existing quote asset or for a non-existing asset pair
//        QUOTE_ASSET_NOT_FOUND = -3,
//        //: Trying to create a sale with start time > end time
//        START_END_INVALID = -4,
//        //: Trying to create a sale with end time in the past
//        INVALID_END = -5,
//        //: Trying to create a sale with 0 price
//        INVALID_PRICE = -6,
//        //: Trying to create a sale with hard cap < soft cap
//        INVALID_CAP = -7,
//        //: Max issuance amount is less than sale's soft cap
//        INSUFFICIENT_MAX_ISSUANCE = -8,
//        //: Trying to create a sale with either an invalid asset code of one of the assets or with a base asset that is the same as one of the quote assets
//        INVALID_ASSET_PAIR = -9,
//        //: Deprecated
//        REQUEST_OR_SALE_ALREADY_EXISTS = -10,
//        //: Trying to create SaleCreationRequest with preissued amount that is less than the hard cap
//        INSUFFICIENT_PREISSUED = -11,
//        //: Creator details are not in a valid JSON format
//        INVALID_CREATOR_DETAILS = -12,
//        //: Version specified in the request is not supported yet
//        VERSION_IS_NOT_SUPPORTED_YET = -13,
//        //: Tasks for the sale creation request were neither provided in the request nor loaded through KeyValue
//        SALE_CREATE_TASKS_NOT_FOUND = -14,
//        //: It is not allowed to set all tasks on rejected SaleCreationRequest update
//        NOT_ALLOWED_TO_SET_TASKS_ON_UPDATE = -15,
//        //: Auto review failed due to a particular reason (e.g., hard cap exceeded either max issuance amount or preissued amount of an asset)
//        AUTO_REVIEW_FAILED = -16,
//        //: Not allowed to pass more account sale rule than allowed by `max_sale_rules_number` key value
//        EXCEEDED_MAX_RULES_SIZE = -17,
//        //: Not allowed to pass rules with the same ledger key and null accountID
//        GLOBAL_SPECIFIC_RULE_DUPLICATION = -18,
//        //: Not allowed to pass rules with the same accountID and ledger key
//        ACCOUNT_SPECIFIC_RULE_DUPLICATION = -19,
//        //: Not allowed to pass rules with out global one (`accountID == null`)
//        GLOBAL_SPECIFIC_RULE_REQUIRED = -20,
//        //: There is no account with id specified in sale rules
//        ACCOUNT_NOT_FOUND = -21
//    };
//
type CreateSaleCreationRequestResultCode int32

const (
	CreateSaleCreationRequestResultCodeSuccess                         CreateSaleCreationRequestResultCode = 0
	CreateSaleCreationRequestResultCodeRequestNotFound                 CreateSaleCreationRequestResultCode = -1
	CreateSaleCreationRequestResultCodeBaseAssetOrAssetRequestNotFound CreateSaleCreationRequestResultCode = -2
	CreateSaleCreationRequestResultCodeQuoteAssetNotFound              CreateSaleCreationRequestResultCode = -3
	CreateSaleCreationRequestResultCodeStartEndInvalid                 CreateSaleCreationRequestResultCode = -4
	CreateSaleCreationRequestResultCodeInvalidEnd                      CreateSaleCreationRequestResultCode = -5
	CreateSaleCreationRequestResultCodeInvalidPrice                    CreateSaleCreationRequestResultCode = -6
	CreateSaleCreationRequestResultCodeInvalidCap                      CreateSaleCreationRequestResultCode = -7
	CreateSaleCreationRequestResultCodeInsufficientMaxIssuance         CreateSaleCreationRequestResultCode = -8
	CreateSaleCreationRequestResultCodeInvalidAssetPair                CreateSaleCreationRequestResultCode = -9
	CreateSaleCreationRequestResultCodeRequestOrSaleAlreadyExists      CreateSaleCreationRequestResultCode = -10
	CreateSaleCreationRequestResultCodeInsufficientPreissued           CreateSaleCreationRequestResultCode = -11
	CreateSaleCreationRequestResultCodeInvalidCreatorDetails           CreateSaleCreationRequestResultCode = -12
	CreateSaleCreationRequestResultCodeVersionIsNotSupportedYet        CreateSaleCreationRequestResultCode = -13
	CreateSaleCreationRequestResultCodeSaleCreateTasksNotFound         CreateSaleCreationRequestResultCode = -14
	CreateSaleCreationRequestResultCodeNotAllowedToSetTasksOnUpdate    CreateSaleCreationRequestResultCode = -15
	CreateSaleCreationRequestResultCodeAutoReviewFailed                CreateSaleCreationRequestResultCode = -16
	CreateSaleCreationRequestResultCodeExceededMaxRulesSize            CreateSaleCreationRequestResultCode = -17
	CreateSaleCreationRequestResultCodeGlobalSpecificRuleDuplication   CreateSaleCreationRequestResultCode = -18
	CreateSaleCreationRequestResultCodeAccountSpecificRuleDuplication  CreateSaleCreationRequestResultCode = -19
	CreateSaleCreationRequestResultCodeGlobalSpecificRuleRequired      CreateSaleCreationRequestResultCode = -20
	CreateSaleCreationRequestResultCodeAccountNotFound                 CreateSaleCreationRequestResultCode = -21
)

var CreateSaleCreationRequestResultCodeAll = []CreateSaleCreationRequestResultCode{
	CreateSaleCreationRequestResultCodeSuccess,
	CreateSaleCreationRequestResultCodeRequestNotFound,
	CreateSaleCreationRequestResultCodeBaseAssetOrAssetRequestNotFound,
	CreateSaleCreationRequestResultCodeQuoteAssetNotFound,
	CreateSaleCreationRequestResultCodeStartEndInvalid,
	CreateSaleCreationRequestResultCodeInvalidEnd,
	CreateSaleCreationRequestResultCodeInvalidPrice,
	CreateSaleCreationRequestResultCodeInvalidCap,
	CreateSaleCreationRequestResultCodeInsufficientMaxIssuance,
	CreateSaleCreationRequestResultCodeInvalidAssetPair,
	CreateSaleCreationRequestResultCodeRequestOrSaleAlreadyExists,
	CreateSaleCreationRequestResultCodeInsufficientPreissued,
	CreateSaleCreationRequestResultCodeInvalidCreatorDetails,
	CreateSaleCreationRequestResultCodeVersionIsNotSupportedYet,
	CreateSaleCreationRequestResultCodeSaleCreateTasksNotFound,
	CreateSaleCreationRequestResultCodeNotAllowedToSetTasksOnUpdate,
	CreateSaleCreationRequestResultCodeAutoReviewFailed,
	CreateSaleCreationRequestResultCodeExceededMaxRulesSize,
	CreateSaleCreationRequestResultCodeGlobalSpecificRuleDuplication,
	CreateSaleCreationRequestResultCodeAccountSpecificRuleDuplication,
	CreateSaleCreationRequestResultCodeGlobalSpecificRuleRequired,
	CreateSaleCreationRequestResultCodeAccountNotFound,
}

var createSaleCreationRequestResultCodeMap = map[int32]string{
	0:   "CreateSaleCreationRequestResultCodeSuccess",
	-1:  "CreateSaleCreationRequestResultCodeRequestNotFound",
	-2:  "CreateSaleCreationRequestResultCodeBaseAssetOrAssetRequestNotFound",
	-3:  "CreateSaleCreationRequestResultCodeQuoteAssetNotFound",
	-4:  "CreateSaleCreationRequestResultCodeStartEndInvalid",
	-5:  "CreateSaleCreationRequestResultCodeInvalidEnd",
	-6:  "CreateSaleCreationRequestResultCodeInvalidPrice",
	-7:  "CreateSaleCreationRequestResultCodeInvalidCap",
	-8:  "CreateSaleCreationRequestResultCodeInsufficientMaxIssuance",
	-9:  "CreateSaleCreationRequestResultCodeInvalidAssetPair",
	-10: "CreateSaleCreationRequestResultCodeRequestOrSaleAlreadyExists",
	-11: "CreateSaleCreationRequestResultCodeInsufficientPreissued",
	-12: "CreateSaleCreationRequestResultCodeInvalidCreatorDetails",
	-13: "CreateSaleCreationRequestResultCodeVersionIsNotSupportedYet",
	-14: "CreateSaleCreationRequestResultCodeSaleCreateTasksNotFound",
	-15: "CreateSaleCreationRequestResultCodeNotAllowedToSetTasksOnUpdate",
	-16: "CreateSaleCreationRequestResultCodeAutoReviewFailed",
	-17: "CreateSaleCreationRequestResultCodeExceededMaxRulesSize",
	-18: "CreateSaleCreationRequestResultCodeGlobalSpecificRuleDuplication",
	-19: "CreateSaleCreationRequestResultCodeAccountSpecificRuleDuplication",
	-20: "CreateSaleCreationRequestResultCodeGlobalSpecificRuleRequired",
	-21: "CreateSaleCreationRequestResultCodeAccountNotFound",
}

var createSaleCreationRequestResultCodeShortMap = map[int32]string{
	0:   "success",
	-1:  "request_not_found",
	-2:  "base_asset_or_asset_request_not_found",
	-3:  "quote_asset_not_found",
	-4:  "start_end_invalid",
	-5:  "invalid_end",
	-6:  "invalid_price",
	-7:  "invalid_cap",
	-8:  "insufficient_max_issuance",
	-9:  "invalid_asset_pair",
	-10: "request_or_sale_already_exists",
	-11: "insufficient_preissued",
	-12: "invalid_creator_details",
	-13: "version_is_not_supported_yet",
	-14: "sale_create_tasks_not_found",
	-15: "not_allowed_to_set_tasks_on_update",
	-16: "auto_review_failed",
	-17: "exceeded_max_rules_size",
	-18: "global_specific_rule_duplication",
	-19: "account_specific_rule_duplication",
	-20: "global_specific_rule_required",
	-21: "account_not_found",
}

var createSaleCreationRequestResultCodeRevMap = map[string]int32{
	"CreateSaleCreationRequestResultCodeSuccess":                         0,
	"CreateSaleCreationRequestResultCodeRequestNotFound":                 -1,
	"CreateSaleCreationRequestResultCodeBaseAssetOrAssetRequestNotFound": -2,
	"CreateSaleCreationRequestResultCodeQuoteAssetNotFound":              -3,
	"CreateSaleCreationRequestResultCodeStartEndInvalid":                 -4,
	"CreateSaleCreationRequestResultCodeInvalidEnd":                      -5,
	"CreateSaleCreationRequestResultCodeInvalidPrice":                    -6,
	"CreateSaleCreationRequestResultCodeInvalidCap":                      -7,
	"CreateSaleCreationRequestResultCodeInsufficientMaxIssuance":         -8,
	"CreateSaleCreationRequestResultCodeInvalidAssetPair":                -9,
	"CreateSaleCreationRequestResultCodeRequestOrSaleAlreadyExists":      -10,
	"CreateSaleCreationRequestResultCodeInsufficientPreissued":           -11,
	"CreateSaleCreationRequestResultCodeInvalidCreatorDetails":           -12,
	"CreateSaleCreationRequestResultCodeVersionIsNotSupportedYet":        -13,
	"CreateSaleCreationRequestResultCodeSaleCreateTasksNotFound":         -14,
	"CreateSaleCreationRequestResultCodeNotAllowedToSetTasksOnUpdate":    -15,
	"CreateSaleCreationRequestResultCodeAutoReviewFailed":                -16,
	"CreateSaleCreationRequestResultCodeExceededMaxRulesSize":            -17,
	"CreateSaleCreationRequestResultCodeGlobalSpecificRuleDuplication":   -18,
	"CreateSaleCreationRequestResultCodeAccountSpecificRuleDuplication":  -19,
	"CreateSaleCreationRequestResultCodeGlobalSpecificRuleRequired":      -20,
	"CreateSaleCreationRequestResultCodeAccountNotFound":                 -21,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CreateSaleCreationRequestResultCode
func (e CreateSaleCreationRequestResultCode) ValidEnum(v int32) bool {
	_, ok := createSaleCreationRequestResultCodeMap[v]
	return ok
}
func (e CreateSaleCreationRequestResultCode) isFlag() bool {
	for i := len(CreateSaleCreationRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := CreateSaleCreationRequestResultCode(2) << uint64(len(CreateSaleCreationRequestResultCodeAll)-1) >> uint64(len(CreateSaleCreationRequestResultCodeAll)-i)
		if expected != CreateSaleCreationRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CreateSaleCreationRequestResultCode) String() string {
	name, _ := createSaleCreationRequestResultCodeMap[int32(e)]
	return name
}

func (e CreateSaleCreationRequestResultCode) ShortString() string {
	name, _ := createSaleCreationRequestResultCodeShortMap[int32(e)]
	return name
}

func (e CreateSaleCreationRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CreateSaleCreationRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CreateSaleCreationRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CreateSaleCreationRequestResultCode(t.Value)
	return nil
}

// CreateSaleCreationSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateSaleCreationSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateSaleCreationSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateSaleCreationSuccessExt
func (u CreateSaleCreationSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateSaleCreationSuccessExt creates a new  CreateSaleCreationSuccessExt.
func NewCreateSaleCreationSuccessExt(v LedgerVersion, value interface{}) (result CreateSaleCreationSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateSaleCreationSuccess is an XDR Struct defines as:
//
//   //: Result of the successful application of CreateSaleCreationRequest operation
//    struct CreateSaleCreationSuccess {
//        //: ID of the SaleCreation request
//        uint64 requestID;
//        //: ID of a newly created sale (if the sale creation request has been auto approved)
//        uint64 saleID;
//        //: Indicates whether or not the sale creation request was auto approved and fulfilled
//        bool fulfilled;
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CreateSaleCreationSuccess struct {
	RequestId Uint64                       `json:"requestID,omitempty"`
	SaleId    Uint64                       `json:"saleID,omitempty"`
	Fulfilled bool                         `json:"fulfilled,omitempty"`
	Ext       CreateSaleCreationSuccessExt `json:"ext,omitempty"`
}

// CreateSaleCreationAutoReviewFailedExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateSaleCreationAutoReviewFailedExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateSaleCreationAutoReviewFailedExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateSaleCreationAutoReviewFailedExt
func (u CreateSaleCreationAutoReviewFailedExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateSaleCreationAutoReviewFailedExt creates a new  CreateSaleCreationAutoReviewFailedExt.
func NewCreateSaleCreationAutoReviewFailedExt(v LedgerVersion, value interface{}) (result CreateSaleCreationAutoReviewFailedExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateSaleCreationAutoReviewFailed is an XDR Struct defines as:
//
//   //: specifies details on why an auto review has failed
//    struct CreateSaleCreationAutoReviewFailed {
//        //: auto review result
//        ReviewRequestResult reviewRequestRequest;
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CreateSaleCreationAutoReviewFailed struct {
	ReviewRequestRequest ReviewRequestResult                   `json:"reviewRequestRequest,omitempty"`
	Ext                  CreateSaleCreationAutoReviewFailedExt `json:"ext,omitempty"`
}

// CreateSaleCreationRequestResult is an XDR Union defines as:
//
//   //: CreateSaleCreationRequest result along with the result code
//    union CreateSaleCreationRequestResult switch (CreateSaleCreationRequestResultCode code)
//    {
//    case SUCCESS:
//        CreateSaleCreationSuccess success;
//    case AUTO_REVIEW_FAILED:
//        CreateSaleCreationAutoReviewFailed autoReviewFailed;
//    default:
//        void;
//    };
//
type CreateSaleCreationRequestResult struct {
	Code             CreateSaleCreationRequestResultCode `json:"code,omitempty"`
	Success          *CreateSaleCreationSuccess          `json:"success,omitempty"`
	AutoReviewFailed *CreateSaleCreationAutoReviewFailed `json:"autoReviewFailed,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateSaleCreationRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateSaleCreationRequestResult
func (u CreateSaleCreationRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch CreateSaleCreationRequestResultCode(sw) {
	case CreateSaleCreationRequestResultCodeSuccess:
		return "Success", true
	case CreateSaleCreationRequestResultCodeAutoReviewFailed:
		return "AutoReviewFailed", true
	default:
		return "", true
	}
}

// NewCreateSaleCreationRequestResult creates a new  CreateSaleCreationRequestResult.
func NewCreateSaleCreationRequestResult(code CreateSaleCreationRequestResultCode, value interface{}) (result CreateSaleCreationRequestResult, err error) {
	result.Code = code
	switch CreateSaleCreationRequestResultCode(code) {
	case CreateSaleCreationRequestResultCodeSuccess:
		tv, ok := value.(CreateSaleCreationSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateSaleCreationSuccess")
			return
		}
		result.Success = &tv
	case CreateSaleCreationRequestResultCodeAutoReviewFailed:
		tv, ok := value.(CreateSaleCreationAutoReviewFailed)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateSaleCreationAutoReviewFailed")
			return
		}
		result.AutoReviewFailed = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CreateSaleCreationRequestResult) MustSuccess() CreateSaleCreationSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CreateSaleCreationRequestResult) GetSuccess() (result CreateSaleCreationSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// MustAutoReviewFailed retrieves the AutoReviewFailed value from the union,
// panicing if the value is not set.
func (u CreateSaleCreationRequestResult) MustAutoReviewFailed() CreateSaleCreationAutoReviewFailed {
	val, ok := u.GetAutoReviewFailed()

	if !ok {
		panic("arm AutoReviewFailed is not set")
	}

	return val
}

// GetAutoReviewFailed retrieves the AutoReviewFailed value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CreateSaleCreationRequestResult) GetAutoReviewFailed() (result CreateSaleCreationAutoReviewFailed, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "AutoReviewFailed" {
		result = *u.AutoReviewFailed
		ok = true
	}

	return
}

// CreateWithdrawalRequestOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateWithdrawalRequestOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateWithdrawalRequestOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateWithdrawalRequestOpExt
func (u CreateWithdrawalRequestOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateWithdrawalRequestOpExt creates a new  CreateWithdrawalRequestOpExt.
func NewCreateWithdrawalRequestOpExt(v LedgerVersion, value interface{}) (result CreateWithdrawalRequestOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateWithdrawalRequestOp is an XDR Struct defines as:
//
//   //: CreateWithdrawalRequest operation is used to create a reviewable request,
//    //: which, after reviewer's approval, will charge the specified amount from balance and send it to external wallet/account
//    struct CreateWithdrawalRequestOp
//    {
//        //: Withdrawal request to create
//        WithdrawalRequest request;
//        //: (optional) Bit mask whose flags must be cleared in order for WithdrawalRequest to be approved, which will be used by key withdrawal_tasks:<asset_code>
//        //: instead of key-value
//        uint32* allTasks;
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//
//    };
//
type CreateWithdrawalRequestOp struct {
	Request  WithdrawalRequest            `json:"request,omitempty"`
	AllTasks *Uint32                      `json:"allTasks,omitempty"`
	Ext      CreateWithdrawalRequestOpExt `json:"ext,omitempty"`
}

// CreateWithdrawalRequestResultCode is an XDR Enum defines as:
//
//   //: CreateWithdrawalRequest operation result codes
//    enum CreateWithdrawalRequestResultCode
//    {
//        // codes considered as "success" for the operation
//        //: CreateWithdrawalRequest operation successfully applied
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: Trying to create a withdrawal with a 0 amount
//        INVALID_AMOUNT = -1,
//        //: Creator details are not in a valid JSON format
//        INVALID_CREATOR_DETAILS = -2,
//        //: Source balance to withdraw from is not found
//        BALANCE_NOT_FOUND = -3, // balance not found
//        //: Asset cannot be withdrawn because AssetPolicy::WITHDRAWABLE is not set
//        ASSET_IS_NOT_WITHDRAWABLE = -4,
//        //: Deprecated
//        CONVERSION_PRICE_IS_NOT_AVAILABLE = -5, // failed to find conversion price - conversion is not allowed
//        //: Expected fee and actual fee mismatch
//        FEE_MISMATCHED = -6,
//        //: Deprecated
//        CONVERSION_OVERFLOW = -7,
//        //: Deprecated
//        CONVERTED_AMOUNT_MISMATCHED = -8,
//        //: Trying to lock balance, locked amount would exceed UINT64_MAX
//        BALANCE_LOCK_OVERFLOW = -9,
//        //: Insufficient balance to withdraw the requested amount
//        UNDERFUNDED = -10,
//        //: Non zero universal amount
//        INVALID_UNIVERSAL_AMOUNT = -11,
//        //: Applying operation would overflow statistics
//        STATS_OVERFLOW = -12,
//        //: Applying operation would exceed limits set in the system
//        LIMITS_EXCEEDED = -13,
//        //: Deprecated
//        INVALID_PRE_CONFIRMATION_DETAILS = -14, // it's not allowed to pass pre confirmation details
//        //: Amount withdrawn is smaller than the minimal withdrawable amount set in the system
//        LOWER_BOUND_NOT_EXCEEDED = -15,
//        //: Withdrawal tasks are not set in the system, i.e. it's not allowed to perform withdraw operations
//        WITHDRAWAL_TASKS_NOT_FOUND = -16,
//        //: Not allowed to set withdrawal tasks on the request creation
//        NOT_ALLOWED_TO_SET_WITHDRAWAL_TASKS = -17,
//        //: Not allowed to set zero tasks
//        WITHDRAWAL_ZERO_TASKS_NOT_ALLOWED = -18
//    };
//
type CreateWithdrawalRequestResultCode int32

const (
	CreateWithdrawalRequestResultCodeSuccess                        CreateWithdrawalRequestResultCode = 0
	CreateWithdrawalRequestResultCodeInvalidAmount                  CreateWithdrawalRequestResultCode = -1
	CreateWithdrawalRequestResultCodeInvalidCreatorDetails          CreateWithdrawalRequestResultCode = -2
	CreateWithdrawalRequestResultCodeBalanceNotFound                CreateWithdrawalRequestResultCode = -3
	CreateWithdrawalRequestResultCodeAssetIsNotWithdrawable         CreateWithdrawalRequestResultCode = -4
	CreateWithdrawalRequestResultCodeConversionPriceIsNotAvailable  CreateWithdrawalRequestResultCode = -5
	CreateWithdrawalRequestResultCodeFeeMismatched                  CreateWithdrawalRequestResultCode = -6
	CreateWithdrawalRequestResultCodeConversionOverflow             CreateWithdrawalRequestResultCode = -7
	CreateWithdrawalRequestResultCodeConvertedAmountMismatched      CreateWithdrawalRequestResultCode = -8
	CreateWithdrawalRequestResultCodeBalanceLockOverflow            CreateWithdrawalRequestResultCode = -9
	CreateWithdrawalRequestResultCodeUnderfunded                    CreateWithdrawalRequestResultCode = -10
	CreateWithdrawalRequestResultCodeInvalidUniversalAmount         CreateWithdrawalRequestResultCode = -11
	CreateWithdrawalRequestResultCodeStatsOverflow                  CreateWithdrawalRequestResultCode = -12
	CreateWithdrawalRequestResultCodeLimitsExceeded                 CreateWithdrawalRequestResultCode = -13
	CreateWithdrawalRequestResultCodeInvalidPreConfirmationDetails  CreateWithdrawalRequestResultCode = -14
	CreateWithdrawalRequestResultCodeLowerBoundNotExceeded          CreateWithdrawalRequestResultCode = -15
	CreateWithdrawalRequestResultCodeWithdrawalTasksNotFound        CreateWithdrawalRequestResultCode = -16
	CreateWithdrawalRequestResultCodeNotAllowedToSetWithdrawalTasks CreateWithdrawalRequestResultCode = -17
	CreateWithdrawalRequestResultCodeWithdrawalZeroTasksNotAllowed  CreateWithdrawalRequestResultCode = -18
)

var CreateWithdrawalRequestResultCodeAll = []CreateWithdrawalRequestResultCode{
	CreateWithdrawalRequestResultCodeSuccess,
	CreateWithdrawalRequestResultCodeInvalidAmount,
	CreateWithdrawalRequestResultCodeInvalidCreatorDetails,
	CreateWithdrawalRequestResultCodeBalanceNotFound,
	CreateWithdrawalRequestResultCodeAssetIsNotWithdrawable,
	CreateWithdrawalRequestResultCodeConversionPriceIsNotAvailable,
	CreateWithdrawalRequestResultCodeFeeMismatched,
	CreateWithdrawalRequestResultCodeConversionOverflow,
	CreateWithdrawalRequestResultCodeConvertedAmountMismatched,
	CreateWithdrawalRequestResultCodeBalanceLockOverflow,
	CreateWithdrawalRequestResultCodeUnderfunded,
	CreateWithdrawalRequestResultCodeInvalidUniversalAmount,
	CreateWithdrawalRequestResultCodeStatsOverflow,
	CreateWithdrawalRequestResultCodeLimitsExceeded,
	CreateWithdrawalRequestResultCodeInvalidPreConfirmationDetails,
	CreateWithdrawalRequestResultCodeLowerBoundNotExceeded,
	CreateWithdrawalRequestResultCodeWithdrawalTasksNotFound,
	CreateWithdrawalRequestResultCodeNotAllowedToSetWithdrawalTasks,
	CreateWithdrawalRequestResultCodeWithdrawalZeroTasksNotAllowed,
}

var createWithdrawalRequestResultCodeMap = map[int32]string{
	0:   "CreateWithdrawalRequestResultCodeSuccess",
	-1:  "CreateWithdrawalRequestResultCodeInvalidAmount",
	-2:  "CreateWithdrawalRequestResultCodeInvalidCreatorDetails",
	-3:  "CreateWithdrawalRequestResultCodeBalanceNotFound",
	-4:  "CreateWithdrawalRequestResultCodeAssetIsNotWithdrawable",
	-5:  "CreateWithdrawalRequestResultCodeConversionPriceIsNotAvailable",
	-6:  "CreateWithdrawalRequestResultCodeFeeMismatched",
	-7:  "CreateWithdrawalRequestResultCodeConversionOverflow",
	-8:  "CreateWithdrawalRequestResultCodeConvertedAmountMismatched",
	-9:  "CreateWithdrawalRequestResultCodeBalanceLockOverflow",
	-10: "CreateWithdrawalRequestResultCodeUnderfunded",
	-11: "CreateWithdrawalRequestResultCodeInvalidUniversalAmount",
	-12: "CreateWithdrawalRequestResultCodeStatsOverflow",
	-13: "CreateWithdrawalRequestResultCodeLimitsExceeded",
	-14: "CreateWithdrawalRequestResultCodeInvalidPreConfirmationDetails",
	-15: "CreateWithdrawalRequestResultCodeLowerBoundNotExceeded",
	-16: "CreateWithdrawalRequestResultCodeWithdrawalTasksNotFound",
	-17: "CreateWithdrawalRequestResultCodeNotAllowedToSetWithdrawalTasks",
	-18: "CreateWithdrawalRequestResultCodeWithdrawalZeroTasksNotAllowed",
}

var createWithdrawalRequestResultCodeShortMap = map[int32]string{
	0:   "success",
	-1:  "invalid_amount",
	-2:  "invalid_creator_details",
	-3:  "balance_not_found",
	-4:  "asset_is_not_withdrawable",
	-5:  "conversion_price_is_not_available",
	-6:  "fee_mismatched",
	-7:  "conversion_overflow",
	-8:  "converted_amount_mismatched",
	-9:  "balance_lock_overflow",
	-10: "underfunded",
	-11: "invalid_universal_amount",
	-12: "stats_overflow",
	-13: "limits_exceeded",
	-14: "invalid_pre_confirmation_details",
	-15: "lower_bound_not_exceeded",
	-16: "withdrawal_tasks_not_found",
	-17: "not_allowed_to_set_withdrawal_tasks",
	-18: "withdrawal_zero_tasks_not_allowed",
}

var createWithdrawalRequestResultCodeRevMap = map[string]int32{
	"CreateWithdrawalRequestResultCodeSuccess":                        0,
	"CreateWithdrawalRequestResultCodeInvalidAmount":                  -1,
	"CreateWithdrawalRequestResultCodeInvalidCreatorDetails":          -2,
	"CreateWithdrawalRequestResultCodeBalanceNotFound":                -3,
	"CreateWithdrawalRequestResultCodeAssetIsNotWithdrawable":         -4,
	"CreateWithdrawalRequestResultCodeConversionPriceIsNotAvailable":  -5,
	"CreateWithdrawalRequestResultCodeFeeMismatched":                  -6,
	"CreateWithdrawalRequestResultCodeConversionOverflow":             -7,
	"CreateWithdrawalRequestResultCodeConvertedAmountMismatched":      -8,
	"CreateWithdrawalRequestResultCodeBalanceLockOverflow":            -9,
	"CreateWithdrawalRequestResultCodeUnderfunded":                    -10,
	"CreateWithdrawalRequestResultCodeInvalidUniversalAmount":         -11,
	"CreateWithdrawalRequestResultCodeStatsOverflow":                  -12,
	"CreateWithdrawalRequestResultCodeLimitsExceeded":                 -13,
	"CreateWithdrawalRequestResultCodeInvalidPreConfirmationDetails":  -14,
	"CreateWithdrawalRequestResultCodeLowerBoundNotExceeded":          -15,
	"CreateWithdrawalRequestResultCodeWithdrawalTasksNotFound":        -16,
	"CreateWithdrawalRequestResultCodeNotAllowedToSetWithdrawalTasks": -17,
	"CreateWithdrawalRequestResultCodeWithdrawalZeroTasksNotAllowed":  -18,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CreateWithdrawalRequestResultCode
func (e CreateWithdrawalRequestResultCode) ValidEnum(v int32) bool {
	_, ok := createWithdrawalRequestResultCodeMap[v]
	return ok
}
func (e CreateWithdrawalRequestResultCode) isFlag() bool {
	for i := len(CreateWithdrawalRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := CreateWithdrawalRequestResultCode(2) << uint64(len(CreateWithdrawalRequestResultCodeAll)-1) >> uint64(len(CreateWithdrawalRequestResultCodeAll)-i)
		if expected != CreateWithdrawalRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CreateWithdrawalRequestResultCode) String() string {
	name, _ := createWithdrawalRequestResultCodeMap[int32(e)]
	return name
}

func (e CreateWithdrawalRequestResultCode) ShortString() string {
	name, _ := createWithdrawalRequestResultCodeShortMap[int32(e)]
	return name
}

func (e CreateWithdrawalRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CreateWithdrawalRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CreateWithdrawalRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CreateWithdrawalRequestResultCode(t.Value)
	return nil
}

// CreateWithdrawalSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateWithdrawalSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateWithdrawalSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateWithdrawalSuccessExt
func (u CreateWithdrawalSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateWithdrawalSuccessExt creates a new  CreateWithdrawalSuccessExt.
func NewCreateWithdrawalSuccessExt(v LedgerVersion, value interface{}) (result CreateWithdrawalSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateWithdrawalSuccess is an XDR Struct defines as:
//
//   //: Result of the successful withdrawal request creation
//    struct CreateWithdrawalSuccess {
//        //: ID of a newly created WithdrawalRequest
//        uint64 requestID;
//        //: Indicates whether or not the withdrawal request was auto approved and fulfilled
//        bool fulfilled;
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CreateWithdrawalSuccess struct {
	RequestId Uint64                     `json:"requestID,omitempty"`
	Fulfilled bool                       `json:"fulfilled,omitempty"`
	Ext       CreateWithdrawalSuccessExt `json:"ext,omitempty"`
}

// CreateWithdrawalRequestResult is an XDR Union defines as:
//
//   //: Result of applying CreateWithdrawalRequst operation along with the result code
//    union CreateWithdrawalRequestResult switch (CreateWithdrawalRequestResultCode code)
//    {
//        case SUCCESS:
//            CreateWithdrawalSuccess success;
//        default:
//            void;
//    };
//
type CreateWithdrawalRequestResult struct {
	Code    CreateWithdrawalRequestResultCode `json:"code,omitempty"`
	Success *CreateWithdrawalSuccess          `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateWithdrawalRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateWithdrawalRequestResult
func (u CreateWithdrawalRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch CreateWithdrawalRequestResultCode(sw) {
	case CreateWithdrawalRequestResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewCreateWithdrawalRequestResult creates a new  CreateWithdrawalRequestResult.
func NewCreateWithdrawalRequestResult(code CreateWithdrawalRequestResultCode, value interface{}) (result CreateWithdrawalRequestResult, err error) {
	result.Code = code
	switch CreateWithdrawalRequestResultCode(code) {
	case CreateWithdrawalRequestResultCodeSuccess:
		tv, ok := value.(CreateWithdrawalSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateWithdrawalSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u CreateWithdrawalRequestResult) MustSuccess() CreateWithdrawalSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CreateWithdrawalRequestResult) GetSuccess() (result CreateWithdrawalSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// InitiateKycRecoveryOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type InitiateKycRecoveryOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u InitiateKycRecoveryOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of InitiateKycRecoveryOpExt
func (u InitiateKycRecoveryOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewInitiateKycRecoveryOpExt creates a new  InitiateKycRecoveryOpExt.
func NewInitiateKycRecoveryOpExt(v LedgerVersion, value interface{}) (result InitiateKycRecoveryOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// InitiateKycRecoveryOp is an XDR Struct defines as:
//
//   //: InitiateKYCRecoveryOp is used to start KYC recovery process
//    struct InitiateKYCRecoveryOp
//    {
//        //: Address of account to be recovered
//        AccountID account;
//        //: New signer to set
//        PublicKey signer;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type InitiateKycRecoveryOp struct {
	Account AccountId                `json:"account,omitempty"`
	Signer  PublicKey                `json:"signer,omitempty"`
	Ext     InitiateKycRecoveryOpExt `json:"ext,omitempty"`
}

// InitiateKycRecoveryResultCode is an XDR Enum defines as:
//
//   //: Result codes of InitiateKYCRecoveryOp
//    enum InitiateKYCRecoveryResultCode
//    {
//        //: Means that KYC recovery was successfully initiated
//        SUCCESS = 0,
//
//        //: System configuration forbids KYC recovery
//        RECOVERY_NOT_ALLOWED = -1,
//        //: Either, there is no entry by key `kyc_recovery_signer_role`, or such role does not exists
//        RECOVERY_SIGNER_ROLE_NOT_FOUND = -2
//    };
//
type InitiateKycRecoveryResultCode int32

const (
	InitiateKycRecoveryResultCodeSuccess                    InitiateKycRecoveryResultCode = 0
	InitiateKycRecoveryResultCodeRecoveryNotAllowed         InitiateKycRecoveryResultCode = -1
	InitiateKycRecoveryResultCodeRecoverySignerRoleNotFound InitiateKycRecoveryResultCode = -2
)

var InitiateKycRecoveryResultCodeAll = []InitiateKycRecoveryResultCode{
	InitiateKycRecoveryResultCodeSuccess,
	InitiateKycRecoveryResultCodeRecoveryNotAllowed,
	InitiateKycRecoveryResultCodeRecoverySignerRoleNotFound,
}

var initiateKycRecoveryResultCodeMap = map[int32]string{
	0:  "InitiateKycRecoveryResultCodeSuccess",
	-1: "InitiateKycRecoveryResultCodeRecoveryNotAllowed",
	-2: "InitiateKycRecoveryResultCodeRecoverySignerRoleNotFound",
}

var initiateKycRecoveryResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "recovery_not_allowed",
	-2: "recovery_signer_role_not_found",
}

var initiateKycRecoveryResultCodeRevMap = map[string]int32{
	"InitiateKycRecoveryResultCodeSuccess":                    0,
	"InitiateKycRecoveryResultCodeRecoveryNotAllowed":         -1,
	"InitiateKycRecoveryResultCodeRecoverySignerRoleNotFound": -2,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for InitiateKycRecoveryResultCode
func (e InitiateKycRecoveryResultCode) ValidEnum(v int32) bool {
	_, ok := initiateKycRecoveryResultCodeMap[v]
	return ok
}
func (e InitiateKycRecoveryResultCode) isFlag() bool {
	for i := len(InitiateKycRecoveryResultCodeAll) - 1; i >= 0; i-- {
		expected := InitiateKycRecoveryResultCode(2) << uint64(len(InitiateKycRecoveryResultCodeAll)-1) >> uint64(len(InitiateKycRecoveryResultCodeAll)-i)
		if expected != InitiateKycRecoveryResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e InitiateKycRecoveryResultCode) String() string {
	name, _ := initiateKycRecoveryResultCodeMap[int32(e)]
	return name
}

func (e InitiateKycRecoveryResultCode) ShortString() string {
	name, _ := initiateKycRecoveryResultCodeShortMap[int32(e)]
	return name
}

func (e InitiateKycRecoveryResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range InitiateKycRecoveryResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *InitiateKycRecoveryResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = InitiateKycRecoveryResultCode(t.Value)
	return nil
}

// InitiateKycRecoveryResultSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//             {
//             case EMPTY_VERSION:
//                 void;
//             }
//
type InitiateKycRecoveryResultSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u InitiateKycRecoveryResultSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of InitiateKycRecoveryResultSuccessExt
func (u InitiateKycRecoveryResultSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewInitiateKycRecoveryResultSuccessExt creates a new  InitiateKycRecoveryResultSuccessExt.
func NewInitiateKycRecoveryResultSuccessExt(v LedgerVersion, value interface{}) (result InitiateKycRecoveryResultSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// InitiateKycRecoveryResultSuccess is an XDR NestedStruct defines as:
//
//   struct
//        {
//             //: reserved for future use
//             union switch (LedgerVersion v)
//             {
//             case EMPTY_VERSION:
//                 void;
//             } ext;
//        }
//
type InitiateKycRecoveryResultSuccess struct {
	Ext InitiateKycRecoveryResultSuccessExt `json:"ext,omitempty"`
}

// InitiateKycRecoveryResult is an XDR Union defines as:
//
//   //: Result of operation applying
//    union InitiateKYCRecoveryResult switch (InitiateKYCRecoveryResultCode code)
//    {
//    case SUCCESS:
//        struct
//        {
//             //: reserved for future use
//             union switch (LedgerVersion v)
//             {
//             case EMPTY_VERSION:
//                 void;
//             } ext;
//        } success;
//    default:
//        void;
//    };
//
type InitiateKycRecoveryResult struct {
	Code    InitiateKycRecoveryResultCode     `json:"code,omitempty"`
	Success *InitiateKycRecoveryResultSuccess `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u InitiateKycRecoveryResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of InitiateKycRecoveryResult
func (u InitiateKycRecoveryResult) ArmForSwitch(sw int32) (string, bool) {
	switch InitiateKycRecoveryResultCode(sw) {
	case InitiateKycRecoveryResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewInitiateKycRecoveryResult creates a new  InitiateKycRecoveryResult.
func NewInitiateKycRecoveryResult(code InitiateKycRecoveryResultCode, value interface{}) (result InitiateKycRecoveryResult, err error) {
	result.Code = code
	switch InitiateKycRecoveryResultCode(code) {
	case InitiateKycRecoveryResultCodeSuccess:
		tv, ok := value.(InitiateKycRecoveryResultSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be InitiateKycRecoveryResultSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u InitiateKycRecoveryResult) MustSuccess() InitiateKycRecoveryResultSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u InitiateKycRecoveryResult) GetSuccess() (result InitiateKycRecoveryResultSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// LicenseOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type LicenseOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LicenseOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LicenseOpExt
func (u LicenseOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLicenseOpExt creates a new  LicenseOpExt.
func NewLicenseOpExt(v LedgerVersion, value interface{}) (result LicenseOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LicenseOp is an XDR Struct defines as:
//
//   //: License operation is used to increase the allowed number of admins and due date
//    struct LicenseOp
//    {
//        //: Allowed number of admins to set in the system
//        uint64 adminCount;
//        //: Expiration date of the license
//        uint64 dueDate;
//        //: Hash of a stamped ledger
//        Hash ledgerHash;
//        //: Hash of the previous license
//        Hash prevLicenseHash;
//        //: Signatures are used to prove authenticity of license that is being submitted.
//        DecoratedSignature signatures<>;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type LicenseOp struct {
	AdminCount      Uint64               `json:"adminCount,omitempty"`
	DueDate         Uint64               `json:"dueDate,omitempty"`
	LedgerHash      Hash                 `json:"ledgerHash,omitempty"`
	PrevLicenseHash Hash                 `json:"prevLicenseHash,omitempty"`
	Signatures      []DecoratedSignature `json:"signatures,omitempty"`
	Ext             LicenseOpExt         `json:"ext,omitempty"`
}

// LicenseResultCode is an XDR Enum defines as:
//
//   //: Result code of the License operation application
//    enum LicenseResultCode
//    {
//        //: License submit was successful, provided adminCount and dueDate were set in the system
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: Provided ledger hash and license hash were not stamped and are missing in the system.
//        INVALID_STAMP = -1,
//        //: Provided due date is in the past.
//        INVALID_DUE_DATE = -2,
//        //: Not enough valid signatures to submit a license (at least one valid signature is required)
//        INVALID_SIGNATURE = -3,
//        EXTRA_SIGNATURES = -4
//    };
//
type LicenseResultCode int32

const (
	LicenseResultCodeSuccess          LicenseResultCode = 0
	LicenseResultCodeInvalidStamp     LicenseResultCode = -1
	LicenseResultCodeInvalidDueDate   LicenseResultCode = -2
	LicenseResultCodeInvalidSignature LicenseResultCode = -3
	LicenseResultCodeExtraSignatures  LicenseResultCode = -4
)

var LicenseResultCodeAll = []LicenseResultCode{
	LicenseResultCodeSuccess,
	LicenseResultCodeInvalidStamp,
	LicenseResultCodeInvalidDueDate,
	LicenseResultCodeInvalidSignature,
	LicenseResultCodeExtraSignatures,
}

var licenseResultCodeMap = map[int32]string{
	0:  "LicenseResultCodeSuccess",
	-1: "LicenseResultCodeInvalidStamp",
	-2: "LicenseResultCodeInvalidDueDate",
	-3: "LicenseResultCodeInvalidSignature",
	-4: "LicenseResultCodeExtraSignatures",
}

var licenseResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "invalid_stamp",
	-2: "invalid_due_date",
	-3: "invalid_signature",
	-4: "extra_signatures",
}

var licenseResultCodeRevMap = map[string]int32{
	"LicenseResultCodeSuccess":          0,
	"LicenseResultCodeInvalidStamp":     -1,
	"LicenseResultCodeInvalidDueDate":   -2,
	"LicenseResultCodeInvalidSignature": -3,
	"LicenseResultCodeExtraSignatures":  -4,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for LicenseResultCode
func (e LicenseResultCode) ValidEnum(v int32) bool {
	_, ok := licenseResultCodeMap[v]
	return ok
}
func (e LicenseResultCode) isFlag() bool {
	for i := len(LicenseResultCodeAll) - 1; i >= 0; i-- {
		expected := LicenseResultCode(2) << uint64(len(LicenseResultCodeAll)-1) >> uint64(len(LicenseResultCodeAll)-i)
		if expected != LicenseResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e LicenseResultCode) String() string {
	name, _ := licenseResultCodeMap[int32(e)]
	return name
}

func (e LicenseResultCode) ShortString() string {
	name, _ := licenseResultCodeShortMap[int32(e)]
	return name
}

func (e LicenseResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range LicenseResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *LicenseResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = LicenseResultCode(t.Value)
	return nil
}

// LicenseSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type LicenseSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LicenseSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LicenseSuccessExt
func (u LicenseSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLicenseSuccessExt creates a new  LicenseSuccessExt.
func NewLicenseSuccessExt(v LedgerVersion, value interface{}) (result LicenseSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LicenseSuccess is an XDR Struct defines as:
//
//   //: LicenseSuccess is a result of successful LicenseOp application
//    struct LicenseSuccess {
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type LicenseSuccess struct {
	Ext LicenseSuccessExt `json:"ext,omitempty"`
}

// LicenseResult is an XDR Union defines as:
//
//   //: Result of the License operation application
//    union LicenseResult switch (LicenseResultCode code)
//    {
//    case SUCCESS:
//        LicenseSuccess success;
//    default:
//        void;
//    };
//
type LicenseResult struct {
	Code    LicenseResultCode `json:"code,omitempty"`
	Success *LicenseSuccess   `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LicenseResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LicenseResult
func (u LicenseResult) ArmForSwitch(sw int32) (string, bool) {
	switch LicenseResultCode(sw) {
	case LicenseResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewLicenseResult creates a new  LicenseResult.
func NewLicenseResult(code LicenseResultCode, value interface{}) (result LicenseResult, err error) {
	result.Code = code
	switch LicenseResultCode(code) {
	case LicenseResultCodeSuccess:
		tv, ok := value.(LicenseSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be LicenseSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u LicenseResult) MustSuccess() LicenseSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u LicenseResult) GetSuccess() (result LicenseSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// ManageAccountRoleAction is an XDR Enum defines as:
//
//   //: Actions that can be performed with the account role
//    enum ManageAccountRoleAction
//    {
//        CREATE = 0,
//        UPDATE = 1,
//        REMOVE = 2
//    };
//
type ManageAccountRoleAction int32

const (
	ManageAccountRoleActionCreate ManageAccountRoleAction = 0
	ManageAccountRoleActionUpdate ManageAccountRoleAction = 1
	ManageAccountRoleActionRemove ManageAccountRoleAction = 2
)

var ManageAccountRoleActionAll = []ManageAccountRoleAction{
	ManageAccountRoleActionCreate,
	ManageAccountRoleActionUpdate,
	ManageAccountRoleActionRemove,
}

var manageAccountRoleActionMap = map[int32]string{
	0: "ManageAccountRoleActionCreate",
	1: "ManageAccountRoleActionUpdate",
	2: "ManageAccountRoleActionRemove",
}

var manageAccountRoleActionShortMap = map[int32]string{
	0: "create",
	1: "update",
	2: "remove",
}

var manageAccountRoleActionRevMap = map[string]int32{
	"ManageAccountRoleActionCreate": 0,
	"ManageAccountRoleActionUpdate": 1,
	"ManageAccountRoleActionRemove": 2,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageAccountRoleAction
func (e ManageAccountRoleAction) ValidEnum(v int32) bool {
	_, ok := manageAccountRoleActionMap[v]
	return ok
}
func (e ManageAccountRoleAction) isFlag() bool {
	for i := len(ManageAccountRoleActionAll) - 1; i >= 0; i-- {
		expected := ManageAccountRoleAction(2) << uint64(len(ManageAccountRoleActionAll)-1) >> uint64(len(ManageAccountRoleActionAll)-i)
		if expected != ManageAccountRoleActionAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageAccountRoleAction) String() string {
	name, _ := manageAccountRoleActionMap[int32(e)]
	return name
}

func (e ManageAccountRoleAction) ShortString() string {
	name, _ := manageAccountRoleActionShortMap[int32(e)]
	return name
}

func (e ManageAccountRoleAction) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageAccountRoleActionAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageAccountRoleAction) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageAccountRoleAction(t.Value)
	return nil
}

// CreateAccountRoleDataExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateAccountRoleDataExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateAccountRoleDataExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateAccountRoleDataExt
func (u CreateAccountRoleDataExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateAccountRoleDataExt creates a new  CreateAccountRoleDataExt.
func NewCreateAccountRoleDataExt(v LedgerVersion, value interface{}) (result CreateAccountRoleDataExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateAccountRoleData is an XDR Struct defines as:
//
//   //: CreateAccountRoleData is used to pass necessary params to create a new account role
//    struct CreateAccountRoleData
//    {
//        //: Arbitrary stringified json object that will be attached to the role
//        longstring details;
//        //: Array of ids of existing unique rules
//        uint64 ruleIDs<>;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type CreateAccountRoleData struct {
	Details Longstring               `json:"details,omitempty"`
	RuleIDs []Uint64                 `json:"ruleIDs,omitempty"`
	Ext     CreateAccountRoleDataExt `json:"ext,omitempty"`
}

// UpdateAccountRoleDataExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type UpdateAccountRoleDataExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u UpdateAccountRoleDataExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of UpdateAccountRoleDataExt
func (u UpdateAccountRoleDataExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewUpdateAccountRoleDataExt creates a new  UpdateAccountRoleDataExt.
func NewUpdateAccountRoleDataExt(v LedgerVersion, value interface{}) (result UpdateAccountRoleDataExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// UpdateAccountRoleData is an XDR Struct defines as:
//
//   //: UpdateAccountRoleData is used to pass necessary params to update existing account role
//    struct UpdateAccountRoleData
//    {
//        //: Identifier of existing signer role
//        uint64 roleID;
//        //: Arbitrary stringified json object that will be attached to the role
//        longstring details;
//        //: Array of ids of existing unique rules
//        uint64 ruleIDs<>;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type UpdateAccountRoleData struct {
	RoleId  Uint64                   `json:"roleID,omitempty"`
	Details Longstring               `json:"details,omitempty"`
	RuleIDs []Uint64                 `json:"ruleIDs,omitempty"`
	Ext     UpdateAccountRoleDataExt `json:"ext,omitempty"`
}

// RemoveAccountRoleDataExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type RemoveAccountRoleDataExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u RemoveAccountRoleDataExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of RemoveAccountRoleDataExt
func (u RemoveAccountRoleDataExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewRemoveAccountRoleDataExt creates a new  RemoveAccountRoleDataExt.
func NewRemoveAccountRoleDataExt(v LedgerVersion, value interface{}) (result RemoveAccountRoleDataExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// RemoveAccountRoleData is an XDR Struct defines as:
//
//   //: RemoveAccountRoleData is used to pass necessary params to remove an existing account role
//    struct RemoveAccountRoleData
//    {
//        //: Identifier of an existing account role
//        uint64 roleID;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type RemoveAccountRoleData struct {
	RoleId Uint64                   `json:"roleID,omitempty"`
	Ext    RemoveAccountRoleDataExt `json:"ext,omitempty"`
}

// ManageAccountRoleOpData is an XDR NestedUnion defines as:
//
//   union switch (ManageAccountRoleAction action)
//        {
//        case CREATE:
//            CreateAccountRoleData createData;
//        case UPDATE:
//            UpdateAccountRoleData updateData;
//        case REMOVE:
//            RemoveAccountRoleData removeData;
//        }
//
type ManageAccountRoleOpData struct {
	Action     ManageAccountRoleAction `json:"action,omitempty"`
	CreateData *CreateAccountRoleData  `json:"createData,omitempty"`
	UpdateData *UpdateAccountRoleData  `json:"updateData,omitempty"`
	RemoveData *RemoveAccountRoleData  `json:"removeData,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageAccountRoleOpData) SwitchFieldName() string {
	return "Action"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageAccountRoleOpData
func (u ManageAccountRoleOpData) ArmForSwitch(sw int32) (string, bool) {
	switch ManageAccountRoleAction(sw) {
	case ManageAccountRoleActionCreate:
		return "CreateData", true
	case ManageAccountRoleActionUpdate:
		return "UpdateData", true
	case ManageAccountRoleActionRemove:
		return "RemoveData", true
	}
	return "-", false
}

// NewManageAccountRoleOpData creates a new  ManageAccountRoleOpData.
func NewManageAccountRoleOpData(action ManageAccountRoleAction, value interface{}) (result ManageAccountRoleOpData, err error) {
	result.Action = action
	switch ManageAccountRoleAction(action) {
	case ManageAccountRoleActionCreate:
		tv, ok := value.(CreateAccountRoleData)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateAccountRoleData")
			return
		}
		result.CreateData = &tv
	case ManageAccountRoleActionUpdate:
		tv, ok := value.(UpdateAccountRoleData)
		if !ok {
			err = fmt.Errorf("invalid value, must be UpdateAccountRoleData")
			return
		}
		result.UpdateData = &tv
	case ManageAccountRoleActionRemove:
		tv, ok := value.(RemoveAccountRoleData)
		if !ok {
			err = fmt.Errorf("invalid value, must be RemoveAccountRoleData")
			return
		}
		result.RemoveData = &tv
	}
	return
}

// MustCreateData retrieves the CreateData value from the union,
// panicing if the value is not set.
func (u ManageAccountRoleOpData) MustCreateData() CreateAccountRoleData {
	val, ok := u.GetCreateData()

	if !ok {
		panic("arm CreateData is not set")
	}

	return val
}

// GetCreateData retrieves the CreateData value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageAccountRoleOpData) GetCreateData() (result CreateAccountRoleData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "CreateData" {
		result = *u.CreateData
		ok = true
	}

	return
}

// MustUpdateData retrieves the UpdateData value from the union,
// panicing if the value is not set.
func (u ManageAccountRoleOpData) MustUpdateData() UpdateAccountRoleData {
	val, ok := u.GetUpdateData()

	if !ok {
		panic("arm UpdateData is not set")
	}

	return val
}

// GetUpdateData retrieves the UpdateData value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageAccountRoleOpData) GetUpdateData() (result UpdateAccountRoleData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "UpdateData" {
		result = *u.UpdateData
		ok = true
	}

	return
}

// MustRemoveData retrieves the RemoveData value from the union,
// panicing if the value is not set.
func (u ManageAccountRoleOpData) MustRemoveData() RemoveAccountRoleData {
	val, ok := u.GetRemoveData()

	if !ok {
		panic("arm RemoveData is not set")
	}

	return val
}

// GetRemoveData retrieves the RemoveData value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageAccountRoleOpData) GetRemoveData() (result RemoveAccountRoleData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "RemoveData" {
		result = *u.RemoveData
		ok = true
	}

	return
}

// ManageAccountRoleOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ManageAccountRoleOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageAccountRoleOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageAccountRoleOpExt
func (u ManageAccountRoleOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageAccountRoleOpExt creates a new  ManageAccountRoleOpExt.
func NewManageAccountRoleOpExt(v LedgerVersion, value interface{}) (result ManageAccountRoleOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageAccountRoleOp is an XDR Struct defines as:
//
//   //: ManageAccountRoleOp is used to create, update or remove account role
//    struct ManageAccountRoleOp
//    {
//        //: data is used to pass one of `ManageAccountRoleAction` with required params
//        union switch (ManageAccountRoleAction action)
//        {
//        case CREATE:
//            CreateAccountRoleData createData;
//        case UPDATE:
//            UpdateAccountRoleData updateData;
//        case REMOVE:
//            RemoveAccountRoleData removeData;
//        } data;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ManageAccountRoleOp struct {
	Data ManageAccountRoleOpData `json:"data,omitempty"`
	Ext  ManageAccountRoleOpExt  `json:"ext,omitempty"`
}

// ManageAccountRoleResultCode is an XDR Enum defines as:
//
//   //: Result codes of ManageAccountRoleResultCode
//    enum ManageAccountRoleResultCode
//    {
//        //: This means that the specified action in `data` of ManageAccountRoleOp was successfully performed
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: There is no account role with such id
//        NOT_FOUND = -1,
//        //: THe role cannot be removed if it is attached to at least one account
//        ROLE_IS_USED = -2,
//        //: Passed details has an invalid json structure
//        INVALID_DETAILS = -3,
//        //: There is no rule with id passed through `ruleIDs`
//        NO_SUCH_RULE = -4,
//        //: It is not allowed to duplicate ids in `ruleIDs` array
//        RULE_ID_DUPLICATION = -5
//    };
//
type ManageAccountRoleResultCode int32

const (
	ManageAccountRoleResultCodeSuccess           ManageAccountRoleResultCode = 0
	ManageAccountRoleResultCodeNotFound          ManageAccountRoleResultCode = -1
	ManageAccountRoleResultCodeRoleIsUsed        ManageAccountRoleResultCode = -2
	ManageAccountRoleResultCodeInvalidDetails    ManageAccountRoleResultCode = -3
	ManageAccountRoleResultCodeNoSuchRule        ManageAccountRoleResultCode = -4
	ManageAccountRoleResultCodeRuleIdDuplication ManageAccountRoleResultCode = -5
)

var ManageAccountRoleResultCodeAll = []ManageAccountRoleResultCode{
	ManageAccountRoleResultCodeSuccess,
	ManageAccountRoleResultCodeNotFound,
	ManageAccountRoleResultCodeRoleIsUsed,
	ManageAccountRoleResultCodeInvalidDetails,
	ManageAccountRoleResultCodeNoSuchRule,
	ManageAccountRoleResultCodeRuleIdDuplication,
}

var manageAccountRoleResultCodeMap = map[int32]string{
	0:  "ManageAccountRoleResultCodeSuccess",
	-1: "ManageAccountRoleResultCodeNotFound",
	-2: "ManageAccountRoleResultCodeRoleIsUsed",
	-3: "ManageAccountRoleResultCodeInvalidDetails",
	-4: "ManageAccountRoleResultCodeNoSuchRule",
	-5: "ManageAccountRoleResultCodeRuleIdDuplication",
}

var manageAccountRoleResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "not_found",
	-2: "role_is_used",
	-3: "invalid_details",
	-4: "no_such_rule",
	-5: "rule_id_duplication",
}

var manageAccountRoleResultCodeRevMap = map[string]int32{
	"ManageAccountRoleResultCodeSuccess":           0,
	"ManageAccountRoleResultCodeNotFound":          -1,
	"ManageAccountRoleResultCodeRoleIsUsed":        -2,
	"ManageAccountRoleResultCodeInvalidDetails":    -3,
	"ManageAccountRoleResultCodeNoSuchRule":        -4,
	"ManageAccountRoleResultCodeRuleIdDuplication": -5,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageAccountRoleResultCode
func (e ManageAccountRoleResultCode) ValidEnum(v int32) bool {
	_, ok := manageAccountRoleResultCodeMap[v]
	return ok
}
func (e ManageAccountRoleResultCode) isFlag() bool {
	for i := len(ManageAccountRoleResultCodeAll) - 1; i >= 0; i-- {
		expected := ManageAccountRoleResultCode(2) << uint64(len(ManageAccountRoleResultCodeAll)-1) >> uint64(len(ManageAccountRoleResultCodeAll)-i)
		if expected != ManageAccountRoleResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageAccountRoleResultCode) String() string {
	name, _ := manageAccountRoleResultCodeMap[int32(e)]
	return name
}

func (e ManageAccountRoleResultCode) ShortString() string {
	name, _ := manageAccountRoleResultCodeShortMap[int32(e)]
	return name
}

func (e ManageAccountRoleResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageAccountRoleResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageAccountRoleResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageAccountRoleResultCode(t.Value)
	return nil
}

// ManageAccountRoleResultSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//                {
//                case EMPTY_VERSION:
//                    void;
//                }
//
type ManageAccountRoleResultSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageAccountRoleResultSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageAccountRoleResultSuccessExt
func (u ManageAccountRoleResultSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageAccountRoleResultSuccessExt creates a new  ManageAccountRoleResultSuccessExt.
func NewManageAccountRoleResultSuccessExt(v LedgerVersion, value interface{}) (result ManageAccountRoleResultSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageAccountRoleResultSuccess is an XDR NestedStruct defines as:
//
//   struct {
//                //: id of the role that was managed
//                uint64 roleID;
//
//                //: reserved for future use
//                union switch (LedgerVersion v)
//                {
//                case EMPTY_VERSION:
//                    void;
//                }
//                ext;
//            }
//
type ManageAccountRoleResultSuccess struct {
	RoleId Uint64                            `json:"roleID,omitempty"`
	Ext    ManageAccountRoleResultSuccessExt `json:"ext,omitempty"`
}

// ManageAccountRoleResult is an XDR Union defines as:
//
//   //: Result of the operation performed
//    union ManageAccountRoleResult switch (ManageAccountRoleResultCode code)
//    {
//        case SUCCESS:
//            //: Is used to pass useful params if the operation is successful
//            struct {
//                //: id of the role that was managed
//                uint64 roleID;
//
//                //: reserved for future use
//                union switch (LedgerVersion v)
//                {
//                case EMPTY_VERSION:
//                    void;
//                }
//                ext;
//            } success;
//        case RULE_ID_DUPLICATION:
//        case NO_SUCH_RULE:
//            //: ID of a rule that was either duplicated or does not exist
//            uint64 ruleID;
//        default:
//            void;
//    };
//
type ManageAccountRoleResult struct {
	Code    ManageAccountRoleResultCode     `json:"code,omitempty"`
	Success *ManageAccountRoleResultSuccess `json:"success,omitempty"`
	RuleId  *Uint64                         `json:"ruleID,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageAccountRoleResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageAccountRoleResult
func (u ManageAccountRoleResult) ArmForSwitch(sw int32) (string, bool) {
	switch ManageAccountRoleResultCode(sw) {
	case ManageAccountRoleResultCodeSuccess:
		return "Success", true
	case ManageAccountRoleResultCodeRuleIdDuplication:
		return "RuleId", true
	case ManageAccountRoleResultCodeNoSuchRule:
		return "RuleId", true
	default:
		return "", true
	}
}

// NewManageAccountRoleResult creates a new  ManageAccountRoleResult.
func NewManageAccountRoleResult(code ManageAccountRoleResultCode, value interface{}) (result ManageAccountRoleResult, err error) {
	result.Code = code
	switch ManageAccountRoleResultCode(code) {
	case ManageAccountRoleResultCodeSuccess:
		tv, ok := value.(ManageAccountRoleResultSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageAccountRoleResultSuccess")
			return
		}
		result.Success = &tv
	case ManageAccountRoleResultCodeRuleIdDuplication:
		tv, ok := value.(Uint64)
		if !ok {
			err = fmt.Errorf("invalid value, must be Uint64")
			return
		}
		result.RuleId = &tv
	case ManageAccountRoleResultCodeNoSuchRule:
		tv, ok := value.(Uint64)
		if !ok {
			err = fmt.Errorf("invalid value, must be Uint64")
			return
		}
		result.RuleId = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u ManageAccountRoleResult) MustSuccess() ManageAccountRoleResultSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageAccountRoleResult) GetSuccess() (result ManageAccountRoleResultSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// MustRuleId retrieves the RuleId value from the union,
// panicing if the value is not set.
func (u ManageAccountRoleResult) MustRuleId() Uint64 {
	val, ok := u.GetRuleId()

	if !ok {
		panic("arm RuleId is not set")
	}

	return val
}

// GetRuleId retrieves the RuleId value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageAccountRoleResult) GetRuleId() (result Uint64, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "RuleId" {
		result = *u.RuleId
		ok = true
	}

	return
}

// ManageAccountRuleAction is an XDR Enum defines as:
//
//   //: Actions that can be performed with account rule
//    enum ManageAccountRuleAction
//    {
//        CREATE = 0,
//        UPDATE = 1,
//        REMOVE = 2
//    };
//
type ManageAccountRuleAction int32

const (
	ManageAccountRuleActionCreate ManageAccountRuleAction = 0
	ManageAccountRuleActionUpdate ManageAccountRuleAction = 1
	ManageAccountRuleActionRemove ManageAccountRuleAction = 2
)

var ManageAccountRuleActionAll = []ManageAccountRuleAction{
	ManageAccountRuleActionCreate,
	ManageAccountRuleActionUpdate,
	ManageAccountRuleActionRemove,
}

var manageAccountRuleActionMap = map[int32]string{
	0: "ManageAccountRuleActionCreate",
	1: "ManageAccountRuleActionUpdate",
	2: "ManageAccountRuleActionRemove",
}

var manageAccountRuleActionShortMap = map[int32]string{
	0: "create",
	1: "update",
	2: "remove",
}

var manageAccountRuleActionRevMap = map[string]int32{
	"ManageAccountRuleActionCreate": 0,
	"ManageAccountRuleActionUpdate": 1,
	"ManageAccountRuleActionRemove": 2,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageAccountRuleAction
func (e ManageAccountRuleAction) ValidEnum(v int32) bool {
	_, ok := manageAccountRuleActionMap[v]
	return ok
}
func (e ManageAccountRuleAction) isFlag() bool {
	for i := len(ManageAccountRuleActionAll) - 1; i >= 0; i-- {
		expected := ManageAccountRuleAction(2) << uint64(len(ManageAccountRuleActionAll)-1) >> uint64(len(ManageAccountRuleActionAll)-i)
		if expected != ManageAccountRuleActionAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageAccountRuleAction) String() string {
	name, _ := manageAccountRuleActionMap[int32(e)]
	return name
}

func (e ManageAccountRuleAction) ShortString() string {
	name, _ := manageAccountRuleActionShortMap[int32(e)]
	return name
}

func (e ManageAccountRuleAction) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageAccountRuleActionAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageAccountRuleAction) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageAccountRuleAction(t.Value)
	return nil
}

// CreateAccountRuleDataExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateAccountRuleDataExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateAccountRuleDataExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateAccountRuleDataExt
func (u CreateAccountRuleDataExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateAccountRuleDataExt creates a new  CreateAccountRuleDataExt.
func NewCreateAccountRuleDataExt(v LedgerVersion, value interface{}) (result CreateAccountRuleDataExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateAccountRuleData is an XDR Struct defines as:
//
//   //: CreateAccountRuleData is used to pass necessary params to create a new account rule
//    struct CreateAccountRuleData
//    {
//        //: Resource is used to specify an entity (for some - with properties) that can be managed through operations
//        AccountRuleResource resource;
//        //: Value from enum that can be applied to `resource`
//        AccountRuleAction action;
//        //: True if such `action` on such `resource` is prohibited, otherwise allows
//        bool forbids;
//        //: Arbitrary stringified json object that will be attached to rule
//        longstring details;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type CreateAccountRuleData struct {
	Resource AccountRuleResource      `json:"resource,omitempty"`
	Action   AccountRuleAction        `json:"action,omitempty"`
	Forbids  bool                     `json:"forbids,omitempty"`
	Details  Longstring               `json:"details,omitempty"`
	Ext      CreateAccountRuleDataExt `json:"ext,omitempty"`
}

// UpdateAccountRuleDataExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type UpdateAccountRuleDataExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u UpdateAccountRuleDataExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of UpdateAccountRuleDataExt
func (u UpdateAccountRuleDataExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewUpdateAccountRuleDataExt creates a new  UpdateAccountRuleDataExt.
func NewUpdateAccountRuleDataExt(v LedgerVersion, value interface{}) (result UpdateAccountRuleDataExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// UpdateAccountRuleData is an XDR Struct defines as:
//
//   //: UpdateAccountRuleData is used to pass necessary params to update existing account rule
//    struct UpdateAccountRuleData
//    {
//        //: Identifier of existing signer rule
//        uint64 ruleID;
//        //: Resource is used to specify entity (for some - with properties) that can be managed through operations
//        AccountRuleResource resource;
//        //: Value from enum that can be applied to `resource`
//        AccountRuleAction action;
//        //: True if such `action` on such `resource` is prohibited, otherwise allows
//        bool forbids;
//        //: Arbitrary stringified json object that will be attached to rule
//        longstring details;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type UpdateAccountRuleData struct {
	RuleId   Uint64                   `json:"ruleID,omitempty"`
	Resource AccountRuleResource      `json:"resource,omitempty"`
	Action   AccountRuleAction        `json:"action,omitempty"`
	Forbids  bool                     `json:"forbids,omitempty"`
	Details  Longstring               `json:"details,omitempty"`
	Ext      UpdateAccountRuleDataExt `json:"ext,omitempty"`
}

// RemoveAccountRuleDataExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type RemoveAccountRuleDataExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u RemoveAccountRuleDataExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of RemoveAccountRuleDataExt
func (u RemoveAccountRuleDataExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewRemoveAccountRuleDataExt creates a new  RemoveAccountRuleDataExt.
func NewRemoveAccountRuleDataExt(v LedgerVersion, value interface{}) (result RemoveAccountRuleDataExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// RemoveAccountRuleData is an XDR Struct defines as:
//
//   //: RemoveAccountRuleData is used to pass necessary params to remove existing account rule
//    struct RemoveAccountRuleData
//    {
//        //: Identifier of existing account rule
//        uint64 ruleID;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type RemoveAccountRuleData struct {
	RuleId Uint64                   `json:"ruleID,omitempty"`
	Ext    RemoveAccountRuleDataExt `json:"ext,omitempty"`
}

// ManageAccountRuleOpData is an XDR NestedUnion defines as:
//
//   union switch (ManageAccountRuleAction action)
//        {
//        case CREATE:
//            CreateAccountRuleData createData;
//        case UPDATE:
//            UpdateAccountRuleData updateData;
//        case REMOVE:
//            RemoveAccountRuleData removeData;
//        }
//
type ManageAccountRuleOpData struct {
	Action     ManageAccountRuleAction `json:"action,omitempty"`
	CreateData *CreateAccountRuleData  `json:"createData,omitempty"`
	UpdateData *UpdateAccountRuleData  `json:"updateData,omitempty"`
	RemoveData *RemoveAccountRuleData  `json:"removeData,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageAccountRuleOpData) SwitchFieldName() string {
	return "Action"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageAccountRuleOpData
func (u ManageAccountRuleOpData) ArmForSwitch(sw int32) (string, bool) {
	switch ManageAccountRuleAction(sw) {
	case ManageAccountRuleActionCreate:
		return "CreateData", true
	case ManageAccountRuleActionUpdate:
		return "UpdateData", true
	case ManageAccountRuleActionRemove:
		return "RemoveData", true
	}
	return "-", false
}

// NewManageAccountRuleOpData creates a new  ManageAccountRuleOpData.
func NewManageAccountRuleOpData(action ManageAccountRuleAction, value interface{}) (result ManageAccountRuleOpData, err error) {
	result.Action = action
	switch ManageAccountRuleAction(action) {
	case ManageAccountRuleActionCreate:
		tv, ok := value.(CreateAccountRuleData)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateAccountRuleData")
			return
		}
		result.CreateData = &tv
	case ManageAccountRuleActionUpdate:
		tv, ok := value.(UpdateAccountRuleData)
		if !ok {
			err = fmt.Errorf("invalid value, must be UpdateAccountRuleData")
			return
		}
		result.UpdateData = &tv
	case ManageAccountRuleActionRemove:
		tv, ok := value.(RemoveAccountRuleData)
		if !ok {
			err = fmt.Errorf("invalid value, must be RemoveAccountRuleData")
			return
		}
		result.RemoveData = &tv
	}
	return
}

// MustCreateData retrieves the CreateData value from the union,
// panicing if the value is not set.
func (u ManageAccountRuleOpData) MustCreateData() CreateAccountRuleData {
	val, ok := u.GetCreateData()

	if !ok {
		panic("arm CreateData is not set")
	}

	return val
}

// GetCreateData retrieves the CreateData value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageAccountRuleOpData) GetCreateData() (result CreateAccountRuleData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "CreateData" {
		result = *u.CreateData
		ok = true
	}

	return
}

// MustUpdateData retrieves the UpdateData value from the union,
// panicing if the value is not set.
func (u ManageAccountRuleOpData) MustUpdateData() UpdateAccountRuleData {
	val, ok := u.GetUpdateData()

	if !ok {
		panic("arm UpdateData is not set")
	}

	return val
}

// GetUpdateData retrieves the UpdateData value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageAccountRuleOpData) GetUpdateData() (result UpdateAccountRuleData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "UpdateData" {
		result = *u.UpdateData
		ok = true
	}

	return
}

// MustRemoveData retrieves the RemoveData value from the union,
// panicing if the value is not set.
func (u ManageAccountRuleOpData) MustRemoveData() RemoveAccountRuleData {
	val, ok := u.GetRemoveData()

	if !ok {
		panic("arm RemoveData is not set")
	}

	return val
}

// GetRemoveData retrieves the RemoveData value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageAccountRuleOpData) GetRemoveData() (result RemoveAccountRuleData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "RemoveData" {
		result = *u.RemoveData
		ok = true
	}

	return
}

// ManageAccountRuleOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ManageAccountRuleOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageAccountRuleOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageAccountRuleOpExt
func (u ManageAccountRuleOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageAccountRuleOpExt creates a new  ManageAccountRuleOpExt.
func NewManageAccountRuleOpExt(v LedgerVersion, value interface{}) (result ManageAccountRuleOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageAccountRuleOp is an XDR Struct defines as:
//
//   //: ManageAccountRuleOp is used to create, update or remove account rule
//    struct ManageAccountRuleOp
//    {
//        //: data is used to pass one of `ManageAccountRuleAction` with required params
//        union switch (ManageAccountRuleAction action)
//        {
//        case CREATE:
//            CreateAccountRuleData createData;
//        case UPDATE:
//            UpdateAccountRuleData updateData;
//        case REMOVE:
//            RemoveAccountRuleData removeData;
//        } data;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ManageAccountRuleOp struct {
	Data ManageAccountRuleOpData `json:"data,omitempty"`
	Ext  ManageAccountRuleOpExt  `json:"ext,omitempty"`
}

// ManageAccountRuleResultCode is an XDR Enum defines as:
//
//   //: Result codes of ManageAccountRuleResultCode
//    enum ManageAccountRuleResultCode
//    {
//        //: Means that specified action in `data` of ManageAccountRuleOp was successfully performed
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: There is no account rule with such id
//        NOT_FOUND = -1,
//        //: It is not allowed to remove the rule if it is used at least in one role
//        RULE_IS_USED = -2,
//        //: Passed details has invalid json structure
//        INVALID_DETAILS = -3,
//        //: Custom rule action can not be used with entries other than CUSTOM
//        INVALID_ACTION = -4
//    };
//
type ManageAccountRuleResultCode int32

const (
	ManageAccountRuleResultCodeSuccess        ManageAccountRuleResultCode = 0
	ManageAccountRuleResultCodeNotFound       ManageAccountRuleResultCode = -1
	ManageAccountRuleResultCodeRuleIsUsed     ManageAccountRuleResultCode = -2
	ManageAccountRuleResultCodeInvalidDetails ManageAccountRuleResultCode = -3
	ManageAccountRuleResultCodeInvalidAction  ManageAccountRuleResultCode = -4
)

var ManageAccountRuleResultCodeAll = []ManageAccountRuleResultCode{
	ManageAccountRuleResultCodeSuccess,
	ManageAccountRuleResultCodeNotFound,
	ManageAccountRuleResultCodeRuleIsUsed,
	ManageAccountRuleResultCodeInvalidDetails,
	ManageAccountRuleResultCodeInvalidAction,
}

var manageAccountRuleResultCodeMap = map[int32]string{
	0:  "ManageAccountRuleResultCodeSuccess",
	-1: "ManageAccountRuleResultCodeNotFound",
	-2: "ManageAccountRuleResultCodeRuleIsUsed",
	-3: "ManageAccountRuleResultCodeInvalidDetails",
	-4: "ManageAccountRuleResultCodeInvalidAction",
}

var manageAccountRuleResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "not_found",
	-2: "rule_is_used",
	-3: "invalid_details",
	-4: "invalid_action",
}

var manageAccountRuleResultCodeRevMap = map[string]int32{
	"ManageAccountRuleResultCodeSuccess":        0,
	"ManageAccountRuleResultCodeNotFound":       -1,
	"ManageAccountRuleResultCodeRuleIsUsed":     -2,
	"ManageAccountRuleResultCodeInvalidDetails": -3,
	"ManageAccountRuleResultCodeInvalidAction":  -4,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageAccountRuleResultCode
func (e ManageAccountRuleResultCode) ValidEnum(v int32) bool {
	_, ok := manageAccountRuleResultCodeMap[v]
	return ok
}
func (e ManageAccountRuleResultCode) isFlag() bool {
	for i := len(ManageAccountRuleResultCodeAll) - 1; i >= 0; i-- {
		expected := ManageAccountRuleResultCode(2) << uint64(len(ManageAccountRuleResultCodeAll)-1) >> uint64(len(ManageAccountRuleResultCodeAll)-i)
		if expected != ManageAccountRuleResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageAccountRuleResultCode) String() string {
	name, _ := manageAccountRuleResultCodeMap[int32(e)]
	return name
}

func (e ManageAccountRuleResultCode) ShortString() string {
	name, _ := manageAccountRuleResultCodeShortMap[int32(e)]
	return name
}

func (e ManageAccountRuleResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageAccountRuleResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageAccountRuleResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageAccountRuleResultCode(t.Value)
	return nil
}

// ManageAccountRuleResultSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//                {
//                case EMPTY_VERSION:
//                    void;
//                }
//
type ManageAccountRuleResultSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageAccountRuleResultSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageAccountRuleResultSuccessExt
func (u ManageAccountRuleResultSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageAccountRuleResultSuccessExt creates a new  ManageAccountRuleResultSuccessExt.
func NewManageAccountRuleResultSuccessExt(v LedgerVersion, value interface{}) (result ManageAccountRuleResultSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageAccountRuleResultSuccess is an XDR NestedStruct defines as:
//
//   struct {
//                //: id of the rule that was managed
//                uint64 ruleID;
//
//                //: reserved for future use
//                union switch (LedgerVersion v)
//                {
//                case EMPTY_VERSION:
//                    void;
//                }
//                ext;
//            }
//
type ManageAccountRuleResultSuccess struct {
	RuleId Uint64                            `json:"ruleID,omitempty"`
	Ext    ManageAccountRuleResultSuccessExt `json:"ext,omitempty"`
}

// ManageAccountRuleResult is an XDR Union defines as:
//
//   //: Result of operation applying
//    union ManageAccountRuleResult switch (ManageAccountRuleResultCode code)
//    {
//        case SUCCESS:
//            //: Is used to pass useful params if operation is success
//            struct {
//                //: id of the rule that was managed
//                uint64 ruleID;
//
//                //: reserved for future use
//                union switch (LedgerVersion v)
//                {
//                case EMPTY_VERSION:
//                    void;
//                }
//                ext;
//            } success;
//        case RULE_IS_USED:
//            //: ids of roles that use the rule that cannot be removed
//            uint64 roleIDs<>;
//        default:
//            void;
//    };
//
type ManageAccountRuleResult struct {
	Code    ManageAccountRuleResultCode     `json:"code,omitempty"`
	Success *ManageAccountRuleResultSuccess `json:"success,omitempty"`
	RoleIDs *[]Uint64                       `json:"roleIDs,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageAccountRuleResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageAccountRuleResult
func (u ManageAccountRuleResult) ArmForSwitch(sw int32) (string, bool) {
	switch ManageAccountRuleResultCode(sw) {
	case ManageAccountRuleResultCodeSuccess:
		return "Success", true
	case ManageAccountRuleResultCodeRuleIsUsed:
		return "RoleIDs", true
	default:
		return "", true
	}
}

// NewManageAccountRuleResult creates a new  ManageAccountRuleResult.
func NewManageAccountRuleResult(code ManageAccountRuleResultCode, value interface{}) (result ManageAccountRuleResult, err error) {
	result.Code = code
	switch ManageAccountRuleResultCode(code) {
	case ManageAccountRuleResultCodeSuccess:
		tv, ok := value.(ManageAccountRuleResultSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageAccountRuleResultSuccess")
			return
		}
		result.Success = &tv
	case ManageAccountRuleResultCodeRuleIsUsed:
		tv, ok := value.([]Uint64)
		if !ok {
			err = fmt.Errorf("invalid value, must be []Uint64")
			return
		}
		result.RoleIDs = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u ManageAccountRuleResult) MustSuccess() ManageAccountRuleResultSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageAccountRuleResult) GetSuccess() (result ManageAccountRuleResultSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// MustRoleIDs retrieves the RoleIDs value from the union,
// panicing if the value is not set.
func (u ManageAccountRuleResult) MustRoleIDs() []Uint64 {
	val, ok := u.GetRoleIDs()

	if !ok {
		panic("arm RoleIDs is not set")
	}

	return val
}

// GetRoleIDs retrieves the RoleIDs value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageAccountRuleResult) GetRoleIDs() (result []Uint64, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "RoleIDs" {
		result = *u.RoleIDs
		ok = true
	}

	return
}

// ManageAccountSpecificRuleAction is an XDR Enum defines as:
//
//   //: Actions that can be performed with account specific rule
//    enum ManageAccountSpecificRuleAction
//    {
//        CREATE = 0,
//        REMOVE = 1
//    };
//
type ManageAccountSpecificRuleAction int32

const (
	ManageAccountSpecificRuleActionCreate ManageAccountSpecificRuleAction = 0
	ManageAccountSpecificRuleActionRemove ManageAccountSpecificRuleAction = 1
)

var ManageAccountSpecificRuleActionAll = []ManageAccountSpecificRuleAction{
	ManageAccountSpecificRuleActionCreate,
	ManageAccountSpecificRuleActionRemove,
}

var manageAccountSpecificRuleActionMap = map[int32]string{
	0: "ManageAccountSpecificRuleActionCreate",
	1: "ManageAccountSpecificRuleActionRemove",
}

var manageAccountSpecificRuleActionShortMap = map[int32]string{
	0: "create",
	1: "remove",
}

var manageAccountSpecificRuleActionRevMap = map[string]int32{
	"ManageAccountSpecificRuleActionCreate": 0,
	"ManageAccountSpecificRuleActionRemove": 1,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageAccountSpecificRuleAction
func (e ManageAccountSpecificRuleAction) ValidEnum(v int32) bool {
	_, ok := manageAccountSpecificRuleActionMap[v]
	return ok
}
func (e ManageAccountSpecificRuleAction) isFlag() bool {
	for i := len(ManageAccountSpecificRuleActionAll) - 1; i >= 0; i-- {
		expected := ManageAccountSpecificRuleAction(2) << uint64(len(ManageAccountSpecificRuleActionAll)-1) >> uint64(len(ManageAccountSpecificRuleActionAll)-i)
		if expected != ManageAccountSpecificRuleActionAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageAccountSpecificRuleAction) String() string {
	name, _ := manageAccountSpecificRuleActionMap[int32(e)]
	return name
}

func (e ManageAccountSpecificRuleAction) ShortString() string {
	name, _ := manageAccountSpecificRuleActionShortMap[int32(e)]
	return name
}

func (e ManageAccountSpecificRuleAction) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageAccountSpecificRuleActionAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageAccountSpecificRuleAction) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageAccountSpecificRuleAction(t.Value)
	return nil
}

// CreateAccountSpecificRuleDataExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateAccountSpecificRuleDataExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateAccountSpecificRuleDataExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateAccountSpecificRuleDataExt
func (u CreateAccountSpecificRuleDataExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateAccountSpecificRuleDataExt creates a new  CreateAccountSpecificRuleDataExt.
func NewCreateAccountSpecificRuleDataExt(v LedgerVersion, value interface{}) (result CreateAccountSpecificRuleDataExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateAccountSpecificRuleData is an XDR Struct defines as:
//
//   //: CreateAccountSpecificRuleData is used to pass necessary params to create a new account specific rule
//    struct CreateAccountSpecificRuleData
//    {
//        //: ledgerKey is used to specify an entity with primary key that can be used through operations
//        LedgerKey ledgerKey;
//        //: Certain account for which rule is applied, null means rule is global
//        AccountID* accountID;
//        //: True if such rule is deniable, otherwise allows
//        bool forbids;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type CreateAccountSpecificRuleData struct {
	LedgerKey LedgerKey                        `json:"ledgerKey,omitempty"`
	AccountId *AccountId                       `json:"accountID,omitempty"`
	Forbids   bool                             `json:"forbids,omitempty"`
	Ext       CreateAccountSpecificRuleDataExt `json:"ext,omitempty"`
}

// RemoveAccountSpecificRuleDataExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type RemoveAccountSpecificRuleDataExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u RemoveAccountSpecificRuleDataExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of RemoveAccountSpecificRuleDataExt
func (u RemoveAccountSpecificRuleDataExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewRemoveAccountSpecificRuleDataExt creates a new  RemoveAccountSpecificRuleDataExt.
func NewRemoveAccountSpecificRuleDataExt(v LedgerVersion, value interface{}) (result RemoveAccountSpecificRuleDataExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// RemoveAccountSpecificRuleData is an XDR Struct defines as:
//
//   //: RemoveAccountSpecificRuleData is used to pass necessary params to remove existing account specific rule
//    struct RemoveAccountSpecificRuleData
//    {
//        //: Identifier of existing account specific rule
//        uint64 ruleID;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type RemoveAccountSpecificRuleData struct {
	RuleId Uint64                           `json:"ruleID,omitempty"`
	Ext    RemoveAccountSpecificRuleDataExt `json:"ext,omitempty"`
}

// ManageAccountSpecificRuleOpData is an XDR NestedUnion defines as:
//
//   union switch (ManageAccountSpecificRuleAction action)
//        {
//        case CREATE:
//            CreateAccountSpecificRuleData createData;
//        case REMOVE:
//            RemoveAccountSpecificRuleData removeData;
//        }
//
type ManageAccountSpecificRuleOpData struct {
	Action     ManageAccountSpecificRuleAction `json:"action,omitempty"`
	CreateData *CreateAccountSpecificRuleData  `json:"createData,omitempty"`
	RemoveData *RemoveAccountSpecificRuleData  `json:"removeData,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageAccountSpecificRuleOpData) SwitchFieldName() string {
	return "Action"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageAccountSpecificRuleOpData
func (u ManageAccountSpecificRuleOpData) ArmForSwitch(sw int32) (string, bool) {
	switch ManageAccountSpecificRuleAction(sw) {
	case ManageAccountSpecificRuleActionCreate:
		return "CreateData", true
	case ManageAccountSpecificRuleActionRemove:
		return "RemoveData", true
	}
	return "-", false
}

// NewManageAccountSpecificRuleOpData creates a new  ManageAccountSpecificRuleOpData.
func NewManageAccountSpecificRuleOpData(action ManageAccountSpecificRuleAction, value interface{}) (result ManageAccountSpecificRuleOpData, err error) {
	result.Action = action
	switch ManageAccountSpecificRuleAction(action) {
	case ManageAccountSpecificRuleActionCreate:
		tv, ok := value.(CreateAccountSpecificRuleData)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateAccountSpecificRuleData")
			return
		}
		result.CreateData = &tv
	case ManageAccountSpecificRuleActionRemove:
		tv, ok := value.(RemoveAccountSpecificRuleData)
		if !ok {
			err = fmt.Errorf("invalid value, must be RemoveAccountSpecificRuleData")
			return
		}
		result.RemoveData = &tv
	}
	return
}

// MustCreateData retrieves the CreateData value from the union,
// panicing if the value is not set.
func (u ManageAccountSpecificRuleOpData) MustCreateData() CreateAccountSpecificRuleData {
	val, ok := u.GetCreateData()

	if !ok {
		panic("arm CreateData is not set")
	}

	return val
}

// GetCreateData retrieves the CreateData value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageAccountSpecificRuleOpData) GetCreateData() (result CreateAccountSpecificRuleData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "CreateData" {
		result = *u.CreateData
		ok = true
	}

	return
}

// MustRemoveData retrieves the RemoveData value from the union,
// panicing if the value is not set.
func (u ManageAccountSpecificRuleOpData) MustRemoveData() RemoveAccountSpecificRuleData {
	val, ok := u.GetRemoveData()

	if !ok {
		panic("arm RemoveData is not set")
	}

	return val
}

// GetRemoveData retrieves the RemoveData value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageAccountSpecificRuleOpData) GetRemoveData() (result RemoveAccountSpecificRuleData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "RemoveData" {
		result = *u.RemoveData
		ok = true
	}

	return
}

// ManageAccountSpecificRuleOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ManageAccountSpecificRuleOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageAccountSpecificRuleOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageAccountSpecificRuleOpExt
func (u ManageAccountSpecificRuleOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageAccountSpecificRuleOpExt creates a new  ManageAccountSpecificRuleOpExt.
func NewManageAccountSpecificRuleOpExt(v LedgerVersion, value interface{}) (result ManageAccountSpecificRuleOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageAccountSpecificRuleOp is an XDR Struct defines as:
//
//   //: ManageAccountSpecificRuleOp is used to create or remove account specific rule
//    struct ManageAccountSpecificRuleOp
//    {
//        //: data is used to pass one of `ManageAccountSpecificRuleAction` with required params
//        union switch (ManageAccountSpecificRuleAction action)
//        {
//        case CREATE:
//            CreateAccountSpecificRuleData createData;
//        case REMOVE:
//            RemoveAccountSpecificRuleData removeData;
//        } data;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ManageAccountSpecificRuleOp struct {
	Data ManageAccountSpecificRuleOpData `json:"data,omitempty"`
	Ext  ManageAccountSpecificRuleOpExt  `json:"ext,omitempty"`
}

// ManageAccountSpecificRuleResultCode is an XDR Enum defines as:
//
//   //: Result codes of ManageAccountSpecificRuleResult
//    enum ManageAccountSpecificRuleResultCode
//    {
//        //: Means that specified action in `data` of ManageAccountSpecificRuleOp was successfully performed
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: There is no rule with such id
//        NOT_FOUND = -1,
//        //: There is no sale with such id
//        SALE_NOT_FOUND = -2,
//        //: Only entry (sale) owner or admin can perform such operation
//        NOT_AUTHORIZED = -3,
//        //: Not allowed to create duplicated rules
//        ALREADY_EXISTS = -4,
//        //: Not allowed to create rule with the same accountID and ledger key, but different forbids value
//        REVERSED_ALREADY_EXISTS = -5,
//        //: Not allowed to use such entry type in ledger key
//        ENTRY_TYPE_NOT_SUPPORTED = -6,
//        //: There is no account rule with such id
//        ACCOUNT_NOT_FOUND = -7,
//        //: Version of entry does not allow to add specific rules
//        SPECIFIC_RULE_NOT_SUPPORTED = -8,
//        //: Not allowed to remove global rule
//        REMOVING_GLOBAL_RULE_FORBIDDEN = -9
//    };
//
type ManageAccountSpecificRuleResultCode int32

const (
	ManageAccountSpecificRuleResultCodeSuccess                     ManageAccountSpecificRuleResultCode = 0
	ManageAccountSpecificRuleResultCodeNotFound                    ManageAccountSpecificRuleResultCode = -1
	ManageAccountSpecificRuleResultCodeSaleNotFound                ManageAccountSpecificRuleResultCode = -2
	ManageAccountSpecificRuleResultCodeNotAuthorized               ManageAccountSpecificRuleResultCode = -3
	ManageAccountSpecificRuleResultCodeAlreadyExists               ManageAccountSpecificRuleResultCode = -4
	ManageAccountSpecificRuleResultCodeReversedAlreadyExists       ManageAccountSpecificRuleResultCode = -5
	ManageAccountSpecificRuleResultCodeEntryTypeNotSupported       ManageAccountSpecificRuleResultCode = -6
	ManageAccountSpecificRuleResultCodeAccountNotFound             ManageAccountSpecificRuleResultCode = -7
	ManageAccountSpecificRuleResultCodeSpecificRuleNotSupported    ManageAccountSpecificRuleResultCode = -8
	ManageAccountSpecificRuleResultCodeRemovingGlobalRuleForbidden ManageAccountSpecificRuleResultCode = -9
)

var ManageAccountSpecificRuleResultCodeAll = []ManageAccountSpecificRuleResultCode{
	ManageAccountSpecificRuleResultCodeSuccess,
	ManageAccountSpecificRuleResultCodeNotFound,
	ManageAccountSpecificRuleResultCodeSaleNotFound,
	ManageAccountSpecificRuleResultCodeNotAuthorized,
	ManageAccountSpecificRuleResultCodeAlreadyExists,
	ManageAccountSpecificRuleResultCodeReversedAlreadyExists,
	ManageAccountSpecificRuleResultCodeEntryTypeNotSupported,
	ManageAccountSpecificRuleResultCodeAccountNotFound,
	ManageAccountSpecificRuleResultCodeSpecificRuleNotSupported,
	ManageAccountSpecificRuleResultCodeRemovingGlobalRuleForbidden,
}

var manageAccountSpecificRuleResultCodeMap = map[int32]string{
	0:  "ManageAccountSpecificRuleResultCodeSuccess",
	-1: "ManageAccountSpecificRuleResultCodeNotFound",
	-2: "ManageAccountSpecificRuleResultCodeSaleNotFound",
	-3: "ManageAccountSpecificRuleResultCodeNotAuthorized",
	-4: "ManageAccountSpecificRuleResultCodeAlreadyExists",
	-5: "ManageAccountSpecificRuleResultCodeReversedAlreadyExists",
	-6: "ManageAccountSpecificRuleResultCodeEntryTypeNotSupported",
	-7: "ManageAccountSpecificRuleResultCodeAccountNotFound",
	-8: "ManageAccountSpecificRuleResultCodeSpecificRuleNotSupported",
	-9: "ManageAccountSpecificRuleResultCodeRemovingGlobalRuleForbidden",
}

var manageAccountSpecificRuleResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "not_found",
	-2: "sale_not_found",
	-3: "not_authorized",
	-4: "already_exists",
	-5: "reversed_already_exists",
	-6: "entry_type_not_supported",
	-7: "account_not_found",
	-8: "specific_rule_not_supported",
	-9: "removing_global_rule_forbidden",
}

var manageAccountSpecificRuleResultCodeRevMap = map[string]int32{
	"ManageAccountSpecificRuleResultCodeSuccess":                     0,
	"ManageAccountSpecificRuleResultCodeNotFound":                    -1,
	"ManageAccountSpecificRuleResultCodeSaleNotFound":                -2,
	"ManageAccountSpecificRuleResultCodeNotAuthorized":               -3,
	"ManageAccountSpecificRuleResultCodeAlreadyExists":               -4,
	"ManageAccountSpecificRuleResultCodeReversedAlreadyExists":       -5,
	"ManageAccountSpecificRuleResultCodeEntryTypeNotSupported":       -6,
	"ManageAccountSpecificRuleResultCodeAccountNotFound":             -7,
	"ManageAccountSpecificRuleResultCodeSpecificRuleNotSupported":    -8,
	"ManageAccountSpecificRuleResultCodeRemovingGlobalRuleForbidden": -9,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageAccountSpecificRuleResultCode
func (e ManageAccountSpecificRuleResultCode) ValidEnum(v int32) bool {
	_, ok := manageAccountSpecificRuleResultCodeMap[v]
	return ok
}
func (e ManageAccountSpecificRuleResultCode) isFlag() bool {
	for i := len(ManageAccountSpecificRuleResultCodeAll) - 1; i >= 0; i-- {
		expected := ManageAccountSpecificRuleResultCode(2) << uint64(len(ManageAccountSpecificRuleResultCodeAll)-1) >> uint64(len(ManageAccountSpecificRuleResultCodeAll)-i)
		if expected != ManageAccountSpecificRuleResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageAccountSpecificRuleResultCode) String() string {
	name, _ := manageAccountSpecificRuleResultCodeMap[int32(e)]
	return name
}

func (e ManageAccountSpecificRuleResultCode) ShortString() string {
	name, _ := manageAccountSpecificRuleResultCodeShortMap[int32(e)]
	return name
}

func (e ManageAccountSpecificRuleResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageAccountSpecificRuleResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageAccountSpecificRuleResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageAccountSpecificRuleResultCode(t.Value)
	return nil
}

// ManageAccountSpecificRuleResultSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type ManageAccountSpecificRuleResultSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageAccountSpecificRuleResultSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageAccountSpecificRuleResultSuccessExt
func (u ManageAccountSpecificRuleResultSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageAccountSpecificRuleResultSuccessExt creates a new  ManageAccountSpecificRuleResultSuccessExt.
func NewManageAccountSpecificRuleResultSuccessExt(v LedgerVersion, value interface{}) (result ManageAccountSpecificRuleResultSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageAccountSpecificRuleResultSuccess is an XDR NestedStruct defines as:
//
//   struct {
//            //: id of the rule that was managed
//            uint64 ruleID;
//
//            //: reserved for future use
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        }
//
type ManageAccountSpecificRuleResultSuccess struct {
	RuleId Uint64                                    `json:"ruleID,omitempty"`
	Ext    ManageAccountSpecificRuleResultSuccessExt `json:"ext,omitempty"`
}

// ManageAccountSpecificRuleResult is an XDR Union defines as:
//
//   //: Result of operation applying
//    union ManageAccountSpecificRuleResult switch (ManageAccountSpecificRuleResultCode code)
//    {
//    case SUCCESS:
//        //: Is used to pass useful params if operation is success
//        struct {
//            //: id of the rule that was managed
//            uint64 ruleID;
//
//            //: reserved for future use
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        } success;
//    default:
//        void;
//    };
//
type ManageAccountSpecificRuleResult struct {
	Code    ManageAccountSpecificRuleResultCode     `json:"code,omitempty"`
	Success *ManageAccountSpecificRuleResultSuccess `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageAccountSpecificRuleResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageAccountSpecificRuleResult
func (u ManageAccountSpecificRuleResult) ArmForSwitch(sw int32) (string, bool) {
	switch ManageAccountSpecificRuleResultCode(sw) {
	case ManageAccountSpecificRuleResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewManageAccountSpecificRuleResult creates a new  ManageAccountSpecificRuleResult.
func NewManageAccountSpecificRuleResult(code ManageAccountSpecificRuleResultCode, value interface{}) (result ManageAccountSpecificRuleResult, err error) {
	result.Code = code
	switch ManageAccountSpecificRuleResultCode(code) {
	case ManageAccountSpecificRuleResultCodeSuccess:
		tv, ok := value.(ManageAccountSpecificRuleResultSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageAccountSpecificRuleResultSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u ManageAccountSpecificRuleResult) MustSuccess() ManageAccountSpecificRuleResultSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageAccountSpecificRuleResult) GetSuccess() (result ManageAccountSpecificRuleResultSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// ManageAssetPairAction is an XDR Enum defines as:
//
//   //: Actions that can be performed on the asset pair
//    enum ManageAssetPairAction
//    {
//        //: Create new asset pair
//        CREATE = 0,
//        //: Update price of the asset pair
//        UPDATE_PRICE = 1,
//        //: Update asset pair policies bitmask
//        UPDATE_POLICIES = 2
//    };
//
type ManageAssetPairAction int32

const (
	ManageAssetPairActionCreate         ManageAssetPairAction = 0
	ManageAssetPairActionUpdatePrice    ManageAssetPairAction = 1
	ManageAssetPairActionUpdatePolicies ManageAssetPairAction = 2
)

var ManageAssetPairActionAll = []ManageAssetPairAction{
	ManageAssetPairActionCreate,
	ManageAssetPairActionUpdatePrice,
	ManageAssetPairActionUpdatePolicies,
}

var manageAssetPairActionMap = map[int32]string{
	0: "ManageAssetPairActionCreate",
	1: "ManageAssetPairActionUpdatePrice",
	2: "ManageAssetPairActionUpdatePolicies",
}

var manageAssetPairActionShortMap = map[int32]string{
	0: "create",
	1: "update_price",
	2: "update_policies",
}

var manageAssetPairActionRevMap = map[string]int32{
	"ManageAssetPairActionCreate":         0,
	"ManageAssetPairActionUpdatePrice":    1,
	"ManageAssetPairActionUpdatePolicies": 2,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageAssetPairAction
func (e ManageAssetPairAction) ValidEnum(v int32) bool {
	_, ok := manageAssetPairActionMap[v]
	return ok
}
func (e ManageAssetPairAction) isFlag() bool {
	for i := len(ManageAssetPairActionAll) - 1; i >= 0; i-- {
		expected := ManageAssetPairAction(2) << uint64(len(ManageAssetPairActionAll)-1) >> uint64(len(ManageAssetPairActionAll)-i)
		if expected != ManageAssetPairActionAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageAssetPairAction) String() string {
	name, _ := manageAssetPairActionMap[int32(e)]
	return name
}

func (e ManageAssetPairAction) ShortString() string {
	name, _ := manageAssetPairActionShortMap[int32(e)]
	return name
}

func (e ManageAssetPairAction) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageAssetPairActionAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageAssetPairAction) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageAssetPairAction(t.Value)
	return nil
}

// ManageAssetPairOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ManageAssetPairOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageAssetPairOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageAssetPairOpExt
func (u ManageAssetPairOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageAssetPairOpExt creates a new  ManageAssetPairOpExt.
func NewManageAssetPairOpExt(v LedgerVersion, value interface{}) (result ManageAssetPairOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageAssetPairOp is an XDR Struct defines as:
//
//   //: `ManageAssetPairOp` either creates new asset pairs or updates prices or policies of existing [asset pairs](#operation/assetPairResources)
//    struct ManageAssetPairOp
//    {
//        //: Defines a ManageBalanceAction that will be performed on an asset pair
//        ManageAssetPairAction action;
//        //: Defines a base asset of an asset pair
//        AssetCode base;
//        //: Defines a base asset of an asset pair
//        AssetCode quote;
//
//        //: New physical price of the asset pair which would be set after successful `ManageAssetPairOp` application
//        int64 physicalPrice;
//
//        //: New correction of the asset pair physical price in percents
//        int64 physicalPriceCorrection;
//        //: New maximal price step of asset pair
//        int64 maxPriceStep;
//
//        //: Bitmask of asset policies set by the creator or corrected by manage asset operations
//        int32 policies;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ManageAssetPairOp struct {
	Action                  ManageAssetPairAction `json:"action,omitempty"`
	Base                    AssetCode             `json:"base,omitempty"`
	Quote                   AssetCode             `json:"quote,omitempty"`
	PhysicalPrice           Int64                 `json:"physicalPrice,omitempty"`
	PhysicalPriceCorrection Int64                 `json:"physicalPriceCorrection,omitempty"`
	MaxPriceStep            Int64                 `json:"maxPriceStep,omitempty"`
	Policies                Int32                 `json:"policies,omitempty"`
	Ext                     ManageAssetPairOpExt  `json:"ext,omitempty"`
}

// ManageAssetPairResultCode is an XDR Enum defines as:
//
//   //: Result codes for ManageAssetPair operation
//    enum ManageAssetPairResultCode
//    {
//        // codes considered as "success" for the operation
//        //: Indicates that `ManageAssetPairOp` has been successfully applied
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: Failed to find an asset pair with given `base` and `quote` asset codes
//        NOT_FOUND = -1,
//        //: Asset pair with given `base` and `quote` asset codes is already present in the system
//        ALREADY_EXISTS = -2,
//        //: Invalid input (e.g. physicalPrice < 0 or physicalPriceCorrection < 0 or maxPriceStep is not in an interval [0..100])
//        MALFORMED = -3,
//        //: Either `base` or `quote`  asset code  (or both) is invalid
//        //: (e.g. asset code does not consist of alphanumeric symbols)
//        INVALID_ASSET = -4,
//        //: `action` is not in the set of valid actions (see `ManageAssetPairAction`)
//        INVALID_ACTION = -5,
//        //: `policies` field is invalid (`policies < 0`)
//        INVALID_POLICIES = -6,
//        //: Asset with such code is not found
//        ASSET_NOT_FOUND = -7,
//        //: Not allowed for base and quote asset to be the same
//        SAME_ASSET = -8
//    };
//
type ManageAssetPairResultCode int32

const (
	ManageAssetPairResultCodeSuccess         ManageAssetPairResultCode = 0
	ManageAssetPairResultCodeNotFound        ManageAssetPairResultCode = -1
	ManageAssetPairResultCodeAlreadyExists   ManageAssetPairResultCode = -2
	ManageAssetPairResultCodeMalformed       ManageAssetPairResultCode = -3
	ManageAssetPairResultCodeInvalidAsset    ManageAssetPairResultCode = -4
	ManageAssetPairResultCodeInvalidAction   ManageAssetPairResultCode = -5
	ManageAssetPairResultCodeInvalidPolicies ManageAssetPairResultCode = -6
	ManageAssetPairResultCodeAssetNotFound   ManageAssetPairResultCode = -7
	ManageAssetPairResultCodeSameAsset       ManageAssetPairResultCode = -8
)

var ManageAssetPairResultCodeAll = []ManageAssetPairResultCode{
	ManageAssetPairResultCodeSuccess,
	ManageAssetPairResultCodeNotFound,
	ManageAssetPairResultCodeAlreadyExists,
	ManageAssetPairResultCodeMalformed,
	ManageAssetPairResultCodeInvalidAsset,
	ManageAssetPairResultCodeInvalidAction,
	ManageAssetPairResultCodeInvalidPolicies,
	ManageAssetPairResultCodeAssetNotFound,
	ManageAssetPairResultCodeSameAsset,
}

var manageAssetPairResultCodeMap = map[int32]string{
	0:  "ManageAssetPairResultCodeSuccess",
	-1: "ManageAssetPairResultCodeNotFound",
	-2: "ManageAssetPairResultCodeAlreadyExists",
	-3: "ManageAssetPairResultCodeMalformed",
	-4: "ManageAssetPairResultCodeInvalidAsset",
	-5: "ManageAssetPairResultCodeInvalidAction",
	-6: "ManageAssetPairResultCodeInvalidPolicies",
	-7: "ManageAssetPairResultCodeAssetNotFound",
	-8: "ManageAssetPairResultCodeSameAsset",
}

var manageAssetPairResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "not_found",
	-2: "already_exists",
	-3: "malformed",
	-4: "invalid_asset",
	-5: "invalid_action",
	-6: "invalid_policies",
	-7: "asset_not_found",
	-8: "same_asset",
}

var manageAssetPairResultCodeRevMap = map[string]int32{
	"ManageAssetPairResultCodeSuccess":         0,
	"ManageAssetPairResultCodeNotFound":        -1,
	"ManageAssetPairResultCodeAlreadyExists":   -2,
	"ManageAssetPairResultCodeMalformed":       -3,
	"ManageAssetPairResultCodeInvalidAsset":    -4,
	"ManageAssetPairResultCodeInvalidAction":   -5,
	"ManageAssetPairResultCodeInvalidPolicies": -6,
	"ManageAssetPairResultCodeAssetNotFound":   -7,
	"ManageAssetPairResultCodeSameAsset":       -8,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageAssetPairResultCode
func (e ManageAssetPairResultCode) ValidEnum(v int32) bool {
	_, ok := manageAssetPairResultCodeMap[v]
	return ok
}
func (e ManageAssetPairResultCode) isFlag() bool {
	for i := len(ManageAssetPairResultCodeAll) - 1; i >= 0; i-- {
		expected := ManageAssetPairResultCode(2) << uint64(len(ManageAssetPairResultCodeAll)-1) >> uint64(len(ManageAssetPairResultCodeAll)-i)
		if expected != ManageAssetPairResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageAssetPairResultCode) String() string {
	name, _ := manageAssetPairResultCodeMap[int32(e)]
	return name
}

func (e ManageAssetPairResultCode) ShortString() string {
	name, _ := manageAssetPairResultCodeShortMap[int32(e)]
	return name
}

func (e ManageAssetPairResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageAssetPairResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageAssetPairResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageAssetPairResultCode(t.Value)
	return nil
}

// ManageAssetPairSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ManageAssetPairSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageAssetPairSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageAssetPairSuccessExt
func (u ManageAssetPairSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageAssetPairSuccessExt creates a new  ManageAssetPairSuccessExt.
func NewManageAssetPairSuccessExt(v LedgerVersion, value interface{}) (result ManageAssetPairSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageAssetPairSuccess is an XDR Struct defines as:
//
//   //: `ManageAssetPairSuccess` represents a successful result of `ManageAssetPairOp`
//    struct ManageAssetPairSuccess
//    {
//        //: Price of an asset pair after the operation
//        int64 currentPrice;
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ManageAssetPairSuccess struct {
	CurrentPrice Int64                     `json:"currentPrice,omitempty"`
	Ext          ManageAssetPairSuccessExt `json:"ext,omitempty"`
}

// ManageAssetPairResult is an XDR Union defines as:
//
//   //: `ManageAssetPairResult` defines the result of `ManageBalanceOp` based on given `ManageAssetPairResultCode`
//    union ManageAssetPairResult switch (ManageAssetPairResultCode code)
//    {
//    case SUCCESS:
//        ManageAssetPairSuccess success;
//    default:
//        void;
//    };
//
type ManageAssetPairResult struct {
	Code    ManageAssetPairResultCode `json:"code,omitempty"`
	Success *ManageAssetPairSuccess   `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageAssetPairResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageAssetPairResult
func (u ManageAssetPairResult) ArmForSwitch(sw int32) (string, bool) {
	switch ManageAssetPairResultCode(sw) {
	case ManageAssetPairResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewManageAssetPairResult creates a new  ManageAssetPairResult.
func NewManageAssetPairResult(code ManageAssetPairResultCode, value interface{}) (result ManageAssetPairResult, err error) {
	result.Code = code
	switch ManageAssetPairResultCode(code) {
	case ManageAssetPairResultCodeSuccess:
		tv, ok := value.(ManageAssetPairSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageAssetPairSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u ManageAssetPairResult) MustSuccess() ManageAssetPairSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageAssetPairResult) GetSuccess() (result ManageAssetPairSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// ManageAssetAction is an XDR Enum defines as:
//
//   //: ManageAssetAction is used to specify an action to be performed with an asset or asset create/update request
//    enum ManageAssetAction
//    {
//        CREATE_ASSET_CREATION_REQUEST = 0,
//        CREATE_ASSET_UPDATE_REQUEST = 1,
//        CANCEL_ASSET_REQUEST = 2,
//        CHANGE_PREISSUED_ASSET_SIGNER = 3,
//        UPDATE_MAX_ISSUANCE = 4
//    };
//
type ManageAssetAction int32

const (
	ManageAssetActionCreateAssetCreationRequest ManageAssetAction = 0
	ManageAssetActionCreateAssetUpdateRequest   ManageAssetAction = 1
	ManageAssetActionCancelAssetRequest         ManageAssetAction = 2
	ManageAssetActionChangePreissuedAssetSigner ManageAssetAction = 3
	ManageAssetActionUpdateMaxIssuance          ManageAssetAction = 4
)

var ManageAssetActionAll = []ManageAssetAction{
	ManageAssetActionCreateAssetCreationRequest,
	ManageAssetActionCreateAssetUpdateRequest,
	ManageAssetActionCancelAssetRequest,
	ManageAssetActionChangePreissuedAssetSigner,
	ManageAssetActionUpdateMaxIssuance,
}

var manageAssetActionMap = map[int32]string{
	0: "ManageAssetActionCreateAssetCreationRequest",
	1: "ManageAssetActionCreateAssetUpdateRequest",
	2: "ManageAssetActionCancelAssetRequest",
	3: "ManageAssetActionChangePreissuedAssetSigner",
	4: "ManageAssetActionUpdateMaxIssuance",
}

var manageAssetActionShortMap = map[int32]string{
	0: "create_asset_creation_request",
	1: "create_asset_update_request",
	2: "cancel_asset_request",
	3: "change_preissued_asset_signer",
	4: "update_max_issuance",
}

var manageAssetActionRevMap = map[string]int32{
	"ManageAssetActionCreateAssetCreationRequest": 0,
	"ManageAssetActionCreateAssetUpdateRequest":   1,
	"ManageAssetActionCancelAssetRequest":         2,
	"ManageAssetActionChangePreissuedAssetSigner": 3,
	"ManageAssetActionUpdateMaxIssuance":          4,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageAssetAction
func (e ManageAssetAction) ValidEnum(v int32) bool {
	_, ok := manageAssetActionMap[v]
	return ok
}
func (e ManageAssetAction) isFlag() bool {
	for i := len(ManageAssetActionAll) - 1; i >= 0; i-- {
		expected := ManageAssetAction(2) << uint64(len(ManageAssetActionAll)-1) >> uint64(len(ManageAssetActionAll)-i)
		if expected != ManageAssetActionAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageAssetAction) String() string {
	name, _ := manageAssetActionMap[int32(e)]
	return name
}

func (e ManageAssetAction) ShortString() string {
	name, _ := manageAssetActionShortMap[int32(e)]
	return name
}

func (e ManageAssetAction) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageAssetActionAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageAssetAction) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageAssetAction(t.Value)
	return nil
}

// CancelAssetRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CancelAssetRequestExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CancelAssetRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CancelAssetRequestExt
func (u CancelAssetRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCancelAssetRequestExt creates a new  CancelAssetRequestExt.
func NewCancelAssetRequestExt(v LedgerVersion, value interface{}) (result CancelAssetRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CancelAssetRequest is an XDR Struct defines as:
//
//   //: CancelAssetRequest is used to cancel an `UPDATE_ASSET` or `CREATE_ASSET` request
//    struct CancelAssetRequest
//    {
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CancelAssetRequest struct {
	Ext CancelAssetRequestExt `json:"ext,omitempty"`
}

// UpdateMaxIssuanceExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type UpdateMaxIssuanceExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u UpdateMaxIssuanceExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of UpdateMaxIssuanceExt
func (u UpdateMaxIssuanceExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewUpdateMaxIssuanceExt creates a new  UpdateMaxIssuanceExt.
func NewUpdateMaxIssuanceExt(v LedgerVersion, value interface{}) (result UpdateMaxIssuanceExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// UpdateMaxIssuance is an XDR Struct defines as:
//
//   //: UpdateMaxIssuance is used to update max issuance amount of an asset.
//    struct UpdateMaxIssuance
//    {
//        //: `assetCode` defines an asset entry that will be updated
//        AssetCode assetCode;
//        //: new max issuance amount for an asset entry
//        uint64 maxIssuanceAmount;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type UpdateMaxIssuance struct {
	AssetCode         AssetCode            `json:"assetCode,omitempty"`
	MaxIssuanceAmount Uint64               `json:"maxIssuanceAmount,omitempty"`
	Ext               UpdateMaxIssuanceExt `json:"ext,omitempty"`
}

// ManageAssetOpCreateAssetCreationRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//                {
//                case EMPTY_VERSION:
//                    void;
//                }
//
type ManageAssetOpCreateAssetCreationRequestExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageAssetOpCreateAssetCreationRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageAssetOpCreateAssetCreationRequestExt
func (u ManageAssetOpCreateAssetCreationRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageAssetOpCreateAssetCreationRequestExt creates a new  ManageAssetOpCreateAssetCreationRequestExt.
func NewManageAssetOpCreateAssetCreationRequestExt(v LedgerVersion, value interface{}) (result ManageAssetOpCreateAssetCreationRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageAssetOpCreateAssetCreationRequest is an XDR NestedStruct defines as:
//
//   struct
//            {
//                //: Is used to pass required fields to create an asset entry
//                AssetCreationRequest createAsset;
//                //: (optional) Bit mask whose flags must be cleared in order for `CREATE_ASSET` request to be approved, which will be used by key `asset_create_tasks`
//                //: instead of key-value
//                uint32* allTasks;
//
//                //: reserved for future use
//                union switch (LedgerVersion v)
//                {
//                case EMPTY_VERSION:
//                    void;
//                }
//                ext;
//            }
//
type ManageAssetOpCreateAssetCreationRequest struct {
	CreateAsset AssetCreationRequest                       `json:"createAsset,omitempty"`
	AllTasks    *Uint32                                    `json:"allTasks,omitempty"`
	Ext         ManageAssetOpCreateAssetCreationRequestExt `json:"ext,omitempty"`
}

// ManageAssetOpCreateAssetUpdateRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//                {
//                case EMPTY_VERSION:
//                    void;
//                }
//
type ManageAssetOpCreateAssetUpdateRequestExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageAssetOpCreateAssetUpdateRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageAssetOpCreateAssetUpdateRequestExt
func (u ManageAssetOpCreateAssetUpdateRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageAssetOpCreateAssetUpdateRequestExt creates a new  ManageAssetOpCreateAssetUpdateRequestExt.
func NewManageAssetOpCreateAssetUpdateRequestExt(v LedgerVersion, value interface{}) (result ManageAssetOpCreateAssetUpdateRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageAssetOpCreateAssetUpdateRequest is an XDR NestedStruct defines as:
//
//   struct
//            {
//                //: Is used to pass required fields to update an asset entry
//                AssetUpdateRequest updateAsset;
//                //: (optional) Bit mask whose flags must be cleared in order for `UPDATE_ASSET` request to be approved, which will be used
//                //: instead of key-value by key `asset_update_tasks`
//                uint32* allTasks;
//
//                //: reserved for future use
//                union switch (LedgerVersion v)
//                {
//                case EMPTY_VERSION:
//                    void;
//                }
//                ext;
//            }
//
type ManageAssetOpCreateAssetUpdateRequest struct {
	UpdateAsset AssetUpdateRequest                       `json:"updateAsset,omitempty"`
	AllTasks    *Uint32                                  `json:"allTasks,omitempty"`
	Ext         ManageAssetOpCreateAssetUpdateRequestExt `json:"ext,omitempty"`
}

// ManageAssetOpRequest is an XDR NestedUnion defines as:
//
//   union switch (ManageAssetAction action)
//        {
//        case CREATE_ASSET_CREATION_REQUEST:
//            //: Is used to pass required fields for `CREATE_ASSET`
//            struct
//            {
//                //: Is used to pass required fields to create an asset entry
//                AssetCreationRequest createAsset;
//                //: (optional) Bit mask whose flags must be cleared in order for `CREATE_ASSET` request to be approved, which will be used by key `asset_create_tasks`
//                //: instead of key-value
//                uint32* allTasks;
//
//                //: reserved for future use
//                union switch (LedgerVersion v)
//                {
//                case EMPTY_VERSION:
//                    void;
//                }
//                ext;
//            } createAssetCreationRequest;
//        case CREATE_ASSET_UPDATE_REQUEST:
//            //: Is used to pass needed fields for `UPDATE_ASSET`
//            struct
//            {
//                //: Is used to pass required fields to update an asset entry
//                AssetUpdateRequest updateAsset;
//                //: (optional) Bit mask whose flags must be cleared in order for `UPDATE_ASSET` request to be approved, which will be used
//                //: instead of key-value by key `asset_update_tasks`
//                uint32* allTasks;
//
//                //: reserved for future use
//                union switch (LedgerVersion v)
//                {
//                case EMPTY_VERSION:
//                    void;
//                }
//                ext;
//            } createAssetUpdateRequest;
//        case CANCEL_ASSET_REQUEST:
//            //: Reserved for future use
//            CancelAssetRequest cancelRequest;
//        case CHANGE_PREISSUED_ASSET_SIGNER:
//            //: Is used to pass required fields to change an asset pre issuer
//            AssetChangePreissuedSigner changePreissuedSigner;
//        case UPDATE_MAX_ISSUANCE:
//            //: Is used to update max issuance of asset
//            UpdateMaxIssuance updateMaxIssuance;
//        }
//
type ManageAssetOpRequest struct {
	Action                     ManageAssetAction                        `json:"action,omitempty"`
	CreateAssetCreationRequest *ManageAssetOpCreateAssetCreationRequest `json:"createAssetCreationRequest,omitempty"`
	CreateAssetUpdateRequest   *ManageAssetOpCreateAssetUpdateRequest   `json:"createAssetUpdateRequest,omitempty"`
	CancelRequest              *CancelAssetRequest                      `json:"cancelRequest,omitempty"`
	ChangePreissuedSigner      *AssetChangePreissuedSigner              `json:"changePreissuedSigner,omitempty"`
	UpdateMaxIssuance          *UpdateMaxIssuance                       `json:"updateMaxIssuance,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageAssetOpRequest) SwitchFieldName() string {
	return "Action"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageAssetOpRequest
func (u ManageAssetOpRequest) ArmForSwitch(sw int32) (string, bool) {
	switch ManageAssetAction(sw) {
	case ManageAssetActionCreateAssetCreationRequest:
		return "CreateAssetCreationRequest", true
	case ManageAssetActionCreateAssetUpdateRequest:
		return "CreateAssetUpdateRequest", true
	case ManageAssetActionCancelAssetRequest:
		return "CancelRequest", true
	case ManageAssetActionChangePreissuedAssetSigner:
		return "ChangePreissuedSigner", true
	case ManageAssetActionUpdateMaxIssuance:
		return "UpdateMaxIssuance", true
	}
	return "-", false
}

// NewManageAssetOpRequest creates a new  ManageAssetOpRequest.
func NewManageAssetOpRequest(action ManageAssetAction, value interface{}) (result ManageAssetOpRequest, err error) {
	result.Action = action
	switch ManageAssetAction(action) {
	case ManageAssetActionCreateAssetCreationRequest:
		tv, ok := value.(ManageAssetOpCreateAssetCreationRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageAssetOpCreateAssetCreationRequest")
			return
		}
		result.CreateAssetCreationRequest = &tv
	case ManageAssetActionCreateAssetUpdateRequest:
		tv, ok := value.(ManageAssetOpCreateAssetUpdateRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageAssetOpCreateAssetUpdateRequest")
			return
		}
		result.CreateAssetUpdateRequest = &tv
	case ManageAssetActionCancelAssetRequest:
		tv, ok := value.(CancelAssetRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be CancelAssetRequest")
			return
		}
		result.CancelRequest = &tv
	case ManageAssetActionChangePreissuedAssetSigner:
		tv, ok := value.(AssetChangePreissuedSigner)
		if !ok {
			err = fmt.Errorf("invalid value, must be AssetChangePreissuedSigner")
			return
		}
		result.ChangePreissuedSigner = &tv
	case ManageAssetActionUpdateMaxIssuance:
		tv, ok := value.(UpdateMaxIssuance)
		if !ok {
			err = fmt.Errorf("invalid value, must be UpdateMaxIssuance")
			return
		}
		result.UpdateMaxIssuance = &tv
	}
	return
}

// MustCreateAssetCreationRequest retrieves the CreateAssetCreationRequest value from the union,
// panicing if the value is not set.
func (u ManageAssetOpRequest) MustCreateAssetCreationRequest() ManageAssetOpCreateAssetCreationRequest {
	val, ok := u.GetCreateAssetCreationRequest()

	if !ok {
		panic("arm CreateAssetCreationRequest is not set")
	}

	return val
}

// GetCreateAssetCreationRequest retrieves the CreateAssetCreationRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageAssetOpRequest) GetCreateAssetCreationRequest() (result ManageAssetOpCreateAssetCreationRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "CreateAssetCreationRequest" {
		result = *u.CreateAssetCreationRequest
		ok = true
	}

	return
}

// MustCreateAssetUpdateRequest retrieves the CreateAssetUpdateRequest value from the union,
// panicing if the value is not set.
func (u ManageAssetOpRequest) MustCreateAssetUpdateRequest() ManageAssetOpCreateAssetUpdateRequest {
	val, ok := u.GetCreateAssetUpdateRequest()

	if !ok {
		panic("arm CreateAssetUpdateRequest is not set")
	}

	return val
}

// GetCreateAssetUpdateRequest retrieves the CreateAssetUpdateRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageAssetOpRequest) GetCreateAssetUpdateRequest() (result ManageAssetOpCreateAssetUpdateRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "CreateAssetUpdateRequest" {
		result = *u.CreateAssetUpdateRequest
		ok = true
	}

	return
}

// MustCancelRequest retrieves the CancelRequest value from the union,
// panicing if the value is not set.
func (u ManageAssetOpRequest) MustCancelRequest() CancelAssetRequest {
	val, ok := u.GetCancelRequest()

	if !ok {
		panic("arm CancelRequest is not set")
	}

	return val
}

// GetCancelRequest retrieves the CancelRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageAssetOpRequest) GetCancelRequest() (result CancelAssetRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "CancelRequest" {
		result = *u.CancelRequest
		ok = true
	}

	return
}

// MustChangePreissuedSigner retrieves the ChangePreissuedSigner value from the union,
// panicing if the value is not set.
func (u ManageAssetOpRequest) MustChangePreissuedSigner() AssetChangePreissuedSigner {
	val, ok := u.GetChangePreissuedSigner()

	if !ok {
		panic("arm ChangePreissuedSigner is not set")
	}

	return val
}

// GetChangePreissuedSigner retrieves the ChangePreissuedSigner value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageAssetOpRequest) GetChangePreissuedSigner() (result AssetChangePreissuedSigner, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "ChangePreissuedSigner" {
		result = *u.ChangePreissuedSigner
		ok = true
	}

	return
}

// MustUpdateMaxIssuance retrieves the UpdateMaxIssuance value from the union,
// panicing if the value is not set.
func (u ManageAssetOpRequest) MustUpdateMaxIssuance() UpdateMaxIssuance {
	val, ok := u.GetUpdateMaxIssuance()

	if !ok {
		panic("arm UpdateMaxIssuance is not set")
	}

	return val
}

// GetUpdateMaxIssuance retrieves the UpdateMaxIssuance value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageAssetOpRequest) GetUpdateMaxIssuance() (result UpdateMaxIssuance, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "UpdateMaxIssuance" {
		result = *u.UpdateMaxIssuance
		ok = true
	}

	return
}

// ManageAssetOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ManageAssetOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageAssetOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageAssetOpExt
func (u ManageAssetOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageAssetOpExt creates a new  ManageAssetOpExt.
func NewManageAssetOpExt(v LedgerVersion, value interface{}) (result ManageAssetOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageAssetOp is an XDR Struct defines as:
//
//   //: ManageAssetOp is used to:
//    //: * create or update `CREATE_ASSET` request;
//    //: * create or update `UPDATE_ASSET` request;
//    //: * cancel `CREATE_ASSET` or `UPDATE_ASSET` request
//    //: * change asset pre issuer
//    //: * update max issuance of an asset
//    struct ManageAssetOp
//    {
//        //: ID of a reviewable request
//        //: If `requestID == 0`, operation creates a new reviewable request; otherwise, it updates the existing one
//        uint64 requestID;
//
//        //: data is used to pass one of `ManageAssetAction` with required params
//        union switch (ManageAssetAction action)
//        {
//        case CREATE_ASSET_CREATION_REQUEST:
//            //: Is used to pass required fields for `CREATE_ASSET`
//            struct
//            {
//                //: Is used to pass required fields to create an asset entry
//                AssetCreationRequest createAsset;
//                //: (optional) Bit mask whose flags must be cleared in order for `CREATE_ASSET` request to be approved, which will be used by key `asset_create_tasks`
//                //: instead of key-value
//                uint32* allTasks;
//
//                //: reserved for future use
//                union switch (LedgerVersion v)
//                {
//                case EMPTY_VERSION:
//                    void;
//                }
//                ext;
//            } createAssetCreationRequest;
//        case CREATE_ASSET_UPDATE_REQUEST:
//            //: Is used to pass needed fields for `UPDATE_ASSET`
//            struct
//            {
//                //: Is used to pass required fields to update an asset entry
//                AssetUpdateRequest updateAsset;
//                //: (optional) Bit mask whose flags must be cleared in order for `UPDATE_ASSET` request to be approved, which will be used
//                //: instead of key-value by key `asset_update_tasks`
//                uint32* allTasks;
//
//                //: reserved for future use
//                union switch (LedgerVersion v)
//                {
//                case EMPTY_VERSION:
//                    void;
//                }
//                ext;
//            } createAssetUpdateRequest;
//        case CANCEL_ASSET_REQUEST:
//            //: Reserved for future use
//            CancelAssetRequest cancelRequest;
//        case CHANGE_PREISSUED_ASSET_SIGNER:
//            //: Is used to pass required fields to change an asset pre issuer
//            AssetChangePreissuedSigner changePreissuedSigner;
//        case UPDATE_MAX_ISSUANCE:
//            //: Is used to update max issuance of asset
//            UpdateMaxIssuance updateMaxIssuance;
//        } request;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ManageAssetOp struct {
	RequestId Uint64               `json:"requestID,omitempty"`
	Request   ManageAssetOpRequest `json:"request,omitempty"`
	Ext       ManageAssetOpExt     `json:"ext,omitempty"`
}

// ManageAssetResultCode is an XDR Enum defines as:
//
//   //: Result codes of ManageAssetOp
//    enum ManageAssetResultCode
//    {
//        //: Specified action in `data` of ManageSignerOp was successfully performed
//        SUCCESS = 0,                       // request was successfully created/updated/canceled
//
//        // codes considered as "failure" for an operation
//        //: There is no `CREATE_ASSET` or `UPDATE_ASSET` request with such id
//        REQUEST_NOT_FOUND = -1,           // failed to find an asset request with such id
//        //: only asset pre issuer can manage asset
//        INVALID_SIGNATURE = -2,
//        //: It is not allowed to create an asset with a code that is already used for another asset
//        ASSET_ALREADY_EXISTS = -3,	      // asset with such code already exist
//        //: It is not allowed to set max issuance amount that is
//        //: less than the sum of issued, pending issuance and available for issuance amounts
//        INVALID_MAX_ISSUANCE_AMOUNT = -4, // max issuance amount is 0
//        //: It is not allowed to use an asset code that is empty or contains space
//        INVALID_CODE = -5,                // asset code is invalid (empty or contains space)
//        //: It is not allowed to set a pre issuer that is the same as an existing one
//        INVALID_PRE_ISSUER = -6,          // pre issuer is the same as an existing one
//        //: It is not allowed to set policies that are not declared
//        INVALID_POLICIES = -7,            // asset policies (has flag which does not belong to AssetPolicies enum)
//        //: There is no asset with such code
//        ASSET_NOT_FOUND = -8,             // asset does not exists
//        //: Request for such asset already exists
//        REQUEST_ALREADY_EXISTS = -9,      // request for creation of unique entry already exists
//        //: It is not allowed to create two or more assets with `STATS_QUOTE_ASSET` policy
//        STATS_ASSET_ALREADY_EXISTS = -10, // statistics quote asset already exists
//        //: It is not allowed to set a pre issued amount that is greater than the max issuance amount
//        INITIAL_PREISSUED_EXCEEDS_MAX_ISSUANCE = -11, // initial pre issued amount exceeds max issuance amount
//        //: It is not allowed to use details with invalid json structure
//        INVALID_CREATOR_DETAILS = -12,                        // details must be a valid json
//        //: It is not allowed to set a trailing digits count greater than the maximum trailing digits count (6 at the moment)
//        INVALID_TRAILING_DIGITS_COUNT = -13,          // invalid number of trailing digits
//        //: Pre issued amount precision and asset precision are mismatched
//        INVALID_PREISSUED_AMOUNT_PRECISION = -14,
//        //: Maximum issuance amount precision and asset precision are mismatched
//        INVALID_MAX_ISSUANCE_AMOUNT_PRECISION = -15,
//        //: There is no value in the key value by `asset_create_tasks` key
//        //: (i.e., it is not allowed to perform asset creation)
//        ASSET_CREATE_TASKS_NOT_FOUND = -16,
//        //: There is no value in key value by `asset_update_tasks` key,
//        //:  (i.e., it is not allowed to perform asset update)
//        ASSET_UPDATE_TASKS_NOT_FOUND = -17,
//        //: It is not allowed to set `allTasks` on the update of a rejected request.
//        NOT_ALLOWED_TO_SET_TASKS_ON_UPDATE = -18
//    };
//
type ManageAssetResultCode int32

const (
	ManageAssetResultCodeSuccess                            ManageAssetResultCode = 0
	ManageAssetResultCodeRequestNotFound                    ManageAssetResultCode = -1
	ManageAssetResultCodeInvalidSignature                   ManageAssetResultCode = -2
	ManageAssetResultCodeAssetAlreadyExists                 ManageAssetResultCode = -3
	ManageAssetResultCodeInvalidMaxIssuanceAmount           ManageAssetResultCode = -4
	ManageAssetResultCodeInvalidCode                        ManageAssetResultCode = -5
	ManageAssetResultCodeInvalidPreIssuer                   ManageAssetResultCode = -6
	ManageAssetResultCodeInvalidPolicies                    ManageAssetResultCode = -7
	ManageAssetResultCodeAssetNotFound                      ManageAssetResultCode = -8
	ManageAssetResultCodeRequestAlreadyExists               ManageAssetResultCode = -9
	ManageAssetResultCodeStatsAssetAlreadyExists            ManageAssetResultCode = -10
	ManageAssetResultCodeInitialPreissuedExceedsMaxIssuance ManageAssetResultCode = -11
	ManageAssetResultCodeInvalidCreatorDetails              ManageAssetResultCode = -12
	ManageAssetResultCodeInvalidTrailingDigitsCount         ManageAssetResultCode = -13
	ManageAssetResultCodeInvalidPreissuedAmountPrecision    ManageAssetResultCode = -14
	ManageAssetResultCodeInvalidMaxIssuanceAmountPrecision  ManageAssetResultCode = -15
	ManageAssetResultCodeAssetCreateTasksNotFound           ManageAssetResultCode = -16
	ManageAssetResultCodeAssetUpdateTasksNotFound           ManageAssetResultCode = -17
	ManageAssetResultCodeNotAllowedToSetTasksOnUpdate       ManageAssetResultCode = -18
)

var ManageAssetResultCodeAll = []ManageAssetResultCode{
	ManageAssetResultCodeSuccess,
	ManageAssetResultCodeRequestNotFound,
	ManageAssetResultCodeInvalidSignature,
	ManageAssetResultCodeAssetAlreadyExists,
	ManageAssetResultCodeInvalidMaxIssuanceAmount,
	ManageAssetResultCodeInvalidCode,
	ManageAssetResultCodeInvalidPreIssuer,
	ManageAssetResultCodeInvalidPolicies,
	ManageAssetResultCodeAssetNotFound,
	ManageAssetResultCodeRequestAlreadyExists,
	ManageAssetResultCodeStatsAssetAlreadyExists,
	ManageAssetResultCodeInitialPreissuedExceedsMaxIssuance,
	ManageAssetResultCodeInvalidCreatorDetails,
	ManageAssetResultCodeInvalidTrailingDigitsCount,
	ManageAssetResultCodeInvalidPreissuedAmountPrecision,
	ManageAssetResultCodeInvalidMaxIssuanceAmountPrecision,
	ManageAssetResultCodeAssetCreateTasksNotFound,
	ManageAssetResultCodeAssetUpdateTasksNotFound,
	ManageAssetResultCodeNotAllowedToSetTasksOnUpdate,
}

var manageAssetResultCodeMap = map[int32]string{
	0:   "ManageAssetResultCodeSuccess",
	-1:  "ManageAssetResultCodeRequestNotFound",
	-2:  "ManageAssetResultCodeInvalidSignature",
	-3:  "ManageAssetResultCodeAssetAlreadyExists",
	-4:  "ManageAssetResultCodeInvalidMaxIssuanceAmount",
	-5:  "ManageAssetResultCodeInvalidCode",
	-6:  "ManageAssetResultCodeInvalidPreIssuer",
	-7:  "ManageAssetResultCodeInvalidPolicies",
	-8:  "ManageAssetResultCodeAssetNotFound",
	-9:  "ManageAssetResultCodeRequestAlreadyExists",
	-10: "ManageAssetResultCodeStatsAssetAlreadyExists",
	-11: "ManageAssetResultCodeInitialPreissuedExceedsMaxIssuance",
	-12: "ManageAssetResultCodeInvalidCreatorDetails",
	-13: "ManageAssetResultCodeInvalidTrailingDigitsCount",
	-14: "ManageAssetResultCodeInvalidPreissuedAmountPrecision",
	-15: "ManageAssetResultCodeInvalidMaxIssuanceAmountPrecision",
	-16: "ManageAssetResultCodeAssetCreateTasksNotFound",
	-17: "ManageAssetResultCodeAssetUpdateTasksNotFound",
	-18: "ManageAssetResultCodeNotAllowedToSetTasksOnUpdate",
}

var manageAssetResultCodeShortMap = map[int32]string{
	0:   "success",
	-1:  "request_not_found",
	-2:  "invalid_signature",
	-3:  "asset_already_exists",
	-4:  "invalid_max_issuance_amount",
	-5:  "invalid_code",
	-6:  "invalid_pre_issuer",
	-7:  "invalid_policies",
	-8:  "asset_not_found",
	-9:  "request_already_exists",
	-10: "stats_asset_already_exists",
	-11: "initial_preissued_exceeds_max_issuance",
	-12: "invalid_creator_details",
	-13: "invalid_trailing_digits_count",
	-14: "invalid_preissued_amount_precision",
	-15: "invalid_max_issuance_amount_precision",
	-16: "asset_create_tasks_not_found",
	-17: "asset_update_tasks_not_found",
	-18: "not_allowed_to_set_tasks_on_update",
}

var manageAssetResultCodeRevMap = map[string]int32{
	"ManageAssetResultCodeSuccess":                            0,
	"ManageAssetResultCodeRequestNotFound":                    -1,
	"ManageAssetResultCodeInvalidSignature":                   -2,
	"ManageAssetResultCodeAssetAlreadyExists":                 -3,
	"ManageAssetResultCodeInvalidMaxIssuanceAmount":           -4,
	"ManageAssetResultCodeInvalidCode":                        -5,
	"ManageAssetResultCodeInvalidPreIssuer":                   -6,
	"ManageAssetResultCodeInvalidPolicies":                    -7,
	"ManageAssetResultCodeAssetNotFound":                      -8,
	"ManageAssetResultCodeRequestAlreadyExists":               -9,
	"ManageAssetResultCodeStatsAssetAlreadyExists":            -10,
	"ManageAssetResultCodeInitialPreissuedExceedsMaxIssuance": -11,
	"ManageAssetResultCodeInvalidCreatorDetails":              -12,
	"ManageAssetResultCodeInvalidTrailingDigitsCount":         -13,
	"ManageAssetResultCodeInvalidPreissuedAmountPrecision":    -14,
	"ManageAssetResultCodeInvalidMaxIssuanceAmountPrecision":  -15,
	"ManageAssetResultCodeAssetCreateTasksNotFound":           -16,
	"ManageAssetResultCodeAssetUpdateTasksNotFound":           -17,
	"ManageAssetResultCodeNotAllowedToSetTasksOnUpdate":       -18,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageAssetResultCode
func (e ManageAssetResultCode) ValidEnum(v int32) bool {
	_, ok := manageAssetResultCodeMap[v]
	return ok
}
func (e ManageAssetResultCode) isFlag() bool {
	for i := len(ManageAssetResultCodeAll) - 1; i >= 0; i-- {
		expected := ManageAssetResultCode(2) << uint64(len(ManageAssetResultCodeAll)-1) >> uint64(len(ManageAssetResultCodeAll)-i)
		if expected != ManageAssetResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageAssetResultCode) String() string {
	name, _ := manageAssetResultCodeMap[int32(e)]
	return name
}

func (e ManageAssetResultCode) ShortString() string {
	name, _ := manageAssetResultCodeShortMap[int32(e)]
	return name
}

func (e ManageAssetResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageAssetResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageAssetResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageAssetResultCode(t.Value)
	return nil
}

// ManageAssetSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ManageAssetSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageAssetSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageAssetSuccessExt
func (u ManageAssetSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageAssetSuccessExt creates a new  ManageAssetSuccessExt.
func NewManageAssetSuccessExt(v LedgerVersion, value interface{}) (result ManageAssetSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageAssetSuccess is an XDR Struct defines as:
//
//   //: Is used to pass useful params after the successful operation application
//    struct ManageAssetSuccess
//    {
//        //: ID of the request that was created in the process of operation application
//        uint64 requestID;
//        //: True means that the request was applied and execution flow was successful
//        bool fulfilled;
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ManageAssetSuccess struct {
	RequestId Uint64                `json:"requestID,omitempty"`
	Fulfilled bool                  `json:"fulfilled,omitempty"`
	Ext       ManageAssetSuccessExt `json:"ext,omitempty"`
}

// ManageAssetResult is an XDR Union defines as:
//
//   //: Is used to return the result of operation application
//    union ManageAssetResult switch (ManageAssetResultCode code)
//    {
//    case SUCCESS:
//        //: Result of successful operation application
//        ManageAssetSuccess success;
//    default:
//        void;
//    };
//
type ManageAssetResult struct {
	Code    ManageAssetResultCode `json:"code,omitempty"`
	Success *ManageAssetSuccess   `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageAssetResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageAssetResult
func (u ManageAssetResult) ArmForSwitch(sw int32) (string, bool) {
	switch ManageAssetResultCode(sw) {
	case ManageAssetResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewManageAssetResult creates a new  ManageAssetResult.
func NewManageAssetResult(code ManageAssetResultCode, value interface{}) (result ManageAssetResult, err error) {
	result.Code = code
	switch ManageAssetResultCode(code) {
	case ManageAssetResultCodeSuccess:
		tv, ok := value.(ManageAssetSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageAssetSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u ManageAssetResult) MustSuccess() ManageAssetSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageAssetResult) GetSuccess() (result ManageAssetSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// ManageBalanceAction is an XDR Enum defines as:
//
//   //: Actions that can be performed on balances
//    enum ManageBalanceAction
//    {
//        //: Create new balance
//        CREATE = 0,
//        //: Delete existing balance by ID. Is reserved and not implemented yet.
//        DELETE_BALANCE = 1,
//        //: Ensures that the balance will not be created if the balance of the provided asset exists and is attached to the provided account
//        CREATE_UNIQUE = 2
//    };
//
type ManageBalanceAction int32

const (
	ManageBalanceActionCreate        ManageBalanceAction = 0
	ManageBalanceActionDeleteBalance ManageBalanceAction = 1
	ManageBalanceActionCreateUnique  ManageBalanceAction = 2
)

var ManageBalanceActionAll = []ManageBalanceAction{
	ManageBalanceActionCreate,
	ManageBalanceActionDeleteBalance,
	ManageBalanceActionCreateUnique,
}

var manageBalanceActionMap = map[int32]string{
	0: "ManageBalanceActionCreate",
	1: "ManageBalanceActionDeleteBalance",
	2: "ManageBalanceActionCreateUnique",
}

var manageBalanceActionShortMap = map[int32]string{
	0: "create",
	1: "delete_balance",
	2: "create_unique",
}

var manageBalanceActionRevMap = map[string]int32{
	"ManageBalanceActionCreate":        0,
	"ManageBalanceActionDeleteBalance": 1,
	"ManageBalanceActionCreateUnique":  2,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageBalanceAction
func (e ManageBalanceAction) ValidEnum(v int32) bool {
	_, ok := manageBalanceActionMap[v]
	return ok
}
func (e ManageBalanceAction) isFlag() bool {
	for i := len(ManageBalanceActionAll) - 1; i >= 0; i-- {
		expected := ManageBalanceAction(2) << uint64(len(ManageBalanceActionAll)-1) >> uint64(len(ManageBalanceActionAll)-i)
		if expected != ManageBalanceActionAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageBalanceAction) String() string {
	name, _ := manageBalanceActionMap[int32(e)]
	return name
}

func (e ManageBalanceAction) ShortString() string {
	name, _ := manageBalanceActionShortMap[int32(e)]
	return name
}

func (e ManageBalanceAction) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageBalanceActionAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageBalanceAction) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageBalanceAction(t.Value)
	return nil
}

// ManageBalanceOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ManageBalanceOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageBalanceOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageBalanceOpExt
func (u ManageBalanceOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageBalanceOpExt creates a new  ManageBalanceOpExt.
func NewManageBalanceOpExt(v LedgerVersion, value interface{}) (result ManageBalanceOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageBalanceOp is an XDR Struct defines as:
//
//   //: `ManageBalanceOp` applies an `action` of the `ManageBalanceAction` type on the balance of a particular `asset` (referenced to by its AssetCode)
//    //: of the `destination` account (referenced to by its AccountID)
//    struct ManageBalanceOp
//    {
//        //: Defines a ManageBalanceAction to be performed. `DELETE_BALANCE` is reserved and not implemented yet.
//        ManageBalanceAction action;
//        //: Defines an account whose balance will be managed
//        AccountID destination;
//        //: Defines an asset code of the balance to which `action` will be applied
//        AssetCode asset;
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ManageBalanceOp struct {
	Action      ManageBalanceAction `json:"action,omitempty"`
	Destination AccountId           `json:"destination,omitempty"`
	Asset       AssetCode           `json:"asset,omitempty"`
	Ext         ManageBalanceOpExt  `json:"ext,omitempty"`
}

// ManageBalanceResultCode is an XDR Enum defines as:
//
//   //: Result codes for the ManageBalance operation
//    enum ManageBalanceResultCode
//    {
//        // codes considered as "success" for the operation
//        //: Indicates that `ManageBalanceOp` is successfully applied
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: It is not allowed to delete a balance
//        MALFORMED = -1,
//        //: (deprecated)
//        NOT_FOUND = -2,
//        //: Cannot find an account provided by the `destination` AccountID
//        DESTINATION_NOT_FOUND = -3,
//        //: Cannot find an asset with a provided asset code
//        ASSET_NOT_FOUND = -4,
//        //: AssetCode `asset` is invalid (e.g. `AssetCode` does not consist of alphanumeric symbols)
//        INVALID_ASSET = -5,
//        //: Balance of the provided `asset` already exists and is owned by the `destination` account
//        BALANCE_ALREADY_EXISTS = -6,
//        //: version specified in the request is not supported yet
//        VERSION_IS_NOT_SUPPORTED_YET = -7
//    };
//
type ManageBalanceResultCode int32

const (
	ManageBalanceResultCodeSuccess                  ManageBalanceResultCode = 0
	ManageBalanceResultCodeMalformed                ManageBalanceResultCode = -1
	ManageBalanceResultCodeNotFound                 ManageBalanceResultCode = -2
	ManageBalanceResultCodeDestinationNotFound      ManageBalanceResultCode = -3
	ManageBalanceResultCodeAssetNotFound            ManageBalanceResultCode = -4
	ManageBalanceResultCodeInvalidAsset             ManageBalanceResultCode = -5
	ManageBalanceResultCodeBalanceAlreadyExists     ManageBalanceResultCode = -6
	ManageBalanceResultCodeVersionIsNotSupportedYet ManageBalanceResultCode = -7
)

var ManageBalanceResultCodeAll = []ManageBalanceResultCode{
	ManageBalanceResultCodeSuccess,
	ManageBalanceResultCodeMalformed,
	ManageBalanceResultCodeNotFound,
	ManageBalanceResultCodeDestinationNotFound,
	ManageBalanceResultCodeAssetNotFound,
	ManageBalanceResultCodeInvalidAsset,
	ManageBalanceResultCodeBalanceAlreadyExists,
	ManageBalanceResultCodeVersionIsNotSupportedYet,
}

var manageBalanceResultCodeMap = map[int32]string{
	0:  "ManageBalanceResultCodeSuccess",
	-1: "ManageBalanceResultCodeMalformed",
	-2: "ManageBalanceResultCodeNotFound",
	-3: "ManageBalanceResultCodeDestinationNotFound",
	-4: "ManageBalanceResultCodeAssetNotFound",
	-5: "ManageBalanceResultCodeInvalidAsset",
	-6: "ManageBalanceResultCodeBalanceAlreadyExists",
	-7: "ManageBalanceResultCodeVersionIsNotSupportedYet",
}

var manageBalanceResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "malformed",
	-2: "not_found",
	-3: "destination_not_found",
	-4: "asset_not_found",
	-5: "invalid_asset",
	-6: "balance_already_exists",
	-7: "version_is_not_supported_yet",
}

var manageBalanceResultCodeRevMap = map[string]int32{
	"ManageBalanceResultCodeSuccess":                  0,
	"ManageBalanceResultCodeMalformed":                -1,
	"ManageBalanceResultCodeNotFound":                 -2,
	"ManageBalanceResultCodeDestinationNotFound":      -3,
	"ManageBalanceResultCodeAssetNotFound":            -4,
	"ManageBalanceResultCodeInvalidAsset":             -5,
	"ManageBalanceResultCodeBalanceAlreadyExists":     -6,
	"ManageBalanceResultCodeVersionIsNotSupportedYet": -7,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageBalanceResultCode
func (e ManageBalanceResultCode) ValidEnum(v int32) bool {
	_, ok := manageBalanceResultCodeMap[v]
	return ok
}
func (e ManageBalanceResultCode) isFlag() bool {
	for i := len(ManageBalanceResultCodeAll) - 1; i >= 0; i-- {
		expected := ManageBalanceResultCode(2) << uint64(len(ManageBalanceResultCodeAll)-1) >> uint64(len(ManageBalanceResultCodeAll)-i)
		if expected != ManageBalanceResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageBalanceResultCode) String() string {
	name, _ := manageBalanceResultCodeMap[int32(e)]
	return name
}

func (e ManageBalanceResultCode) ShortString() string {
	name, _ := manageBalanceResultCodeShortMap[int32(e)]
	return name
}

func (e ManageBalanceResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageBalanceResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageBalanceResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageBalanceResultCode(t.Value)
	return nil
}

// ManageBalanceSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ManageBalanceSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageBalanceSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageBalanceSuccessExt
func (u ManageBalanceSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageBalanceSuccessExt creates a new  ManageBalanceSuccessExt.
func NewManageBalanceSuccessExt(v LedgerVersion, value interface{}) (result ManageBalanceSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageBalanceSuccess is an XDR Struct defines as:
//
//   struct ManageBalanceSuccess {
//        //: ID of the balance that was managed
//        BalanceID balanceID;
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ManageBalanceSuccess struct {
	BalanceId BalanceId               `json:"balanceID,omitempty"`
	Ext       ManageBalanceSuccessExt `json:"ext,omitempty"`
}

// ManageBalanceResult is an XDR Union defines as:
//
//   union ManageBalanceResult switch (ManageBalanceResultCode code)
//    {
//    case SUCCESS:
//        ManageBalanceSuccess success;
//    default:
//        void;
//    };
//
type ManageBalanceResult struct {
	Code    ManageBalanceResultCode `json:"code,omitempty"`
	Success *ManageBalanceSuccess   `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageBalanceResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageBalanceResult
func (u ManageBalanceResult) ArmForSwitch(sw int32) (string, bool) {
	switch ManageBalanceResultCode(sw) {
	case ManageBalanceResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewManageBalanceResult creates a new  ManageBalanceResult.
func NewManageBalanceResult(code ManageBalanceResultCode, value interface{}) (result ManageBalanceResult, err error) {
	result.Code = code
	switch ManageBalanceResultCode(code) {
	case ManageBalanceResultCodeSuccess:
		tv, ok := value.(ManageBalanceSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageBalanceSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u ManageBalanceResult) MustSuccess() ManageBalanceSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageBalanceResult) GetSuccess() (result ManageBalanceSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// ManageContractRequestAction is an XDR Enum defines as:
//
//   enum ManageContractRequestAction
//    {
//        CREATE = 0,
//        REMOVE = 1
//    };
//
type ManageContractRequestAction int32

const (
	ManageContractRequestActionCreate ManageContractRequestAction = 0
	ManageContractRequestActionRemove ManageContractRequestAction = 1
)

var ManageContractRequestActionAll = []ManageContractRequestAction{
	ManageContractRequestActionCreate,
	ManageContractRequestActionRemove,
}

var manageContractRequestActionMap = map[int32]string{
	0: "ManageContractRequestActionCreate",
	1: "ManageContractRequestActionRemove",
}

var manageContractRequestActionShortMap = map[int32]string{
	0: "create",
	1: "remove",
}

var manageContractRequestActionRevMap = map[string]int32{
	"ManageContractRequestActionCreate": 0,
	"ManageContractRequestActionRemove": 1,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageContractRequestAction
func (e ManageContractRequestAction) ValidEnum(v int32) bool {
	_, ok := manageContractRequestActionMap[v]
	return ok
}
func (e ManageContractRequestAction) isFlag() bool {
	for i := len(ManageContractRequestActionAll) - 1; i >= 0; i-- {
		expected := ManageContractRequestAction(2) << uint64(len(ManageContractRequestActionAll)-1) >> uint64(len(ManageContractRequestActionAll)-i)
		if expected != ManageContractRequestActionAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageContractRequestAction) String() string {
	name, _ := manageContractRequestActionMap[int32(e)]
	return name
}

func (e ManageContractRequestAction) ShortString() string {
	name, _ := manageContractRequestActionShortMap[int32(e)]
	return name
}

func (e ManageContractRequestAction) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageContractRequestActionAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageContractRequestAction) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageContractRequestAction(t.Value)
	return nil
}

// CreateContractRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateContractRequestExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateContractRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateContractRequestExt
func (u CreateContractRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateContractRequestExt creates a new  CreateContractRequestExt.
func NewCreateContractRequestExt(v LedgerVersion, value interface{}) (result CreateContractRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateContractRequest is an XDR Struct defines as:
//
//   struct CreateContractRequest
//    {
//        ContractRequest contractRequest;
//        uint32* allTasks;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CreateContractRequest struct {
	ContractRequest ContractRequest          `json:"contractRequest,omitempty"`
	AllTasks        *Uint32                  `json:"allTasks,omitempty"`
	Ext             CreateContractRequestExt `json:"ext,omitempty"`
}

// ManageContractRequestOpDetails is an XDR NestedUnion defines as:
//
//   union switch (ManageContractRequestAction action){
//        case CREATE:
//            CreateContractRequest createContractRequest;
//        case REMOVE:
//            uint64 requestID;
//        }
//
type ManageContractRequestOpDetails struct {
	Action                ManageContractRequestAction `json:"action,omitempty"`
	CreateContractRequest *CreateContractRequest      `json:"createContractRequest,omitempty"`
	RequestId             *Uint64                     `json:"requestID,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageContractRequestOpDetails) SwitchFieldName() string {
	return "Action"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageContractRequestOpDetails
func (u ManageContractRequestOpDetails) ArmForSwitch(sw int32) (string, bool) {
	switch ManageContractRequestAction(sw) {
	case ManageContractRequestActionCreate:
		return "CreateContractRequest", true
	case ManageContractRequestActionRemove:
		return "RequestId", true
	}
	return "-", false
}

// NewManageContractRequestOpDetails creates a new  ManageContractRequestOpDetails.
func NewManageContractRequestOpDetails(action ManageContractRequestAction, value interface{}) (result ManageContractRequestOpDetails, err error) {
	result.Action = action
	switch ManageContractRequestAction(action) {
	case ManageContractRequestActionCreate:
		tv, ok := value.(CreateContractRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateContractRequest")
			return
		}
		result.CreateContractRequest = &tv
	case ManageContractRequestActionRemove:
		tv, ok := value.(Uint64)
		if !ok {
			err = fmt.Errorf("invalid value, must be Uint64")
			return
		}
		result.RequestId = &tv
	}
	return
}

// MustCreateContractRequest retrieves the CreateContractRequest value from the union,
// panicing if the value is not set.
func (u ManageContractRequestOpDetails) MustCreateContractRequest() CreateContractRequest {
	val, ok := u.GetCreateContractRequest()

	if !ok {
		panic("arm CreateContractRequest is not set")
	}

	return val
}

// GetCreateContractRequest retrieves the CreateContractRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageContractRequestOpDetails) GetCreateContractRequest() (result CreateContractRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "CreateContractRequest" {
		result = *u.CreateContractRequest
		ok = true
	}

	return
}

// MustRequestId retrieves the RequestId value from the union,
// panicing if the value is not set.
func (u ManageContractRequestOpDetails) MustRequestId() Uint64 {
	val, ok := u.GetRequestId()

	if !ok {
		panic("arm RequestId is not set")
	}

	return val
}

// GetRequestId retrieves the RequestId value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageContractRequestOpDetails) GetRequestId() (result Uint64, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "RequestId" {
		result = *u.RequestId
		ok = true
	}

	return
}

// ManageContractRequestOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ManageContractRequestOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageContractRequestOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageContractRequestOpExt
func (u ManageContractRequestOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageContractRequestOpExt creates a new  ManageContractRequestOpExt.
func NewManageContractRequestOpExt(v LedgerVersion, value interface{}) (result ManageContractRequestOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageContractRequestOp is an XDR Struct defines as:
//
//   struct ManageContractRequestOp
//    {
//        union switch (ManageContractRequestAction action){
//        case CREATE:
//            CreateContractRequest createContractRequest;
//        case REMOVE:
//            uint64 requestID;
//        } details;
//
//    	// reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ManageContractRequestOp struct {
	Details ManageContractRequestOpDetails `json:"details,omitempty"`
	Ext     ManageContractRequestOpExt     `json:"ext,omitempty"`
}

// ManageContractRequestResultCode is an XDR Enum defines as:
//
//   enum ManageContractRequestResultCode
//    {
//        // codes considered as "success" for the operation
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        MALFORMED = -1,
//        NOT_FOUND = -2, // not found contract request, when try to remove
//        TOO_MANY_CONTRACTS = -3,
//        NOT_ALLOWED_TO_REMOVE = -4, // only contract creator can remove contract
//        DETAILS_TOO_LONG = -5,
//        CONTRACT_CREATE_TASKS_NOT_FOUND = -6 // key-value not set
//    };
//
type ManageContractRequestResultCode int32

const (
	ManageContractRequestResultCodeSuccess                     ManageContractRequestResultCode = 0
	ManageContractRequestResultCodeMalformed                   ManageContractRequestResultCode = -1
	ManageContractRequestResultCodeNotFound                    ManageContractRequestResultCode = -2
	ManageContractRequestResultCodeTooManyContracts            ManageContractRequestResultCode = -3
	ManageContractRequestResultCodeNotAllowedToRemove          ManageContractRequestResultCode = -4
	ManageContractRequestResultCodeDetailsTooLong              ManageContractRequestResultCode = -5
	ManageContractRequestResultCodeContractCreateTasksNotFound ManageContractRequestResultCode = -6
)

var ManageContractRequestResultCodeAll = []ManageContractRequestResultCode{
	ManageContractRequestResultCodeSuccess,
	ManageContractRequestResultCodeMalformed,
	ManageContractRequestResultCodeNotFound,
	ManageContractRequestResultCodeTooManyContracts,
	ManageContractRequestResultCodeNotAllowedToRemove,
	ManageContractRequestResultCodeDetailsTooLong,
	ManageContractRequestResultCodeContractCreateTasksNotFound,
}

var manageContractRequestResultCodeMap = map[int32]string{
	0:  "ManageContractRequestResultCodeSuccess",
	-1: "ManageContractRequestResultCodeMalformed",
	-2: "ManageContractRequestResultCodeNotFound",
	-3: "ManageContractRequestResultCodeTooManyContracts",
	-4: "ManageContractRequestResultCodeNotAllowedToRemove",
	-5: "ManageContractRequestResultCodeDetailsTooLong",
	-6: "ManageContractRequestResultCodeContractCreateTasksNotFound",
}

var manageContractRequestResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "malformed",
	-2: "not_found",
	-3: "too_many_contracts",
	-4: "not_allowed_to_remove",
	-5: "details_too_long",
	-6: "contract_create_tasks_not_found",
}

var manageContractRequestResultCodeRevMap = map[string]int32{
	"ManageContractRequestResultCodeSuccess":                     0,
	"ManageContractRequestResultCodeMalformed":                   -1,
	"ManageContractRequestResultCodeNotFound":                    -2,
	"ManageContractRequestResultCodeTooManyContracts":            -3,
	"ManageContractRequestResultCodeNotAllowedToRemove":          -4,
	"ManageContractRequestResultCodeDetailsTooLong":              -5,
	"ManageContractRequestResultCodeContractCreateTasksNotFound": -6,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageContractRequestResultCode
func (e ManageContractRequestResultCode) ValidEnum(v int32) bool {
	_, ok := manageContractRequestResultCodeMap[v]
	return ok
}
func (e ManageContractRequestResultCode) isFlag() bool {
	for i := len(ManageContractRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := ManageContractRequestResultCode(2) << uint64(len(ManageContractRequestResultCodeAll)-1) >> uint64(len(ManageContractRequestResultCodeAll)-i)
		if expected != ManageContractRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageContractRequestResultCode) String() string {
	name, _ := manageContractRequestResultCodeMap[int32(e)]
	return name
}

func (e ManageContractRequestResultCode) ShortString() string {
	name, _ := manageContractRequestResultCodeShortMap[int32(e)]
	return name
}

func (e ManageContractRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageContractRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageContractRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageContractRequestResultCode(t.Value)
	return nil
}

// CreateContractRequestResponseExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateContractRequestResponseExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateContractRequestResponseExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateContractRequestResponseExt
func (u CreateContractRequestResponseExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateContractRequestResponseExt creates a new  CreateContractRequestResponseExt.
func NewCreateContractRequestResponseExt(v LedgerVersion, value interface{}) (result CreateContractRequestResponseExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateContractRequestResponse is an XDR Struct defines as:
//
//   struct CreateContractRequestResponse
//    {
//    	uint64 requestID;
//        bool fulfilled;
//
//    	union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CreateContractRequestResponse struct {
	RequestId Uint64                           `json:"requestID,omitempty"`
	Fulfilled bool                             `json:"fulfilled,omitempty"`
	Ext       CreateContractRequestResponseExt `json:"ext,omitempty"`
}

// ManageContractRequestResultSuccessDetails is an XDR NestedUnion defines as:
//
//   union switch (ManageContractRequestAction action)
//            {
//            case CREATE:
//                CreateContractRequestResponse response;
//            case REMOVE:
//                void;
//            }
//
type ManageContractRequestResultSuccessDetails struct {
	Action   ManageContractRequestAction    `json:"action,omitempty"`
	Response *CreateContractRequestResponse `json:"response,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageContractRequestResultSuccessDetails) SwitchFieldName() string {
	return "Action"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageContractRequestResultSuccessDetails
func (u ManageContractRequestResultSuccessDetails) ArmForSwitch(sw int32) (string, bool) {
	switch ManageContractRequestAction(sw) {
	case ManageContractRequestActionCreate:
		return "Response", true
	case ManageContractRequestActionRemove:
		return "", true
	}
	return "-", false
}

// NewManageContractRequestResultSuccessDetails creates a new  ManageContractRequestResultSuccessDetails.
func NewManageContractRequestResultSuccessDetails(action ManageContractRequestAction, value interface{}) (result ManageContractRequestResultSuccessDetails, err error) {
	result.Action = action
	switch ManageContractRequestAction(action) {
	case ManageContractRequestActionCreate:
		tv, ok := value.(CreateContractRequestResponse)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateContractRequestResponse")
			return
		}
		result.Response = &tv
	case ManageContractRequestActionRemove:
		// void
	}
	return
}

// MustResponse retrieves the Response value from the union,
// panicing if the value is not set.
func (u ManageContractRequestResultSuccessDetails) MustResponse() CreateContractRequestResponse {
	val, ok := u.GetResponse()

	if !ok {
		panic("arm Response is not set")
	}

	return val
}

// GetResponse retrieves the Response value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageContractRequestResultSuccessDetails) GetResponse() (result CreateContractRequestResponse, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "Response" {
		result = *u.Response
		ok = true
	}

	return
}

// ManageContractRequestResultSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type ManageContractRequestResultSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageContractRequestResultSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageContractRequestResultSuccessExt
func (u ManageContractRequestResultSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageContractRequestResultSuccessExt creates a new  ManageContractRequestResultSuccessExt.
func NewManageContractRequestResultSuccessExt(v LedgerVersion, value interface{}) (result ManageContractRequestResultSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageContractRequestResultSuccess is an XDR NestedStruct defines as:
//
//   struct
//        {
//            union switch (ManageContractRequestAction action)
//            {
//            case CREATE:
//                CreateContractRequestResponse response;
//            case REMOVE:
//                void;
//            } details;
//
//            // reserved for future use
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            } ext;
//        }
//
type ManageContractRequestResultSuccess struct {
	Details ManageContractRequestResultSuccessDetails `json:"details,omitempty"`
	Ext     ManageContractRequestResultSuccessExt     `json:"ext,omitempty"`
}

// ManageContractRequestResult is an XDR Union defines as:
//
//   union ManageContractRequestResult switch (ManageContractRequestResultCode code)
//    {
//    case SUCCESS:
//        struct
//        {
//            union switch (ManageContractRequestAction action)
//            {
//            case CREATE:
//                CreateContractRequestResponse response;
//            case REMOVE:
//                void;
//            } details;
//
//            // reserved for future use
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            } ext;
//        } success;
//    default:
//        void;
//    };
//
type ManageContractRequestResult struct {
	Code    ManageContractRequestResultCode     `json:"code,omitempty"`
	Success *ManageContractRequestResultSuccess `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageContractRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageContractRequestResult
func (u ManageContractRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch ManageContractRequestResultCode(sw) {
	case ManageContractRequestResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewManageContractRequestResult creates a new  ManageContractRequestResult.
func NewManageContractRequestResult(code ManageContractRequestResultCode, value interface{}) (result ManageContractRequestResult, err error) {
	result.Code = code
	switch ManageContractRequestResultCode(code) {
	case ManageContractRequestResultCodeSuccess:
		tv, ok := value.(ManageContractRequestResultSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageContractRequestResultSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u ManageContractRequestResult) MustSuccess() ManageContractRequestResultSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageContractRequestResult) GetSuccess() (result ManageContractRequestResultSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// ManageContractAction is an XDR Enum defines as:
//
//   enum ManageContractAction
//    {
//        ADD_DETAILS = 0,
//        CONFIRM_COMPLETED = 1,
//        START_DISPUTE = 2,
//        RESOLVE_DISPUTE = 3
//    };
//
type ManageContractAction int32

const (
	ManageContractActionAddDetails       ManageContractAction = 0
	ManageContractActionConfirmCompleted ManageContractAction = 1
	ManageContractActionStartDispute     ManageContractAction = 2
	ManageContractActionResolveDispute   ManageContractAction = 3
)

var ManageContractActionAll = []ManageContractAction{
	ManageContractActionAddDetails,
	ManageContractActionConfirmCompleted,
	ManageContractActionStartDispute,
	ManageContractActionResolveDispute,
}

var manageContractActionMap = map[int32]string{
	0: "ManageContractActionAddDetails",
	1: "ManageContractActionConfirmCompleted",
	2: "ManageContractActionStartDispute",
	3: "ManageContractActionResolveDispute",
}

var manageContractActionShortMap = map[int32]string{
	0: "add_details",
	1: "confirm_completed",
	2: "start_dispute",
	3: "resolve_dispute",
}

var manageContractActionRevMap = map[string]int32{
	"ManageContractActionAddDetails":       0,
	"ManageContractActionConfirmCompleted": 1,
	"ManageContractActionStartDispute":     2,
	"ManageContractActionResolveDispute":   3,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageContractAction
func (e ManageContractAction) ValidEnum(v int32) bool {
	_, ok := manageContractActionMap[v]
	return ok
}
func (e ManageContractAction) isFlag() bool {
	for i := len(ManageContractActionAll) - 1; i >= 0; i-- {
		expected := ManageContractAction(2) << uint64(len(ManageContractActionAll)-1) >> uint64(len(ManageContractActionAll)-i)
		if expected != ManageContractActionAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageContractAction) String() string {
	name, _ := manageContractActionMap[int32(e)]
	return name
}

func (e ManageContractAction) ShortString() string {
	name, _ := manageContractActionShortMap[int32(e)]
	return name
}

func (e ManageContractAction) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageContractActionAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageContractAction) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageContractAction(t.Value)
	return nil
}

// ManageContractOpData is an XDR NestedUnion defines as:
//
//   union switch (ManageContractAction action)
//        {
//        case ADD_DETAILS:
//            longstring details;
//        case CONFIRM_COMPLETED:
//            void;
//        case START_DISPUTE:
//            longstring disputeReason;
//        case RESOLVE_DISPUTE:
//            bool isRevert;
//        }
//
type ManageContractOpData struct {
	Action        ManageContractAction `json:"action,omitempty"`
	Details       *Longstring          `json:"details,omitempty"`
	DisputeReason *Longstring          `json:"disputeReason,omitempty"`
	IsRevert      *bool                `json:"isRevert,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageContractOpData) SwitchFieldName() string {
	return "Action"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageContractOpData
func (u ManageContractOpData) ArmForSwitch(sw int32) (string, bool) {
	switch ManageContractAction(sw) {
	case ManageContractActionAddDetails:
		return "Details", true
	case ManageContractActionConfirmCompleted:
		return "", true
	case ManageContractActionStartDispute:
		return "DisputeReason", true
	case ManageContractActionResolveDispute:
		return "IsRevert", true
	}
	return "-", false
}

// NewManageContractOpData creates a new  ManageContractOpData.
func NewManageContractOpData(action ManageContractAction, value interface{}) (result ManageContractOpData, err error) {
	result.Action = action
	switch ManageContractAction(action) {
	case ManageContractActionAddDetails:
		tv, ok := value.(Longstring)
		if !ok {
			err = fmt.Errorf("invalid value, must be Longstring")
			return
		}
		result.Details = &tv
	case ManageContractActionConfirmCompleted:
		// void
	case ManageContractActionStartDispute:
		tv, ok := value.(Longstring)
		if !ok {
			err = fmt.Errorf("invalid value, must be Longstring")
			return
		}
		result.DisputeReason = &tv
	case ManageContractActionResolveDispute:
		tv, ok := value.(bool)
		if !ok {
			err = fmt.Errorf("invalid value, must be bool")
			return
		}
		result.IsRevert = &tv
	}
	return
}

// MustDetails retrieves the Details value from the union,
// panicing if the value is not set.
func (u ManageContractOpData) MustDetails() Longstring {
	val, ok := u.GetDetails()

	if !ok {
		panic("arm Details is not set")
	}

	return val
}

// GetDetails retrieves the Details value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageContractOpData) GetDetails() (result Longstring, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "Details" {
		result = *u.Details
		ok = true
	}

	return
}

// MustDisputeReason retrieves the DisputeReason value from the union,
// panicing if the value is not set.
func (u ManageContractOpData) MustDisputeReason() Longstring {
	val, ok := u.GetDisputeReason()

	if !ok {
		panic("arm DisputeReason is not set")
	}

	return val
}

// GetDisputeReason retrieves the DisputeReason value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageContractOpData) GetDisputeReason() (result Longstring, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "DisputeReason" {
		result = *u.DisputeReason
		ok = true
	}

	return
}

// MustIsRevert retrieves the IsRevert value from the union,
// panicing if the value is not set.
func (u ManageContractOpData) MustIsRevert() bool {
	val, ok := u.GetIsRevert()

	if !ok {
		panic("arm IsRevert is not set")
	}

	return val
}

// GetIsRevert retrieves the IsRevert value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageContractOpData) GetIsRevert() (result bool, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "IsRevert" {
		result = *u.IsRevert
		ok = true
	}

	return
}

// ManageContractOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ManageContractOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageContractOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageContractOpExt
func (u ManageContractOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageContractOpExt creates a new  ManageContractOpExt.
func NewManageContractOpExt(v LedgerVersion, value interface{}) (result ManageContractOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageContractOp is an XDR Struct defines as:
//
//   struct ManageContractOp
//    {
//        uint64 contractID;
//
//        union switch (ManageContractAction action)
//        {
//        case ADD_DETAILS:
//            longstring details;
//        case CONFIRM_COMPLETED:
//            void;
//        case START_DISPUTE:
//            longstring disputeReason;
//        case RESOLVE_DISPUTE:
//            bool isRevert;
//        }
//        data;
//
//    	// reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ManageContractOp struct {
	ContractId Uint64               `json:"contractID,omitempty"`
	Data       ManageContractOpData `json:"data,omitempty"`
	Ext        ManageContractOpExt  `json:"ext,omitempty"`
}

// ManageContractResultCode is an XDR Enum defines as:
//
//   enum ManageContractResultCode
//    {
//        // codes considered as "success" for the operation
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        MALFORMED = -1,
//        NOT_FOUND = -2, // not found contract
//        NOT_ALLOWED = -3, // only contractor or customer can add details
//        DETAILS_TOO_LONG = -4,
//        DISPUTE_REASON_TOO_LONG = -5,
//        ALREADY_CONFIRMED = -6,
//        INVOICE_NOT_APPROVED = -7, // all contract invoices must be approved
//        DISPUTE_ALREADY_STARTED = -8,
//        CUSTOMER_BALANCE_OVERFLOW = -9,
//        INCORRECT_PRECISION = -10
//    };
//
type ManageContractResultCode int32

const (
	ManageContractResultCodeSuccess                 ManageContractResultCode = 0
	ManageContractResultCodeMalformed               ManageContractResultCode = -1
	ManageContractResultCodeNotFound                ManageContractResultCode = -2
	ManageContractResultCodeNotAllowed              ManageContractResultCode = -3
	ManageContractResultCodeDetailsTooLong          ManageContractResultCode = -4
	ManageContractResultCodeDisputeReasonTooLong    ManageContractResultCode = -5
	ManageContractResultCodeAlreadyConfirmed        ManageContractResultCode = -6
	ManageContractResultCodeInvoiceNotApproved      ManageContractResultCode = -7
	ManageContractResultCodeDisputeAlreadyStarted   ManageContractResultCode = -8
	ManageContractResultCodeCustomerBalanceOverflow ManageContractResultCode = -9
	ManageContractResultCodeIncorrectPrecision      ManageContractResultCode = -10
)

var ManageContractResultCodeAll = []ManageContractResultCode{
	ManageContractResultCodeSuccess,
	ManageContractResultCodeMalformed,
	ManageContractResultCodeNotFound,
	ManageContractResultCodeNotAllowed,
	ManageContractResultCodeDetailsTooLong,
	ManageContractResultCodeDisputeReasonTooLong,
	ManageContractResultCodeAlreadyConfirmed,
	ManageContractResultCodeInvoiceNotApproved,
	ManageContractResultCodeDisputeAlreadyStarted,
	ManageContractResultCodeCustomerBalanceOverflow,
	ManageContractResultCodeIncorrectPrecision,
}

var manageContractResultCodeMap = map[int32]string{
	0:   "ManageContractResultCodeSuccess",
	-1:  "ManageContractResultCodeMalformed",
	-2:  "ManageContractResultCodeNotFound",
	-3:  "ManageContractResultCodeNotAllowed",
	-4:  "ManageContractResultCodeDetailsTooLong",
	-5:  "ManageContractResultCodeDisputeReasonTooLong",
	-6:  "ManageContractResultCodeAlreadyConfirmed",
	-7:  "ManageContractResultCodeInvoiceNotApproved",
	-8:  "ManageContractResultCodeDisputeAlreadyStarted",
	-9:  "ManageContractResultCodeCustomerBalanceOverflow",
	-10: "ManageContractResultCodeIncorrectPrecision",
}

var manageContractResultCodeShortMap = map[int32]string{
	0:   "success",
	-1:  "malformed",
	-2:  "not_found",
	-3:  "not_allowed",
	-4:  "details_too_long",
	-5:  "dispute_reason_too_long",
	-6:  "already_confirmed",
	-7:  "invoice_not_approved",
	-8:  "dispute_already_started",
	-9:  "customer_balance_overflow",
	-10: "incorrect_precision",
}

var manageContractResultCodeRevMap = map[string]int32{
	"ManageContractResultCodeSuccess":                 0,
	"ManageContractResultCodeMalformed":               -1,
	"ManageContractResultCodeNotFound":                -2,
	"ManageContractResultCodeNotAllowed":              -3,
	"ManageContractResultCodeDetailsTooLong":          -4,
	"ManageContractResultCodeDisputeReasonTooLong":    -5,
	"ManageContractResultCodeAlreadyConfirmed":        -6,
	"ManageContractResultCodeInvoiceNotApproved":      -7,
	"ManageContractResultCodeDisputeAlreadyStarted":   -8,
	"ManageContractResultCodeCustomerBalanceOverflow": -9,
	"ManageContractResultCodeIncorrectPrecision":      -10,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageContractResultCode
func (e ManageContractResultCode) ValidEnum(v int32) bool {
	_, ok := manageContractResultCodeMap[v]
	return ok
}
func (e ManageContractResultCode) isFlag() bool {
	for i := len(ManageContractResultCodeAll) - 1; i >= 0; i-- {
		expected := ManageContractResultCode(2) << uint64(len(ManageContractResultCodeAll)-1) >> uint64(len(ManageContractResultCodeAll)-i)
		if expected != ManageContractResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageContractResultCode) String() string {
	name, _ := manageContractResultCodeMap[int32(e)]
	return name
}

func (e ManageContractResultCode) ShortString() string {
	name, _ := manageContractResultCodeShortMap[int32(e)]
	return name
}

func (e ManageContractResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageContractResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageContractResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageContractResultCode(t.Value)
	return nil
}

// ManageContractResponseData is an XDR NestedUnion defines as:
//
//   union switch (ManageContractAction action)
//        {
//        case CONFIRM_COMPLETED:
//            bool isCompleted;
//        default:
//            void;
//        }
//
type ManageContractResponseData struct {
	Action      ManageContractAction `json:"action,omitempty"`
	IsCompleted *bool                `json:"isCompleted,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageContractResponseData) SwitchFieldName() string {
	return "Action"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageContractResponseData
func (u ManageContractResponseData) ArmForSwitch(sw int32) (string, bool) {
	switch ManageContractAction(sw) {
	case ManageContractActionConfirmCompleted:
		return "IsCompleted", true
	default:
		return "", true
	}
}

// NewManageContractResponseData creates a new  ManageContractResponseData.
func NewManageContractResponseData(action ManageContractAction, value interface{}) (result ManageContractResponseData, err error) {
	result.Action = action
	switch ManageContractAction(action) {
	case ManageContractActionConfirmCompleted:
		tv, ok := value.(bool)
		if !ok {
			err = fmt.Errorf("invalid value, must be bool")
			return
		}
		result.IsCompleted = &tv
	default:
		// void
	}
	return
}

// MustIsCompleted retrieves the IsCompleted value from the union,
// panicing if the value is not set.
func (u ManageContractResponseData) MustIsCompleted() bool {
	val, ok := u.GetIsCompleted()

	if !ok {
		panic("arm IsCompleted is not set")
	}

	return val
}

// GetIsCompleted retrieves the IsCompleted value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageContractResponseData) GetIsCompleted() (result bool, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "IsCompleted" {
		result = *u.IsCompleted
		ok = true
	}

	return
}

// ManageContractResponseExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ManageContractResponseExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageContractResponseExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageContractResponseExt
func (u ManageContractResponseExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageContractResponseExt creates a new  ManageContractResponseExt.
func NewManageContractResponseExt(v LedgerVersion, value interface{}) (result ManageContractResponseExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageContractResponse is an XDR Struct defines as:
//
//   struct ManageContractResponse
//    {
//        union switch (ManageContractAction action)
//        {
//        case CONFIRM_COMPLETED:
//            bool isCompleted;
//        default:
//            void;
//        }
//        data;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ManageContractResponse struct {
	Data ManageContractResponseData `json:"data,omitempty"`
	Ext  ManageContractResponseExt  `json:"ext,omitempty"`
}

// ManageContractResult is an XDR Union defines as:
//
//   union ManageContractResult switch (ManageContractResultCode code)
//    {
//    case SUCCESS:
//        ManageContractResponse response;
//    default:
//        void;
//    };
//
type ManageContractResult struct {
	Code     ManageContractResultCode `json:"code,omitempty"`
	Response *ManageContractResponse  `json:"response,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageContractResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageContractResult
func (u ManageContractResult) ArmForSwitch(sw int32) (string, bool) {
	switch ManageContractResultCode(sw) {
	case ManageContractResultCodeSuccess:
		return "Response", true
	default:
		return "", true
	}
}

// NewManageContractResult creates a new  ManageContractResult.
func NewManageContractResult(code ManageContractResultCode, value interface{}) (result ManageContractResult, err error) {
	result.Code = code
	switch ManageContractResultCode(code) {
	case ManageContractResultCodeSuccess:
		tv, ok := value.(ManageContractResponse)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageContractResponse")
			return
		}
		result.Response = &tv
	default:
		// void
	}
	return
}

// MustResponse retrieves the Response value from the union,
// panicing if the value is not set.
func (u ManageContractResult) MustResponse() ManageContractResponse {
	val, ok := u.GetResponse()

	if !ok {
		panic("arm Response is not set")
	}

	return val
}

// GetResponse retrieves the Response value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageContractResult) GetResponse() (result ManageContractResponse, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Response" {
		result = *u.Response
		ok = true
	}

	return
}

// ManageCreatePollRequestAction is an XDR Enum defines as:
//
//   //: Actions that can be applied to a `CREATE_POLL` request
//    enum ManageCreatePollRequestAction
//    {
//        CREATE = 0,
//        CANCEL = 1
//    };
//
type ManageCreatePollRequestAction int32

const (
	ManageCreatePollRequestActionCreate ManageCreatePollRequestAction = 0
	ManageCreatePollRequestActionCancel ManageCreatePollRequestAction = 1
)

var ManageCreatePollRequestActionAll = []ManageCreatePollRequestAction{
	ManageCreatePollRequestActionCreate,
	ManageCreatePollRequestActionCancel,
}

var manageCreatePollRequestActionMap = map[int32]string{
	0: "ManageCreatePollRequestActionCreate",
	1: "ManageCreatePollRequestActionCancel",
}

var manageCreatePollRequestActionShortMap = map[int32]string{
	0: "create",
	1: "cancel",
}

var manageCreatePollRequestActionRevMap = map[string]int32{
	"ManageCreatePollRequestActionCreate": 0,
	"ManageCreatePollRequestActionCancel": 1,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageCreatePollRequestAction
func (e ManageCreatePollRequestAction) ValidEnum(v int32) bool {
	_, ok := manageCreatePollRequestActionMap[v]
	return ok
}
func (e ManageCreatePollRequestAction) isFlag() bool {
	for i := len(ManageCreatePollRequestActionAll) - 1; i >= 0; i-- {
		expected := ManageCreatePollRequestAction(2) << uint64(len(ManageCreatePollRequestActionAll)-1) >> uint64(len(ManageCreatePollRequestActionAll)-i)
		if expected != ManageCreatePollRequestActionAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageCreatePollRequestAction) String() string {
	name, _ := manageCreatePollRequestActionMap[int32(e)]
	return name
}

func (e ManageCreatePollRequestAction) ShortString() string {
	name, _ := manageCreatePollRequestActionShortMap[int32(e)]
	return name
}

func (e ManageCreatePollRequestAction) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageCreatePollRequestActionAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageCreatePollRequestAction) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageCreatePollRequestAction(t.Value)
	return nil
}

// CreatePollRequestDataExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreatePollRequestDataExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreatePollRequestDataExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreatePollRequestDataExt
func (u CreatePollRequestDataExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreatePollRequestDataExt creates a new  CreatePollRequestDataExt.
func NewCreatePollRequestDataExt(v LedgerVersion, value interface{}) (result CreatePollRequestDataExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreatePollRequestData is an XDR Struct defines as:
//
//   //: CreatePollRequestData is used to pass necessary data to create a `CREATE_POLL` request
//    struct CreatePollRequestData
//    {
//        //: Body of `CREATE_POLL` request
//        CreatePollRequest request;
//
//        //: Bit mask that will be used instead of the value from key-value entry by
//        //: `create_poll_tasks:<permissionType>` key
//        uint32* allTasks;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CreatePollRequestData struct {
	Request  CreatePollRequest        `json:"request,omitempty"`
	AllTasks *Uint32                  `json:"allTasks,omitempty"`
	Ext      CreatePollRequestDataExt `json:"ext,omitempty"`
}

// CancelPollRequestDataExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CancelPollRequestDataExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CancelPollRequestDataExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CancelPollRequestDataExt
func (u CancelPollRequestDataExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCancelPollRequestDataExt creates a new  CancelPollRequestDataExt.
func NewCancelPollRequestDataExt(v LedgerVersion, value interface{}) (result CancelPollRequestDataExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CancelPollRequestData is an XDR Struct defines as:
//
//   //: CancelPollRequestData is used to pass necessary data to remove a `CREATE_POLL` request
//    struct CancelPollRequestData
//    {
//        //: ID of `CREATE_POLL` request to remove
//        uint64 requestID;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CancelPollRequestData struct {
	RequestId Uint64                   `json:"requestID,omitempty"`
	Ext       CancelPollRequestDataExt `json:"ext,omitempty"`
}

// ManageCreatePollRequestOpData is an XDR NestedUnion defines as:
//
//   union switch (ManageCreatePollRequestAction action)
//        {
//        case CREATE:
//            CreatePollRequestData createData;
//        case CANCEL:
//            CancelPollRequestData cancelData;
//        }
//
type ManageCreatePollRequestOpData struct {
	Action     ManageCreatePollRequestAction `json:"action,omitempty"`
	CreateData *CreatePollRequestData        `json:"createData,omitempty"`
	CancelData *CancelPollRequestData        `json:"cancelData,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageCreatePollRequestOpData) SwitchFieldName() string {
	return "Action"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageCreatePollRequestOpData
func (u ManageCreatePollRequestOpData) ArmForSwitch(sw int32) (string, bool) {
	switch ManageCreatePollRequestAction(sw) {
	case ManageCreatePollRequestActionCreate:
		return "CreateData", true
	case ManageCreatePollRequestActionCancel:
		return "CancelData", true
	}
	return "-", false
}

// NewManageCreatePollRequestOpData creates a new  ManageCreatePollRequestOpData.
func NewManageCreatePollRequestOpData(action ManageCreatePollRequestAction, value interface{}) (result ManageCreatePollRequestOpData, err error) {
	result.Action = action
	switch ManageCreatePollRequestAction(action) {
	case ManageCreatePollRequestActionCreate:
		tv, ok := value.(CreatePollRequestData)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreatePollRequestData")
			return
		}
		result.CreateData = &tv
	case ManageCreatePollRequestActionCancel:
		tv, ok := value.(CancelPollRequestData)
		if !ok {
			err = fmt.Errorf("invalid value, must be CancelPollRequestData")
			return
		}
		result.CancelData = &tv
	}
	return
}

// MustCreateData retrieves the CreateData value from the union,
// panicing if the value is not set.
func (u ManageCreatePollRequestOpData) MustCreateData() CreatePollRequestData {
	val, ok := u.GetCreateData()

	if !ok {
		panic("arm CreateData is not set")
	}

	return val
}

// GetCreateData retrieves the CreateData value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageCreatePollRequestOpData) GetCreateData() (result CreatePollRequestData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "CreateData" {
		result = *u.CreateData
		ok = true
	}

	return
}

// MustCancelData retrieves the CancelData value from the union,
// panicing if the value is not set.
func (u ManageCreatePollRequestOpData) MustCancelData() CancelPollRequestData {
	val, ok := u.GetCancelData()

	if !ok {
		panic("arm CancelData is not set")
	}

	return val
}

// GetCancelData retrieves the CancelData value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageCreatePollRequestOpData) GetCancelData() (result CancelPollRequestData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "CancelData" {
		result = *u.CancelData
		ok = true
	}

	return
}

// ManageCreatePollRequestOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ManageCreatePollRequestOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageCreatePollRequestOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageCreatePollRequestOpExt
func (u ManageCreatePollRequestOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageCreatePollRequestOpExt creates a new  ManageCreatePollRequestOpExt.
func NewManageCreatePollRequestOpExt(v LedgerVersion, value interface{}) (result ManageCreatePollRequestOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageCreatePollRequestOp is an XDR Struct defines as:
//
//   //: ManageCreatePollRequestOp is used to create or remove a `CREATE_POLL` request
//    struct ManageCreatePollRequestOp
//    {
//        //: data is used to pass one of `ManageCreatePollRequestAction` with required params
//        union switch (ManageCreatePollRequestAction action)
//        {
//        case CREATE:
//            CreatePollRequestData createData;
//        case CANCEL:
//            CancelPollRequestData cancelData;
//        }
//        data;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ManageCreatePollRequestOp struct {
	Data ManageCreatePollRequestOpData `json:"data,omitempty"`
	Ext  ManageCreatePollRequestOpExt  `json:"ext,omitempty"`
}

// ManageCreatePollRequestResultCode is an XDR Enum defines as:
//
//   //: Result codes of ManageCreatePollRequestOp
//    enum ManageCreatePollRequestResultCode
//    {
//        //: `CREATE_POLL` request has either been successfully created
//        //: or auto approved
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: Passed details have invalid json structure
//        INVALID_CREATOR_DETAILS = -1,
//        //: There is no `CREATE_POLL` request with such id
//        NOT_FOUND = -2,
//        //: Not allowed to create poll which has `endTime` not later than `startTime`
//        INVALID_DATES = -3,
//        //: Not allowed to create poll which `endTime` early than currentTime
//        INVALID_END_TIME = -4,
//        //: There is no account which such id
//        RESULT_PROVIDER_NOT_FOUND = -5,
//        //: There is no key-value entry by `create_poll_tasks:<permissionType>` key in the system;
//        //: configuration does not allow to create `CREATE_POLL` request with such `permissionType`
//        CREATE_POLL_TASKS_NOT_FOUND = -6,
//        //: Not allowed to create poll with zero number of choices
//        INVALID_NUMBER_OF_CHOICES = -7
//    };
//
type ManageCreatePollRequestResultCode int32

const (
	ManageCreatePollRequestResultCodeSuccess                 ManageCreatePollRequestResultCode = 0
	ManageCreatePollRequestResultCodeInvalidCreatorDetails   ManageCreatePollRequestResultCode = -1
	ManageCreatePollRequestResultCodeNotFound                ManageCreatePollRequestResultCode = -2
	ManageCreatePollRequestResultCodeInvalidDates            ManageCreatePollRequestResultCode = -3
	ManageCreatePollRequestResultCodeInvalidEndTime          ManageCreatePollRequestResultCode = -4
	ManageCreatePollRequestResultCodeResultProviderNotFound  ManageCreatePollRequestResultCode = -5
	ManageCreatePollRequestResultCodeCreatePollTasksNotFound ManageCreatePollRequestResultCode = -6
	ManageCreatePollRequestResultCodeInvalidNumberOfChoices  ManageCreatePollRequestResultCode = -7
)

var ManageCreatePollRequestResultCodeAll = []ManageCreatePollRequestResultCode{
	ManageCreatePollRequestResultCodeSuccess,
	ManageCreatePollRequestResultCodeInvalidCreatorDetails,
	ManageCreatePollRequestResultCodeNotFound,
	ManageCreatePollRequestResultCodeInvalidDates,
	ManageCreatePollRequestResultCodeInvalidEndTime,
	ManageCreatePollRequestResultCodeResultProviderNotFound,
	ManageCreatePollRequestResultCodeCreatePollTasksNotFound,
	ManageCreatePollRequestResultCodeInvalidNumberOfChoices,
}

var manageCreatePollRequestResultCodeMap = map[int32]string{
	0:  "ManageCreatePollRequestResultCodeSuccess",
	-1: "ManageCreatePollRequestResultCodeInvalidCreatorDetails",
	-2: "ManageCreatePollRequestResultCodeNotFound",
	-3: "ManageCreatePollRequestResultCodeInvalidDates",
	-4: "ManageCreatePollRequestResultCodeInvalidEndTime",
	-5: "ManageCreatePollRequestResultCodeResultProviderNotFound",
	-6: "ManageCreatePollRequestResultCodeCreatePollTasksNotFound",
	-7: "ManageCreatePollRequestResultCodeInvalidNumberOfChoices",
}

var manageCreatePollRequestResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "invalid_creator_details",
	-2: "not_found",
	-3: "invalid_dates",
	-4: "invalid_end_time",
	-5: "result_provider_not_found",
	-6: "create_poll_tasks_not_found",
	-7: "invalid_number_of_choices",
}

var manageCreatePollRequestResultCodeRevMap = map[string]int32{
	"ManageCreatePollRequestResultCodeSuccess":                 0,
	"ManageCreatePollRequestResultCodeInvalidCreatorDetails":   -1,
	"ManageCreatePollRequestResultCodeNotFound":                -2,
	"ManageCreatePollRequestResultCodeInvalidDates":            -3,
	"ManageCreatePollRequestResultCodeInvalidEndTime":          -4,
	"ManageCreatePollRequestResultCodeResultProviderNotFound":  -5,
	"ManageCreatePollRequestResultCodeCreatePollTasksNotFound": -6,
	"ManageCreatePollRequestResultCodeInvalidNumberOfChoices":  -7,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageCreatePollRequestResultCode
func (e ManageCreatePollRequestResultCode) ValidEnum(v int32) bool {
	_, ok := manageCreatePollRequestResultCodeMap[v]
	return ok
}
func (e ManageCreatePollRequestResultCode) isFlag() bool {
	for i := len(ManageCreatePollRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := ManageCreatePollRequestResultCode(2) << uint64(len(ManageCreatePollRequestResultCodeAll)-1) >> uint64(len(ManageCreatePollRequestResultCodeAll)-i)
		if expected != ManageCreatePollRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageCreatePollRequestResultCode) String() string {
	name, _ := manageCreatePollRequestResultCodeMap[int32(e)]
	return name
}

func (e ManageCreatePollRequestResultCode) ShortString() string {
	name, _ := manageCreatePollRequestResultCodeShortMap[int32(e)]
	return name
}

func (e ManageCreatePollRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageCreatePollRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageCreatePollRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageCreatePollRequestResultCode(t.Value)
	return nil
}

// CreatePollRequestResponseExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreatePollRequestResponseExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreatePollRequestResponseExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreatePollRequestResponseExt
func (u CreatePollRequestResponseExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreatePollRequestResponseExt creates a new  CreatePollRequestResponseExt.
func NewCreatePollRequestResponseExt(v LedgerVersion, value interface{}) (result CreatePollRequestResponseExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreatePollRequestResponse is an XDR Struct defines as:
//
//   //: CreatePollRequestResponse is used to pass useful fields after `CREATE_POLL` request creation
//    struct CreatePollRequestResponse
//    {
//        //: ID of a created request
//        uint64 requestID;
//
//        //: Indicates whether or not the `CREATE_POLL` request was auto approved and fulfilled
//        //: True means that poll was successfully created
//        bool fulfilled;
//
//        //: ID of created poll if request was fulfilled
//        uint64* pollID;
//
//        //: reserved for the future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CreatePollRequestResponse struct {
	RequestId Uint64                       `json:"requestID,omitempty"`
	Fulfilled bool                         `json:"fulfilled,omitempty"`
	PollId    *Uint64                      `json:"pollID,omitempty"`
	Ext       CreatePollRequestResponseExt `json:"ext,omitempty"`
}

// ManageCreatePollRequestSuccessResultDetails is an XDR NestedUnion defines as:
//
//   union switch (ManageCreatePollRequestAction action)
//        {
//        case CREATE:
//            CreatePollRequestResponse response;
//        case CANCEL:
//            void;
//        }
//
type ManageCreatePollRequestSuccessResultDetails struct {
	Action   ManageCreatePollRequestAction `json:"action,omitempty"`
	Response *CreatePollRequestResponse    `json:"response,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageCreatePollRequestSuccessResultDetails) SwitchFieldName() string {
	return "Action"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageCreatePollRequestSuccessResultDetails
func (u ManageCreatePollRequestSuccessResultDetails) ArmForSwitch(sw int32) (string, bool) {
	switch ManageCreatePollRequestAction(sw) {
	case ManageCreatePollRequestActionCreate:
		return "Response", true
	case ManageCreatePollRequestActionCancel:
		return "", true
	}
	return "-", false
}

// NewManageCreatePollRequestSuccessResultDetails creates a new  ManageCreatePollRequestSuccessResultDetails.
func NewManageCreatePollRequestSuccessResultDetails(action ManageCreatePollRequestAction, value interface{}) (result ManageCreatePollRequestSuccessResultDetails, err error) {
	result.Action = action
	switch ManageCreatePollRequestAction(action) {
	case ManageCreatePollRequestActionCreate:
		tv, ok := value.(CreatePollRequestResponse)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreatePollRequestResponse")
			return
		}
		result.Response = &tv
	case ManageCreatePollRequestActionCancel:
		// void
	}
	return
}

// MustResponse retrieves the Response value from the union,
// panicing if the value is not set.
func (u ManageCreatePollRequestSuccessResultDetails) MustResponse() CreatePollRequestResponse {
	val, ok := u.GetResponse()

	if !ok {
		panic("arm Response is not set")
	}

	return val
}

// GetResponse retrieves the Response value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageCreatePollRequestSuccessResultDetails) GetResponse() (result CreatePollRequestResponse, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "Response" {
		result = *u.Response
		ok = true
	}

	return
}

// ManageCreatePollRequestSuccessResultExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ManageCreatePollRequestSuccessResultExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageCreatePollRequestSuccessResultExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageCreatePollRequestSuccessResultExt
func (u ManageCreatePollRequestSuccessResultExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageCreatePollRequestSuccessResultExt creates a new  ManageCreatePollRequestSuccessResultExt.
func NewManageCreatePollRequestSuccessResultExt(v LedgerVersion, value interface{}) (result ManageCreatePollRequestSuccessResultExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageCreatePollRequestSuccessResult is an XDR Struct defines as:
//
//   //: Success result of operation application
//    struct ManageCreatePollRequestSuccessResult
//    {
//        //: `details` id used to pass useful fields
//        union switch (ManageCreatePollRequestAction action)
//        {
//        case CREATE:
//            CreatePollRequestResponse response;
//        case CANCEL:
//            void;
//        } details;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ManageCreatePollRequestSuccessResult struct {
	Details ManageCreatePollRequestSuccessResultDetails `json:"details,omitempty"`
	Ext     ManageCreatePollRequestSuccessResultExt     `json:"ext,omitempty"`
}

// ManageCreatePollRequestResult is an XDR Union defines as:
//
//   //: Result of ManageCreatePollRequestOp application
//    union ManageCreatePollRequestResult switch (ManageCreatePollRequestResultCode code)
//    {
//    case SUCCESS:
//        ManageCreatePollRequestSuccessResult success;
//    default:
//        void;
//    };
//
type ManageCreatePollRequestResult struct {
	Code    ManageCreatePollRequestResultCode     `json:"code,omitempty"`
	Success *ManageCreatePollRequestSuccessResult `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageCreatePollRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageCreatePollRequestResult
func (u ManageCreatePollRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch ManageCreatePollRequestResultCode(sw) {
	case ManageCreatePollRequestResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewManageCreatePollRequestResult creates a new  ManageCreatePollRequestResult.
func NewManageCreatePollRequestResult(code ManageCreatePollRequestResultCode, value interface{}) (result ManageCreatePollRequestResult, err error) {
	result.Code = code
	switch ManageCreatePollRequestResultCode(code) {
	case ManageCreatePollRequestResultCodeSuccess:
		tv, ok := value.(ManageCreatePollRequestSuccessResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageCreatePollRequestSuccessResult")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u ManageCreatePollRequestResult) MustSuccess() ManageCreatePollRequestSuccessResult {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageCreatePollRequestResult) GetSuccess() (result ManageCreatePollRequestSuccessResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// ManageExternalSystemAccountIdPoolEntryAction is an XDR Enum defines as:
//
//   //: Actions that can be performed with an external system account ID in the external system ID pool
//    enum ManageExternalSystemAccountIdPoolEntryAction
//    {
//        CREATE = 0,
//        REMOVE = 1
//    };
//
type ManageExternalSystemAccountIdPoolEntryAction int32

const (
	ManageExternalSystemAccountIdPoolEntryActionCreate ManageExternalSystemAccountIdPoolEntryAction = 0
	ManageExternalSystemAccountIdPoolEntryActionRemove ManageExternalSystemAccountIdPoolEntryAction = 1
)

var ManageExternalSystemAccountIdPoolEntryActionAll = []ManageExternalSystemAccountIdPoolEntryAction{
	ManageExternalSystemAccountIdPoolEntryActionCreate,
	ManageExternalSystemAccountIdPoolEntryActionRemove,
}

var manageExternalSystemAccountIdPoolEntryActionMap = map[int32]string{
	0: "ManageExternalSystemAccountIdPoolEntryActionCreate",
	1: "ManageExternalSystemAccountIdPoolEntryActionRemove",
}

var manageExternalSystemAccountIdPoolEntryActionShortMap = map[int32]string{
	0: "create",
	1: "remove",
}

var manageExternalSystemAccountIdPoolEntryActionRevMap = map[string]int32{
	"ManageExternalSystemAccountIdPoolEntryActionCreate": 0,
	"ManageExternalSystemAccountIdPoolEntryActionRemove": 1,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageExternalSystemAccountIdPoolEntryAction
func (e ManageExternalSystemAccountIdPoolEntryAction) ValidEnum(v int32) bool {
	_, ok := manageExternalSystemAccountIdPoolEntryActionMap[v]
	return ok
}
func (e ManageExternalSystemAccountIdPoolEntryAction) isFlag() bool {
	for i := len(ManageExternalSystemAccountIdPoolEntryActionAll) - 1; i >= 0; i-- {
		expected := ManageExternalSystemAccountIdPoolEntryAction(2) << uint64(len(ManageExternalSystemAccountIdPoolEntryActionAll)-1) >> uint64(len(ManageExternalSystemAccountIdPoolEntryActionAll)-i)
		if expected != ManageExternalSystemAccountIdPoolEntryActionAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageExternalSystemAccountIdPoolEntryAction) String() string {
	name, _ := manageExternalSystemAccountIdPoolEntryActionMap[int32(e)]
	return name
}

func (e ManageExternalSystemAccountIdPoolEntryAction) ShortString() string {
	name, _ := manageExternalSystemAccountIdPoolEntryActionShortMap[int32(e)]
	return name
}

func (e ManageExternalSystemAccountIdPoolEntryAction) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageExternalSystemAccountIdPoolEntryActionAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageExternalSystemAccountIdPoolEntryAction) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageExternalSystemAccountIdPoolEntryAction(t.Value)
	return nil
}

// CreateExternalSystemAccountIdPoolEntryActionInputExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateExternalSystemAccountIdPoolEntryActionInputExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateExternalSystemAccountIdPoolEntryActionInputExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateExternalSystemAccountIdPoolEntryActionInputExt
func (u CreateExternalSystemAccountIdPoolEntryActionInputExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateExternalSystemAccountIdPoolEntryActionInputExt creates a new  CreateExternalSystemAccountIdPoolEntryActionInputExt.
func NewCreateExternalSystemAccountIdPoolEntryActionInputExt(v LedgerVersion, value interface{}) (result CreateExternalSystemAccountIdPoolEntryActionInputExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateExternalSystemAccountIdPoolEntryActionInput is an XDR Struct defines as:
//
//   //: CreateExternalSystemAccountIdPoolEntryActionInput is used to
//    //: pass necessary params to create a new external system account ID in the external system ID pool
//    struct CreateExternalSystemAccountIdPoolEntryActionInput
//    {
//        //: Type of external system, selected arbitrarily
//        int32 externalSystemType;
//        //: Data for external system binding
//        longstring data;
//        //: External system ID of the creator
//        uint64 parent;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CreateExternalSystemAccountIdPoolEntryActionInput struct {
	ExternalSystemType Int32                                                `json:"externalSystemType,omitempty"`
	Data               Longstring                                           `json:"data,omitempty"`
	Parent             Uint64                                               `json:"parent,omitempty"`
	Ext                CreateExternalSystemAccountIdPoolEntryActionInputExt `json:"ext,omitempty"`
}

// DeleteExternalSystemAccountIdPoolEntryActionInputExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type DeleteExternalSystemAccountIdPoolEntryActionInputExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u DeleteExternalSystemAccountIdPoolEntryActionInputExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of DeleteExternalSystemAccountIdPoolEntryActionInputExt
func (u DeleteExternalSystemAccountIdPoolEntryActionInputExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewDeleteExternalSystemAccountIdPoolEntryActionInputExt creates a new  DeleteExternalSystemAccountIdPoolEntryActionInputExt.
func NewDeleteExternalSystemAccountIdPoolEntryActionInputExt(v LedgerVersion, value interface{}) (result DeleteExternalSystemAccountIdPoolEntryActionInputExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// DeleteExternalSystemAccountIdPoolEntryActionInput is an XDR Struct defines as:
//
//   //: DeleteExternalSystemAccountIdPoolEntryActionInput is used to
//    //: pass necessary params to remove an existing external system account ID in the external system ID pool
//    struct DeleteExternalSystemAccountIdPoolEntryActionInput
//    {
//        //: ID of an existing external system account ID pool
//        uint64 poolEntryID;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type DeleteExternalSystemAccountIdPoolEntryActionInput struct {
	PoolEntryId Uint64                                               `json:"poolEntryID,omitempty"`
	Ext         DeleteExternalSystemAccountIdPoolEntryActionInputExt `json:"ext,omitempty"`
}

// ManageExternalSystemAccountIdPoolEntryOpActionInput is an XDR NestedUnion defines as:
//
//   union switch (ManageExternalSystemAccountIdPoolEntryAction action)
//        {
//        case CREATE:
//            CreateExternalSystemAccountIdPoolEntryActionInput createExternalSystemAccountIdPoolEntryActionInput;
//        case REMOVE:
//            DeleteExternalSystemAccountIdPoolEntryActionInput deleteExternalSystemAccountIdPoolEntryActionInput;
//        }
//
type ManageExternalSystemAccountIdPoolEntryOpActionInput struct {
	Action                                            ManageExternalSystemAccountIdPoolEntryAction       `json:"action,omitempty"`
	CreateExternalSystemAccountIdPoolEntryActionInput *CreateExternalSystemAccountIdPoolEntryActionInput `json:"createExternalSystemAccountIdPoolEntryActionInput,omitempty"`
	DeleteExternalSystemAccountIdPoolEntryActionInput *DeleteExternalSystemAccountIdPoolEntryActionInput `json:"deleteExternalSystemAccountIdPoolEntryActionInput,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageExternalSystemAccountIdPoolEntryOpActionInput) SwitchFieldName() string {
	return "Action"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageExternalSystemAccountIdPoolEntryOpActionInput
func (u ManageExternalSystemAccountIdPoolEntryOpActionInput) ArmForSwitch(sw int32) (string, bool) {
	switch ManageExternalSystemAccountIdPoolEntryAction(sw) {
	case ManageExternalSystemAccountIdPoolEntryActionCreate:
		return "CreateExternalSystemAccountIdPoolEntryActionInput", true
	case ManageExternalSystemAccountIdPoolEntryActionRemove:
		return "DeleteExternalSystemAccountIdPoolEntryActionInput", true
	}
	return "-", false
}

// NewManageExternalSystemAccountIdPoolEntryOpActionInput creates a new  ManageExternalSystemAccountIdPoolEntryOpActionInput.
func NewManageExternalSystemAccountIdPoolEntryOpActionInput(action ManageExternalSystemAccountIdPoolEntryAction, value interface{}) (result ManageExternalSystemAccountIdPoolEntryOpActionInput, err error) {
	result.Action = action
	switch ManageExternalSystemAccountIdPoolEntryAction(action) {
	case ManageExternalSystemAccountIdPoolEntryActionCreate:
		tv, ok := value.(CreateExternalSystemAccountIdPoolEntryActionInput)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateExternalSystemAccountIdPoolEntryActionInput")
			return
		}
		result.CreateExternalSystemAccountIdPoolEntryActionInput = &tv
	case ManageExternalSystemAccountIdPoolEntryActionRemove:
		tv, ok := value.(DeleteExternalSystemAccountIdPoolEntryActionInput)
		if !ok {
			err = fmt.Errorf("invalid value, must be DeleteExternalSystemAccountIdPoolEntryActionInput")
			return
		}
		result.DeleteExternalSystemAccountIdPoolEntryActionInput = &tv
	}
	return
}

// MustCreateExternalSystemAccountIdPoolEntryActionInput retrieves the CreateExternalSystemAccountIdPoolEntryActionInput value from the union,
// panicing if the value is not set.
func (u ManageExternalSystemAccountIdPoolEntryOpActionInput) MustCreateExternalSystemAccountIdPoolEntryActionInput() CreateExternalSystemAccountIdPoolEntryActionInput {
	val, ok := u.GetCreateExternalSystemAccountIdPoolEntryActionInput()

	if !ok {
		panic("arm CreateExternalSystemAccountIdPoolEntryActionInput is not set")
	}

	return val
}

// GetCreateExternalSystemAccountIdPoolEntryActionInput retrieves the CreateExternalSystemAccountIdPoolEntryActionInput value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageExternalSystemAccountIdPoolEntryOpActionInput) GetCreateExternalSystemAccountIdPoolEntryActionInput() (result CreateExternalSystemAccountIdPoolEntryActionInput, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "CreateExternalSystemAccountIdPoolEntryActionInput" {
		result = *u.CreateExternalSystemAccountIdPoolEntryActionInput
		ok = true
	}

	return
}

// MustDeleteExternalSystemAccountIdPoolEntryActionInput retrieves the DeleteExternalSystemAccountIdPoolEntryActionInput value from the union,
// panicing if the value is not set.
func (u ManageExternalSystemAccountIdPoolEntryOpActionInput) MustDeleteExternalSystemAccountIdPoolEntryActionInput() DeleteExternalSystemAccountIdPoolEntryActionInput {
	val, ok := u.GetDeleteExternalSystemAccountIdPoolEntryActionInput()

	if !ok {
		panic("arm DeleteExternalSystemAccountIdPoolEntryActionInput is not set")
	}

	return val
}

// GetDeleteExternalSystemAccountIdPoolEntryActionInput retrieves the DeleteExternalSystemAccountIdPoolEntryActionInput value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageExternalSystemAccountIdPoolEntryOpActionInput) GetDeleteExternalSystemAccountIdPoolEntryActionInput() (result DeleteExternalSystemAccountIdPoolEntryActionInput, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "DeleteExternalSystemAccountIdPoolEntryActionInput" {
		result = *u.DeleteExternalSystemAccountIdPoolEntryActionInput
		ok = true
	}

	return
}

// ManageExternalSystemAccountIdPoolEntryOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ManageExternalSystemAccountIdPoolEntryOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageExternalSystemAccountIdPoolEntryOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageExternalSystemAccountIdPoolEntryOpExt
func (u ManageExternalSystemAccountIdPoolEntryOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageExternalSystemAccountIdPoolEntryOpExt creates a new  ManageExternalSystemAccountIdPoolEntryOpExt.
func NewManageExternalSystemAccountIdPoolEntryOpExt(v LedgerVersion, value interface{}) (result ManageExternalSystemAccountIdPoolEntryOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageExternalSystemAccountIdPoolEntryOp is an XDR Struct defines as:
//
//   //: ManageExternalSystemAccountIdPoolEntryOp is used to create or remove
//    //: an external system account ID from the external system ID pool
//    struct ManageExternalSystemAccountIdPoolEntryOp
//    {
//        //: `actionInput` is used to pass one of
//        //: `ManageExternalSystemAccountIdPoolEntryAction` with required params
//        union switch (ManageExternalSystemAccountIdPoolEntryAction action)
//        {
//        case CREATE:
//            CreateExternalSystemAccountIdPoolEntryActionInput createExternalSystemAccountIdPoolEntryActionInput;
//        case REMOVE:
//            DeleteExternalSystemAccountIdPoolEntryActionInput deleteExternalSystemAccountIdPoolEntryActionInput;
//        } actionInput;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ManageExternalSystemAccountIdPoolEntryOp struct {
	ActionInput ManageExternalSystemAccountIdPoolEntryOpActionInput `json:"actionInput,omitempty"`
	Ext         ManageExternalSystemAccountIdPoolEntryOpExt         `json:"ext,omitempty"`
}

// ManageExternalSystemAccountIdPoolEntryResultCode is an XDR Enum defines as:
//
//   //: Result codes of ManageExternalSystemAccountIdPoolEntryOp
//    enum ManageExternalSystemAccountIdPoolEntryResultCode
//    {
//        //: Specified action in `actionInput` of ManageExternalSystemAccountIdPoolEntryOp
//        //: was performed successfully
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: It is not allowed to pass empty `data`
//        MALFORMED = -1,
//        //: It is not allowed to create external system account ID pool with duplicated
//        //: data and external system type
//        ALREADY_EXISTS = -2,
//        //: There is no external system account ID pool with passed ID
//        NOT_FOUND = -3
//    };
//
type ManageExternalSystemAccountIdPoolEntryResultCode int32

const (
	ManageExternalSystemAccountIdPoolEntryResultCodeSuccess       ManageExternalSystemAccountIdPoolEntryResultCode = 0
	ManageExternalSystemAccountIdPoolEntryResultCodeMalformed     ManageExternalSystemAccountIdPoolEntryResultCode = -1
	ManageExternalSystemAccountIdPoolEntryResultCodeAlreadyExists ManageExternalSystemAccountIdPoolEntryResultCode = -2
	ManageExternalSystemAccountIdPoolEntryResultCodeNotFound      ManageExternalSystemAccountIdPoolEntryResultCode = -3
)

var ManageExternalSystemAccountIdPoolEntryResultCodeAll = []ManageExternalSystemAccountIdPoolEntryResultCode{
	ManageExternalSystemAccountIdPoolEntryResultCodeSuccess,
	ManageExternalSystemAccountIdPoolEntryResultCodeMalformed,
	ManageExternalSystemAccountIdPoolEntryResultCodeAlreadyExists,
	ManageExternalSystemAccountIdPoolEntryResultCodeNotFound,
}

var manageExternalSystemAccountIdPoolEntryResultCodeMap = map[int32]string{
	0:  "ManageExternalSystemAccountIdPoolEntryResultCodeSuccess",
	-1: "ManageExternalSystemAccountIdPoolEntryResultCodeMalformed",
	-2: "ManageExternalSystemAccountIdPoolEntryResultCodeAlreadyExists",
	-3: "ManageExternalSystemAccountIdPoolEntryResultCodeNotFound",
}

var manageExternalSystemAccountIdPoolEntryResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "malformed",
	-2: "already_exists",
	-3: "not_found",
}

var manageExternalSystemAccountIdPoolEntryResultCodeRevMap = map[string]int32{
	"ManageExternalSystemAccountIdPoolEntryResultCodeSuccess":       0,
	"ManageExternalSystemAccountIdPoolEntryResultCodeMalformed":     -1,
	"ManageExternalSystemAccountIdPoolEntryResultCodeAlreadyExists": -2,
	"ManageExternalSystemAccountIdPoolEntryResultCodeNotFound":      -3,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageExternalSystemAccountIdPoolEntryResultCode
func (e ManageExternalSystemAccountIdPoolEntryResultCode) ValidEnum(v int32) bool {
	_, ok := manageExternalSystemAccountIdPoolEntryResultCodeMap[v]
	return ok
}
func (e ManageExternalSystemAccountIdPoolEntryResultCode) isFlag() bool {
	for i := len(ManageExternalSystemAccountIdPoolEntryResultCodeAll) - 1; i >= 0; i-- {
		expected := ManageExternalSystemAccountIdPoolEntryResultCode(2) << uint64(len(ManageExternalSystemAccountIdPoolEntryResultCodeAll)-1) >> uint64(len(ManageExternalSystemAccountIdPoolEntryResultCodeAll)-i)
		if expected != ManageExternalSystemAccountIdPoolEntryResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageExternalSystemAccountIdPoolEntryResultCode) String() string {
	name, _ := manageExternalSystemAccountIdPoolEntryResultCodeMap[int32(e)]
	return name
}

func (e ManageExternalSystemAccountIdPoolEntryResultCode) ShortString() string {
	name, _ := manageExternalSystemAccountIdPoolEntryResultCodeShortMap[int32(e)]
	return name
}

func (e ManageExternalSystemAccountIdPoolEntryResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageExternalSystemAccountIdPoolEntryResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageExternalSystemAccountIdPoolEntryResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageExternalSystemAccountIdPoolEntryResultCode(t.Value)
	return nil
}

// ManageExternalSystemAccountIdPoolEntrySuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ManageExternalSystemAccountIdPoolEntrySuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageExternalSystemAccountIdPoolEntrySuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageExternalSystemAccountIdPoolEntrySuccessExt
func (u ManageExternalSystemAccountIdPoolEntrySuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageExternalSystemAccountIdPoolEntrySuccessExt creates a new  ManageExternalSystemAccountIdPoolEntrySuccessExt.
func NewManageExternalSystemAccountIdPoolEntrySuccessExt(v LedgerVersion, value interface{}) (result ManageExternalSystemAccountIdPoolEntrySuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageExternalSystemAccountIdPoolEntrySuccess is an XDR Struct defines as:
//
//   //: Success result of operation application
//    struct ManageExternalSystemAccountIdPoolEntrySuccess
//    {
//        //: ID of the created external system account ID pool
//        uint64 poolEntryID;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ManageExternalSystemAccountIdPoolEntrySuccess struct {
	PoolEntryId Uint64                                           `json:"poolEntryID,omitempty"`
	Ext         ManageExternalSystemAccountIdPoolEntrySuccessExt `json:"ext,omitempty"`
}

// ManageExternalSystemAccountIdPoolEntryResult is an XDR Union defines as:
//
//   //: Result of operation application
//    union ManageExternalSystemAccountIdPoolEntryResult switch (ManageExternalSystemAccountIdPoolEntryResultCode code)
//    {
//    case SUCCESS:
//        ManageExternalSystemAccountIdPoolEntrySuccess success;
//    default:
//        void;
//    };
//
type ManageExternalSystemAccountIdPoolEntryResult struct {
	Code    ManageExternalSystemAccountIdPoolEntryResultCode `json:"code,omitempty"`
	Success *ManageExternalSystemAccountIdPoolEntrySuccess   `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageExternalSystemAccountIdPoolEntryResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageExternalSystemAccountIdPoolEntryResult
func (u ManageExternalSystemAccountIdPoolEntryResult) ArmForSwitch(sw int32) (string, bool) {
	switch ManageExternalSystemAccountIdPoolEntryResultCode(sw) {
	case ManageExternalSystemAccountIdPoolEntryResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewManageExternalSystemAccountIdPoolEntryResult creates a new  ManageExternalSystemAccountIdPoolEntryResult.
func NewManageExternalSystemAccountIdPoolEntryResult(code ManageExternalSystemAccountIdPoolEntryResultCode, value interface{}) (result ManageExternalSystemAccountIdPoolEntryResult, err error) {
	result.Code = code
	switch ManageExternalSystemAccountIdPoolEntryResultCode(code) {
	case ManageExternalSystemAccountIdPoolEntryResultCodeSuccess:
		tv, ok := value.(ManageExternalSystemAccountIdPoolEntrySuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageExternalSystemAccountIdPoolEntrySuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u ManageExternalSystemAccountIdPoolEntryResult) MustSuccess() ManageExternalSystemAccountIdPoolEntrySuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageExternalSystemAccountIdPoolEntryResult) GetSuccess() (result ManageExternalSystemAccountIdPoolEntrySuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// ManageInvoiceRequestAction is an XDR Enum defines as:
//
//   enum ManageInvoiceRequestAction
//    {
//        CREATE = 0,
//        REMOVE = 1
//    };
//
type ManageInvoiceRequestAction int32

const (
	ManageInvoiceRequestActionCreate ManageInvoiceRequestAction = 0
	ManageInvoiceRequestActionRemove ManageInvoiceRequestAction = 1
)

var ManageInvoiceRequestActionAll = []ManageInvoiceRequestAction{
	ManageInvoiceRequestActionCreate,
	ManageInvoiceRequestActionRemove,
}

var manageInvoiceRequestActionMap = map[int32]string{
	0: "ManageInvoiceRequestActionCreate",
	1: "ManageInvoiceRequestActionRemove",
}

var manageInvoiceRequestActionShortMap = map[int32]string{
	0: "create",
	1: "remove",
}

var manageInvoiceRequestActionRevMap = map[string]int32{
	"ManageInvoiceRequestActionCreate": 0,
	"ManageInvoiceRequestActionRemove": 1,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageInvoiceRequestAction
func (e ManageInvoiceRequestAction) ValidEnum(v int32) bool {
	_, ok := manageInvoiceRequestActionMap[v]
	return ok
}
func (e ManageInvoiceRequestAction) isFlag() bool {
	for i := len(ManageInvoiceRequestActionAll) - 1; i >= 0; i-- {
		expected := ManageInvoiceRequestAction(2) << uint64(len(ManageInvoiceRequestActionAll)-1) >> uint64(len(ManageInvoiceRequestActionAll)-i)
		if expected != ManageInvoiceRequestActionAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageInvoiceRequestAction) String() string {
	name, _ := manageInvoiceRequestActionMap[int32(e)]
	return name
}

func (e ManageInvoiceRequestAction) ShortString() string {
	name, _ := manageInvoiceRequestActionShortMap[int32(e)]
	return name
}

func (e ManageInvoiceRequestAction) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageInvoiceRequestActionAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageInvoiceRequestAction) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageInvoiceRequestAction(t.Value)
	return nil
}

// InvoiceCreationRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type InvoiceCreationRequestExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u InvoiceCreationRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of InvoiceCreationRequestExt
func (u InvoiceCreationRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewInvoiceCreationRequestExt creates a new  InvoiceCreationRequestExt.
func NewInvoiceCreationRequestExt(v LedgerVersion, value interface{}) (result InvoiceCreationRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// InvoiceCreationRequest is an XDR Struct defines as:
//
//   struct InvoiceCreationRequest
//    {
//        AssetCode asset;
//        AccountID sender;
//        uint64 amount; // not allowed to set 0
//
//        uint64 *contractID;
//        longstring details;
//
//        uint32* allTasks;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type InvoiceCreationRequest struct {
	Asset      AssetCode                 `json:"asset,omitempty"`
	Sender     AccountId                 `json:"sender,omitempty"`
	Amount     Uint64                    `json:"amount,omitempty"`
	ContractId *Uint64                   `json:"contractID,omitempty"`
	Details    Longstring                `json:"details,omitempty"`
	AllTasks   *Uint32                   `json:"allTasks,omitempty"`
	Ext        InvoiceCreationRequestExt `json:"ext,omitempty"`
}

// ManageInvoiceRequestOpDetails is an XDR NestedUnion defines as:
//
//   union switch (ManageInvoiceRequestAction action){
//        case CREATE:
//            InvoiceCreationRequest invoiceRequest;
//        case REMOVE:
//            uint64 requestID;
//        }
//
type ManageInvoiceRequestOpDetails struct {
	Action         ManageInvoiceRequestAction `json:"action,omitempty"`
	InvoiceRequest *InvoiceCreationRequest    `json:"invoiceRequest,omitempty"`
	RequestId      *Uint64                    `json:"requestID,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageInvoiceRequestOpDetails) SwitchFieldName() string {
	return "Action"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageInvoiceRequestOpDetails
func (u ManageInvoiceRequestOpDetails) ArmForSwitch(sw int32) (string, bool) {
	switch ManageInvoiceRequestAction(sw) {
	case ManageInvoiceRequestActionCreate:
		return "InvoiceRequest", true
	case ManageInvoiceRequestActionRemove:
		return "RequestId", true
	}
	return "-", false
}

// NewManageInvoiceRequestOpDetails creates a new  ManageInvoiceRequestOpDetails.
func NewManageInvoiceRequestOpDetails(action ManageInvoiceRequestAction, value interface{}) (result ManageInvoiceRequestOpDetails, err error) {
	result.Action = action
	switch ManageInvoiceRequestAction(action) {
	case ManageInvoiceRequestActionCreate:
		tv, ok := value.(InvoiceCreationRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be InvoiceCreationRequest")
			return
		}
		result.InvoiceRequest = &tv
	case ManageInvoiceRequestActionRemove:
		tv, ok := value.(Uint64)
		if !ok {
			err = fmt.Errorf("invalid value, must be Uint64")
			return
		}
		result.RequestId = &tv
	}
	return
}

// MustInvoiceRequest retrieves the InvoiceRequest value from the union,
// panicing if the value is not set.
func (u ManageInvoiceRequestOpDetails) MustInvoiceRequest() InvoiceCreationRequest {
	val, ok := u.GetInvoiceRequest()

	if !ok {
		panic("arm InvoiceRequest is not set")
	}

	return val
}

// GetInvoiceRequest retrieves the InvoiceRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageInvoiceRequestOpDetails) GetInvoiceRequest() (result InvoiceCreationRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "InvoiceRequest" {
		result = *u.InvoiceRequest
		ok = true
	}

	return
}

// MustRequestId retrieves the RequestId value from the union,
// panicing if the value is not set.
func (u ManageInvoiceRequestOpDetails) MustRequestId() Uint64 {
	val, ok := u.GetRequestId()

	if !ok {
		panic("arm RequestId is not set")
	}

	return val
}

// GetRequestId retrieves the RequestId value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageInvoiceRequestOpDetails) GetRequestId() (result Uint64, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "RequestId" {
		result = *u.RequestId
		ok = true
	}

	return
}

// ManageInvoiceRequestOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ManageInvoiceRequestOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageInvoiceRequestOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageInvoiceRequestOpExt
func (u ManageInvoiceRequestOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageInvoiceRequestOpExt creates a new  ManageInvoiceRequestOpExt.
func NewManageInvoiceRequestOpExt(v LedgerVersion, value interface{}) (result ManageInvoiceRequestOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageInvoiceRequestOp is an XDR Struct defines as:
//
//   struct ManageInvoiceRequestOp
//    {
//        union switch (ManageInvoiceRequestAction action){
//        case CREATE:
//            InvoiceCreationRequest invoiceRequest;
//        case REMOVE:
//            uint64 requestID;
//        } details;
//
//    	// reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ManageInvoiceRequestOp struct {
	Details ManageInvoiceRequestOpDetails `json:"details,omitempty"`
	Ext     ManageInvoiceRequestOpExt     `json:"ext,omitempty"`
}

// ManageInvoiceRequestResultCode is an XDR Enum defines as:
//
//   enum ManageInvoiceRequestResultCode
//    {
//        // codes considered as "success" for the operation
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        MALFORMED = -1,
//        BALANCE_NOT_FOUND = -2, // sender balance not found
//        NOT_FOUND = -3, // not found invoice request, when try to remove
//        TOO_MANY_INVOICES = -4,
//        DETAILS_TOO_LONG = -5,
//        NOT_ALLOWED_TO_REMOVE = -6, // only invoice creator can remove invoice
//        CONTRACT_NOT_FOUND = -7,
//        ONLY_CONTRACTOR_CAN_ATTACH_INVOICE_TO_CONTRACT = -8,
//        SENDER_ACCOUNT_MISMATCHED = -9,
//        INVOICE_IS_APPROVED = -10, // not allowed to remove approved invoice
//        INVOICE_TASKS_NOT_FOUND = -11
//    };
//
type ManageInvoiceRequestResultCode int32

const (
	ManageInvoiceRequestResultCodeSuccess                                  ManageInvoiceRequestResultCode = 0
	ManageInvoiceRequestResultCodeMalformed                                ManageInvoiceRequestResultCode = -1
	ManageInvoiceRequestResultCodeBalanceNotFound                          ManageInvoiceRequestResultCode = -2
	ManageInvoiceRequestResultCodeNotFound                                 ManageInvoiceRequestResultCode = -3
	ManageInvoiceRequestResultCodeTooManyInvoices                          ManageInvoiceRequestResultCode = -4
	ManageInvoiceRequestResultCodeDetailsTooLong                           ManageInvoiceRequestResultCode = -5
	ManageInvoiceRequestResultCodeNotAllowedToRemove                       ManageInvoiceRequestResultCode = -6
	ManageInvoiceRequestResultCodeContractNotFound                         ManageInvoiceRequestResultCode = -7
	ManageInvoiceRequestResultCodeOnlyContractorCanAttachInvoiceToContract ManageInvoiceRequestResultCode = -8
	ManageInvoiceRequestResultCodeSenderAccountMismatched                  ManageInvoiceRequestResultCode = -9
	ManageInvoiceRequestResultCodeInvoiceIsApproved                        ManageInvoiceRequestResultCode = -10
	ManageInvoiceRequestResultCodeInvoiceTasksNotFound                     ManageInvoiceRequestResultCode = -11
)

var ManageInvoiceRequestResultCodeAll = []ManageInvoiceRequestResultCode{
	ManageInvoiceRequestResultCodeSuccess,
	ManageInvoiceRequestResultCodeMalformed,
	ManageInvoiceRequestResultCodeBalanceNotFound,
	ManageInvoiceRequestResultCodeNotFound,
	ManageInvoiceRequestResultCodeTooManyInvoices,
	ManageInvoiceRequestResultCodeDetailsTooLong,
	ManageInvoiceRequestResultCodeNotAllowedToRemove,
	ManageInvoiceRequestResultCodeContractNotFound,
	ManageInvoiceRequestResultCodeOnlyContractorCanAttachInvoiceToContract,
	ManageInvoiceRequestResultCodeSenderAccountMismatched,
	ManageInvoiceRequestResultCodeInvoiceIsApproved,
	ManageInvoiceRequestResultCodeInvoiceTasksNotFound,
}

var manageInvoiceRequestResultCodeMap = map[int32]string{
	0:   "ManageInvoiceRequestResultCodeSuccess",
	-1:  "ManageInvoiceRequestResultCodeMalformed",
	-2:  "ManageInvoiceRequestResultCodeBalanceNotFound",
	-3:  "ManageInvoiceRequestResultCodeNotFound",
	-4:  "ManageInvoiceRequestResultCodeTooManyInvoices",
	-5:  "ManageInvoiceRequestResultCodeDetailsTooLong",
	-6:  "ManageInvoiceRequestResultCodeNotAllowedToRemove",
	-7:  "ManageInvoiceRequestResultCodeContractNotFound",
	-8:  "ManageInvoiceRequestResultCodeOnlyContractorCanAttachInvoiceToContract",
	-9:  "ManageInvoiceRequestResultCodeSenderAccountMismatched",
	-10: "ManageInvoiceRequestResultCodeInvoiceIsApproved",
	-11: "ManageInvoiceRequestResultCodeInvoiceTasksNotFound",
}

var manageInvoiceRequestResultCodeShortMap = map[int32]string{
	0:   "success",
	-1:  "malformed",
	-2:  "balance_not_found",
	-3:  "not_found",
	-4:  "too_many_invoices",
	-5:  "details_too_long",
	-6:  "not_allowed_to_remove",
	-7:  "contract_not_found",
	-8:  "only_contractor_can_attach_invoice_to_contract",
	-9:  "sender_account_mismatched",
	-10: "invoice_is_approved",
	-11: "invoice_tasks_not_found",
}

var manageInvoiceRequestResultCodeRevMap = map[string]int32{
	"ManageInvoiceRequestResultCodeSuccess":                                  0,
	"ManageInvoiceRequestResultCodeMalformed":                                -1,
	"ManageInvoiceRequestResultCodeBalanceNotFound":                          -2,
	"ManageInvoiceRequestResultCodeNotFound":                                 -3,
	"ManageInvoiceRequestResultCodeTooManyInvoices":                          -4,
	"ManageInvoiceRequestResultCodeDetailsTooLong":                           -5,
	"ManageInvoiceRequestResultCodeNotAllowedToRemove":                       -6,
	"ManageInvoiceRequestResultCodeContractNotFound":                         -7,
	"ManageInvoiceRequestResultCodeOnlyContractorCanAttachInvoiceToContract": -8,
	"ManageInvoiceRequestResultCodeSenderAccountMismatched":                  -9,
	"ManageInvoiceRequestResultCodeInvoiceIsApproved":                        -10,
	"ManageInvoiceRequestResultCodeInvoiceTasksNotFound":                     -11,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageInvoiceRequestResultCode
func (e ManageInvoiceRequestResultCode) ValidEnum(v int32) bool {
	_, ok := manageInvoiceRequestResultCodeMap[v]
	return ok
}
func (e ManageInvoiceRequestResultCode) isFlag() bool {
	for i := len(ManageInvoiceRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := ManageInvoiceRequestResultCode(2) << uint64(len(ManageInvoiceRequestResultCodeAll)-1) >> uint64(len(ManageInvoiceRequestResultCodeAll)-i)
		if expected != ManageInvoiceRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageInvoiceRequestResultCode) String() string {
	name, _ := manageInvoiceRequestResultCodeMap[int32(e)]
	return name
}

func (e ManageInvoiceRequestResultCode) ShortString() string {
	name, _ := manageInvoiceRequestResultCodeShortMap[int32(e)]
	return name
}

func (e ManageInvoiceRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageInvoiceRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageInvoiceRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageInvoiceRequestResultCode(t.Value)
	return nil
}

// CreateInvoiceRequestResponseExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateInvoiceRequestResponseExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateInvoiceRequestResponseExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateInvoiceRequestResponseExt
func (u CreateInvoiceRequestResponseExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateInvoiceRequestResponseExt creates a new  CreateInvoiceRequestResponseExt.
func NewCreateInvoiceRequestResponseExt(v LedgerVersion, value interface{}) (result CreateInvoiceRequestResponseExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateInvoiceRequestResponse is an XDR Struct defines as:
//
//   struct CreateInvoiceRequestResponse
//    {
//    	BalanceID receiverBalance;
//    	BalanceID senderBalance;
//
//    	uint64 requestID;
//
//    	union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CreateInvoiceRequestResponse struct {
	ReceiverBalance BalanceId                       `json:"receiverBalance,omitempty"`
	SenderBalance   BalanceId                       `json:"senderBalance,omitempty"`
	RequestId       Uint64                          `json:"requestID,omitempty"`
	Ext             CreateInvoiceRequestResponseExt `json:"ext,omitempty"`
}

// ManageInvoiceRequestResultSuccessDetails is an XDR NestedUnion defines as:
//
//   union switch (ManageInvoiceRequestAction action)
//            {
//            case CREATE:
//                CreateInvoiceRequestResponse response;
//            case REMOVE:
//                void;
//            }
//
type ManageInvoiceRequestResultSuccessDetails struct {
	Action   ManageInvoiceRequestAction    `json:"action,omitempty"`
	Response *CreateInvoiceRequestResponse `json:"response,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageInvoiceRequestResultSuccessDetails) SwitchFieldName() string {
	return "Action"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageInvoiceRequestResultSuccessDetails
func (u ManageInvoiceRequestResultSuccessDetails) ArmForSwitch(sw int32) (string, bool) {
	switch ManageInvoiceRequestAction(sw) {
	case ManageInvoiceRequestActionCreate:
		return "Response", true
	case ManageInvoiceRequestActionRemove:
		return "", true
	}
	return "-", false
}

// NewManageInvoiceRequestResultSuccessDetails creates a new  ManageInvoiceRequestResultSuccessDetails.
func NewManageInvoiceRequestResultSuccessDetails(action ManageInvoiceRequestAction, value interface{}) (result ManageInvoiceRequestResultSuccessDetails, err error) {
	result.Action = action
	switch ManageInvoiceRequestAction(action) {
	case ManageInvoiceRequestActionCreate:
		tv, ok := value.(CreateInvoiceRequestResponse)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateInvoiceRequestResponse")
			return
		}
		result.Response = &tv
	case ManageInvoiceRequestActionRemove:
		// void
	}
	return
}

// MustResponse retrieves the Response value from the union,
// panicing if the value is not set.
func (u ManageInvoiceRequestResultSuccessDetails) MustResponse() CreateInvoiceRequestResponse {
	val, ok := u.GetResponse()

	if !ok {
		panic("arm Response is not set")
	}

	return val
}

// GetResponse retrieves the Response value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageInvoiceRequestResultSuccessDetails) GetResponse() (result CreateInvoiceRequestResponse, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "Response" {
		result = *u.Response
		ok = true
	}

	return
}

// ManageInvoiceRequestResultSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type ManageInvoiceRequestResultSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageInvoiceRequestResultSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageInvoiceRequestResultSuccessExt
func (u ManageInvoiceRequestResultSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageInvoiceRequestResultSuccessExt creates a new  ManageInvoiceRequestResultSuccessExt.
func NewManageInvoiceRequestResultSuccessExt(v LedgerVersion, value interface{}) (result ManageInvoiceRequestResultSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageInvoiceRequestResultSuccess is an XDR NestedStruct defines as:
//
//   struct
//        {
//            bool fulfilled;
//            union switch (ManageInvoiceRequestAction action)
//            {
//            case CREATE:
//                CreateInvoiceRequestResponse response;
//            case REMOVE:
//                void;
//            } details;
//
//            // reserved for future use
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            } ext;
//        }
//
type ManageInvoiceRequestResultSuccess struct {
	Fulfilled bool                                     `json:"fulfilled,omitempty"`
	Details   ManageInvoiceRequestResultSuccessDetails `json:"details,omitempty"`
	Ext       ManageInvoiceRequestResultSuccessExt     `json:"ext,omitempty"`
}

// ManageInvoiceRequestResult is an XDR Union defines as:
//
//   union ManageInvoiceRequestResult switch (ManageInvoiceRequestResultCode code)
//    {
//    case SUCCESS:
//        struct
//        {
//            bool fulfilled;
//            union switch (ManageInvoiceRequestAction action)
//            {
//            case CREATE:
//                CreateInvoiceRequestResponse response;
//            case REMOVE:
//                void;
//            } details;
//
//            // reserved for future use
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            } ext;
//        } success;
//    default:
//        void;
//    };
//
type ManageInvoiceRequestResult struct {
	Code    ManageInvoiceRequestResultCode     `json:"code,omitempty"`
	Success *ManageInvoiceRequestResultSuccess `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageInvoiceRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageInvoiceRequestResult
func (u ManageInvoiceRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch ManageInvoiceRequestResultCode(sw) {
	case ManageInvoiceRequestResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewManageInvoiceRequestResult creates a new  ManageInvoiceRequestResult.
func NewManageInvoiceRequestResult(code ManageInvoiceRequestResultCode, value interface{}) (result ManageInvoiceRequestResult, err error) {
	result.Code = code
	switch ManageInvoiceRequestResultCode(code) {
	case ManageInvoiceRequestResultCodeSuccess:
		tv, ok := value.(ManageInvoiceRequestResultSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageInvoiceRequestResultSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u ManageInvoiceRequestResult) MustSuccess() ManageInvoiceRequestResultSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageInvoiceRequestResult) GetSuccess() (result ManageInvoiceRequestResultSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// ManageKvAction is an XDR Enum defines as:
//
//   //: Actions that can be performed on `KeyValueEntry`
//        enum ManageKVAction
//        {
//            PUT = 1,
//            REMOVE = 2
//        };
//
type ManageKvAction int32

const (
	ManageKvActionPut    ManageKvAction = 1
	ManageKvActionRemove ManageKvAction = 2
)

var ManageKvActionAll = []ManageKvAction{
	ManageKvActionPut,
	ManageKvActionRemove,
}

var manageKvActionMap = map[int32]string{
	1: "ManageKvActionPut",
	2: "ManageKvActionRemove",
}

var manageKvActionShortMap = map[int32]string{
	1: "put",
	2: "remove",
}

var manageKvActionRevMap = map[string]int32{
	"ManageKvActionPut":    1,
	"ManageKvActionRemove": 2,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageKvAction
func (e ManageKvAction) ValidEnum(v int32) bool {
	_, ok := manageKvActionMap[v]
	return ok
}
func (e ManageKvAction) isFlag() bool {
	for i := len(ManageKvActionAll) - 1; i >= 0; i-- {
		expected := ManageKvAction(2) << uint64(len(ManageKvActionAll)-1) >> uint64(len(ManageKvActionAll)-i)
		if expected != ManageKvActionAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageKvAction) String() string {
	name, _ := manageKvActionMap[int32(e)]
	return name
}

func (e ManageKvAction) ShortString() string {
	name, _ := manageKvActionShortMap[int32(e)]
	return name
}

func (e ManageKvAction) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageKvActionAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageKvAction) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageKvAction(t.Value)
	return nil
}

// ManageKeyValueOpAction is an XDR NestedUnion defines as:
//
//   union switch(ManageKVAction action)
//            {
//                case PUT:
//                     KeyValueEntryValue value;
//                case REMOVE:
//                    void;
//            }
//
type ManageKeyValueOpAction struct {
	Action ManageKvAction      `json:"action,omitempty"`
	Value  *KeyValueEntryValue `json:"value,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageKeyValueOpAction) SwitchFieldName() string {
	return "Action"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageKeyValueOpAction
func (u ManageKeyValueOpAction) ArmForSwitch(sw int32) (string, bool) {
	switch ManageKvAction(sw) {
	case ManageKvActionPut:
		return "Value", true
	case ManageKvActionRemove:
		return "", true
	}
	return "-", false
}

// NewManageKeyValueOpAction creates a new  ManageKeyValueOpAction.
func NewManageKeyValueOpAction(action ManageKvAction, value interface{}) (result ManageKeyValueOpAction, err error) {
	result.Action = action
	switch ManageKvAction(action) {
	case ManageKvActionPut:
		tv, ok := value.(KeyValueEntryValue)
		if !ok {
			err = fmt.Errorf("invalid value, must be KeyValueEntryValue")
			return
		}
		result.Value = &tv
	case ManageKvActionRemove:
		// void
	}
	return
}

// MustValue retrieves the Value value from the union,
// panicing if the value is not set.
func (u ManageKeyValueOpAction) MustValue() KeyValueEntryValue {
	val, ok := u.GetValue()

	if !ok {
		panic("arm Value is not set")
	}

	return val
}

// GetValue retrieves the Value value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageKeyValueOpAction) GetValue() (result KeyValueEntryValue, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "Value" {
		result = *u.Value
		ok = true
	}

	return
}

// ManageKeyValueOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//                case EMPTY_VERSION:
//                    void;
//            }
//
type ManageKeyValueOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageKeyValueOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageKeyValueOpExt
func (u ManageKeyValueOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageKeyValueOpExt creates a new  ManageKeyValueOpExt.
func NewManageKeyValueOpExt(v LedgerVersion, value interface{}) (result ManageKeyValueOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageKeyValueOp is an XDR Struct defines as:
//
//   //: `ManageKeyValueOp` is used to create the manage key-value operation which, if applied successfully, will update the key-value entry present in the system
//        struct ManageKeyValueOp
//        {
//            //: `key` is the key for KeyValueEntry
//            longstring key;
//            //: `action` defines an action applied to the KeyValue based on given ManageKVAction
//            //: * Action `PUT` stores new value for a particular key
//            //: * Action `REMOVE` removes the value by a particular key
//            union switch(ManageKVAction action)
//            {
//                case PUT:
//                     KeyValueEntryValue value;
//                case REMOVE:
//                    void;
//            }
//            action;
//
//            //: reserved for future use
//            union switch (LedgerVersion v)
//            {
//                case EMPTY_VERSION:
//                    void;
//            }
//            ext;
//        };
//
type ManageKeyValueOp struct {
	Key    Longstring             `json:"key,omitempty"`
	Action ManageKeyValueOpAction `json:"action,omitempty"`
	Ext    ManageKeyValueOpExt    `json:"ext,omitempty"`
}

// ManageKeyValueSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//                case EMPTY_VERSION:
//                    void;
//            }
//
type ManageKeyValueSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageKeyValueSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageKeyValueSuccessExt
func (u ManageKeyValueSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageKeyValueSuccessExt creates a new  ManageKeyValueSuccessExt.
func NewManageKeyValueSuccessExt(v LedgerVersion, value interface{}) (result ManageKeyValueSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageKeyValueSuccess is an XDR Struct defines as:
//
//   //: `ManageKeyValueSuccess` represents details returned after the successful application of `ManageKeyValueOp`
//        struct ManageKeyValueSuccess
//        {
//            //: reserved for future use
//            union switch (LedgerVersion v)
//            {
//                case EMPTY_VERSION:
//                    void;
//            }
//            ext;
//        };
//
type ManageKeyValueSuccess struct {
	Ext ManageKeyValueSuccessExt `json:"ext,omitempty"`
}

// ManageKeyValueResultCode is an XDR Enum defines as:
//
//   //: Result codes for `ManageKeyValueOp`
//        enum ManageKeyValueResultCode
//        {
//            //: `ManageKeyValueOp` is applied successfully
//            SUCCESS = 0,
//            //: There is no key value with such key
//            NOT_FOUND = -1,
//            //: Value type of the key-value entry is forbidden for the provided key
//            INVALID_TYPE = -2,
//            //: zero value is forbidden for the provided key
//            ZERO_VALUE_NOT_ALLOWED = -3
//        };
//
type ManageKeyValueResultCode int32

const (
	ManageKeyValueResultCodeSuccess             ManageKeyValueResultCode = 0
	ManageKeyValueResultCodeNotFound            ManageKeyValueResultCode = -1
	ManageKeyValueResultCodeInvalidType         ManageKeyValueResultCode = -2
	ManageKeyValueResultCodeZeroValueNotAllowed ManageKeyValueResultCode = -3
)

var ManageKeyValueResultCodeAll = []ManageKeyValueResultCode{
	ManageKeyValueResultCodeSuccess,
	ManageKeyValueResultCodeNotFound,
	ManageKeyValueResultCodeInvalidType,
	ManageKeyValueResultCodeZeroValueNotAllowed,
}

var manageKeyValueResultCodeMap = map[int32]string{
	0:  "ManageKeyValueResultCodeSuccess",
	-1: "ManageKeyValueResultCodeNotFound",
	-2: "ManageKeyValueResultCodeInvalidType",
	-3: "ManageKeyValueResultCodeZeroValueNotAllowed",
}

var manageKeyValueResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "not_found",
	-2: "invalid_type",
	-3: "zero_value_not_allowed",
}

var manageKeyValueResultCodeRevMap = map[string]int32{
	"ManageKeyValueResultCodeSuccess":             0,
	"ManageKeyValueResultCodeNotFound":            -1,
	"ManageKeyValueResultCodeInvalidType":         -2,
	"ManageKeyValueResultCodeZeroValueNotAllowed": -3,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageKeyValueResultCode
func (e ManageKeyValueResultCode) ValidEnum(v int32) bool {
	_, ok := manageKeyValueResultCodeMap[v]
	return ok
}
func (e ManageKeyValueResultCode) isFlag() bool {
	for i := len(ManageKeyValueResultCodeAll) - 1; i >= 0; i-- {
		expected := ManageKeyValueResultCode(2) << uint64(len(ManageKeyValueResultCodeAll)-1) >> uint64(len(ManageKeyValueResultCodeAll)-i)
		if expected != ManageKeyValueResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageKeyValueResultCode) String() string {
	name, _ := manageKeyValueResultCodeMap[int32(e)]
	return name
}

func (e ManageKeyValueResultCode) ShortString() string {
	name, _ := manageKeyValueResultCodeShortMap[int32(e)]
	return name
}

func (e ManageKeyValueResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageKeyValueResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageKeyValueResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageKeyValueResultCode(t.Value)
	return nil
}

// ManageKeyValueResult is an XDR Union defines as:
//
//   //: `ManageKeyValueResult` represents the result of ManageKeyValueOp
//        union ManageKeyValueResult switch (ManageKeyValueResultCode code)
//        {
//            case SUCCESS:
//                ManageKeyValueSuccess success;
//            default:
//                void;
//        };
//
type ManageKeyValueResult struct {
	Code    ManageKeyValueResultCode `json:"code,omitempty"`
	Success *ManageKeyValueSuccess   `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageKeyValueResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageKeyValueResult
func (u ManageKeyValueResult) ArmForSwitch(sw int32) (string, bool) {
	switch ManageKeyValueResultCode(sw) {
	case ManageKeyValueResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewManageKeyValueResult creates a new  ManageKeyValueResult.
func NewManageKeyValueResult(code ManageKeyValueResultCode, value interface{}) (result ManageKeyValueResult, err error) {
	result.Code = code
	switch ManageKeyValueResultCode(code) {
	case ManageKeyValueResultCodeSuccess:
		tv, ok := value.(ManageKeyValueSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageKeyValueSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u ManageKeyValueResult) MustSuccess() ManageKeyValueSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageKeyValueResult) GetSuccess() (result ManageKeyValueSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// ManageLimitsAction is an XDR Enum defines as:
//
//   //: `ManageLimitsAction` defines which action can be performed on the Limits entry
//    enum ManageLimitsAction
//    {
//        CREATE = 0,
//        REMOVE = 1
//    };
//
type ManageLimitsAction int32

const (
	ManageLimitsActionCreate ManageLimitsAction = 0
	ManageLimitsActionRemove ManageLimitsAction = 1
)

var ManageLimitsActionAll = []ManageLimitsAction{
	ManageLimitsActionCreate,
	ManageLimitsActionRemove,
}

var manageLimitsActionMap = map[int32]string{
	0: "ManageLimitsActionCreate",
	1: "ManageLimitsActionRemove",
}

var manageLimitsActionShortMap = map[int32]string{
	0: "create",
	1: "remove",
}

var manageLimitsActionRevMap = map[string]int32{
	"ManageLimitsActionCreate": 0,
	"ManageLimitsActionRemove": 1,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageLimitsAction
func (e ManageLimitsAction) ValidEnum(v int32) bool {
	_, ok := manageLimitsActionMap[v]
	return ok
}
func (e ManageLimitsAction) isFlag() bool {
	for i := len(ManageLimitsActionAll) - 1; i >= 0; i-- {
		expected := ManageLimitsAction(2) << uint64(len(ManageLimitsActionAll)-1) >> uint64(len(ManageLimitsActionAll)-i)
		if expected != ManageLimitsActionAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageLimitsAction) String() string {
	name, _ := manageLimitsActionMap[int32(e)]
	return name
}

func (e ManageLimitsAction) ShortString() string {
	name, _ := manageLimitsActionShortMap[int32(e)]
	return name
}

func (e ManageLimitsAction) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageLimitsActionAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageLimitsAction) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageLimitsAction(t.Value)
	return nil
}

// LimitsCreateDetailsExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type LimitsCreateDetailsExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LimitsCreateDetailsExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LimitsCreateDetailsExt
func (u LimitsCreateDetailsExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLimitsCreateDetailsExt creates a new  LimitsCreateDetailsExt.
func NewLimitsCreateDetailsExt(v LedgerVersion, value interface{}) (result LimitsCreateDetailsExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LimitsCreateDetails is an XDR Struct defines as:
//
//   //: `LimitsCreateDetails` is used in the system configuration to set limits (daily, weekly, montly, annual)
//    //: for different assets, operations (according to StatsOpType), particular account roles, particular accounts,
//    //: or globally (only if both parameters particular account role and paticular account are not specified)
//    struct LimitsCreateDetails
//    {
//        //: (optional) ID of an account role that will be imposed with limits
//        uint64*     accountRole;
//        //: (optional) ID of an account that will be imposed with limits
//        AccountID*  accountID;
//        //: Operation type to which limits will be applied. See `enum StatsOpType`
//        StatsOpType statsOpType;
//        //: `AssetCode` defines an asset to which limits will be applied
//        AssetCode   assetCode;
//        //: `isConvertNeeded` indicates whether the asset conversion is needed for the limits entry or not needed.
//        //: If this field is `true` - limits are applied to all balances of the account (to every asset account owns).
//        //: Otherwise limits from particular limits entry are applied only to the balances with `AssetCode` provided by entry.
//        bool        isConvertNeeded;
//
//        //: daily out limit
//        uint64 dailyOut;
//        //: weekly out limit
//        uint64 weeklyOut;
//        //: monthly out limit
//        uint64 monthlyOut;
//        //: annual out limit
//        uint64 annualOut;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type LimitsCreateDetails struct {
	AccountRole     *Uint64                `json:"accountRole,omitempty"`
	AccountId       *AccountId             `json:"accountID,omitempty"`
	StatsOpType     StatsOpType            `json:"statsOpType,omitempty"`
	AssetCode       AssetCode              `json:"assetCode,omitempty"`
	IsConvertNeeded bool                   `json:"isConvertNeeded,omitempty"`
	DailyOut        Uint64                 `json:"dailyOut,omitempty"`
	WeeklyOut       Uint64                 `json:"weeklyOut,omitempty"`
	MonthlyOut      Uint64                 `json:"monthlyOut,omitempty"`
	AnnualOut       Uint64                 `json:"annualOut,omitempty"`
	Ext             LimitsCreateDetailsExt `json:"ext,omitempty"`
}

// ManageLimitsOpDetails is an XDR NestedUnion defines as:
//
//   union switch (ManageLimitsAction action)
//        {
//        case CREATE:
//            LimitsCreateDetails limitsCreateDetails;
//        case REMOVE:
//            uint64 id;
//        }
//
type ManageLimitsOpDetails struct {
	Action              ManageLimitsAction   `json:"action,omitempty"`
	LimitsCreateDetails *LimitsCreateDetails `json:"limitsCreateDetails,omitempty"`
	Id                  *Uint64              `json:"id,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageLimitsOpDetails) SwitchFieldName() string {
	return "Action"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageLimitsOpDetails
func (u ManageLimitsOpDetails) ArmForSwitch(sw int32) (string, bool) {
	switch ManageLimitsAction(sw) {
	case ManageLimitsActionCreate:
		return "LimitsCreateDetails", true
	case ManageLimitsActionRemove:
		return "Id", true
	}
	return "-", false
}

// NewManageLimitsOpDetails creates a new  ManageLimitsOpDetails.
func NewManageLimitsOpDetails(action ManageLimitsAction, value interface{}) (result ManageLimitsOpDetails, err error) {
	result.Action = action
	switch ManageLimitsAction(action) {
	case ManageLimitsActionCreate:
		tv, ok := value.(LimitsCreateDetails)
		if !ok {
			err = fmt.Errorf("invalid value, must be LimitsCreateDetails")
			return
		}
		result.LimitsCreateDetails = &tv
	case ManageLimitsActionRemove:
		tv, ok := value.(Uint64)
		if !ok {
			err = fmt.Errorf("invalid value, must be Uint64")
			return
		}
		result.Id = &tv
	}
	return
}

// MustLimitsCreateDetails retrieves the LimitsCreateDetails value from the union,
// panicing if the value is not set.
func (u ManageLimitsOpDetails) MustLimitsCreateDetails() LimitsCreateDetails {
	val, ok := u.GetLimitsCreateDetails()

	if !ok {
		panic("arm LimitsCreateDetails is not set")
	}

	return val
}

// GetLimitsCreateDetails retrieves the LimitsCreateDetails value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageLimitsOpDetails) GetLimitsCreateDetails() (result LimitsCreateDetails, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "LimitsCreateDetails" {
		result = *u.LimitsCreateDetails
		ok = true
	}

	return
}

// MustId retrieves the Id value from the union,
// panicing if the value is not set.
func (u ManageLimitsOpDetails) MustId() Uint64 {
	val, ok := u.GetId()

	if !ok {
		panic("arm Id is not set")
	}

	return val
}

// GetId retrieves the Id value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageLimitsOpDetails) GetId() (result Uint64, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "Id" {
		result = *u.Id
		ok = true
	}

	return
}

// ManageLimitsOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ManageLimitsOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageLimitsOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageLimitsOpExt
func (u ManageLimitsOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageLimitsOpExt creates a new  ManageLimitsOpExt.
func NewManageLimitsOpExt(v LedgerVersion, value interface{}) (result ManageLimitsOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageLimitsOp is an XDR Struct defines as:
//
//   //: `ManageLimitsOp` is used to update limits set in the system
//    struct ManageLimitsOp
//    {
//        //: `details` defines all details of an operation based on given `ManageLimitsAction`
//        union switch (ManageLimitsAction action)
//        {
//        case CREATE:
//            LimitsCreateDetails limitsCreateDetails;
//        case REMOVE:
//            uint64 id;
//        } details;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ManageLimitsOp struct {
	Details ManageLimitsOpDetails `json:"details,omitempty"`
	Ext     ManageLimitsOpExt     `json:"ext,omitempty"`
}

// ManageLimitsResultCode is an XDR Enum defines as:
//
//   //: Result codes for ManageLimits operation
//    enum ManageLimitsResultCode
//    {
//        // codes considered as "success" for the operation
//        //: `ManageLimitsOp` was successfully applied
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: There is no account with passed ID
//        ACCOUNT_NOT_FOUND = -1,
//        //: Limits entry is not found
//        NOT_FOUND = -2,
//        //: There is no role with passed ID
//        ROLE_NOT_FOUND = -3,
//        //: Limits cannot be created for account ID and account role simultaneously
//        CANNOT_CREATE_FOR_ACC_ID_AND_ACC_TYPE = -4, // FIXME ACC_ROLE ?
//        //: Limits entry is invalid (e.g. weeklyOut is less than dailyOut)
//        INVALID_LIMITS = -5,
//        //: Asset with provided asset code does not exist
//        ASSET_NOT_FOUND = -6
//    };
//
type ManageLimitsResultCode int32

const (
	ManageLimitsResultCodeSuccess                        ManageLimitsResultCode = 0
	ManageLimitsResultCodeAccountNotFound                ManageLimitsResultCode = -1
	ManageLimitsResultCodeNotFound                       ManageLimitsResultCode = -2
	ManageLimitsResultCodeRoleNotFound                   ManageLimitsResultCode = -3
	ManageLimitsResultCodeCannotCreateForAccIdAndAccType ManageLimitsResultCode = -4
	ManageLimitsResultCodeInvalidLimits                  ManageLimitsResultCode = -5
	ManageLimitsResultCodeAssetNotFound                  ManageLimitsResultCode = -6
)

var ManageLimitsResultCodeAll = []ManageLimitsResultCode{
	ManageLimitsResultCodeSuccess,
	ManageLimitsResultCodeAccountNotFound,
	ManageLimitsResultCodeNotFound,
	ManageLimitsResultCodeRoleNotFound,
	ManageLimitsResultCodeCannotCreateForAccIdAndAccType,
	ManageLimitsResultCodeInvalidLimits,
	ManageLimitsResultCodeAssetNotFound,
}

var manageLimitsResultCodeMap = map[int32]string{
	0:  "ManageLimitsResultCodeSuccess",
	-1: "ManageLimitsResultCodeAccountNotFound",
	-2: "ManageLimitsResultCodeNotFound",
	-3: "ManageLimitsResultCodeRoleNotFound",
	-4: "ManageLimitsResultCodeCannotCreateForAccIdAndAccType",
	-5: "ManageLimitsResultCodeInvalidLimits",
	-6: "ManageLimitsResultCodeAssetNotFound",
}

var manageLimitsResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "account_not_found",
	-2: "not_found",
	-3: "role_not_found",
	-4: "cannot_create_for_acc_id_and_acc_type",
	-5: "invalid_limits",
	-6: "asset_not_found",
}

var manageLimitsResultCodeRevMap = map[string]int32{
	"ManageLimitsResultCodeSuccess":                        0,
	"ManageLimitsResultCodeAccountNotFound":                -1,
	"ManageLimitsResultCodeNotFound":                       -2,
	"ManageLimitsResultCodeRoleNotFound":                   -3,
	"ManageLimitsResultCodeCannotCreateForAccIdAndAccType": -4,
	"ManageLimitsResultCodeInvalidLimits":                  -5,
	"ManageLimitsResultCodeAssetNotFound":                  -6,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageLimitsResultCode
func (e ManageLimitsResultCode) ValidEnum(v int32) bool {
	_, ok := manageLimitsResultCodeMap[v]
	return ok
}
func (e ManageLimitsResultCode) isFlag() bool {
	for i := len(ManageLimitsResultCodeAll) - 1; i >= 0; i-- {
		expected := ManageLimitsResultCode(2) << uint64(len(ManageLimitsResultCodeAll)-1) >> uint64(len(ManageLimitsResultCodeAll)-i)
		if expected != ManageLimitsResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageLimitsResultCode) String() string {
	name, _ := manageLimitsResultCodeMap[int32(e)]
	return name
}

func (e ManageLimitsResultCode) ShortString() string {
	name, _ := manageLimitsResultCodeShortMap[int32(e)]
	return name
}

func (e ManageLimitsResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageLimitsResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageLimitsResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageLimitsResultCode(t.Value)
	return nil
}

// ManageLimitsResultSuccessDetails is an XDR NestedUnion defines as:
//
//   union switch (ManageLimitsAction action)
//            {
//            case CREATE:
//                //: ID of the created limits entry
//                uint64 id;
//            case REMOVE:
//                void;
//            }
//
type ManageLimitsResultSuccessDetails struct {
	Action ManageLimitsAction `json:"action,omitempty"`
	Id     *Uint64            `json:"id,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageLimitsResultSuccessDetails) SwitchFieldName() string {
	return "Action"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageLimitsResultSuccessDetails
func (u ManageLimitsResultSuccessDetails) ArmForSwitch(sw int32) (string, bool) {
	switch ManageLimitsAction(sw) {
	case ManageLimitsActionCreate:
		return "Id", true
	case ManageLimitsActionRemove:
		return "", true
	}
	return "-", false
}

// NewManageLimitsResultSuccessDetails creates a new  ManageLimitsResultSuccessDetails.
func NewManageLimitsResultSuccessDetails(action ManageLimitsAction, value interface{}) (result ManageLimitsResultSuccessDetails, err error) {
	result.Action = action
	switch ManageLimitsAction(action) {
	case ManageLimitsActionCreate:
		tv, ok := value.(Uint64)
		if !ok {
			err = fmt.Errorf("invalid value, must be Uint64")
			return
		}
		result.Id = &tv
	case ManageLimitsActionRemove:
		// void
	}
	return
}

// MustId retrieves the Id value from the union,
// panicing if the value is not set.
func (u ManageLimitsResultSuccessDetails) MustId() Uint64 {
	val, ok := u.GetId()

	if !ok {
		panic("arm Id is not set")
	}

	return val
}

// GetId retrieves the Id value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageLimitsResultSuccessDetails) GetId() (result Uint64, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "Id" {
		result = *u.Id
		ok = true
	}

	return
}

// ManageLimitsResultSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type ManageLimitsResultSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageLimitsResultSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageLimitsResultSuccessExt
func (u ManageLimitsResultSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageLimitsResultSuccessExt creates a new  ManageLimitsResultSuccessExt.
func NewManageLimitsResultSuccessExt(v LedgerVersion, value interface{}) (result ManageLimitsResultSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageLimitsResultSuccess is an XDR NestedStruct defines as:
//
//   struct {
//            //: `details` represents an additional information of the `ManageLimitsOp` application result
//            union switch (ManageLimitsAction action)
//            {
//            case CREATE:
//                //: ID of the created limits entry
//                uint64 id;
//            case REMOVE:
//                void;
//            } details;
//
//            //: reserved for future use
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//    }
//
type ManageLimitsResultSuccess struct {
	Details ManageLimitsResultSuccessDetails `json:"details,omitempty"`
	Ext     ManageLimitsResultSuccessExt     `json:"ext,omitempty"`
}

// ManageLimitsResult is an XDR Union defines as:
//
//   //: `ManageLimitsResult` defines the result of ManageLimitsOp application based on given `ManageLimitsResultCode`
//    union ManageLimitsResult switch (ManageLimitsResultCode code)
//    {
//    case SUCCESS:
//        struct {
//            //: `details` represents an additional information of the `ManageLimitsOp` application result
//            union switch (ManageLimitsAction action)
//            {
//            case CREATE:
//                //: ID of the created limits entry
//                uint64 id;
//            case REMOVE:
//                void;
//            } details;
//
//            //: reserved for future use
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//    } success;
//    default:
//        void;
//    };
//
type ManageLimitsResult struct {
	Code    ManageLimitsResultCode     `json:"code,omitempty"`
	Success *ManageLimitsResultSuccess `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageLimitsResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageLimitsResult
func (u ManageLimitsResult) ArmForSwitch(sw int32) (string, bool) {
	switch ManageLimitsResultCode(sw) {
	case ManageLimitsResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewManageLimitsResult creates a new  ManageLimitsResult.
func NewManageLimitsResult(code ManageLimitsResultCode, value interface{}) (result ManageLimitsResult, err error) {
	result.Code = code
	switch ManageLimitsResultCode(code) {
	case ManageLimitsResultCodeSuccess:
		tv, ok := value.(ManageLimitsResultSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageLimitsResultSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u ManageLimitsResult) MustSuccess() ManageLimitsResultSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageLimitsResult) GetSuccess() (result ManageLimitsResultSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// ManageOfferOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//                void;
//        }
//
type ManageOfferOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageOfferOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageOfferOpExt
func (u ManageOfferOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageOfferOpExt creates a new  ManageOfferOpExt.
func NewManageOfferOpExt(v LedgerVersion, value interface{}) (result ManageOfferOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageOfferOp is an XDR Struct defines as:
//
//   //: ManageOfferOp is used to create or delete offer
//    struct ManageOfferOp
//    {
//        //: Balance for base asset of an offer creator
//        BalanceID baseBalance;
//
//        //: Balance for quote asset of an offer creator
//        BalanceID quoteBalance;
//
//        //: Direction of an offer (to buy or to sell)
//        bool isBuy;
//
//        //: Amount in base asset to buy or sell (to delete an offer, set 0)
//        int64 amount;
//
//        //: Price of base asset in the ratio of quote asset
//        int64 price;
//
//        //: Fee in quote asset to pay
//        int64 fee;
//
//        //: ID of an offer to be managed. 0 to create a new offer, otherwise to edit an existing offer
//        uint64 offerID;
//
//        //: ID of an orderBook to put an offer in and to find a match in
//        uint64 orderBookID;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//                void;
//        }
//        ext;
//    };
//
type ManageOfferOp struct {
	BaseBalance  BalanceId        `json:"baseBalance,omitempty"`
	QuoteBalance BalanceId        `json:"quoteBalance,omitempty"`
	IsBuy        bool             `json:"isBuy,omitempty"`
	Amount       Int64            `json:"amount,omitempty"`
	Price        Int64            `json:"price,omitempty"`
	Fee          Int64            `json:"fee,omitempty"`
	OfferId      Uint64           `json:"offerID,omitempty"`
	OrderBookId  Uint64           `json:"orderBookID,omitempty"`
	Ext          ManageOfferOpExt `json:"ext,omitempty"`
}

// ManageOfferResultCode is an XDR Enum defines as:
//
//   enum ManageOfferResultCode
//    {
//        // codes considered as "success" for the operation
//        //: ManageOfferOp was successfully applied
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: Either the quote amount is less than the fee or the new fee is less than the old one
//        MALFORMED = -1,
//        //: Asset pair does not allow creating offers with it
//        PAIR_NOT_TRADED = -2,
//        //: Source account of an operation does not owns one of the provided balances
//        BALANCE_NOT_FOUND = -3,
//        //: One of the balances does not hold the amount that it is trying to sell
//        UNDERFUNDED = -4,
//        //: Offer will cross with another offer of the same user
//        CROSS_SELF = -5,
//        //: Overflow happened during the quote amount or fee calculation
//        OFFER_OVERFLOW = -6,
//        //: Either an asset pair does not exist or base and quote assets are the same
//        ASSET_PAIR_NOT_TRADABLE = -7,
//        //: Offer price violates the physical price restriction
//        PHYSICAL_PRICE_RESTRICTION = -8,
//        //: Offer price violates the current price restriction
//        CURRENT_PRICE_RESTRICTION = -9,
//        //: Offer with provided offerID is not found
//        NOT_FOUND = -10,
//        //: Negative fee is not allowed
//        INVALID_PERCENT_FEE = -11,
//        //: Price is too small
//        INSUFFICIENT_PRICE = -12,
//        //: Order book with provided ID does not exist
//        ORDER_BOOK_DOES_NOT_EXISTS = -13,
//        //: Sale has not started yet
//        SALE_IS_NOT_STARTED_YET = -14,
//        //: Sale has already ended
//        SALE_ALREADY_ENDED = -15,
//        //: CurrentCap of sale + offer amount will exceed the hard cap of the sale
//        ORDER_VIOLATES_HARD_CAP = -16,
//        //: Offer creator cannot participate in their own sale
//        CANT_PARTICIPATE_OWN_SALE = -17,
//        //: Sale assets and assets for specified balances are mismatched
//        ASSET_MISMATCHED = -18,
//        //: Sale price and offer price are mismatched
//        PRICE_DOES_NOT_MATCH = -19,
//        //: Price must be positive
//        PRICE_IS_INVALID = -20,
//        //: Offer update is not allowed
//        UPDATE_IS_NOT_ALLOWED = -21,
//        //: Amount must be positive
//        INVALID_AMOUNT = -22,
//        //: Sale is not active
//        SALE_IS_NOT_ACTIVE = -23,
//        //: Source must have KYC in order to participate
//        REQUIRES_KYC = -24,
//        //: Source account is underfunded
//        SOURCE_UNDERFUNDED = -25,
//        //: Overflow happened during the balance lock
//        SOURCE_BALANCE_LOCK_OVERFLOW = -26,
//        //: Source account must be verified in order to participate
//        REQUIRES_VERIFICATION = -27,
//        //: Precision set in the system and precision of the amount are mismatched
//        INCORRECT_AMOUNT_PRECISION = -28,
//        //: Sale specific rule forbids to participate in sale for source account
//        SPECIFIC_RULE_FORBIDS = -29,
//        //: Amount must be less then pending issuance
//        PENDING_ISSUANCE_LESS_THEN_AMOUNT = -30
//    };
//
type ManageOfferResultCode int32

const (
	ManageOfferResultCodeSuccess                       ManageOfferResultCode = 0
	ManageOfferResultCodeMalformed                     ManageOfferResultCode = -1
	ManageOfferResultCodePairNotTraded                 ManageOfferResultCode = -2
	ManageOfferResultCodeBalanceNotFound               ManageOfferResultCode = -3
	ManageOfferResultCodeUnderfunded                   ManageOfferResultCode = -4
	ManageOfferResultCodeCrossSelf                     ManageOfferResultCode = -5
	ManageOfferResultCodeOfferOverflow                 ManageOfferResultCode = -6
	ManageOfferResultCodeAssetPairNotTradable          ManageOfferResultCode = -7
	ManageOfferResultCodePhysicalPriceRestriction      ManageOfferResultCode = -8
	ManageOfferResultCodeCurrentPriceRestriction       ManageOfferResultCode = -9
	ManageOfferResultCodeNotFound                      ManageOfferResultCode = -10
	ManageOfferResultCodeInvalidPercentFee             ManageOfferResultCode = -11
	ManageOfferResultCodeInsufficientPrice             ManageOfferResultCode = -12
	ManageOfferResultCodeOrderBookDoesNotExists        ManageOfferResultCode = -13
	ManageOfferResultCodeSaleIsNotStartedYet           ManageOfferResultCode = -14
	ManageOfferResultCodeSaleAlreadyEnded              ManageOfferResultCode = -15
	ManageOfferResultCodeOrderViolatesHardCap          ManageOfferResultCode = -16
	ManageOfferResultCodeCantParticipateOwnSale        ManageOfferResultCode = -17
	ManageOfferResultCodeAssetMismatched               ManageOfferResultCode = -18
	ManageOfferResultCodePriceDoesNotMatch             ManageOfferResultCode = -19
	ManageOfferResultCodePriceIsInvalid                ManageOfferResultCode = -20
	ManageOfferResultCodeUpdateIsNotAllowed            ManageOfferResultCode = -21
	ManageOfferResultCodeInvalidAmount                 ManageOfferResultCode = -22
	ManageOfferResultCodeSaleIsNotActive               ManageOfferResultCode = -23
	ManageOfferResultCodeRequiresKyc                   ManageOfferResultCode = -24
	ManageOfferResultCodeSourceUnderfunded             ManageOfferResultCode = -25
	ManageOfferResultCodeSourceBalanceLockOverflow     ManageOfferResultCode = -26
	ManageOfferResultCodeRequiresVerification          ManageOfferResultCode = -27
	ManageOfferResultCodeIncorrectAmountPrecision      ManageOfferResultCode = -28
	ManageOfferResultCodeSpecificRuleForbids           ManageOfferResultCode = -29
	ManageOfferResultCodePendingIssuanceLessThenAmount ManageOfferResultCode = -30
)

var ManageOfferResultCodeAll = []ManageOfferResultCode{
	ManageOfferResultCodeSuccess,
	ManageOfferResultCodeMalformed,
	ManageOfferResultCodePairNotTraded,
	ManageOfferResultCodeBalanceNotFound,
	ManageOfferResultCodeUnderfunded,
	ManageOfferResultCodeCrossSelf,
	ManageOfferResultCodeOfferOverflow,
	ManageOfferResultCodeAssetPairNotTradable,
	ManageOfferResultCodePhysicalPriceRestriction,
	ManageOfferResultCodeCurrentPriceRestriction,
	ManageOfferResultCodeNotFound,
	ManageOfferResultCodeInvalidPercentFee,
	ManageOfferResultCodeInsufficientPrice,
	ManageOfferResultCodeOrderBookDoesNotExists,
	ManageOfferResultCodeSaleIsNotStartedYet,
	ManageOfferResultCodeSaleAlreadyEnded,
	ManageOfferResultCodeOrderViolatesHardCap,
	ManageOfferResultCodeCantParticipateOwnSale,
	ManageOfferResultCodeAssetMismatched,
	ManageOfferResultCodePriceDoesNotMatch,
	ManageOfferResultCodePriceIsInvalid,
	ManageOfferResultCodeUpdateIsNotAllowed,
	ManageOfferResultCodeInvalidAmount,
	ManageOfferResultCodeSaleIsNotActive,
	ManageOfferResultCodeRequiresKyc,
	ManageOfferResultCodeSourceUnderfunded,
	ManageOfferResultCodeSourceBalanceLockOverflow,
	ManageOfferResultCodeRequiresVerification,
	ManageOfferResultCodeIncorrectAmountPrecision,
	ManageOfferResultCodeSpecificRuleForbids,
	ManageOfferResultCodePendingIssuanceLessThenAmount,
}

var manageOfferResultCodeMap = map[int32]string{
	0:   "ManageOfferResultCodeSuccess",
	-1:  "ManageOfferResultCodeMalformed",
	-2:  "ManageOfferResultCodePairNotTraded",
	-3:  "ManageOfferResultCodeBalanceNotFound",
	-4:  "ManageOfferResultCodeUnderfunded",
	-5:  "ManageOfferResultCodeCrossSelf",
	-6:  "ManageOfferResultCodeOfferOverflow",
	-7:  "ManageOfferResultCodeAssetPairNotTradable",
	-8:  "ManageOfferResultCodePhysicalPriceRestriction",
	-9:  "ManageOfferResultCodeCurrentPriceRestriction",
	-10: "ManageOfferResultCodeNotFound",
	-11: "ManageOfferResultCodeInvalidPercentFee",
	-12: "ManageOfferResultCodeInsufficientPrice",
	-13: "ManageOfferResultCodeOrderBookDoesNotExists",
	-14: "ManageOfferResultCodeSaleIsNotStartedYet",
	-15: "ManageOfferResultCodeSaleAlreadyEnded",
	-16: "ManageOfferResultCodeOrderViolatesHardCap",
	-17: "ManageOfferResultCodeCantParticipateOwnSale",
	-18: "ManageOfferResultCodeAssetMismatched",
	-19: "ManageOfferResultCodePriceDoesNotMatch",
	-20: "ManageOfferResultCodePriceIsInvalid",
	-21: "ManageOfferResultCodeUpdateIsNotAllowed",
	-22: "ManageOfferResultCodeInvalidAmount",
	-23: "ManageOfferResultCodeSaleIsNotActive",
	-24: "ManageOfferResultCodeRequiresKyc",
	-25: "ManageOfferResultCodeSourceUnderfunded",
	-26: "ManageOfferResultCodeSourceBalanceLockOverflow",
	-27: "ManageOfferResultCodeRequiresVerification",
	-28: "ManageOfferResultCodeIncorrectAmountPrecision",
	-29: "ManageOfferResultCodeSpecificRuleForbids",
	-30: "ManageOfferResultCodePendingIssuanceLessThenAmount",
}

var manageOfferResultCodeShortMap = map[int32]string{
	0:   "success",
	-1:  "malformed",
	-2:  "pair_not_traded",
	-3:  "balance_not_found",
	-4:  "underfunded",
	-5:  "cross_self",
	-6:  "offer_overflow",
	-7:  "asset_pair_not_tradable",
	-8:  "physical_price_restriction",
	-9:  "current_price_restriction",
	-10: "not_found",
	-11: "invalid_percent_fee",
	-12: "insufficient_price",
	-13: "order_book_does_not_exists",
	-14: "sale_is_not_started_yet",
	-15: "sale_already_ended",
	-16: "order_violates_hard_cap",
	-17: "cant_participate_own_sale",
	-18: "asset_mismatched",
	-19: "price_does_not_match",
	-20: "price_is_invalid",
	-21: "update_is_not_allowed",
	-22: "invalid_amount",
	-23: "sale_is_not_active",
	-24: "requires_kyc",
	-25: "source_underfunded",
	-26: "source_balance_lock_overflow",
	-27: "requires_verification",
	-28: "incorrect_amount_precision",
	-29: "specific_rule_forbids",
	-30: "pending_issuance_less_then_amount",
}

var manageOfferResultCodeRevMap = map[string]int32{
	"ManageOfferResultCodeSuccess":                       0,
	"ManageOfferResultCodeMalformed":                     -1,
	"ManageOfferResultCodePairNotTraded":                 -2,
	"ManageOfferResultCodeBalanceNotFound":               -3,
	"ManageOfferResultCodeUnderfunded":                   -4,
	"ManageOfferResultCodeCrossSelf":                     -5,
	"ManageOfferResultCodeOfferOverflow":                 -6,
	"ManageOfferResultCodeAssetPairNotTradable":          -7,
	"ManageOfferResultCodePhysicalPriceRestriction":      -8,
	"ManageOfferResultCodeCurrentPriceRestriction":       -9,
	"ManageOfferResultCodeNotFound":                      -10,
	"ManageOfferResultCodeInvalidPercentFee":             -11,
	"ManageOfferResultCodeInsufficientPrice":             -12,
	"ManageOfferResultCodeOrderBookDoesNotExists":        -13,
	"ManageOfferResultCodeSaleIsNotStartedYet":           -14,
	"ManageOfferResultCodeSaleAlreadyEnded":              -15,
	"ManageOfferResultCodeOrderViolatesHardCap":          -16,
	"ManageOfferResultCodeCantParticipateOwnSale":        -17,
	"ManageOfferResultCodeAssetMismatched":               -18,
	"ManageOfferResultCodePriceDoesNotMatch":             -19,
	"ManageOfferResultCodePriceIsInvalid":                -20,
	"ManageOfferResultCodeUpdateIsNotAllowed":            -21,
	"ManageOfferResultCodeInvalidAmount":                 -22,
	"ManageOfferResultCodeSaleIsNotActive":               -23,
	"ManageOfferResultCodeRequiresKyc":                   -24,
	"ManageOfferResultCodeSourceUnderfunded":             -25,
	"ManageOfferResultCodeSourceBalanceLockOverflow":     -26,
	"ManageOfferResultCodeRequiresVerification":          -27,
	"ManageOfferResultCodeIncorrectAmountPrecision":      -28,
	"ManageOfferResultCodeSpecificRuleForbids":           -29,
	"ManageOfferResultCodePendingIssuanceLessThenAmount": -30,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageOfferResultCode
func (e ManageOfferResultCode) ValidEnum(v int32) bool {
	_, ok := manageOfferResultCodeMap[v]
	return ok
}
func (e ManageOfferResultCode) isFlag() bool {
	for i := len(ManageOfferResultCodeAll) - 1; i >= 0; i-- {
		expected := ManageOfferResultCode(2) << uint64(len(ManageOfferResultCodeAll)-1) >> uint64(len(ManageOfferResultCodeAll)-i)
		if expected != ManageOfferResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageOfferResultCode) String() string {
	name, _ := manageOfferResultCodeMap[int32(e)]
	return name
}

func (e ManageOfferResultCode) ShortString() string {
	name, _ := manageOfferResultCodeShortMap[int32(e)]
	return name
}

func (e ManageOfferResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageOfferResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageOfferResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageOfferResultCode(t.Value)
	return nil
}

// ManageOfferEffect is an XDR Enum defines as:
//
//   enum ManageOfferEffect
//    {
//        //: Offer created
//        CREATED = 0,
//        //: Offer updated
//        UPDATED = 1,
//        //: Offer deleted
//        DELETED = 2
//    };
//
type ManageOfferEffect int32

const (
	ManageOfferEffectCreated ManageOfferEffect = 0
	ManageOfferEffectUpdated ManageOfferEffect = 1
	ManageOfferEffectDeleted ManageOfferEffect = 2
)

var ManageOfferEffectAll = []ManageOfferEffect{
	ManageOfferEffectCreated,
	ManageOfferEffectUpdated,
	ManageOfferEffectDeleted,
}

var manageOfferEffectMap = map[int32]string{
	0: "ManageOfferEffectCreated",
	1: "ManageOfferEffectUpdated",
	2: "ManageOfferEffectDeleted",
}

var manageOfferEffectShortMap = map[int32]string{
	0: "created",
	1: "updated",
	2: "deleted",
}

var manageOfferEffectRevMap = map[string]int32{
	"ManageOfferEffectCreated": 0,
	"ManageOfferEffectUpdated": 1,
	"ManageOfferEffectDeleted": 2,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageOfferEffect
func (e ManageOfferEffect) ValidEnum(v int32) bool {
	_, ok := manageOfferEffectMap[v]
	return ok
}
func (e ManageOfferEffect) isFlag() bool {
	for i := len(ManageOfferEffectAll) - 1; i >= 0; i-- {
		expected := ManageOfferEffect(2) << uint64(len(ManageOfferEffectAll)-1) >> uint64(len(ManageOfferEffectAll)-i)
		if expected != ManageOfferEffectAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageOfferEffect) String() string {
	name, _ := manageOfferEffectMap[int32(e)]
	return name
}

func (e ManageOfferEffect) ShortString() string {
	name, _ := manageOfferEffectShortMap[int32(e)]
	return name
}

func (e ManageOfferEffect) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageOfferEffectAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageOfferEffect) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageOfferEffect(t.Value)
	return nil
}

// ClaimOfferAtomExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ClaimOfferAtomExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ClaimOfferAtomExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ClaimOfferAtomExt
func (u ClaimOfferAtomExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewClaimOfferAtomExt creates a new  ClaimOfferAtomExt.
func NewClaimOfferAtomExt(v LedgerVersion, value interface{}) (result ClaimOfferAtomExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ClaimOfferAtom is an XDR Struct defines as:
//
//   //: Used when offers are taken during the operation
//    struct ClaimOfferAtom
//    {
//        // emitted to identify the offer
//        //: ID of an account that created the matched offer
//        AccountID bAccountID;
//        //: ID of the matched offer
//        uint64 offerID;
//        //: Amount in base asset taken during the match
//        int64 baseAmount;
//        //: Amount in quote asset taked during the match
//        int64 quoteAmount;
//        //: Fee paid by an offer owner
//        int64 bFeePaid;
//        //: Fee paid by the source of an operation
//        int64 aFeePaid;
//        //: Balance in base asset of an offer owner
//        BalanceID baseBalance;
//        //: Balance in quote asset of an offer owner
//        BalanceID quoteBalance;
//        //: Match price
//        int64 currentPrice;
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ClaimOfferAtom struct {
	BAccountId   AccountId         `json:"bAccountID,omitempty"`
	OfferId      Uint64            `json:"offerID,omitempty"`
	BaseAmount   Int64             `json:"baseAmount,omitempty"`
	QuoteAmount  Int64             `json:"quoteAmount,omitempty"`
	BFeePaid     Int64             `json:"bFeePaid,omitempty"`
	AFeePaid     Int64             `json:"aFeePaid,omitempty"`
	BaseBalance  BalanceId         `json:"baseBalance,omitempty"`
	QuoteBalance BalanceId         `json:"quoteBalance,omitempty"`
	CurrentPrice Int64             `json:"currentPrice,omitempty"`
	Ext          ClaimOfferAtomExt `json:"ext,omitempty"`
}

// ManageOfferSuccessResultOffer is an XDR NestedUnion defines as:
//
//   union switch (ManageOfferEffect effect)
//        {
//        case CREATED:
//        case UPDATED:
//            //: Updated offer entry
//            OfferEntry offer;
//        default:
//            void;
//        }
//
type ManageOfferSuccessResultOffer struct {
	Effect ManageOfferEffect `json:"effect,omitempty"`
	Offer  *OfferEntry       `json:"offer,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageOfferSuccessResultOffer) SwitchFieldName() string {
	return "Effect"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageOfferSuccessResultOffer
func (u ManageOfferSuccessResultOffer) ArmForSwitch(sw int32) (string, bool) {
	switch ManageOfferEffect(sw) {
	case ManageOfferEffectCreated:
		return "Offer", true
	case ManageOfferEffectUpdated:
		return "Offer", true
	default:
		return "", true
	}
}

// NewManageOfferSuccessResultOffer creates a new  ManageOfferSuccessResultOffer.
func NewManageOfferSuccessResultOffer(effect ManageOfferEffect, value interface{}) (result ManageOfferSuccessResultOffer, err error) {
	result.Effect = effect
	switch ManageOfferEffect(effect) {
	case ManageOfferEffectCreated:
		tv, ok := value.(OfferEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be OfferEntry")
			return
		}
		result.Offer = &tv
	case ManageOfferEffectUpdated:
		tv, ok := value.(OfferEntry)
		if !ok {
			err = fmt.Errorf("invalid value, must be OfferEntry")
			return
		}
		result.Offer = &tv
	default:
		// void
	}
	return
}

// MustOffer retrieves the Offer value from the union,
// panicing if the value is not set.
func (u ManageOfferSuccessResultOffer) MustOffer() OfferEntry {
	val, ok := u.GetOffer()

	if !ok {
		panic("arm Offer is not set")
	}

	return val
}

// GetOffer retrieves the Offer value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageOfferSuccessResultOffer) GetOffer() (result OfferEntry, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Effect))

	if armName == "Offer" {
		result = *u.Offer
		ok = true
	}

	return
}

// ManageOfferSuccessResultExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ManageOfferSuccessResultExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageOfferSuccessResultExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageOfferSuccessResultExt
func (u ManageOfferSuccessResultExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageOfferSuccessResultExt creates a new  ManageOfferSuccessResultExt.
func NewManageOfferSuccessResultExt(v LedgerVersion, value interface{}) (result ManageOfferSuccessResultExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageOfferSuccessResult is an XDR Struct defines as:
//
//   //: Contains details of successful operation application
//    struct ManageOfferSuccessResult
//    {
//
//        //: Offers that matched a created offer
//        ClaimOfferAtom offersClaimed<>;
//        //: Base asset of an offer
//        AssetCode baseAsset;
//        //: Quote asset of an offer
//        AssetCode quoteAsset;
//
//        //: Effect of operation
//        union switch (ManageOfferEffect effect)
//        {
//        case CREATED:
//        case UPDATED:
//            //: Updated offer entry
//            OfferEntry offer;
//        default:
//            void;
//        }
//        offer;
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ManageOfferSuccessResult struct {
	OffersClaimed []ClaimOfferAtom              `json:"offersClaimed,omitempty"`
	BaseAsset     AssetCode                     `json:"baseAsset,omitempty"`
	QuoteAsset    AssetCode                     `json:"quoteAsset,omitempty"`
	Offer         ManageOfferSuccessResultOffer `json:"offer,omitempty"`
	Ext           ManageOfferSuccessResultExt   `json:"ext,omitempty"`
}

// ManageOfferResultPhysicalPriceRestrictionExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type ManageOfferResultPhysicalPriceRestrictionExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageOfferResultPhysicalPriceRestrictionExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageOfferResultPhysicalPriceRestrictionExt
func (u ManageOfferResultPhysicalPriceRestrictionExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageOfferResultPhysicalPriceRestrictionExt creates a new  ManageOfferResultPhysicalPriceRestrictionExt.
func NewManageOfferResultPhysicalPriceRestrictionExt(v LedgerVersion, value interface{}) (result ManageOfferResultPhysicalPriceRestrictionExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageOfferResultPhysicalPriceRestriction is an XDR NestedStruct defines as:
//
//   struct {
//            //: Physical price of the base asset
//            int64 physicalPrice;
//            //: Reserved for future use
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        }
//
type ManageOfferResultPhysicalPriceRestriction struct {
	PhysicalPrice Int64                                        `json:"physicalPrice,omitempty"`
	Ext           ManageOfferResultPhysicalPriceRestrictionExt `json:"ext,omitempty"`
}

// ManageOfferResultCurrentPriceRestrictionExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type ManageOfferResultCurrentPriceRestrictionExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageOfferResultCurrentPriceRestrictionExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageOfferResultCurrentPriceRestrictionExt
func (u ManageOfferResultCurrentPriceRestrictionExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageOfferResultCurrentPriceRestrictionExt creates a new  ManageOfferResultCurrentPriceRestrictionExt.
func NewManageOfferResultCurrentPriceRestrictionExt(v LedgerVersion, value interface{}) (result ManageOfferResultCurrentPriceRestrictionExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageOfferResultCurrentPriceRestriction is an XDR NestedStruct defines as:
//
//   struct {
//            //: Current price of the base asset
//            int64 currentPrice;
//            //: Reserved for future use
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        }
//
type ManageOfferResultCurrentPriceRestriction struct {
	CurrentPrice Int64                                       `json:"currentPrice,omitempty"`
	Ext          ManageOfferResultCurrentPriceRestrictionExt `json:"ext,omitempty"`
}

// ManageOfferResult is an XDR Union defines as:
//
//   //: Result of `ManageOfferOp`
//    union ManageOfferResult switch (ManageOfferResultCode code)
//    {
//    case SUCCESS:
//        ManageOfferSuccessResult success;
//    case PHYSICAL_PRICE_RESTRICTION:
//        struct {
//            //: Physical price of the base asset
//            int64 physicalPrice;
//            //: Reserved for future use
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        } physicalPriceRestriction;
//    case CURRENT_PRICE_RESTRICTION:
//        struct {
//            //: Current price of the base asset
//            int64 currentPrice;
//            //: Reserved for future use
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        } currentPriceRestriction;
//    default:
//        void;
//    };
//
type ManageOfferResult struct {
	Code                     ManageOfferResultCode                      `json:"code,omitempty"`
	Success                  *ManageOfferSuccessResult                  `json:"success,omitempty"`
	PhysicalPriceRestriction *ManageOfferResultPhysicalPriceRestriction `json:"physicalPriceRestriction,omitempty"`
	CurrentPriceRestriction  *ManageOfferResultCurrentPriceRestriction  `json:"currentPriceRestriction,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageOfferResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageOfferResult
func (u ManageOfferResult) ArmForSwitch(sw int32) (string, bool) {
	switch ManageOfferResultCode(sw) {
	case ManageOfferResultCodeSuccess:
		return "Success", true
	case ManageOfferResultCodePhysicalPriceRestriction:
		return "PhysicalPriceRestriction", true
	case ManageOfferResultCodeCurrentPriceRestriction:
		return "CurrentPriceRestriction", true
	default:
		return "", true
	}
}

// NewManageOfferResult creates a new  ManageOfferResult.
func NewManageOfferResult(code ManageOfferResultCode, value interface{}) (result ManageOfferResult, err error) {
	result.Code = code
	switch ManageOfferResultCode(code) {
	case ManageOfferResultCodeSuccess:
		tv, ok := value.(ManageOfferSuccessResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageOfferSuccessResult")
			return
		}
		result.Success = &tv
	case ManageOfferResultCodePhysicalPriceRestriction:
		tv, ok := value.(ManageOfferResultPhysicalPriceRestriction)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageOfferResultPhysicalPriceRestriction")
			return
		}
		result.PhysicalPriceRestriction = &tv
	case ManageOfferResultCodeCurrentPriceRestriction:
		tv, ok := value.(ManageOfferResultCurrentPriceRestriction)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageOfferResultCurrentPriceRestriction")
			return
		}
		result.CurrentPriceRestriction = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u ManageOfferResult) MustSuccess() ManageOfferSuccessResult {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageOfferResult) GetSuccess() (result ManageOfferSuccessResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// MustPhysicalPriceRestriction retrieves the PhysicalPriceRestriction value from the union,
// panicing if the value is not set.
func (u ManageOfferResult) MustPhysicalPriceRestriction() ManageOfferResultPhysicalPriceRestriction {
	val, ok := u.GetPhysicalPriceRestriction()

	if !ok {
		panic("arm PhysicalPriceRestriction is not set")
	}

	return val
}

// GetPhysicalPriceRestriction retrieves the PhysicalPriceRestriction value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageOfferResult) GetPhysicalPriceRestriction() (result ManageOfferResultPhysicalPriceRestriction, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "PhysicalPriceRestriction" {
		result = *u.PhysicalPriceRestriction
		ok = true
	}

	return
}

// MustCurrentPriceRestriction retrieves the CurrentPriceRestriction value from the union,
// panicing if the value is not set.
func (u ManageOfferResult) MustCurrentPriceRestriction() ManageOfferResultCurrentPriceRestriction {
	val, ok := u.GetCurrentPriceRestriction()

	if !ok {
		panic("arm CurrentPriceRestriction is not set")
	}

	return val
}

// GetCurrentPriceRestriction retrieves the CurrentPriceRestriction value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageOfferResult) GetCurrentPriceRestriction() (result ManageOfferResultCurrentPriceRestriction, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "CurrentPriceRestriction" {
		result = *u.CurrentPriceRestriction
		ok = true
	}

	return
}

// ManagePollAction is an XDR Enum defines as:
//
//   //: Actions that can be applied to a poll
//    enum ManagePollAction
//    {
//        CLOSE = 0,
//        UPDATE_END_TIME = 1,
//        CANCEL = 2
//    };
//
type ManagePollAction int32

const (
	ManagePollActionClose         ManagePollAction = 0
	ManagePollActionUpdateEndTime ManagePollAction = 1
	ManagePollActionCancel        ManagePollAction = 2
)

var ManagePollActionAll = []ManagePollAction{
	ManagePollActionClose,
	ManagePollActionUpdateEndTime,
	ManagePollActionCancel,
}

var managePollActionMap = map[int32]string{
	0: "ManagePollActionClose",
	1: "ManagePollActionUpdateEndTime",
	2: "ManagePollActionCancel",
}

var managePollActionShortMap = map[int32]string{
	0: "close",
	1: "update_end_time",
	2: "cancel",
}

var managePollActionRevMap = map[string]int32{
	"ManagePollActionClose":         0,
	"ManagePollActionUpdateEndTime": 1,
	"ManagePollActionCancel":        2,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManagePollAction
func (e ManagePollAction) ValidEnum(v int32) bool {
	_, ok := managePollActionMap[v]
	return ok
}
func (e ManagePollAction) isFlag() bool {
	for i := len(ManagePollActionAll) - 1; i >= 0; i-- {
		expected := ManagePollAction(2) << uint64(len(ManagePollActionAll)-1) >> uint64(len(ManagePollActionAll)-i)
		if expected != ManagePollActionAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManagePollAction) String() string {
	name, _ := managePollActionMap[int32(e)]
	return name
}

func (e ManagePollAction) ShortString() string {
	name, _ := managePollActionShortMap[int32(e)]
	return name
}

func (e ManagePollAction) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManagePollActionAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManagePollAction) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManagePollAction(t.Value)
	return nil
}

// PollResult is an XDR Enum defines as:
//
//   //: PollResult is used to specify result of voting
//    enum PollResult
//    {
//        PASSED = 0,
//        FAILED = 1
//    };
//
type PollResult int32

const (
	PollResultPassed PollResult = 0
	PollResultFailed PollResult = 1
)

var PollResultAll = []PollResult{
	PollResultPassed,
	PollResultFailed,
}

var pollResultMap = map[int32]string{
	0: "PollResultPassed",
	1: "PollResultFailed",
}

var pollResultShortMap = map[int32]string{
	0: "passed",
	1: "failed",
}

var pollResultRevMap = map[string]int32{
	"PollResultPassed": 0,
	"PollResultFailed": 1,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for PollResult
func (e PollResult) ValidEnum(v int32) bool {
	_, ok := pollResultMap[v]
	return ok
}
func (e PollResult) isFlag() bool {
	for i := len(PollResultAll) - 1; i >= 0; i-- {
		expected := PollResult(2) << uint64(len(PollResultAll)-1) >> uint64(len(PollResultAll)-i)
		if expected != PollResultAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e PollResult) String() string {
	name, _ := pollResultMap[int32(e)]
	return name
}

func (e PollResult) ShortString() string {
	name, _ := pollResultShortMap[int32(e)]
	return name
}

func (e PollResult) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range PollResultAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *PollResult) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = PollResult(t.Value)
	return nil
}

// ClosePollDataExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ClosePollDataExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ClosePollDataExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ClosePollDataExt
func (u ClosePollDataExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewClosePollDataExt creates a new  ClosePollDataExt.
func NewClosePollDataExt(v LedgerVersion, value interface{}) (result ClosePollDataExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ClosePollData is an XDR Struct defines as:
//
//   //: ClosePollData is used to submit poll results
//    struct ClosePollData
//    {
//        //: result of voting
//        PollResult result;
//
//        //: Arbitrary stringified json object with details about the result
//        longstring details;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ClosePollData struct {
	Result  PollResult       `json:"result,omitempty"`
	Details Longstring       `json:"details,omitempty"`
	Ext     ClosePollDataExt `json:"ext,omitempty"`
}

// UpdatePollEndTimeDataExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type UpdatePollEndTimeDataExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u UpdatePollEndTimeDataExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of UpdatePollEndTimeDataExt
func (u UpdatePollEndTimeDataExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewUpdatePollEndTimeDataExt creates a new  UpdatePollEndTimeDataExt.
func NewUpdatePollEndTimeDataExt(v LedgerVersion, value interface{}) (result UpdatePollEndTimeDataExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// UpdatePollEndTimeData is an XDR Struct defines as:
//
//   struct UpdatePollEndTimeData
//    {
//        uint64 newEndTime;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type UpdatePollEndTimeData struct {
	NewEndTime Uint64                   `json:"newEndTime,omitempty"`
	Ext        UpdatePollEndTimeDataExt `json:"ext,omitempty"`
}

// ManagePollOpData is an XDR NestedUnion defines as:
//
//   union switch (ManagePollAction action)
//        {
//        case CLOSE:
//            ClosePollData closePollData;
//        case UPDATE_END_TIME:
//            UpdatePollEndTimeData updateTimeData;
//        case CANCEL:
//            EmptyExt ext;
//        }
//
type ManagePollOpData struct {
	Action         ManagePollAction       `json:"action,omitempty"`
	ClosePollData  *ClosePollData         `json:"closePollData,omitempty"`
	UpdateTimeData *UpdatePollEndTimeData `json:"updateTimeData,omitempty"`
	Ext            *EmptyExt              `json:"ext,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManagePollOpData) SwitchFieldName() string {
	return "Action"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManagePollOpData
func (u ManagePollOpData) ArmForSwitch(sw int32) (string, bool) {
	switch ManagePollAction(sw) {
	case ManagePollActionClose:
		return "ClosePollData", true
	case ManagePollActionUpdateEndTime:
		return "UpdateTimeData", true
	case ManagePollActionCancel:
		return "Ext", true
	}
	return "-", false
}

// NewManagePollOpData creates a new  ManagePollOpData.
func NewManagePollOpData(action ManagePollAction, value interface{}) (result ManagePollOpData, err error) {
	result.Action = action
	switch ManagePollAction(action) {
	case ManagePollActionClose:
		tv, ok := value.(ClosePollData)
		if !ok {
			err = fmt.Errorf("invalid value, must be ClosePollData")
			return
		}
		result.ClosePollData = &tv
	case ManagePollActionUpdateEndTime:
		tv, ok := value.(UpdatePollEndTimeData)
		if !ok {
			err = fmt.Errorf("invalid value, must be UpdatePollEndTimeData")
			return
		}
		result.UpdateTimeData = &tv
	case ManagePollActionCancel:
		tv, ok := value.(EmptyExt)
		if !ok {
			err = fmt.Errorf("invalid value, must be EmptyExt")
			return
		}
		result.Ext = &tv
	}
	return
}

// MustClosePollData retrieves the ClosePollData value from the union,
// panicing if the value is not set.
func (u ManagePollOpData) MustClosePollData() ClosePollData {
	val, ok := u.GetClosePollData()

	if !ok {
		panic("arm ClosePollData is not set")
	}

	return val
}

// GetClosePollData retrieves the ClosePollData value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManagePollOpData) GetClosePollData() (result ClosePollData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "ClosePollData" {
		result = *u.ClosePollData
		ok = true
	}

	return
}

// MustUpdateTimeData retrieves the UpdateTimeData value from the union,
// panicing if the value is not set.
func (u ManagePollOpData) MustUpdateTimeData() UpdatePollEndTimeData {
	val, ok := u.GetUpdateTimeData()

	if !ok {
		panic("arm UpdateTimeData is not set")
	}

	return val
}

// GetUpdateTimeData retrieves the UpdateTimeData value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManagePollOpData) GetUpdateTimeData() (result UpdatePollEndTimeData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "UpdateTimeData" {
		result = *u.UpdateTimeData
		ok = true
	}

	return
}

// MustExt retrieves the Ext value from the union,
// panicing if the value is not set.
func (u ManagePollOpData) MustExt() EmptyExt {
	val, ok := u.GetExt()

	if !ok {
		panic("arm Ext is not set")
	}

	return val
}

// GetExt retrieves the Ext value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManagePollOpData) GetExt() (result EmptyExt, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "Ext" {
		result = *u.Ext
		ok = true
	}

	return
}

// ManagePollOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ManagePollOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManagePollOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManagePollOpExt
func (u ManagePollOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManagePollOpExt creates a new  ManagePollOpExt.
func NewManagePollOpExt(v LedgerVersion, value interface{}) (result ManagePollOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManagePollOp is an XDR Struct defines as:
//
//   //: ManagePollOp is used to close,  update end time or cancel the poll
//    struct ManagePollOp
//    {
//        //: ID of poll to manage
//        uint64 pollID;
//
//        //: data is used to pass one of `ManagePollAction` with required params
//        union switch (ManagePollAction action)
//        {
//        case CLOSE:
//            ClosePollData closePollData;
//        case UPDATE_END_TIME:
//            UpdatePollEndTimeData updateTimeData;
//        case CANCEL:
//            EmptyExt ext;
//        }
//        data;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ManagePollOp struct {
	PollId Uint64           `json:"pollID,omitempty"`
	Data   ManagePollOpData `json:"data,omitempty"`
	Ext    ManagePollOpExt  `json:"ext,omitempty"`
}

// ManagePollResultCode is an XDR Enum defines as:
//
//   //: Result codes of ManagePollOp
//    enum ManagePollResultCode
//    {
//        //: Specified action in `data` of ManagePollOp was successfully executed
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: There is no poll with such id
//        NOT_FOUND = -1,
//        //: Not allowed to close poll which
//        POLL_NOT_READY = -2,
//        //: Only result provider is allowed to close poll
//        NOT_AUTHORIZED_TO_CLOSE_POLL = -3,
//        //: End time is in the past
//        INVALID_END_TIME = -4,
//        //: Only poll owner and admin are allowed to cancel poll and update end time
//        NOT_AUTHORIZED = -5
//    };
//
type ManagePollResultCode int32

const (
	ManagePollResultCodeSuccess                  ManagePollResultCode = 0
	ManagePollResultCodeNotFound                 ManagePollResultCode = -1
	ManagePollResultCodePollNotReady             ManagePollResultCode = -2
	ManagePollResultCodeNotAuthorizedToClosePoll ManagePollResultCode = -3
	ManagePollResultCodeInvalidEndTime           ManagePollResultCode = -4
	ManagePollResultCodeNotAuthorized            ManagePollResultCode = -5
)

var ManagePollResultCodeAll = []ManagePollResultCode{
	ManagePollResultCodeSuccess,
	ManagePollResultCodeNotFound,
	ManagePollResultCodePollNotReady,
	ManagePollResultCodeNotAuthorizedToClosePoll,
	ManagePollResultCodeInvalidEndTime,
	ManagePollResultCodeNotAuthorized,
}

var managePollResultCodeMap = map[int32]string{
	0:  "ManagePollResultCodeSuccess",
	-1: "ManagePollResultCodeNotFound",
	-2: "ManagePollResultCodePollNotReady",
	-3: "ManagePollResultCodeNotAuthorizedToClosePoll",
	-4: "ManagePollResultCodeInvalidEndTime",
	-5: "ManagePollResultCodeNotAuthorized",
}

var managePollResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "not_found",
	-2: "poll_not_ready",
	-3: "not_authorized_to_close_poll",
	-4: "invalid_end_time",
	-5: "not_authorized",
}

var managePollResultCodeRevMap = map[string]int32{
	"ManagePollResultCodeSuccess":                  0,
	"ManagePollResultCodeNotFound":                 -1,
	"ManagePollResultCodePollNotReady":             -2,
	"ManagePollResultCodeNotAuthorizedToClosePoll": -3,
	"ManagePollResultCodeInvalidEndTime":           -4,
	"ManagePollResultCodeNotAuthorized":            -5,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManagePollResultCode
func (e ManagePollResultCode) ValidEnum(v int32) bool {
	_, ok := managePollResultCodeMap[v]
	return ok
}
func (e ManagePollResultCode) isFlag() bool {
	for i := len(ManagePollResultCodeAll) - 1; i >= 0; i-- {
		expected := ManagePollResultCode(2) << uint64(len(ManagePollResultCodeAll)-1) >> uint64(len(ManagePollResultCodeAll)-i)
		if expected != ManagePollResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManagePollResultCode) String() string {
	name, _ := managePollResultCodeMap[int32(e)]
	return name
}

func (e ManagePollResultCode) ShortString() string {
	name, _ := managePollResultCodeShortMap[int32(e)]
	return name
}

func (e ManagePollResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManagePollResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManagePollResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManagePollResultCode(t.Value)
	return nil
}

// ManagePollResult is an XDR Union defines as:
//
//   //: Result of operation application
//    union ManagePollResult switch (ManagePollResultCode code)
//    {
//    case SUCCESS:
//        EmptyExt ext;
//    default:
//        void;
//    };
//
type ManagePollResult struct {
	Code ManagePollResultCode `json:"code,omitempty"`
	Ext  *EmptyExt            `json:"ext,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManagePollResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManagePollResult
func (u ManagePollResult) ArmForSwitch(sw int32) (string, bool) {
	switch ManagePollResultCode(sw) {
	case ManagePollResultCodeSuccess:
		return "Ext", true
	default:
		return "", true
	}
}

// NewManagePollResult creates a new  ManagePollResult.
func NewManagePollResult(code ManagePollResultCode, value interface{}) (result ManagePollResult, err error) {
	result.Code = code
	switch ManagePollResultCode(code) {
	case ManagePollResultCodeSuccess:
		tv, ok := value.(EmptyExt)
		if !ok {
			err = fmt.Errorf("invalid value, must be EmptyExt")
			return
		}
		result.Ext = &tv
	default:
		// void
	}
	return
}

// MustExt retrieves the Ext value from the union,
// panicing if the value is not set.
func (u ManagePollResult) MustExt() EmptyExt {
	val, ok := u.GetExt()

	if !ok {
		panic("arm Ext is not set")
	}

	return val
}

// GetExt retrieves the Ext value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManagePollResult) GetExt() (result EmptyExt, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Ext" {
		result = *u.Ext
		ok = true
	}

	return
}

// ManageSaleAction is an XDR Enum defines as:
//
//   enum ManageSaleAction
//    {
//        CREATE_UPDATE_DETAILS_REQUEST = 1,
//        CANCEL = 2
//    };
//
type ManageSaleAction int32

const (
	ManageSaleActionCreateUpdateDetailsRequest ManageSaleAction = 1
	ManageSaleActionCancel                     ManageSaleAction = 2
)

var ManageSaleActionAll = []ManageSaleAction{
	ManageSaleActionCreateUpdateDetailsRequest,
	ManageSaleActionCancel,
}

var manageSaleActionMap = map[int32]string{
	1: "ManageSaleActionCreateUpdateDetailsRequest",
	2: "ManageSaleActionCancel",
}

var manageSaleActionShortMap = map[int32]string{
	1: "create_update_details_request",
	2: "cancel",
}

var manageSaleActionRevMap = map[string]int32{
	"ManageSaleActionCreateUpdateDetailsRequest": 1,
	"ManageSaleActionCancel":                     2,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageSaleAction
func (e ManageSaleAction) ValidEnum(v int32) bool {
	_, ok := manageSaleActionMap[v]
	return ok
}
func (e ManageSaleAction) isFlag() bool {
	for i := len(ManageSaleActionAll) - 1; i >= 0; i-- {
		expected := ManageSaleAction(2) << uint64(len(ManageSaleActionAll)-1) >> uint64(len(ManageSaleActionAll)-i)
		if expected != ManageSaleActionAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageSaleAction) String() string {
	name, _ := manageSaleActionMap[int32(e)]
	return name
}

func (e ManageSaleAction) ShortString() string {
	name, _ := manageSaleActionShortMap[int32(e)]
	return name
}

func (e ManageSaleAction) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageSaleActionAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageSaleAction) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageSaleAction(t.Value)
	return nil
}

// UpdateSaleDetailsDataExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type UpdateSaleDetailsDataExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u UpdateSaleDetailsDataExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of UpdateSaleDetailsDataExt
func (u UpdateSaleDetailsDataExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewUpdateSaleDetailsDataExt creates a new  UpdateSaleDetailsDataExt.
func NewUpdateSaleDetailsDataExt(v LedgerVersion, value interface{}) (result UpdateSaleDetailsDataExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// UpdateSaleDetailsData is an XDR Struct defines as:
//
//   //: Details regarding the `Update Sale Details` request
//    struct UpdateSaleDetailsData {
//        //: ID of a reviewable request. If set 0, request is created, else - request is updated
//        uint64 requestID; // if requestID is 0 - create request, else - update
//        //: Arbitrary stringified json object that can be used to attach data to be reviewed by an admin
//        longstring creatorDetails;
//        //: (optional) Bit mask whose flags must be cleared in order for UpdateSaleDetailsRequest to be approved,
//        //: which will be used instead of key-value by key sale_update_tasks:<asset_code>
//        uint32* allTasks;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type UpdateSaleDetailsData struct {
	RequestId      Uint64                   `json:"requestID,omitempty"`
	CreatorDetails Longstring               `json:"creatorDetails,omitempty"`
	AllTasks       *Uint32                  `json:"allTasks,omitempty"`
	Ext            UpdateSaleDetailsDataExt `json:"ext,omitempty"`
}

// ManageSaleOpData is an XDR NestedUnion defines as:
//
//   union switch (ManageSaleAction action) {
//        case CREATE_UPDATE_DETAILS_REQUEST:
//            UpdateSaleDetailsData updateSaleDetailsData;
//        case CANCEL:
//            void;
//        }
//
type ManageSaleOpData struct {
	Action                ManageSaleAction       `json:"action,omitempty"`
	UpdateSaleDetailsData *UpdateSaleDetailsData `json:"updateSaleDetailsData,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageSaleOpData) SwitchFieldName() string {
	return "Action"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageSaleOpData
func (u ManageSaleOpData) ArmForSwitch(sw int32) (string, bool) {
	switch ManageSaleAction(sw) {
	case ManageSaleActionCreateUpdateDetailsRequest:
		return "UpdateSaleDetailsData", true
	case ManageSaleActionCancel:
		return "", true
	}
	return "-", false
}

// NewManageSaleOpData creates a new  ManageSaleOpData.
func NewManageSaleOpData(action ManageSaleAction, value interface{}) (result ManageSaleOpData, err error) {
	result.Action = action
	switch ManageSaleAction(action) {
	case ManageSaleActionCreateUpdateDetailsRequest:
		tv, ok := value.(UpdateSaleDetailsData)
		if !ok {
			err = fmt.Errorf("invalid value, must be UpdateSaleDetailsData")
			return
		}
		result.UpdateSaleDetailsData = &tv
	case ManageSaleActionCancel:
		// void
	}
	return
}

// MustUpdateSaleDetailsData retrieves the UpdateSaleDetailsData value from the union,
// panicing if the value is not set.
func (u ManageSaleOpData) MustUpdateSaleDetailsData() UpdateSaleDetailsData {
	val, ok := u.GetUpdateSaleDetailsData()

	if !ok {
		panic("arm UpdateSaleDetailsData is not set")
	}

	return val
}

// GetUpdateSaleDetailsData retrieves the UpdateSaleDetailsData value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageSaleOpData) GetUpdateSaleDetailsData() (result UpdateSaleDetailsData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "UpdateSaleDetailsData" {
		result = *u.UpdateSaleDetailsData
		ok = true
	}

	return
}

// ManageSaleOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ManageSaleOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageSaleOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageSaleOpExt
func (u ManageSaleOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageSaleOpExt creates a new  ManageSaleOpExt.
func NewManageSaleOpExt(v LedgerVersion, value interface{}) (result ManageSaleOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageSaleOp is an XDR Struct defines as:
//
//   //: ManageSaleOp is used to cancel a sale, or create a reviewable request which, after approval, will update sale details.
//    struct ManageSaleOp
//    {
//        //: ID of the sale to manage
//        uint64 saleID;
//        //: data is used to pass ManageSaleAction along with required parameters
//        union switch (ManageSaleAction action) {
//        case CREATE_UPDATE_DETAILS_REQUEST:
//            UpdateSaleDetailsData updateSaleDetailsData;
//        case CANCEL:
//            void;
//        } data;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type ManageSaleOp struct {
	SaleId Uint64           `json:"saleID,omitempty"`
	Data   ManageSaleOpData `json:"data,omitempty"`
	Ext    ManageSaleOpExt  `json:"ext,omitempty"`
}

// ManageSaleResultCode is an XDR Enum defines as:
//
//   //: Result codes for ManageSaleOperation
//    enum ManageSaleResultCode
//    {
//        //: Operation is successfully applied
//        SUCCESS = 0,
//        //: Sale with provided ID is not found
//        SALE_NOT_FOUND = -1, // sale not found
//
//        // errors related to action "CREATE_UPDATE_DETAILS_REQUEST"
//        //: CreatorDetails is not a valid JSON
//        INVALID_CREATOR_DETAILS = -2, // newDetails field is invalid JSON
//        //: Request to update sale with provided ID already exists
//        UPDATE_DETAILS_REQUEST_ALREADY_EXISTS = -3,
//        //: UpdateSaleDetails request with provided ID is not found
//        UPDATE_DETAILS_REQUEST_NOT_FOUND = -4,
//        //: It is not allowed to set allTasks for a pending reviewable request
//        NOT_ALLOWED_TO_SET_TASKS_ON_UPDATE = -5, // not allowed to set allTasks on request update
//        //: Update sale details tasks are not set in the system, i.e. it's not allowed to perform the update of sale details
//        SALE_UPDATE_DETAILS_TASKS_NOT_FOUND = -6
//    };
//
type ManageSaleResultCode int32

const (
	ManageSaleResultCodeSuccess                           ManageSaleResultCode = 0
	ManageSaleResultCodeSaleNotFound                      ManageSaleResultCode = -1
	ManageSaleResultCodeInvalidCreatorDetails             ManageSaleResultCode = -2
	ManageSaleResultCodeUpdateDetailsRequestAlreadyExists ManageSaleResultCode = -3
	ManageSaleResultCodeUpdateDetailsRequestNotFound      ManageSaleResultCode = -4
	ManageSaleResultCodeNotAllowedToSetTasksOnUpdate      ManageSaleResultCode = -5
	ManageSaleResultCodeSaleUpdateDetailsTasksNotFound    ManageSaleResultCode = -6
)

var ManageSaleResultCodeAll = []ManageSaleResultCode{
	ManageSaleResultCodeSuccess,
	ManageSaleResultCodeSaleNotFound,
	ManageSaleResultCodeInvalidCreatorDetails,
	ManageSaleResultCodeUpdateDetailsRequestAlreadyExists,
	ManageSaleResultCodeUpdateDetailsRequestNotFound,
	ManageSaleResultCodeNotAllowedToSetTasksOnUpdate,
	ManageSaleResultCodeSaleUpdateDetailsTasksNotFound,
}

var manageSaleResultCodeMap = map[int32]string{
	0:  "ManageSaleResultCodeSuccess",
	-1: "ManageSaleResultCodeSaleNotFound",
	-2: "ManageSaleResultCodeInvalidCreatorDetails",
	-3: "ManageSaleResultCodeUpdateDetailsRequestAlreadyExists",
	-4: "ManageSaleResultCodeUpdateDetailsRequestNotFound",
	-5: "ManageSaleResultCodeNotAllowedToSetTasksOnUpdate",
	-6: "ManageSaleResultCodeSaleUpdateDetailsTasksNotFound",
}

var manageSaleResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "sale_not_found",
	-2: "invalid_creator_details",
	-3: "update_details_request_already_exists",
	-4: "update_details_request_not_found",
	-5: "not_allowed_to_set_tasks_on_update",
	-6: "sale_update_details_tasks_not_found",
}

var manageSaleResultCodeRevMap = map[string]int32{
	"ManageSaleResultCodeSuccess":                           0,
	"ManageSaleResultCodeSaleNotFound":                      -1,
	"ManageSaleResultCodeInvalidCreatorDetails":             -2,
	"ManageSaleResultCodeUpdateDetailsRequestAlreadyExists": -3,
	"ManageSaleResultCodeUpdateDetailsRequestNotFound":      -4,
	"ManageSaleResultCodeNotAllowedToSetTasksOnUpdate":      -5,
	"ManageSaleResultCodeSaleUpdateDetailsTasksNotFound":    -6,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageSaleResultCode
func (e ManageSaleResultCode) ValidEnum(v int32) bool {
	_, ok := manageSaleResultCodeMap[v]
	return ok
}
func (e ManageSaleResultCode) isFlag() bool {
	for i := len(ManageSaleResultCodeAll) - 1; i >= 0; i-- {
		expected := ManageSaleResultCode(2) << uint64(len(ManageSaleResultCodeAll)-1) >> uint64(len(ManageSaleResultCodeAll)-i)
		if expected != ManageSaleResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageSaleResultCode) String() string {
	name, _ := manageSaleResultCodeMap[int32(e)]
	return name
}

func (e ManageSaleResultCode) ShortString() string {
	name, _ := manageSaleResultCodeShortMap[int32(e)]
	return name
}

func (e ManageSaleResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageSaleResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageSaleResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageSaleResultCode(t.Value)
	return nil
}

// ManageSaleResultSuccessResponse is an XDR NestedUnion defines as:
//
//   union switch (ManageSaleAction action) {
//        case CREATE_UPDATE_DETAILS_REQUEST:
//            uint64 requestID;
//        case CANCEL:
//            void;
//        }
//
type ManageSaleResultSuccessResponse struct {
	Action    ManageSaleAction `json:"action,omitempty"`
	RequestId *Uint64          `json:"requestID,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageSaleResultSuccessResponse) SwitchFieldName() string {
	return "Action"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageSaleResultSuccessResponse
func (u ManageSaleResultSuccessResponse) ArmForSwitch(sw int32) (string, bool) {
	switch ManageSaleAction(sw) {
	case ManageSaleActionCreateUpdateDetailsRequest:
		return "RequestId", true
	case ManageSaleActionCancel:
		return "", true
	}
	return "-", false
}

// NewManageSaleResultSuccessResponse creates a new  ManageSaleResultSuccessResponse.
func NewManageSaleResultSuccessResponse(action ManageSaleAction, value interface{}) (result ManageSaleResultSuccessResponse, err error) {
	result.Action = action
	switch ManageSaleAction(action) {
	case ManageSaleActionCreateUpdateDetailsRequest:
		tv, ok := value.(Uint64)
		if !ok {
			err = fmt.Errorf("invalid value, must be Uint64")
			return
		}
		result.RequestId = &tv
	case ManageSaleActionCancel:
		// void
	}
	return
}

// MustRequestId retrieves the RequestId value from the union,
// panicing if the value is not set.
func (u ManageSaleResultSuccessResponse) MustRequestId() Uint64 {
	val, ok := u.GetRequestId()

	if !ok {
		panic("arm RequestId is not set")
	}

	return val
}

// GetRequestId retrieves the RequestId value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageSaleResultSuccessResponse) GetRequestId() (result Uint64, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "RequestId" {
		result = *u.RequestId
		ok = true
	}

	return
}

// ManageSaleResultSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ManageSaleResultSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageSaleResultSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageSaleResultSuccessExt
func (u ManageSaleResultSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageSaleResultSuccessExt creates a new  ManageSaleResultSuccessExt.
func NewManageSaleResultSuccessExt(v LedgerVersion, value interface{}) (result ManageSaleResultSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageSaleResultSuccess is an XDR Struct defines as:
//
//   //:Result of ManageSale operation successful application
//    struct ManageSaleResultSuccess
//    {
//        //: Indicates  whether or not the ManageSale request was auto approved and fulfilled
//        bool fulfilled; // can be used for any reviewable request type created with manage sale operation
//
//        //: response is used for additional information regarding the action performed on sale during operation application
//        union switch (ManageSaleAction action) {
//        case CREATE_UPDATE_DETAILS_REQUEST:
//            uint64 requestID;
//        case CANCEL:
//            void;
//        } response;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ManageSaleResultSuccess struct {
	Fulfilled bool                            `json:"fulfilled,omitempty"`
	Response  ManageSaleResultSuccessResponse `json:"response,omitempty"`
	Ext       ManageSaleResultSuccessExt      `json:"ext,omitempty"`
}

// ManageSaleResult is an XDR Union defines as:
//
//   //: Result of ManageSale operation application along with result code
//    union ManageSaleResult switch (ManageSaleResultCode code)
//    {
//    case SUCCESS:
//        ManageSaleResultSuccess success;
//    default:
//        void;
//    };
//
type ManageSaleResult struct {
	Code    ManageSaleResultCode     `json:"code,omitempty"`
	Success *ManageSaleResultSuccess `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageSaleResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageSaleResult
func (u ManageSaleResult) ArmForSwitch(sw int32) (string, bool) {
	switch ManageSaleResultCode(sw) {
	case ManageSaleResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewManageSaleResult creates a new  ManageSaleResult.
func NewManageSaleResult(code ManageSaleResultCode, value interface{}) (result ManageSaleResult, err error) {
	result.Code = code
	switch ManageSaleResultCode(code) {
	case ManageSaleResultCodeSuccess:
		tv, ok := value.(ManageSaleResultSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageSaleResultSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u ManageSaleResult) MustSuccess() ManageSaleResultSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageSaleResult) GetSuccess() (result ManageSaleResultSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// ManageSignerRoleAction is an XDR Enum defines as:
//
//   //: Actions that can be performed on a signer role
//    enum ManageSignerRoleAction
//    {
//        CREATE = 0,
//        UPDATE = 1,
//        REMOVE = 2
//    };
//
type ManageSignerRoleAction int32

const (
	ManageSignerRoleActionCreate ManageSignerRoleAction = 0
	ManageSignerRoleActionUpdate ManageSignerRoleAction = 1
	ManageSignerRoleActionRemove ManageSignerRoleAction = 2
)

var ManageSignerRoleActionAll = []ManageSignerRoleAction{
	ManageSignerRoleActionCreate,
	ManageSignerRoleActionUpdate,
	ManageSignerRoleActionRemove,
}

var manageSignerRoleActionMap = map[int32]string{
	0: "ManageSignerRoleActionCreate",
	1: "ManageSignerRoleActionUpdate",
	2: "ManageSignerRoleActionRemove",
}

var manageSignerRoleActionShortMap = map[int32]string{
	0: "create",
	1: "update",
	2: "remove",
}

var manageSignerRoleActionRevMap = map[string]int32{
	"ManageSignerRoleActionCreate": 0,
	"ManageSignerRoleActionUpdate": 1,
	"ManageSignerRoleActionRemove": 2,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageSignerRoleAction
func (e ManageSignerRoleAction) ValidEnum(v int32) bool {
	_, ok := manageSignerRoleActionMap[v]
	return ok
}
func (e ManageSignerRoleAction) isFlag() bool {
	for i := len(ManageSignerRoleActionAll) - 1; i >= 0; i-- {
		expected := ManageSignerRoleAction(2) << uint64(len(ManageSignerRoleActionAll)-1) >> uint64(len(ManageSignerRoleActionAll)-i)
		if expected != ManageSignerRoleActionAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageSignerRoleAction) String() string {
	name, _ := manageSignerRoleActionMap[int32(e)]
	return name
}

func (e ManageSignerRoleAction) ShortString() string {
	name, _ := manageSignerRoleActionShortMap[int32(e)]
	return name
}

func (e ManageSignerRoleAction) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageSignerRoleActionAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageSignerRoleAction) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageSignerRoleAction(t.Value)
	return nil
}

// CreateSignerRoleDataExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateSignerRoleDataExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateSignerRoleDataExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateSignerRoleDataExt
func (u CreateSignerRoleDataExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateSignerRoleDataExt creates a new  CreateSignerRoleDataExt.
func NewCreateSignerRoleDataExt(v LedgerVersion, value interface{}) (result CreateSignerRoleDataExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateSignerRoleData is an XDR Struct defines as:
//
//   //: CreateSignerRoleData is used to pass necessary params to create a new signer role
//    struct CreateSignerRoleData
//    {
//        //: Array of ids of existing, unique and not default rules
//        uint64 ruleIDs<>;
//        //: Indicates whether or not a rule can be modified in the future
//        bool isReadOnly;
//        //: Arbitrary stringified json object with details to attach to the role
//        longstring details;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type CreateSignerRoleData struct {
	RuleIDs    []Uint64                `json:"ruleIDs,omitempty"`
	IsReadOnly bool                    `json:"isReadOnly,omitempty"`
	Details    Longstring              `json:"details,omitempty"`
	Ext        CreateSignerRoleDataExt `json:"ext,omitempty"`
}

// UpdateSignerRoleDataExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type UpdateSignerRoleDataExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u UpdateSignerRoleDataExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of UpdateSignerRoleDataExt
func (u UpdateSignerRoleDataExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewUpdateSignerRoleDataExt creates a new  UpdateSignerRoleDataExt.
func NewUpdateSignerRoleDataExt(v LedgerVersion, value interface{}) (result UpdateSignerRoleDataExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// UpdateSignerRoleData is an XDR Struct defines as:
//
//   //: UpdateSignerRoleData is used to pass necessary params to update an existing signer role
//    struct UpdateSignerRoleData
//    {
//        //: ID of an existing signer role
//        uint64 roleID;
//        //: Array of ids of existing, unique and not default rules
//        uint64 ruleIDs<>;
//
//        //: Arbitrary stringified json object with details to attach to the role
//        longstring details;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type UpdateSignerRoleData struct {
	RoleId  Uint64                  `json:"roleID,omitempty"`
	RuleIDs []Uint64                `json:"ruleIDs,omitempty"`
	Details Longstring              `json:"details,omitempty"`
	Ext     UpdateSignerRoleDataExt `json:"ext,omitempty"`
}

// RemoveSignerRoleDataExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type RemoveSignerRoleDataExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u RemoveSignerRoleDataExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of RemoveSignerRoleDataExt
func (u RemoveSignerRoleDataExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewRemoveSignerRoleDataExt creates a new  RemoveSignerRoleDataExt.
func NewRemoveSignerRoleDataExt(v LedgerVersion, value interface{}) (result RemoveSignerRoleDataExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// RemoveSignerRoleData is an XDR Struct defines as:
//
//   //: RemoveSignerRoleData is used to pass necessary params to remove existing signer role
//    struct RemoveSignerRoleData
//    {
//        //: Identifier of an existing signer role
//        uint64 roleID;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type RemoveSignerRoleData struct {
	RoleId Uint64                  `json:"roleID,omitempty"`
	Ext    RemoveSignerRoleDataExt `json:"ext,omitempty"`
}

// ManageSignerRoleOpData is an XDR NestedUnion defines as:
//
//   union switch (ManageSignerRoleAction action)
//        {
//        case CREATE:
//            CreateSignerRoleData createData;
//        case UPDATE:
//            UpdateSignerRoleData updateData;
//        case REMOVE:
//            RemoveSignerRoleData removeData;
//        }
//
type ManageSignerRoleOpData struct {
	Action     ManageSignerRoleAction `json:"action,omitempty"`
	CreateData *CreateSignerRoleData  `json:"createData,omitempty"`
	UpdateData *UpdateSignerRoleData  `json:"updateData,omitempty"`
	RemoveData *RemoveSignerRoleData  `json:"removeData,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageSignerRoleOpData) SwitchFieldName() string {
	return "Action"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageSignerRoleOpData
func (u ManageSignerRoleOpData) ArmForSwitch(sw int32) (string, bool) {
	switch ManageSignerRoleAction(sw) {
	case ManageSignerRoleActionCreate:
		return "CreateData", true
	case ManageSignerRoleActionUpdate:
		return "UpdateData", true
	case ManageSignerRoleActionRemove:
		return "RemoveData", true
	}
	return "-", false
}

// NewManageSignerRoleOpData creates a new  ManageSignerRoleOpData.
func NewManageSignerRoleOpData(action ManageSignerRoleAction, value interface{}) (result ManageSignerRoleOpData, err error) {
	result.Action = action
	switch ManageSignerRoleAction(action) {
	case ManageSignerRoleActionCreate:
		tv, ok := value.(CreateSignerRoleData)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateSignerRoleData")
			return
		}
		result.CreateData = &tv
	case ManageSignerRoleActionUpdate:
		tv, ok := value.(UpdateSignerRoleData)
		if !ok {
			err = fmt.Errorf("invalid value, must be UpdateSignerRoleData")
			return
		}
		result.UpdateData = &tv
	case ManageSignerRoleActionRemove:
		tv, ok := value.(RemoveSignerRoleData)
		if !ok {
			err = fmt.Errorf("invalid value, must be RemoveSignerRoleData")
			return
		}
		result.RemoveData = &tv
	}
	return
}

// MustCreateData retrieves the CreateData value from the union,
// panicing if the value is not set.
func (u ManageSignerRoleOpData) MustCreateData() CreateSignerRoleData {
	val, ok := u.GetCreateData()

	if !ok {
		panic("arm CreateData is not set")
	}

	return val
}

// GetCreateData retrieves the CreateData value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageSignerRoleOpData) GetCreateData() (result CreateSignerRoleData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "CreateData" {
		result = *u.CreateData
		ok = true
	}

	return
}

// MustUpdateData retrieves the UpdateData value from the union,
// panicing if the value is not set.
func (u ManageSignerRoleOpData) MustUpdateData() UpdateSignerRoleData {
	val, ok := u.GetUpdateData()

	if !ok {
		panic("arm UpdateData is not set")
	}

	return val
}

// GetUpdateData retrieves the UpdateData value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageSignerRoleOpData) GetUpdateData() (result UpdateSignerRoleData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "UpdateData" {
		result = *u.UpdateData
		ok = true
	}

	return
}

// MustRemoveData retrieves the RemoveData value from the union,
// panicing if the value is not set.
func (u ManageSignerRoleOpData) MustRemoveData() RemoveSignerRoleData {
	val, ok := u.GetRemoveData()

	if !ok {
		panic("arm RemoveData is not set")
	}

	return val
}

// GetRemoveData retrieves the RemoveData value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageSignerRoleOpData) GetRemoveData() (result RemoveSignerRoleData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "RemoveData" {
		result = *u.RemoveData
		ok = true
	}

	return
}

// ManageSignerRoleOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ManageSignerRoleOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageSignerRoleOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageSignerRoleOpExt
func (u ManageSignerRoleOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageSignerRoleOpExt creates a new  ManageSignerRoleOpExt.
func NewManageSignerRoleOpExt(v LedgerVersion, value interface{}) (result ManageSignerRoleOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageSignerRoleOp is an XDR Struct defines as:
//
//   //: ManageSignerRoleOp is used to create, update or remove a signer role
//    struct ManageSignerRoleOp
//    {
//        //: data is used to pass one of `ManageSignerRoleAction` with required params
//        union switch (ManageSignerRoleAction action)
//        {
//        case CREATE:
//            CreateSignerRoleData createData;
//        case UPDATE:
//            UpdateSignerRoleData updateData;
//        case REMOVE:
//            RemoveSignerRoleData removeData;
//        } data;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ManageSignerRoleOp struct {
	Data ManageSignerRoleOpData `json:"data,omitempty"`
	Ext  ManageSignerRoleOpExt  `json:"ext,omitempty"`
}

// ManageSignerRoleResultCode is an XDR Enum defines as:
//
//   //: Result codes of ManageSignerRoleResultCode
//    enum ManageSignerRoleResultCode
//    {
//        //: Means that the specified action in `data` of ManageSignerRoleOp was successfully executed
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: There is no signer role with such id or the source cannot manage a role
//        NOT_FOUND = -1, // does not exist or owner mismatched
//        //: It is not allowed to remove role if it is attached to at least one singer
//        ROLE_IS_USED = -2,
//        //: Passed details have invalid json structure
//        INVALID_DETAILS = -3,
//        //: There is no rule with id passed through `ruleIDs`
//        NO_SUCH_RULE = -4,
//        //: It is not allowed to duplicate ids in `ruleIDs` array
//        RULE_ID_DUPLICATION = -5,
//        //: It is not allowed to pass ids of default rules on `ruleIDs` array
//        DEFAULT_RULE_ID_DUPLICATION = -6,
//        //: It is not allowed to pass ruleIDs that are more than maxSignerRuleCount (by default, 128)
//        TOO_MANY_RULE_IDS = -7
//    };
//
type ManageSignerRoleResultCode int32

const (
	ManageSignerRoleResultCodeSuccess                  ManageSignerRoleResultCode = 0
	ManageSignerRoleResultCodeNotFound                 ManageSignerRoleResultCode = -1
	ManageSignerRoleResultCodeRoleIsUsed               ManageSignerRoleResultCode = -2
	ManageSignerRoleResultCodeInvalidDetails           ManageSignerRoleResultCode = -3
	ManageSignerRoleResultCodeNoSuchRule               ManageSignerRoleResultCode = -4
	ManageSignerRoleResultCodeRuleIdDuplication        ManageSignerRoleResultCode = -5
	ManageSignerRoleResultCodeDefaultRuleIdDuplication ManageSignerRoleResultCode = -6
	ManageSignerRoleResultCodeTooManyRuleIds           ManageSignerRoleResultCode = -7
)

var ManageSignerRoleResultCodeAll = []ManageSignerRoleResultCode{
	ManageSignerRoleResultCodeSuccess,
	ManageSignerRoleResultCodeNotFound,
	ManageSignerRoleResultCodeRoleIsUsed,
	ManageSignerRoleResultCodeInvalidDetails,
	ManageSignerRoleResultCodeNoSuchRule,
	ManageSignerRoleResultCodeRuleIdDuplication,
	ManageSignerRoleResultCodeDefaultRuleIdDuplication,
	ManageSignerRoleResultCodeTooManyRuleIds,
}

var manageSignerRoleResultCodeMap = map[int32]string{
	0:  "ManageSignerRoleResultCodeSuccess",
	-1: "ManageSignerRoleResultCodeNotFound",
	-2: "ManageSignerRoleResultCodeRoleIsUsed",
	-3: "ManageSignerRoleResultCodeInvalidDetails",
	-4: "ManageSignerRoleResultCodeNoSuchRule",
	-5: "ManageSignerRoleResultCodeRuleIdDuplication",
	-6: "ManageSignerRoleResultCodeDefaultRuleIdDuplication",
	-7: "ManageSignerRoleResultCodeTooManyRuleIds",
}

var manageSignerRoleResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "not_found",
	-2: "role_is_used",
	-3: "invalid_details",
	-4: "no_such_rule",
	-5: "rule_id_duplication",
	-6: "default_rule_id_duplication",
	-7: "too_many_rule_ids",
}

var manageSignerRoleResultCodeRevMap = map[string]int32{
	"ManageSignerRoleResultCodeSuccess":                  0,
	"ManageSignerRoleResultCodeNotFound":                 -1,
	"ManageSignerRoleResultCodeRoleIsUsed":               -2,
	"ManageSignerRoleResultCodeInvalidDetails":           -3,
	"ManageSignerRoleResultCodeNoSuchRule":               -4,
	"ManageSignerRoleResultCodeRuleIdDuplication":        -5,
	"ManageSignerRoleResultCodeDefaultRuleIdDuplication": -6,
	"ManageSignerRoleResultCodeTooManyRuleIds":           -7,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageSignerRoleResultCode
func (e ManageSignerRoleResultCode) ValidEnum(v int32) bool {
	_, ok := manageSignerRoleResultCodeMap[v]
	return ok
}
func (e ManageSignerRoleResultCode) isFlag() bool {
	for i := len(ManageSignerRoleResultCodeAll) - 1; i >= 0; i-- {
		expected := ManageSignerRoleResultCode(2) << uint64(len(ManageSignerRoleResultCodeAll)-1) >> uint64(len(ManageSignerRoleResultCodeAll)-i)
		if expected != ManageSignerRoleResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageSignerRoleResultCode) String() string {
	name, _ := manageSignerRoleResultCodeMap[int32(e)]
	return name
}

func (e ManageSignerRoleResultCode) ShortString() string {
	name, _ := manageSignerRoleResultCodeShortMap[int32(e)]
	return name
}

func (e ManageSignerRoleResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageSignerRoleResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageSignerRoleResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageSignerRoleResultCode(t.Value)
	return nil
}

// ManageSignerRoleResultSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//                {
//                case EMPTY_VERSION:
//                    void;
//                }
//
type ManageSignerRoleResultSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageSignerRoleResultSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageSignerRoleResultSuccessExt
func (u ManageSignerRoleResultSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageSignerRoleResultSuccessExt creates a new  ManageSignerRoleResultSuccessExt.
func NewManageSignerRoleResultSuccessExt(v LedgerVersion, value interface{}) (result ManageSignerRoleResultSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageSignerRoleResultSuccess is an XDR NestedStruct defines as:
//
//   struct
//            {
//                //: id of a role that was managed
//                uint64 roleID;
//
//                //: reserved for future use
//                union switch (LedgerVersion v)
//                {
//                case EMPTY_VERSION:
//                    void;
//                }
//                ext;
//            }
//
type ManageSignerRoleResultSuccess struct {
	RoleId Uint64                           `json:"roleID,omitempty"`
	Ext    ManageSignerRoleResultSuccessExt `json:"ext,omitempty"`
}

// ManageSignerRoleResult is an XDR Union defines as:
//
//   //: Result of operation application
//    union ManageSignerRoleResult switch (ManageSignerRoleResultCode code)
//    {
//        case SUCCESS:
//            struct
//            {
//                //: id of a role that was managed
//                uint64 roleID;
//
//                //: reserved for future use
//                union switch (LedgerVersion v)
//                {
//                case EMPTY_VERSION:
//                    void;
//                }
//                ext;
//            } success;
//        case RULE_ID_DUPLICATION:
//        case DEFAULT_RULE_ID_DUPLICATION:
//        case NO_SUCH_RULE:
//            //: ID of a rule that was either duplicated or is default or does not exist
//            uint64 ruleID;
//        case TOO_MANY_RULE_IDS:
//            //: max count of rule ids that can be passed in `ruleIDs` array
//            uint64 maxRuleIDsCount;
//        default:
//            void;
//    };
//
type ManageSignerRoleResult struct {
	Code            ManageSignerRoleResultCode     `json:"code,omitempty"`
	Success         *ManageSignerRoleResultSuccess `json:"success,omitempty"`
	RuleId          *Uint64                        `json:"ruleID,omitempty"`
	MaxRuleIDsCount *Uint64                        `json:"maxRuleIDsCount,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageSignerRoleResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageSignerRoleResult
func (u ManageSignerRoleResult) ArmForSwitch(sw int32) (string, bool) {
	switch ManageSignerRoleResultCode(sw) {
	case ManageSignerRoleResultCodeSuccess:
		return "Success", true
	case ManageSignerRoleResultCodeRuleIdDuplication:
		return "RuleId", true
	case ManageSignerRoleResultCodeDefaultRuleIdDuplication:
		return "RuleId", true
	case ManageSignerRoleResultCodeNoSuchRule:
		return "RuleId", true
	case ManageSignerRoleResultCodeTooManyRuleIds:
		return "MaxRuleIDsCount", true
	default:
		return "", true
	}
}

// NewManageSignerRoleResult creates a new  ManageSignerRoleResult.
func NewManageSignerRoleResult(code ManageSignerRoleResultCode, value interface{}) (result ManageSignerRoleResult, err error) {
	result.Code = code
	switch ManageSignerRoleResultCode(code) {
	case ManageSignerRoleResultCodeSuccess:
		tv, ok := value.(ManageSignerRoleResultSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageSignerRoleResultSuccess")
			return
		}
		result.Success = &tv
	case ManageSignerRoleResultCodeRuleIdDuplication:
		tv, ok := value.(Uint64)
		if !ok {
			err = fmt.Errorf("invalid value, must be Uint64")
			return
		}
		result.RuleId = &tv
	case ManageSignerRoleResultCodeDefaultRuleIdDuplication:
		tv, ok := value.(Uint64)
		if !ok {
			err = fmt.Errorf("invalid value, must be Uint64")
			return
		}
		result.RuleId = &tv
	case ManageSignerRoleResultCodeNoSuchRule:
		tv, ok := value.(Uint64)
		if !ok {
			err = fmt.Errorf("invalid value, must be Uint64")
			return
		}
		result.RuleId = &tv
	case ManageSignerRoleResultCodeTooManyRuleIds:
		tv, ok := value.(Uint64)
		if !ok {
			err = fmt.Errorf("invalid value, must be Uint64")
			return
		}
		result.MaxRuleIDsCount = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u ManageSignerRoleResult) MustSuccess() ManageSignerRoleResultSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageSignerRoleResult) GetSuccess() (result ManageSignerRoleResultSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// MustRuleId retrieves the RuleId value from the union,
// panicing if the value is not set.
func (u ManageSignerRoleResult) MustRuleId() Uint64 {
	val, ok := u.GetRuleId()

	if !ok {
		panic("arm RuleId is not set")
	}

	return val
}

// GetRuleId retrieves the RuleId value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageSignerRoleResult) GetRuleId() (result Uint64, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "RuleId" {
		result = *u.RuleId
		ok = true
	}

	return
}

// MustMaxRuleIDsCount retrieves the MaxRuleIDsCount value from the union,
// panicing if the value is not set.
func (u ManageSignerRoleResult) MustMaxRuleIDsCount() Uint64 {
	val, ok := u.GetMaxRuleIDsCount()

	if !ok {
		panic("arm MaxRuleIDsCount is not set")
	}

	return val
}

// GetMaxRuleIDsCount retrieves the MaxRuleIDsCount value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageSignerRoleResult) GetMaxRuleIDsCount() (result Uint64, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "MaxRuleIDsCount" {
		result = *u.MaxRuleIDsCount
		ok = true
	}

	return
}

// ManageSignerRuleAction is an XDR Enum defines as:
//
//   //: Actions that can be performed with a signer rule
//    enum ManageSignerRuleAction
//    {
//        CREATE = 0,
//        UPDATE = 1,
//        REMOVE = 2
//    };
//
type ManageSignerRuleAction int32

const (
	ManageSignerRuleActionCreate ManageSignerRuleAction = 0
	ManageSignerRuleActionUpdate ManageSignerRuleAction = 1
	ManageSignerRuleActionRemove ManageSignerRuleAction = 2
)

var ManageSignerRuleActionAll = []ManageSignerRuleAction{
	ManageSignerRuleActionCreate,
	ManageSignerRuleActionUpdate,
	ManageSignerRuleActionRemove,
}

var manageSignerRuleActionMap = map[int32]string{
	0: "ManageSignerRuleActionCreate",
	1: "ManageSignerRuleActionUpdate",
	2: "ManageSignerRuleActionRemove",
}

var manageSignerRuleActionShortMap = map[int32]string{
	0: "create",
	1: "update",
	2: "remove",
}

var manageSignerRuleActionRevMap = map[string]int32{
	"ManageSignerRuleActionCreate": 0,
	"ManageSignerRuleActionUpdate": 1,
	"ManageSignerRuleActionRemove": 2,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageSignerRuleAction
func (e ManageSignerRuleAction) ValidEnum(v int32) bool {
	_, ok := manageSignerRuleActionMap[v]
	return ok
}
func (e ManageSignerRuleAction) isFlag() bool {
	for i := len(ManageSignerRuleActionAll) - 1; i >= 0; i-- {
		expected := ManageSignerRuleAction(2) << uint64(len(ManageSignerRuleActionAll)-1) >> uint64(len(ManageSignerRuleActionAll)-i)
		if expected != ManageSignerRuleActionAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageSignerRuleAction) String() string {
	name, _ := manageSignerRuleActionMap[int32(e)]
	return name
}

func (e ManageSignerRuleAction) ShortString() string {
	name, _ := manageSignerRuleActionShortMap[int32(e)]
	return name
}

func (e ManageSignerRuleAction) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageSignerRuleActionAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageSignerRuleAction) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageSignerRuleAction(t.Value)
	return nil
}

// CreateSignerRuleDataExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateSignerRuleDataExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateSignerRuleDataExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateSignerRuleDataExt
func (u CreateSignerRuleDataExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateSignerRuleDataExt creates a new  CreateSignerRuleDataExt.
func NewCreateSignerRuleDataExt(v LedgerVersion, value interface{}) (result CreateSignerRuleDataExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateSignerRuleData is an XDR Struct defines as:
//
//   //: CreateSignerRuleData is used to pass necessary params to create a new signer rule
//    struct CreateSignerRuleData
//    {
//        //: Resource is used to specify an entity (for some, with properties) that can be managed through operations
//        SignerRuleResource resource;
//        //: Value from enum that can be applied to `resource`
//        SignerRuleAction action;
//        //: Indicate whether or not an `action` on the provided `resource` is prohibited
//        bool forbids;
//        //: True means that such rule will be automatically added to each new or updated signer role
//        bool isDefault;
//        //: Indicates whether or not a rule can be modified in the future
//        bool isReadOnly;
//        //: Arbitrary stringified json object with details that will be attached to a rule
//        longstring details;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type CreateSignerRuleData struct {
	Resource   SignerRuleResource      `json:"resource,omitempty"`
	Action     SignerRuleAction        `json:"action,omitempty"`
	Forbids    bool                    `json:"forbids,omitempty"`
	IsDefault  bool                    `json:"isDefault,omitempty"`
	IsReadOnly bool                    `json:"isReadOnly,omitempty"`
	Details    Longstring              `json:"details,omitempty"`
	Ext        CreateSignerRuleDataExt `json:"ext,omitempty"`
}

// UpdateSignerRuleDataExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type UpdateSignerRuleDataExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u UpdateSignerRuleDataExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of UpdateSignerRuleDataExt
func (u UpdateSignerRuleDataExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewUpdateSignerRuleDataExt creates a new  UpdateSignerRuleDataExt.
func NewUpdateSignerRuleDataExt(v LedgerVersion, value interface{}) (result UpdateSignerRuleDataExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// UpdateSignerRuleData is an XDR Struct defines as:
//
//   //: UpdateSignerRuleData is used to pass necessary params to update an existing signer rule
//    struct UpdateSignerRuleData
//    {
//        //: Identifier of an existing signer rule
//        uint64 ruleID;
//        //: Resource is used to specify entity (for some, with properties) that can be managed through operations
//        SignerRuleResource resource;
//        //: Value from enum that can be applied to `resource`
//        SignerRuleAction action;
//        //: True means that such rule will be automatically added to each new or updated signer role
//        bool forbids;
//        //: True means that no one can manage such rule after creating
//        bool isDefault;
//        //: Arbitrary stringified json object with details that will be attached to a rule
//        longstring details;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type UpdateSignerRuleData struct {
	RuleId    Uint64                  `json:"ruleID,omitempty"`
	Resource  SignerRuleResource      `json:"resource,omitempty"`
	Action    SignerRuleAction        `json:"action,omitempty"`
	Forbids   bool                    `json:"forbids,omitempty"`
	IsDefault bool                    `json:"isDefault,omitempty"`
	Details   Longstring              `json:"details,omitempty"`
	Ext       UpdateSignerRuleDataExt `json:"ext,omitempty"`
}

// RemoveSignerRuleDataExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type RemoveSignerRuleDataExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u RemoveSignerRuleDataExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of RemoveSignerRuleDataExt
func (u RemoveSignerRuleDataExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewRemoveSignerRuleDataExt creates a new  RemoveSignerRuleDataExt.
func NewRemoveSignerRuleDataExt(v LedgerVersion, value interface{}) (result RemoveSignerRuleDataExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// RemoveSignerRuleData is an XDR Struct defines as:
//
//   //: RemoveSignerRuleData is used to pass necessary params to remove existing signer rule
//    struct RemoveSignerRuleData
//    {
//        //: Identifier of an existing signer rule
//        uint64 ruleID;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type RemoveSignerRuleData struct {
	RuleId Uint64                  `json:"ruleID,omitempty"`
	Ext    RemoveSignerRuleDataExt `json:"ext,omitempty"`
}

// ManageSignerRuleOpData is an XDR NestedUnion defines as:
//
//   union switch (ManageSignerRuleAction action)
//        {
//        case CREATE:
//            CreateSignerRuleData createData;
//        case UPDATE:
//            UpdateSignerRuleData updateData;
//        case REMOVE:
//            RemoveSignerRuleData removeData;
//        }
//
type ManageSignerRuleOpData struct {
	Action     ManageSignerRuleAction `json:"action,omitempty"`
	CreateData *CreateSignerRuleData  `json:"createData,omitempty"`
	UpdateData *UpdateSignerRuleData  `json:"updateData,omitempty"`
	RemoveData *RemoveSignerRuleData  `json:"removeData,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageSignerRuleOpData) SwitchFieldName() string {
	return "Action"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageSignerRuleOpData
func (u ManageSignerRuleOpData) ArmForSwitch(sw int32) (string, bool) {
	switch ManageSignerRuleAction(sw) {
	case ManageSignerRuleActionCreate:
		return "CreateData", true
	case ManageSignerRuleActionUpdate:
		return "UpdateData", true
	case ManageSignerRuleActionRemove:
		return "RemoveData", true
	}
	return "-", false
}

// NewManageSignerRuleOpData creates a new  ManageSignerRuleOpData.
func NewManageSignerRuleOpData(action ManageSignerRuleAction, value interface{}) (result ManageSignerRuleOpData, err error) {
	result.Action = action
	switch ManageSignerRuleAction(action) {
	case ManageSignerRuleActionCreate:
		tv, ok := value.(CreateSignerRuleData)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateSignerRuleData")
			return
		}
		result.CreateData = &tv
	case ManageSignerRuleActionUpdate:
		tv, ok := value.(UpdateSignerRuleData)
		if !ok {
			err = fmt.Errorf("invalid value, must be UpdateSignerRuleData")
			return
		}
		result.UpdateData = &tv
	case ManageSignerRuleActionRemove:
		tv, ok := value.(RemoveSignerRuleData)
		if !ok {
			err = fmt.Errorf("invalid value, must be RemoveSignerRuleData")
			return
		}
		result.RemoveData = &tv
	}
	return
}

// MustCreateData retrieves the CreateData value from the union,
// panicing if the value is not set.
func (u ManageSignerRuleOpData) MustCreateData() CreateSignerRuleData {
	val, ok := u.GetCreateData()

	if !ok {
		panic("arm CreateData is not set")
	}

	return val
}

// GetCreateData retrieves the CreateData value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageSignerRuleOpData) GetCreateData() (result CreateSignerRuleData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "CreateData" {
		result = *u.CreateData
		ok = true
	}

	return
}

// MustUpdateData retrieves the UpdateData value from the union,
// panicing if the value is not set.
func (u ManageSignerRuleOpData) MustUpdateData() UpdateSignerRuleData {
	val, ok := u.GetUpdateData()

	if !ok {
		panic("arm UpdateData is not set")
	}

	return val
}

// GetUpdateData retrieves the UpdateData value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageSignerRuleOpData) GetUpdateData() (result UpdateSignerRuleData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "UpdateData" {
		result = *u.UpdateData
		ok = true
	}

	return
}

// MustRemoveData retrieves the RemoveData value from the union,
// panicing if the value is not set.
func (u ManageSignerRuleOpData) MustRemoveData() RemoveSignerRuleData {
	val, ok := u.GetRemoveData()

	if !ok {
		panic("arm RemoveData is not set")
	}

	return val
}

// GetRemoveData retrieves the RemoveData value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageSignerRuleOpData) GetRemoveData() (result RemoveSignerRuleData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "RemoveData" {
		result = *u.RemoveData
		ok = true
	}

	return
}

// ManageSignerRuleOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ManageSignerRuleOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageSignerRuleOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageSignerRuleOpExt
func (u ManageSignerRuleOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageSignerRuleOpExt creates a new  ManageSignerRuleOpExt.
func NewManageSignerRuleOpExt(v LedgerVersion, value interface{}) (result ManageSignerRuleOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageSignerRuleOp is an XDR Struct defines as:
//
//   //: ManageSignerRuleOp is used to create, update or remove signer rule
//    struct ManageSignerRuleOp
//    {
//        //: data is used to pass one of `ManageSignerRuleAction` with required params
//        union switch (ManageSignerRuleAction action)
//        {
//        case CREATE:
//            CreateSignerRuleData createData;
//        case UPDATE:
//            UpdateSignerRuleData updateData;
//        case REMOVE:
//            RemoveSignerRuleData removeData;
//        } data;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ManageSignerRuleOp struct {
	Data ManageSignerRuleOpData `json:"data,omitempty"`
	Ext  ManageSignerRuleOpExt  `json:"ext,omitempty"`
}

// ManageSignerRuleResultCode is an XDR Enum defines as:
//
//   //: Result codes of ManageSignerRuleOp
//    enum ManageSignerRuleResultCode
//    {
//        //: Specified action in `data` of ManageSignerRuleOp was successfully executed
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: There is no signer rule with such id or source cannot manage the rule
//        NOT_FOUND = -1, // does not exists or owner mismatched
//        //: It is not allowed to remove the rule if it is attached to at least one role
//        RULE_IS_USED = -2,
//        //: Passed details have invalid json structure
//        INVALID_DETAILS = -3,
//        //: Custom rule action can not be used with entries other than CUSTOM
//        INVALID_ACTION = -4
//    };
//
type ManageSignerRuleResultCode int32

const (
	ManageSignerRuleResultCodeSuccess        ManageSignerRuleResultCode = 0
	ManageSignerRuleResultCodeNotFound       ManageSignerRuleResultCode = -1
	ManageSignerRuleResultCodeRuleIsUsed     ManageSignerRuleResultCode = -2
	ManageSignerRuleResultCodeInvalidDetails ManageSignerRuleResultCode = -3
	ManageSignerRuleResultCodeInvalidAction  ManageSignerRuleResultCode = -4
)

var ManageSignerRuleResultCodeAll = []ManageSignerRuleResultCode{
	ManageSignerRuleResultCodeSuccess,
	ManageSignerRuleResultCodeNotFound,
	ManageSignerRuleResultCodeRuleIsUsed,
	ManageSignerRuleResultCodeInvalidDetails,
	ManageSignerRuleResultCodeInvalidAction,
}

var manageSignerRuleResultCodeMap = map[int32]string{
	0:  "ManageSignerRuleResultCodeSuccess",
	-1: "ManageSignerRuleResultCodeNotFound",
	-2: "ManageSignerRuleResultCodeRuleIsUsed",
	-3: "ManageSignerRuleResultCodeInvalidDetails",
	-4: "ManageSignerRuleResultCodeInvalidAction",
}

var manageSignerRuleResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "not_found",
	-2: "rule_is_used",
	-3: "invalid_details",
	-4: "invalid_action",
}

var manageSignerRuleResultCodeRevMap = map[string]int32{
	"ManageSignerRuleResultCodeSuccess":        0,
	"ManageSignerRuleResultCodeNotFound":       -1,
	"ManageSignerRuleResultCodeRuleIsUsed":     -2,
	"ManageSignerRuleResultCodeInvalidDetails": -3,
	"ManageSignerRuleResultCodeInvalidAction":  -4,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageSignerRuleResultCode
func (e ManageSignerRuleResultCode) ValidEnum(v int32) bool {
	_, ok := manageSignerRuleResultCodeMap[v]
	return ok
}
func (e ManageSignerRuleResultCode) isFlag() bool {
	for i := len(ManageSignerRuleResultCodeAll) - 1; i >= 0; i-- {
		expected := ManageSignerRuleResultCode(2) << uint64(len(ManageSignerRuleResultCodeAll)-1) >> uint64(len(ManageSignerRuleResultCodeAll)-i)
		if expected != ManageSignerRuleResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageSignerRuleResultCode) String() string {
	name, _ := manageSignerRuleResultCodeMap[int32(e)]
	return name
}

func (e ManageSignerRuleResultCode) ShortString() string {
	name, _ := manageSignerRuleResultCodeShortMap[int32(e)]
	return name
}

func (e ManageSignerRuleResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageSignerRuleResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageSignerRuleResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageSignerRuleResultCode(t.Value)
	return nil
}

// ManageSignerRuleResultSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//                {
//                case EMPTY_VERSION:
//                    void;
//                }
//
type ManageSignerRuleResultSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageSignerRuleResultSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageSignerRuleResultSuccessExt
func (u ManageSignerRuleResultSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageSignerRuleResultSuccessExt creates a new  ManageSignerRuleResultSuccessExt.
func NewManageSignerRuleResultSuccessExt(v LedgerVersion, value interface{}) (result ManageSignerRuleResultSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageSignerRuleResultSuccess is an XDR NestedStruct defines as:
//
//   struct {
//                //: id of the rule that was managed
//                uint64 ruleID;
//
//                //: reserved for future use
//                union switch (LedgerVersion v)
//                {
//                case EMPTY_VERSION:
//                    void;
//                }
//                ext;
//            }
//
type ManageSignerRuleResultSuccess struct {
	RuleId Uint64                           `json:"ruleID,omitempty"`
	Ext    ManageSignerRuleResultSuccessExt `json:"ext,omitempty"`
}

// ManageSignerRuleResult is an XDR Union defines as:
//
//   //: Result of operation application
//    union ManageSignerRuleResult switch (ManageSignerRuleResultCode code)
//    {
//        case SUCCESS:
//            struct {
//                //: id of the rule that was managed
//                uint64 ruleID;
//
//                //: reserved for future use
//                union switch (LedgerVersion v)
//                {
//                case EMPTY_VERSION:
//                    void;
//                }
//                ext;
//            } success;
//        case RULE_IS_USED:
//            //: ids of roles which use a rule that cannot be removed
//            uint64 roleIDs<>;
//        default:
//            void;
//    };
//
type ManageSignerRuleResult struct {
	Code    ManageSignerRuleResultCode     `json:"code,omitempty"`
	Success *ManageSignerRuleResultSuccess `json:"success,omitempty"`
	RoleIDs *[]Uint64                      `json:"roleIDs,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageSignerRuleResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageSignerRuleResult
func (u ManageSignerRuleResult) ArmForSwitch(sw int32) (string, bool) {
	switch ManageSignerRuleResultCode(sw) {
	case ManageSignerRuleResultCodeSuccess:
		return "Success", true
	case ManageSignerRuleResultCodeRuleIsUsed:
		return "RoleIDs", true
	default:
		return "", true
	}
}

// NewManageSignerRuleResult creates a new  ManageSignerRuleResult.
func NewManageSignerRuleResult(code ManageSignerRuleResultCode, value interface{}) (result ManageSignerRuleResult, err error) {
	result.Code = code
	switch ManageSignerRuleResultCode(code) {
	case ManageSignerRuleResultCodeSuccess:
		tv, ok := value.(ManageSignerRuleResultSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageSignerRuleResultSuccess")
			return
		}
		result.Success = &tv
	case ManageSignerRuleResultCodeRuleIsUsed:
		tv, ok := value.([]Uint64)
		if !ok {
			err = fmt.Errorf("invalid value, must be []Uint64")
			return
		}
		result.RoleIDs = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u ManageSignerRuleResult) MustSuccess() ManageSignerRuleResultSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageSignerRuleResult) GetSuccess() (result ManageSignerRuleResultSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// MustRoleIDs retrieves the RoleIDs value from the union,
// panicing if the value is not set.
func (u ManageSignerRuleResult) MustRoleIDs() []Uint64 {
	val, ok := u.GetRoleIDs()

	if !ok {
		panic("arm RoleIDs is not set")
	}

	return val
}

// GetRoleIDs retrieves the RoleIDs value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageSignerRuleResult) GetRoleIDs() (result []Uint64, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "RoleIDs" {
		result = *u.RoleIDs
		ok = true
	}

	return
}

// ManageSignerAction is an XDR Enum defines as:
//
//   //: Actions that can be applied to a signer
//    enum ManageSignerAction
//    {
//        CREATE = 0,
//        UPDATE = 1,
//        REMOVE = 2
//    };
//
type ManageSignerAction int32

const (
	ManageSignerActionCreate ManageSignerAction = 0
	ManageSignerActionUpdate ManageSignerAction = 1
	ManageSignerActionRemove ManageSignerAction = 2
)

var ManageSignerActionAll = []ManageSignerAction{
	ManageSignerActionCreate,
	ManageSignerActionUpdate,
	ManageSignerActionRemove,
}

var manageSignerActionMap = map[int32]string{
	0: "ManageSignerActionCreate",
	1: "ManageSignerActionUpdate",
	2: "ManageSignerActionRemove",
}

var manageSignerActionShortMap = map[int32]string{
	0: "create",
	1: "update",
	2: "remove",
}

var manageSignerActionRevMap = map[string]int32{
	"ManageSignerActionCreate": 0,
	"ManageSignerActionUpdate": 1,
	"ManageSignerActionRemove": 2,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageSignerAction
func (e ManageSignerAction) ValidEnum(v int32) bool {
	_, ok := manageSignerActionMap[v]
	return ok
}
func (e ManageSignerAction) isFlag() bool {
	for i := len(ManageSignerActionAll) - 1; i >= 0; i-- {
		expected := ManageSignerAction(2) << uint64(len(ManageSignerActionAll)-1) >> uint64(len(ManageSignerActionAll)-i)
		if expected != ManageSignerActionAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageSignerAction) String() string {
	name, _ := manageSignerActionMap[int32(e)]
	return name
}

func (e ManageSignerAction) ShortString() string {
	name, _ := manageSignerActionShortMap[int32(e)]
	return name
}

func (e ManageSignerAction) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageSignerActionAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageSignerAction) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageSignerAction(t.Value)
	return nil
}

// UpdateSignerData is an XDR Struct defines as:
//
//   //: UpdateSignerData is used to pass necessary data to create or update the signer
//    struct UpdateSignerData
//    {
//        //: Public key of a signer
//        PublicKey publicKey;
//        //: id of the role that will be attached to a signer
//        uint64 roleID;
//
//        //: weight that signer will have, threshold for all SignerRequirements equals 1000
//        uint32 weight;
//        //: If there are some signers with equal identity, only one signer will be chosen
//        //: (either the one with the biggest weight or the one who was the first to satisfy a threshold)
//        uint32 identity;
//
//        //: Arbitrary stringified json object with details that will be attached to signer
//        longstring details;
//
//        //: reserved for future extension
//        EmptyExt ext;
//    };
//
type UpdateSignerData struct {
	PublicKey PublicKey  `json:"publicKey,omitempty"`
	RoleId    Uint64     `json:"roleID,omitempty"`
	Weight    Uint32     `json:"weight,omitempty"`
	Identity  Uint32     `json:"identity,omitempty"`
	Details   Longstring `json:"details,omitempty"`
	Ext       EmptyExt   `json:"ext,omitempty"`
}

// RemoveSignerData is an XDR Struct defines as:
//
//   //: RemoveSignerData is used to pass necessary data to remove a signer
//    struct RemoveSignerData
//    {
//        //: Public key of an existing signer
//        PublicKey publicKey;
//
//        //: reserved for future extension
//        EmptyExt ext;
//    };
//
type RemoveSignerData struct {
	PublicKey PublicKey `json:"publicKey,omitempty"`
	Ext       EmptyExt  `json:"ext,omitempty"`
}

// ManageSignerOpData is an XDR NestedUnion defines as:
//
//   union switch (ManageSignerAction action)
//        {
//        case CREATE:
//            UpdateSignerData createData;
//        case UPDATE:
//            UpdateSignerData updateData;
//        case REMOVE:
//            RemoveSignerData removeData;
//        }
//
type ManageSignerOpData struct {
	Action     ManageSignerAction `json:"action,omitempty"`
	CreateData *UpdateSignerData  `json:"createData,omitempty"`
	UpdateData *UpdateSignerData  `json:"updateData,omitempty"`
	RemoveData *RemoveSignerData  `json:"removeData,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageSignerOpData) SwitchFieldName() string {
	return "Action"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageSignerOpData
func (u ManageSignerOpData) ArmForSwitch(sw int32) (string, bool) {
	switch ManageSignerAction(sw) {
	case ManageSignerActionCreate:
		return "CreateData", true
	case ManageSignerActionUpdate:
		return "UpdateData", true
	case ManageSignerActionRemove:
		return "RemoveData", true
	}
	return "-", false
}

// NewManageSignerOpData creates a new  ManageSignerOpData.
func NewManageSignerOpData(action ManageSignerAction, value interface{}) (result ManageSignerOpData, err error) {
	result.Action = action
	switch ManageSignerAction(action) {
	case ManageSignerActionCreate:
		tv, ok := value.(UpdateSignerData)
		if !ok {
			err = fmt.Errorf("invalid value, must be UpdateSignerData")
			return
		}
		result.CreateData = &tv
	case ManageSignerActionUpdate:
		tv, ok := value.(UpdateSignerData)
		if !ok {
			err = fmt.Errorf("invalid value, must be UpdateSignerData")
			return
		}
		result.UpdateData = &tv
	case ManageSignerActionRemove:
		tv, ok := value.(RemoveSignerData)
		if !ok {
			err = fmt.Errorf("invalid value, must be RemoveSignerData")
			return
		}
		result.RemoveData = &tv
	}
	return
}

// MustCreateData retrieves the CreateData value from the union,
// panicing if the value is not set.
func (u ManageSignerOpData) MustCreateData() UpdateSignerData {
	val, ok := u.GetCreateData()

	if !ok {
		panic("arm CreateData is not set")
	}

	return val
}

// GetCreateData retrieves the CreateData value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageSignerOpData) GetCreateData() (result UpdateSignerData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "CreateData" {
		result = *u.CreateData
		ok = true
	}

	return
}

// MustUpdateData retrieves the UpdateData value from the union,
// panicing if the value is not set.
func (u ManageSignerOpData) MustUpdateData() UpdateSignerData {
	val, ok := u.GetUpdateData()

	if !ok {
		panic("arm UpdateData is not set")
	}

	return val
}

// GetUpdateData retrieves the UpdateData value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageSignerOpData) GetUpdateData() (result UpdateSignerData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "UpdateData" {
		result = *u.UpdateData
		ok = true
	}

	return
}

// MustRemoveData retrieves the RemoveData value from the union,
// panicing if the value is not set.
func (u ManageSignerOpData) MustRemoveData() RemoveSignerData {
	val, ok := u.GetRemoveData()

	if !ok {
		panic("arm RemoveData is not set")
	}

	return val
}

// GetRemoveData retrieves the RemoveData value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageSignerOpData) GetRemoveData() (result RemoveSignerData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "RemoveData" {
		result = *u.RemoveData
		ok = true
	}

	return
}

// ManageSignerOp is an XDR Struct defines as:
//
//   //: ManageSignerOp is used to create, update or remove a signer
//    struct ManageSignerOp
//    {
//        //: data is used to pass one of `ManageSignerAction` with required params
//        union switch (ManageSignerAction action)
//        {
//        case CREATE:
//            UpdateSignerData createData;
//        case UPDATE:
//            UpdateSignerData updateData;
//        case REMOVE:
//            RemoveSignerData removeData;
//        }
//        data;
//
//        //: reserved for future extension
//        EmptyExt ext;
//    };
//
type ManageSignerOp struct {
	Data ManageSignerOpData `json:"data,omitempty"`
	Ext  EmptyExt           `json:"ext,omitempty"`
}

// ManageSignerResultCode is an XDR Enum defines as:
//
//   //: Result codes of ManageSignerOp
//    enum ManageSignerResultCode
//    {
//        //: Specified action in `data` of ManageSignerOp was successfully executed
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: Passed details have invalid json structure
//        INVALID_DETAILS = -1, // invalid json details
//        //: Signer with such public key is already attached to the source account
//        ALREADY_EXISTS = -2, // signer already exist
//        //: There is no role with such id
//        NO_SUCH_ROLE = -3,
//        //: It is not allowed to set weight more than 1000
//        INVALID_WEIGHT = -4, // more than 1000
//        //: Source account does not have a signer with the provided public key
//        NOT_FOUND = -5, // there is no signer with such public key
//        //: only occurs during the creation of signers for admins if the number of signers exceeds the number specified in a license
//    	NUMBER_OF_ADMINS_EXCEEDS_LICENSE = -6
//    };
//
type ManageSignerResultCode int32

const (
	ManageSignerResultCodeSuccess                      ManageSignerResultCode = 0
	ManageSignerResultCodeInvalidDetails               ManageSignerResultCode = -1
	ManageSignerResultCodeAlreadyExists                ManageSignerResultCode = -2
	ManageSignerResultCodeNoSuchRole                   ManageSignerResultCode = -3
	ManageSignerResultCodeInvalidWeight                ManageSignerResultCode = -4
	ManageSignerResultCodeNotFound                     ManageSignerResultCode = -5
	ManageSignerResultCodeNumberOfAdminsExceedsLicense ManageSignerResultCode = -6
)

var ManageSignerResultCodeAll = []ManageSignerResultCode{
	ManageSignerResultCodeSuccess,
	ManageSignerResultCodeInvalidDetails,
	ManageSignerResultCodeAlreadyExists,
	ManageSignerResultCodeNoSuchRole,
	ManageSignerResultCodeInvalidWeight,
	ManageSignerResultCodeNotFound,
	ManageSignerResultCodeNumberOfAdminsExceedsLicense,
}

var manageSignerResultCodeMap = map[int32]string{
	0:  "ManageSignerResultCodeSuccess",
	-1: "ManageSignerResultCodeInvalidDetails",
	-2: "ManageSignerResultCodeAlreadyExists",
	-3: "ManageSignerResultCodeNoSuchRole",
	-4: "ManageSignerResultCodeInvalidWeight",
	-5: "ManageSignerResultCodeNotFound",
	-6: "ManageSignerResultCodeNumberOfAdminsExceedsLicense",
}

var manageSignerResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "invalid_details",
	-2: "already_exists",
	-3: "no_such_role",
	-4: "invalid_weight",
	-5: "not_found",
	-6: "number_of_admins_exceeds_license",
}

var manageSignerResultCodeRevMap = map[string]int32{
	"ManageSignerResultCodeSuccess":                      0,
	"ManageSignerResultCodeInvalidDetails":               -1,
	"ManageSignerResultCodeAlreadyExists":                -2,
	"ManageSignerResultCodeNoSuchRole":                   -3,
	"ManageSignerResultCodeInvalidWeight":                -4,
	"ManageSignerResultCodeNotFound":                     -5,
	"ManageSignerResultCodeNumberOfAdminsExceedsLicense": -6,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageSignerResultCode
func (e ManageSignerResultCode) ValidEnum(v int32) bool {
	_, ok := manageSignerResultCodeMap[v]
	return ok
}
func (e ManageSignerResultCode) isFlag() bool {
	for i := len(ManageSignerResultCodeAll) - 1; i >= 0; i-- {
		expected := ManageSignerResultCode(2) << uint64(len(ManageSignerResultCodeAll)-1) >> uint64(len(ManageSignerResultCodeAll)-i)
		if expected != ManageSignerResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageSignerResultCode) String() string {
	name, _ := manageSignerResultCodeMap[int32(e)]
	return name
}

func (e ManageSignerResultCode) ShortString() string {
	name, _ := manageSignerResultCodeShortMap[int32(e)]
	return name
}

func (e ManageSignerResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageSignerResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageSignerResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageSignerResultCode(t.Value)
	return nil
}

// ManageSignerResult is an XDR Union defines as:
//
//   //: Result of operation application
//    union ManageSignerResult switch (ManageSignerResultCode code)
//    {
//    case SUCCESS:
//        //: reserved for future extension
//        EmptyExt ext;
//    default:
//        void;
//    };
//
type ManageSignerResult struct {
	Code ManageSignerResultCode `json:"code,omitempty"`
	Ext  *EmptyExt              `json:"ext,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageSignerResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageSignerResult
func (u ManageSignerResult) ArmForSwitch(sw int32) (string, bool) {
	switch ManageSignerResultCode(sw) {
	case ManageSignerResultCodeSuccess:
		return "Ext", true
	default:
		return "", true
	}
}

// NewManageSignerResult creates a new  ManageSignerResult.
func NewManageSignerResult(code ManageSignerResultCode, value interface{}) (result ManageSignerResult, err error) {
	result.Code = code
	switch ManageSignerResultCode(code) {
	case ManageSignerResultCodeSuccess:
		tv, ok := value.(EmptyExt)
		if !ok {
			err = fmt.Errorf("invalid value, must be EmptyExt")
			return
		}
		result.Ext = &tv
	default:
		// void
	}
	return
}

// MustExt retrieves the Ext value from the union,
// panicing if the value is not set.
func (u ManageSignerResult) MustExt() EmptyExt {
	val, ok := u.GetExt()

	if !ok {
		panic("arm Ext is not set")
	}

	return val
}

// GetExt retrieves the Ext value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageSignerResult) GetExt() (result EmptyExt, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Ext" {
		result = *u.Ext
		ok = true
	}

	return
}

// ManageVoteAction is an XDR Enum defines as:
//
//   //: Actions that can be applied to a vote entry
//    enum ManageVoteAction
//    {
//        CREATE = 0,
//        REMOVE = 1
//    };
//
type ManageVoteAction int32

const (
	ManageVoteActionCreate ManageVoteAction = 0
	ManageVoteActionRemove ManageVoteAction = 1
)

var ManageVoteActionAll = []ManageVoteAction{
	ManageVoteActionCreate,
	ManageVoteActionRemove,
}

var manageVoteActionMap = map[int32]string{
	0: "ManageVoteActionCreate",
	1: "ManageVoteActionRemove",
}

var manageVoteActionShortMap = map[int32]string{
	0: "create",
	1: "remove",
}

var manageVoteActionRevMap = map[string]int32{
	"ManageVoteActionCreate": 0,
	"ManageVoteActionRemove": 1,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageVoteAction
func (e ManageVoteAction) ValidEnum(v int32) bool {
	_, ok := manageVoteActionMap[v]
	return ok
}
func (e ManageVoteAction) isFlag() bool {
	for i := len(ManageVoteActionAll) - 1; i >= 0; i-- {
		expected := ManageVoteAction(2) << uint64(len(ManageVoteActionAll)-1) >> uint64(len(ManageVoteActionAll)-i)
		if expected != ManageVoteActionAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageVoteAction) String() string {
	name, _ := manageVoteActionMap[int32(e)]
	return name
}

func (e ManageVoteAction) ShortString() string {
	name, _ := manageVoteActionShortMap[int32(e)]
	return name
}

func (e ManageVoteAction) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageVoteActionAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageVoteAction) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageVoteAction(t.Value)
	return nil
}

// CreateVoteDataExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateVoteDataExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateVoteDataExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateVoteDataExt
func (u CreateVoteDataExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateVoteDataExt creates a new  CreateVoteDataExt.
func NewCreateVoteDataExt(v LedgerVersion, value interface{}) (result CreateVoteDataExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateVoteData is an XDR Struct defines as:
//
//   //: CreateVoteData is used to pass needed params to create (send) vote
//    struct CreateVoteData
//    {
//        //: ID of poll to vote in
//        uint64 pollID;
//
//        //: `data` is used to pass choice with functional type of poll
//        VoteData data;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type CreateVoteData struct {
	PollId Uint64            `json:"pollID,omitempty"`
	Data   VoteData          `json:"data,omitempty"`
	Ext    CreateVoteDataExt `json:"ext,omitempty"`
}

// RemoveVoteDataExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type RemoveVoteDataExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u RemoveVoteDataExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of RemoveVoteDataExt
func (u RemoveVoteDataExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewRemoveVoteDataExt creates a new  RemoveVoteDataExt.
func NewRemoveVoteDataExt(v LedgerVersion, value interface{}) (result RemoveVoteDataExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// RemoveVoteData is an XDR Struct defines as:
//
//   //: RemoveVoteData is used to pass needed params to remove (cancel) own vote
//    struct RemoveVoteData
//    {
//        //: ID of poll
//        uint64 pollID;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type RemoveVoteData struct {
	PollId Uint64            `json:"pollID,omitempty"`
	Ext    RemoveVoteDataExt `json:"ext,omitempty"`
}

// ManageVoteOpData is an XDR NestedUnion defines as:
//
//   union switch (ManageVoteAction action)
//        {
//        case CREATE:
//            CreateVoteData createData;
//        case REMOVE:
//            RemoveVoteData removeData;
//        }
//
type ManageVoteOpData struct {
	Action     ManageVoteAction `json:"action,omitempty"`
	CreateData *CreateVoteData  `json:"createData,omitempty"`
	RemoveData *RemoveVoteData  `json:"removeData,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageVoteOpData) SwitchFieldName() string {
	return "Action"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageVoteOpData
func (u ManageVoteOpData) ArmForSwitch(sw int32) (string, bool) {
	switch ManageVoteAction(sw) {
	case ManageVoteActionCreate:
		return "CreateData", true
	case ManageVoteActionRemove:
		return "RemoveData", true
	}
	return "-", false
}

// NewManageVoteOpData creates a new  ManageVoteOpData.
func NewManageVoteOpData(action ManageVoteAction, value interface{}) (result ManageVoteOpData, err error) {
	result.Action = action
	switch ManageVoteAction(action) {
	case ManageVoteActionCreate:
		tv, ok := value.(CreateVoteData)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateVoteData")
			return
		}
		result.CreateData = &tv
	case ManageVoteActionRemove:
		tv, ok := value.(RemoveVoteData)
		if !ok {
			err = fmt.Errorf("invalid value, must be RemoveVoteData")
			return
		}
		result.RemoveData = &tv
	}
	return
}

// MustCreateData retrieves the CreateData value from the union,
// panicing if the value is not set.
func (u ManageVoteOpData) MustCreateData() CreateVoteData {
	val, ok := u.GetCreateData()

	if !ok {
		panic("arm CreateData is not set")
	}

	return val
}

// GetCreateData retrieves the CreateData value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageVoteOpData) GetCreateData() (result CreateVoteData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "CreateData" {
		result = *u.CreateData
		ok = true
	}

	return
}

// MustRemoveData retrieves the RemoveData value from the union,
// panicing if the value is not set.
func (u ManageVoteOpData) MustRemoveData() RemoveVoteData {
	val, ok := u.GetRemoveData()

	if !ok {
		panic("arm RemoveData is not set")
	}

	return val
}

// GetRemoveData retrieves the RemoveData value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageVoteOpData) GetRemoveData() (result RemoveVoteData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Action))

	if armName == "RemoveData" {
		result = *u.RemoveData
		ok = true
	}

	return
}

// ManageVoteOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ManageVoteOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageVoteOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageVoteOpExt
func (u ManageVoteOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewManageVoteOpExt creates a new  ManageVoteOpExt.
func NewManageVoteOpExt(v LedgerVersion, value interface{}) (result ManageVoteOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ManageVoteOp is an XDR Struct defines as:
//
//   //: ManageVoteOp is used to create (send) or remove (cancel) vote
//    struct ManageVoteOp
//    {
//        //: `data` is used to pass `ManageVoteAction` with needed params
//        union switch (ManageVoteAction action)
//        {
//        case CREATE:
//            CreateVoteData createData;
//        case REMOVE:
//            RemoveVoteData removeData;
//        }
//        data;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type ManageVoteOp struct {
	Data ManageVoteOpData `json:"data,omitempty"`
	Ext  ManageVoteOpExt  `json:"ext,omitempty"`
}

// ManageVoteResultCode is an XDR Enum defines as:
//
//   //: Result code of ManageVoteOp
//    enum ManageVoteResultCode
//    {
//        // codes considered as "success" for the operation
//        //: Specified action in `data` of ManageVoteOp was successfully executed
//        SUCCESS = 0,
//
//        // codes considered as "failure" for the operation
//        //: There is no vote from source account in such poll
//        VOTE_NOT_FOUND = -1, // vote to remove  not found
//        //: There is no poll with such id
//        POLL_NOT_FOUND = -2, // poll not found
//        //: Not allowed to create (send) two votes for one poll
//        VOTE_EXISTS = -3,
//        //: Not allowed to create (send) vote with functional type that is different from the poll functional type
//        POLL_TYPE_MISMATCHED = -4,
//        //: Not allowed to vote in poll which not started yet
//        POLL_NOT_STARTED = -5,
//        //: Not allowed to vote in poll which already was ended
//        POLL_ENDED = -6
//    };
//
type ManageVoteResultCode int32

const (
	ManageVoteResultCodeSuccess            ManageVoteResultCode = 0
	ManageVoteResultCodeVoteNotFound       ManageVoteResultCode = -1
	ManageVoteResultCodePollNotFound       ManageVoteResultCode = -2
	ManageVoteResultCodeVoteExists         ManageVoteResultCode = -3
	ManageVoteResultCodePollTypeMismatched ManageVoteResultCode = -4
	ManageVoteResultCodePollNotStarted     ManageVoteResultCode = -5
	ManageVoteResultCodePollEnded          ManageVoteResultCode = -6
)

var ManageVoteResultCodeAll = []ManageVoteResultCode{
	ManageVoteResultCodeSuccess,
	ManageVoteResultCodeVoteNotFound,
	ManageVoteResultCodePollNotFound,
	ManageVoteResultCodeVoteExists,
	ManageVoteResultCodePollTypeMismatched,
	ManageVoteResultCodePollNotStarted,
	ManageVoteResultCodePollEnded,
}

var manageVoteResultCodeMap = map[int32]string{
	0:  "ManageVoteResultCodeSuccess",
	-1: "ManageVoteResultCodeVoteNotFound",
	-2: "ManageVoteResultCodePollNotFound",
	-3: "ManageVoteResultCodeVoteExists",
	-4: "ManageVoteResultCodePollTypeMismatched",
	-5: "ManageVoteResultCodePollNotStarted",
	-6: "ManageVoteResultCodePollEnded",
}

var manageVoteResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "vote_not_found",
	-2: "poll_not_found",
	-3: "vote_exists",
	-4: "poll_type_mismatched",
	-5: "poll_not_started",
	-6: "poll_ended",
}

var manageVoteResultCodeRevMap = map[string]int32{
	"ManageVoteResultCodeSuccess":            0,
	"ManageVoteResultCodeVoteNotFound":       -1,
	"ManageVoteResultCodePollNotFound":       -2,
	"ManageVoteResultCodeVoteExists":         -3,
	"ManageVoteResultCodePollTypeMismatched": -4,
	"ManageVoteResultCodePollNotStarted":     -5,
	"ManageVoteResultCodePollEnded":          -6,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ManageVoteResultCode
func (e ManageVoteResultCode) ValidEnum(v int32) bool {
	_, ok := manageVoteResultCodeMap[v]
	return ok
}
func (e ManageVoteResultCode) isFlag() bool {
	for i := len(ManageVoteResultCodeAll) - 1; i >= 0; i-- {
		expected := ManageVoteResultCode(2) << uint64(len(ManageVoteResultCodeAll)-1) >> uint64(len(ManageVoteResultCodeAll)-i)
		if expected != ManageVoteResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ManageVoteResultCode) String() string {
	name, _ := manageVoteResultCodeMap[int32(e)]
	return name
}

func (e ManageVoteResultCode) ShortString() string {
	name, _ := manageVoteResultCodeShortMap[int32(e)]
	return name
}

func (e ManageVoteResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ManageVoteResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ManageVoteResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ManageVoteResultCode(t.Value)
	return nil
}

// ManageVoteResult is an XDR Union defines as:
//
//   //: Result of ManageVoteOp application
//    union ManageVoteResult switch (ManageVoteResultCode code)
//    {
//    case SUCCESS:
//        EmptyExt ext;
//    default:
//        void;
//    };
//
type ManageVoteResult struct {
	Code ManageVoteResultCode `json:"code,omitempty"`
	Ext  *EmptyExt            `json:"ext,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageVoteResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageVoteResult
func (u ManageVoteResult) ArmForSwitch(sw int32) (string, bool) {
	switch ManageVoteResultCode(sw) {
	case ManageVoteResultCodeSuccess:
		return "Ext", true
	default:
		return "", true
	}
}

// NewManageVoteResult creates a new  ManageVoteResult.
func NewManageVoteResult(code ManageVoteResultCode, value interface{}) (result ManageVoteResult, err error) {
	result.Code = code
	switch ManageVoteResultCode(code) {
	case ManageVoteResultCodeSuccess:
		tv, ok := value.(EmptyExt)
		if !ok {
			err = fmt.Errorf("invalid value, must be EmptyExt")
			return
		}
		result.Ext = &tv
	default:
		// void
	}
	return
}

// MustExt retrieves the Ext value from the union,
// panicing if the value is not set.
func (u ManageVoteResult) MustExt() EmptyExt {
	val, ok := u.GetExt()

	if !ok {
		panic("arm Ext is not set")
	}

	return val
}

// GetExt retrieves the Ext value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageVoteResult) GetExt() (result EmptyExt, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Ext" {
		result = *u.Ext
		ok = true
	}

	return
}

// OpenSwapOpDestination is an XDR NestedUnion defines as:
//
//   union switch (PaymentDestinationType type) {
//           case ACCOUNT:
//               AccountID accountID;
//           case BALANCE:
//               BalanceID balanceID;
//       }
//
type OpenSwapOpDestination struct {
	Type      PaymentDestinationType `json:"type,omitempty"`
	AccountId *AccountId             `json:"accountID,omitempty"`
	BalanceId *BalanceId             `json:"balanceID,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u OpenSwapOpDestination) SwitchFieldName() string {
	return "Type"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of OpenSwapOpDestination
func (u OpenSwapOpDestination) ArmForSwitch(sw int32) (string, bool) {
	switch PaymentDestinationType(sw) {
	case PaymentDestinationTypeAccount:
		return "AccountId", true
	case PaymentDestinationTypeBalance:
		return "BalanceId", true
	}
	return "-", false
}

// NewOpenSwapOpDestination creates a new  OpenSwapOpDestination.
func NewOpenSwapOpDestination(aType PaymentDestinationType, value interface{}) (result OpenSwapOpDestination, err error) {
	result.Type = aType
	switch PaymentDestinationType(aType) {
	case PaymentDestinationTypeAccount:
		tv, ok := value.(AccountId)
		if !ok {
			err = fmt.Errorf("invalid value, must be AccountId")
			return
		}
		result.AccountId = &tv
	case PaymentDestinationTypeBalance:
		tv, ok := value.(BalanceId)
		if !ok {
			err = fmt.Errorf("invalid value, must be BalanceId")
			return
		}
		result.BalanceId = &tv
	}
	return
}

// MustAccountId retrieves the AccountId value from the union,
// panicing if the value is not set.
func (u OpenSwapOpDestination) MustAccountId() AccountId {
	val, ok := u.GetAccountId()

	if !ok {
		panic("arm AccountId is not set")
	}

	return val
}

// GetAccountId retrieves the AccountId value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OpenSwapOpDestination) GetAccountId() (result AccountId, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "AccountId" {
		result = *u.AccountId
		ok = true
	}

	return
}

// MustBalanceId retrieves the BalanceId value from the union,
// panicing if the value is not set.
func (u OpenSwapOpDestination) MustBalanceId() BalanceId {
	val, ok := u.GetBalanceId()

	if !ok {
		panic("arm BalanceId is not set")
	}

	return val
}

// GetBalanceId retrieves the BalanceId value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OpenSwapOpDestination) GetBalanceId() (result BalanceId, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "BalanceId" {
		result = *u.BalanceId
		ok = true
	}

	return
}

// OpenSwapOp is an XDR Struct defines as:
//
//   struct OpenSwapOp
//    {
//        //: Source balance of the swap
//        BalanceID sourceBalance;
//        //: Amount to send in swap
//        uint64 amount;
//
//       //: `destination` defines the type of instance that receives amount based on given PaymentDestinationType
//       union switch (PaymentDestinationType type) {
//           case ACCOUNT:
//               AccountID accountID;
//           case BALANCE:
//               BalanceID balanceID;
//       } destination;
//
//        //: Fee data for the swap
//        PaymentFeeData feeData;
//        //: Arbitrary stringified json object provided by swap source
//        longstring details;
//
//        //: Hash of the secret
//        Hash secretHash;
//        //: Time till which swapped funds can be received by destination if valid secret is provided
//        int64 lockTime;
//
//        //: reserved for future extension
//        EmptyExt ext;
//    };
//
type OpenSwapOp struct {
	SourceBalance BalanceId             `json:"sourceBalance,omitempty"`
	Amount        Uint64                `json:"amount,omitempty"`
	Destination   OpenSwapOpDestination `json:"destination,omitempty"`
	FeeData       PaymentFeeData        `json:"feeData,omitempty"`
	Details       Longstring            `json:"details,omitempty"`
	SecretHash    Hash                  `json:"secretHash,omitempty"`
	LockTime      Int64                 `json:"lockTime,omitempty"`
	Ext           EmptyExt              `json:"ext,omitempty"`
}

// OpenSwapResultCode is an XDR Enum defines as:
//
//   enum OpenSwapResultCode
//    {
//        //: OpenSwap was successful
//        SUCCESS = 0,
//
//        //: Source and destination balances are the same
//        MALFORMED = -1,
//        //: Not enough funds in the source account
//        UNDERFUNDED = -2,
//        //: There is no balance found with an ID provided in `destinations.balanceID`
//        //: Sender balance asset and receiver balance asset are not equal
//        BALANCE_ASSETS_MISMATCHED = -3,
//        //: There is no balance found with ID provided in `sourceBalanceID`
//        SRC_BALANCE_NOT_FOUND = -4,
//        //: Payment asset does not have a `SWAPPABLE` policy set
//        NOT_ALLOWED_BY_ASSET_POLICY = -5,
//        //: Overflow during total fee calculation
//        INVALID_DESTINATION_FEE = -6,
//        //: Payment fee amount is insufficient
//        INSUFFICIENT_FEE_AMOUNT = -7,
//        //: Fee charged from destination balance is greater than the amount
//        AMOUNT_IS_LESS_THAN_DEST_FEE = -8,
//        //: There is no account found with an ID provided in `destination.accountID`
//        //: Amount precision and asset precision are mismatched
//        INCORRECT_AMOUNT_PRECISION = -9,
//        //: Not allowed to create swap with invalid json details
//        INVALID_DETAILS = -10,
//        //: Lock time is in the past
//        INVALID_LOCK_TIME = -11,
//        //: Zero amount is not allowed
//        INVALID_AMOUNT = -12
//
//    };
//
type OpenSwapResultCode int32

const (
	OpenSwapResultCodeSuccess                  OpenSwapResultCode = 0
	OpenSwapResultCodeMalformed                OpenSwapResultCode = -1
	OpenSwapResultCodeUnderfunded              OpenSwapResultCode = -2
	OpenSwapResultCodeBalanceAssetsMismatched  OpenSwapResultCode = -3
	OpenSwapResultCodeSrcBalanceNotFound       OpenSwapResultCode = -4
	OpenSwapResultCodeNotAllowedByAssetPolicy  OpenSwapResultCode = -5
	OpenSwapResultCodeInvalidDestinationFee    OpenSwapResultCode = -6
	OpenSwapResultCodeInsufficientFeeAmount    OpenSwapResultCode = -7
	OpenSwapResultCodeAmountIsLessThanDestFee  OpenSwapResultCode = -8
	OpenSwapResultCodeIncorrectAmountPrecision OpenSwapResultCode = -9
	OpenSwapResultCodeInvalidDetails           OpenSwapResultCode = -10
	OpenSwapResultCodeInvalidLockTime          OpenSwapResultCode = -11
	OpenSwapResultCodeInvalidAmount            OpenSwapResultCode = -12
)

var OpenSwapResultCodeAll = []OpenSwapResultCode{
	OpenSwapResultCodeSuccess,
	OpenSwapResultCodeMalformed,
	OpenSwapResultCodeUnderfunded,
	OpenSwapResultCodeBalanceAssetsMismatched,
	OpenSwapResultCodeSrcBalanceNotFound,
	OpenSwapResultCodeNotAllowedByAssetPolicy,
	OpenSwapResultCodeInvalidDestinationFee,
	OpenSwapResultCodeInsufficientFeeAmount,
	OpenSwapResultCodeAmountIsLessThanDestFee,
	OpenSwapResultCodeIncorrectAmountPrecision,
	OpenSwapResultCodeInvalidDetails,
	OpenSwapResultCodeInvalidLockTime,
	OpenSwapResultCodeInvalidAmount,
}

var openSwapResultCodeMap = map[int32]string{
	0:   "OpenSwapResultCodeSuccess",
	-1:  "OpenSwapResultCodeMalformed",
	-2:  "OpenSwapResultCodeUnderfunded",
	-3:  "OpenSwapResultCodeBalanceAssetsMismatched",
	-4:  "OpenSwapResultCodeSrcBalanceNotFound",
	-5:  "OpenSwapResultCodeNotAllowedByAssetPolicy",
	-6:  "OpenSwapResultCodeInvalidDestinationFee",
	-7:  "OpenSwapResultCodeInsufficientFeeAmount",
	-8:  "OpenSwapResultCodeAmountIsLessThanDestFee",
	-9:  "OpenSwapResultCodeIncorrectAmountPrecision",
	-10: "OpenSwapResultCodeInvalidDetails",
	-11: "OpenSwapResultCodeInvalidLockTime",
	-12: "OpenSwapResultCodeInvalidAmount",
}

var openSwapResultCodeShortMap = map[int32]string{
	0:   "success",
	-1:  "malformed",
	-2:  "underfunded",
	-3:  "balance_assets_mismatched",
	-4:  "src_balance_not_found",
	-5:  "not_allowed_by_asset_policy",
	-6:  "invalid_destination_fee",
	-7:  "insufficient_fee_amount",
	-8:  "amount_is_less_than_dest_fee",
	-9:  "incorrect_amount_precision",
	-10: "invalid_details",
	-11: "invalid_lock_time",
	-12: "invalid_amount",
}

var openSwapResultCodeRevMap = map[string]int32{
	"OpenSwapResultCodeSuccess":                  0,
	"OpenSwapResultCodeMalformed":                -1,
	"OpenSwapResultCodeUnderfunded":              -2,
	"OpenSwapResultCodeBalanceAssetsMismatched":  -3,
	"OpenSwapResultCodeSrcBalanceNotFound":       -4,
	"OpenSwapResultCodeNotAllowedByAssetPolicy":  -5,
	"OpenSwapResultCodeInvalidDestinationFee":    -6,
	"OpenSwapResultCodeInsufficientFeeAmount":    -7,
	"OpenSwapResultCodeAmountIsLessThanDestFee":  -8,
	"OpenSwapResultCodeIncorrectAmountPrecision": -9,
	"OpenSwapResultCodeInvalidDetails":           -10,
	"OpenSwapResultCodeInvalidLockTime":          -11,
	"OpenSwapResultCodeInvalidAmount":            -12,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for OpenSwapResultCode
func (e OpenSwapResultCode) ValidEnum(v int32) bool {
	_, ok := openSwapResultCodeMap[v]
	return ok
}
func (e OpenSwapResultCode) isFlag() bool {
	for i := len(OpenSwapResultCodeAll) - 1; i >= 0; i-- {
		expected := OpenSwapResultCode(2) << uint64(len(OpenSwapResultCodeAll)-1) >> uint64(len(OpenSwapResultCodeAll)-i)
		if expected != OpenSwapResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e OpenSwapResultCode) String() string {
	name, _ := openSwapResultCodeMap[int32(e)]
	return name
}

func (e OpenSwapResultCode) ShortString() string {
	name, _ := openSwapResultCodeShortMap[int32(e)]
	return name
}

func (e OpenSwapResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range OpenSwapResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *OpenSwapResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = OpenSwapResultCode(t.Value)
	return nil
}

// OpenSwapSuccess is an XDR Struct defines as:
//
//   //: OpenSwapSuccess is used to pass saved ledger hash and license hash
//    struct OpenSwapSuccess {
//        uint64 swapID;
//
//        //: ID of the destination account
//        AccountID destination;
//        //: ID of the destination balance
//        BalanceID destinationBalance;
//
//        //: Code of an asset used in swap
//        AssetCode asset;
//
//        //: Fee to be charged from the source balance
//        Fee actualSourceFee;
//        //: Fee to be charged from the destination balance
//        Fee actualDestinationFee;
//
//        //: reserved for future extension
//        EmptyExt ext;
//    };
//
type OpenSwapSuccess struct {
	SwapId               Uint64    `json:"swapID,omitempty"`
	Destination          AccountId `json:"destination,omitempty"`
	DestinationBalance   BalanceId `json:"destinationBalance,omitempty"`
	Asset                AssetCode `json:"asset,omitempty"`
	ActualSourceFee      Fee       `json:"actualSourceFee,omitempty"`
	ActualDestinationFee Fee       `json:"actualDestinationFee,omitempty"`
	Ext                  EmptyExt  `json:"ext,omitempty"`
}

// OpenSwapResult is an XDR Union defines as:
//
//   //: OpenSwapResult is a result of OpenSwap operation application
//    union OpenSwapResult switch (OpenSwapResultCode code)
//    {
//    case SUCCESS:
//        OpenSwapSuccess success;
//    default:
//        void;
//    };
//
type OpenSwapResult struct {
	Code    OpenSwapResultCode `json:"code,omitempty"`
	Success *OpenSwapSuccess   `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u OpenSwapResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of OpenSwapResult
func (u OpenSwapResult) ArmForSwitch(sw int32) (string, bool) {
	switch OpenSwapResultCode(sw) {
	case OpenSwapResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewOpenSwapResult creates a new  OpenSwapResult.
func NewOpenSwapResult(code OpenSwapResultCode, value interface{}) (result OpenSwapResult, err error) {
	result.Code = code
	switch OpenSwapResultCode(code) {
	case OpenSwapResultCodeSuccess:
		tv, ok := value.(OpenSwapSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be OpenSwapSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u OpenSwapResult) MustSuccess() OpenSwapSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OpenSwapResult) GetSuccess() (result OpenSwapSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// PaymentFeeDataExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type PaymentFeeDataExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u PaymentFeeDataExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of PaymentFeeDataExt
func (u PaymentFeeDataExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewPaymentFeeDataExt creates a new  PaymentFeeDataExt.
func NewPaymentFeeDataExt(v LedgerVersion, value interface{}) (result PaymentFeeDataExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// PaymentFeeData is an XDR Struct defines as:
//
//   struct PaymentFeeData {
//        //: Fee to pay by source balance
//        Fee sourceFee;
//        //: Fee kept from destination account/balance
//        Fee destinationFee;
//        //: Indicates whether or not the source of payment pays the destination fee
//        bool sourcePaysForDest;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type PaymentFeeData struct {
	SourceFee         Fee               `json:"sourceFee,omitempty"`
	DestinationFee    Fee               `json:"destinationFee,omitempty"`
	SourcePaysForDest bool              `json:"sourcePaysForDest,omitempty"`
	Ext               PaymentFeeDataExt `json:"ext,omitempty"`
}

// PaymentDestinationType is an XDR Enum defines as:
//
//   //: Defines the type of destination of the payment
//    enum PaymentDestinationType {
//        ACCOUNT = 0,
//        BALANCE = 1
//    };
//
type PaymentDestinationType int32

const (
	PaymentDestinationTypeAccount PaymentDestinationType = 0
	PaymentDestinationTypeBalance PaymentDestinationType = 1
)

var PaymentDestinationTypeAll = []PaymentDestinationType{
	PaymentDestinationTypeAccount,
	PaymentDestinationTypeBalance,
}

var paymentDestinationTypeMap = map[int32]string{
	0: "PaymentDestinationTypeAccount",
	1: "PaymentDestinationTypeBalance",
}

var paymentDestinationTypeShortMap = map[int32]string{
	0: "account",
	1: "balance",
}

var paymentDestinationTypeRevMap = map[string]int32{
	"PaymentDestinationTypeAccount": 0,
	"PaymentDestinationTypeBalance": 1,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for PaymentDestinationType
func (e PaymentDestinationType) ValidEnum(v int32) bool {
	_, ok := paymentDestinationTypeMap[v]
	return ok
}
func (e PaymentDestinationType) isFlag() bool {
	for i := len(PaymentDestinationTypeAll) - 1; i >= 0; i-- {
		expected := PaymentDestinationType(2) << uint64(len(PaymentDestinationTypeAll)-1) >> uint64(len(PaymentDestinationTypeAll)-i)
		if expected != PaymentDestinationTypeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e PaymentDestinationType) String() string {
	name, _ := paymentDestinationTypeMap[int32(e)]
	return name
}

func (e PaymentDestinationType) ShortString() string {
	name, _ := paymentDestinationTypeShortMap[int32(e)]
	return name
}

func (e PaymentDestinationType) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range PaymentDestinationTypeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *PaymentDestinationType) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = PaymentDestinationType(t.Value)
	return nil
}

// PaymentOpDestination is an XDR NestedUnion defines as:
//
//   union switch (PaymentDestinationType type) {
//            case ACCOUNT:
//                AccountID accountID;
//            case BALANCE:
//                BalanceID balanceID;
//        }
//
type PaymentOpDestination struct {
	Type      PaymentDestinationType `json:"type,omitempty"`
	AccountId *AccountId             `json:"accountID,omitempty"`
	BalanceId *BalanceId             `json:"balanceID,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u PaymentOpDestination) SwitchFieldName() string {
	return "Type"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of PaymentOpDestination
func (u PaymentOpDestination) ArmForSwitch(sw int32) (string, bool) {
	switch PaymentDestinationType(sw) {
	case PaymentDestinationTypeAccount:
		return "AccountId", true
	case PaymentDestinationTypeBalance:
		return "BalanceId", true
	}
	return "-", false
}

// NewPaymentOpDestination creates a new  PaymentOpDestination.
func NewPaymentOpDestination(aType PaymentDestinationType, value interface{}) (result PaymentOpDestination, err error) {
	result.Type = aType
	switch PaymentDestinationType(aType) {
	case PaymentDestinationTypeAccount:
		tv, ok := value.(AccountId)
		if !ok {
			err = fmt.Errorf("invalid value, must be AccountId")
			return
		}
		result.AccountId = &tv
	case PaymentDestinationTypeBalance:
		tv, ok := value.(BalanceId)
		if !ok {
			err = fmt.Errorf("invalid value, must be BalanceId")
			return
		}
		result.BalanceId = &tv
	}
	return
}

// MustAccountId retrieves the AccountId value from the union,
// panicing if the value is not set.
func (u PaymentOpDestination) MustAccountId() AccountId {
	val, ok := u.GetAccountId()

	if !ok {
		panic("arm AccountId is not set")
	}

	return val
}

// GetAccountId retrieves the AccountId value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u PaymentOpDestination) GetAccountId() (result AccountId, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "AccountId" {
		result = *u.AccountId
		ok = true
	}

	return
}

// MustBalanceId retrieves the BalanceId value from the union,
// panicing if the value is not set.
func (u PaymentOpDestination) MustBalanceId() BalanceId {
	val, ok := u.GetBalanceId()

	if !ok {
		panic("arm BalanceId is not set")
	}

	return val
}

// GetBalanceId retrieves the BalanceId value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u PaymentOpDestination) GetBalanceId() (result BalanceId, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "BalanceId" {
		result = *u.BalanceId
		ok = true
	}

	return
}

// PaymentOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type PaymentOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u PaymentOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of PaymentOpExt
func (u PaymentOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewPaymentOpExt creates a new  PaymentOpExt.
func NewPaymentOpExt(v LedgerVersion, value interface{}) (result PaymentOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// PaymentOp is an XDR Struct defines as:
//
//   //: PaymentOp is used to transfer some amount of asset from the source balance to destination account/balance
//    struct PaymentOp
//    {
//        //: ID of the source balance of payment
//        BalanceID sourceBalanceID;
//
//        //: `destination` defines the type of instance that receives the payment based on given PaymentDestinationType
//        union switch (PaymentDestinationType type) {
//            case ACCOUNT:
//                AccountID accountID;
//            case BALANCE:
//                BalanceID balanceID;
//        } destination;
//
//        //: Amount of payment
//        uint64 amount;
//
//        //: `feeData` defines all data about the payment fee
//        PaymentFeeData feeData;
//
//        //: `subject` is a user-provided info about the real-life purpose of payment
//        longstring subject;
//        //: `reference` is a string formed by a payment sender. `Reference-sender account` pair is unique.
//        longstring reference;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type PaymentOp struct {
	SourceBalanceId BalanceId            `json:"sourceBalanceID,omitempty"`
	Destination     PaymentOpDestination `json:"destination,omitempty"`
	Amount          Uint64               `json:"amount,omitempty"`
	FeeData         PaymentFeeData       `json:"feeData,omitempty"`
	Subject         Longstring           `json:"subject,omitempty"`
	Reference       Longstring           `json:"reference,omitempty"`
	Ext             PaymentOpExt         `json:"ext,omitempty"`
}

// PaymentResultCode is an XDR Enum defines as:
//
//   enum PaymentResultCode
//    {
//        // codes considered as "success" for the operation
//        //: Payment was successfully completed
//        SUCCESS = 0, // payment successfully completed
//
//        // codes considered as "failure" for the operation
//        //: Payment sender balance ID and payment receiver balance ID are equal or reference is longer than 64 symbols
//        MALFORMED = -1,
//        //: Not enough funds in the source account
//        UNDERFUNDED = -2,
//        //: After the payment fulfillment, the destination balance will exceed the limit (total amount on the balance will be greater than UINT64_MAX)
//        LINE_FULL = -3,
//        //: There is no balance found with an ID provided in `destinations.balanceID`
//        DESTINATION_BALANCE_NOT_FOUND = -4,
//        //: Sender balance asset and receiver balance asset are not equal
//        BALANCE_ASSETS_MISMATCHED = -5,
//        //: There is no balance found with ID provided in `sourceBalanceID`
//        SRC_BALANCE_NOT_FOUND = -6,
//        //: Pair `reference-sender account` of the payment is not unique
//        REFERENCE_DUPLICATION = -7,
//        //: Stats entry exceeded account limits
//        STATS_OVERFLOW = -8,
//        //: Account will exceed its limits after the payment is fulfilled
//        LIMITS_EXCEEDED = -9,
//        //: Payment asset does not have a `TRANSFERABLE` policy set
//        NOT_ALLOWED_BY_ASSET_POLICY = -10,
//        //: Overflow during total fee calculation
//        INVALID_DESTINATION_FEE = -11,
//        //: Payment fee amount is insufficient
//        INSUFFICIENT_FEE_AMOUNT = -12,
//        //: Fee charged from destination balance is greater than the payment amount
//        PAYMENT_AMOUNT_IS_LESS_THAN_DEST_FEE = -13,
//        //: There is no account found with an ID provided in `destination.accountID`
//        DESTINATION_ACCOUNT_NOT_FOUND = -14,
//        //: Amount precision and asset precision are mismatched
//        INCORRECT_AMOUNT_PRECISION = -15,
//        //: Too much signs in subject
//        INVALID_SUBJECT = -16
//    };
//
type PaymentResultCode int32

const (
	PaymentResultCodeSuccess                        PaymentResultCode = 0
	PaymentResultCodeMalformed                      PaymentResultCode = -1
	PaymentResultCodeUnderfunded                    PaymentResultCode = -2
	PaymentResultCodeLineFull                       PaymentResultCode = -3
	PaymentResultCodeDestinationBalanceNotFound     PaymentResultCode = -4
	PaymentResultCodeBalanceAssetsMismatched        PaymentResultCode = -5
	PaymentResultCodeSrcBalanceNotFound             PaymentResultCode = -6
	PaymentResultCodeReferenceDuplication           PaymentResultCode = -7
	PaymentResultCodeStatsOverflow                  PaymentResultCode = -8
	PaymentResultCodeLimitsExceeded                 PaymentResultCode = -9
	PaymentResultCodeNotAllowedByAssetPolicy        PaymentResultCode = -10
	PaymentResultCodeInvalidDestinationFee          PaymentResultCode = -11
	PaymentResultCodeInsufficientFeeAmount          PaymentResultCode = -12
	PaymentResultCodePaymentAmountIsLessThanDestFee PaymentResultCode = -13
	PaymentResultCodeDestinationAccountNotFound     PaymentResultCode = -14
	PaymentResultCodeIncorrectAmountPrecision       PaymentResultCode = -15
	PaymentResultCodeInvalidSubject                 PaymentResultCode = -16
)

var PaymentResultCodeAll = []PaymentResultCode{
	PaymentResultCodeSuccess,
	PaymentResultCodeMalformed,
	PaymentResultCodeUnderfunded,
	PaymentResultCodeLineFull,
	PaymentResultCodeDestinationBalanceNotFound,
	PaymentResultCodeBalanceAssetsMismatched,
	PaymentResultCodeSrcBalanceNotFound,
	PaymentResultCodeReferenceDuplication,
	PaymentResultCodeStatsOverflow,
	PaymentResultCodeLimitsExceeded,
	PaymentResultCodeNotAllowedByAssetPolicy,
	PaymentResultCodeInvalidDestinationFee,
	PaymentResultCodeInsufficientFeeAmount,
	PaymentResultCodePaymentAmountIsLessThanDestFee,
	PaymentResultCodeDestinationAccountNotFound,
	PaymentResultCodeIncorrectAmountPrecision,
	PaymentResultCodeInvalidSubject,
}

var paymentResultCodeMap = map[int32]string{
	0:   "PaymentResultCodeSuccess",
	-1:  "PaymentResultCodeMalformed",
	-2:  "PaymentResultCodeUnderfunded",
	-3:  "PaymentResultCodeLineFull",
	-4:  "PaymentResultCodeDestinationBalanceNotFound",
	-5:  "PaymentResultCodeBalanceAssetsMismatched",
	-6:  "PaymentResultCodeSrcBalanceNotFound",
	-7:  "PaymentResultCodeReferenceDuplication",
	-8:  "PaymentResultCodeStatsOverflow",
	-9:  "PaymentResultCodeLimitsExceeded",
	-10: "PaymentResultCodeNotAllowedByAssetPolicy",
	-11: "PaymentResultCodeInvalidDestinationFee",
	-12: "PaymentResultCodeInsufficientFeeAmount",
	-13: "PaymentResultCodePaymentAmountIsLessThanDestFee",
	-14: "PaymentResultCodeDestinationAccountNotFound",
	-15: "PaymentResultCodeIncorrectAmountPrecision",
	-16: "PaymentResultCodeInvalidSubject",
}

var paymentResultCodeShortMap = map[int32]string{
	0:   "success",
	-1:  "malformed",
	-2:  "underfunded",
	-3:  "line_full",
	-4:  "destination_balance_not_found",
	-5:  "balance_assets_mismatched",
	-6:  "src_balance_not_found",
	-7:  "reference_duplication",
	-8:  "stats_overflow",
	-9:  "limits_exceeded",
	-10: "not_allowed_by_asset_policy",
	-11: "invalid_destination_fee",
	-12: "insufficient_fee_amount",
	-13: "payment_amount_is_less_than_dest_fee",
	-14: "destination_account_not_found",
	-15: "incorrect_amount_precision",
	-16: "invalid_subject",
}

var paymentResultCodeRevMap = map[string]int32{
	"PaymentResultCodeSuccess":                        0,
	"PaymentResultCodeMalformed":                      -1,
	"PaymentResultCodeUnderfunded":                    -2,
	"PaymentResultCodeLineFull":                       -3,
	"PaymentResultCodeDestinationBalanceNotFound":     -4,
	"PaymentResultCodeBalanceAssetsMismatched":        -5,
	"PaymentResultCodeSrcBalanceNotFound":             -6,
	"PaymentResultCodeReferenceDuplication":           -7,
	"PaymentResultCodeStatsOverflow":                  -8,
	"PaymentResultCodeLimitsExceeded":                 -9,
	"PaymentResultCodeNotAllowedByAssetPolicy":        -10,
	"PaymentResultCodeInvalidDestinationFee":          -11,
	"PaymentResultCodeInsufficientFeeAmount":          -12,
	"PaymentResultCodePaymentAmountIsLessThanDestFee": -13,
	"PaymentResultCodeDestinationAccountNotFound":     -14,
	"PaymentResultCodeIncorrectAmountPrecision":       -15,
	"PaymentResultCodeInvalidSubject":                 -16,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for PaymentResultCode
func (e PaymentResultCode) ValidEnum(v int32) bool {
	_, ok := paymentResultCodeMap[v]
	return ok
}
func (e PaymentResultCode) isFlag() bool {
	for i := len(PaymentResultCodeAll) - 1; i >= 0; i-- {
		expected := PaymentResultCode(2) << uint64(len(PaymentResultCodeAll)-1) >> uint64(len(PaymentResultCodeAll)-i)
		if expected != PaymentResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e PaymentResultCode) String() string {
	name, _ := paymentResultCodeMap[int32(e)]
	return name
}

func (e PaymentResultCode) ShortString() string {
	name, _ := paymentResultCodeShortMap[int32(e)]
	return name
}

func (e PaymentResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range PaymentResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *PaymentResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = PaymentResultCode(t.Value)
	return nil
}

// PaymentResponseExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type PaymentResponseExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u PaymentResponseExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of PaymentResponseExt
func (u PaymentResponseExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewPaymentResponseExt creates a new  PaymentResponseExt.
func NewPaymentResponseExt(v LedgerVersion, value interface{}) (result PaymentResponseExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// PaymentResponse is an XDR Struct defines as:
//
//   //: `PaymentResponse` defines the response on the corresponding PaymentOp
//    struct PaymentResponse {
//        //: ID of the destination account
//        AccountID destination;
//        //: ID of the destination balance
//        BalanceID destinationBalanceID;
//
//        //: Code of an asset used in payment
//        AssetCode asset;
//        //: Amount sent by the sender
//        uint64 sourceSentUniversal;
//        //: Unique ID of the payment
//        uint64 paymentID;
//
//        //: Fee charged from the source balance
//        Fee actualSourcePaymentFee;
//        //: Fee charged from the destination balance
//        Fee actualDestinationPaymentFee;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type PaymentResponse struct {
	Destination                 AccountId          `json:"destination,omitempty"`
	DestinationBalanceId        BalanceId          `json:"destinationBalanceID,omitempty"`
	Asset                       AssetCode          `json:"asset,omitempty"`
	SourceSentUniversal         Uint64             `json:"sourceSentUniversal,omitempty"`
	PaymentId                   Uint64             `json:"paymentID,omitempty"`
	ActualSourcePaymentFee      Fee                `json:"actualSourcePaymentFee,omitempty"`
	ActualDestinationPaymentFee Fee                `json:"actualDestinationPaymentFee,omitempty"`
	Ext                         PaymentResponseExt `json:"ext,omitempty"`
}

// PaymentResult is an XDR Union defines as:
//
//   union PaymentResult switch (PaymentResultCode code)
//    {
//    case SUCCESS:
//        PaymentResponse paymentResponse;
//    default:
//        void;
//    };
//
type PaymentResult struct {
	Code            PaymentResultCode `json:"code,omitempty"`
	PaymentResponse *PaymentResponse  `json:"paymentResponse,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u PaymentResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of PaymentResult
func (u PaymentResult) ArmForSwitch(sw int32) (string, bool) {
	switch PaymentResultCode(sw) {
	case PaymentResultCodeSuccess:
		return "PaymentResponse", true
	default:
		return "", true
	}
}

// NewPaymentResult creates a new  PaymentResult.
func NewPaymentResult(code PaymentResultCode, value interface{}) (result PaymentResult, err error) {
	result.Code = code
	switch PaymentResultCode(code) {
	case PaymentResultCodeSuccess:
		tv, ok := value.(PaymentResponse)
		if !ok {
			err = fmt.Errorf("invalid value, must be PaymentResponse")
			return
		}
		result.PaymentResponse = &tv
	default:
		// void
	}
	return
}

// MustPaymentResponse retrieves the PaymentResponse value from the union,
// panicing if the value is not set.
func (u PaymentResult) MustPaymentResponse() PaymentResponse {
	val, ok := u.GetPaymentResponse()

	if !ok {
		panic("arm PaymentResponse is not set")
	}

	return val
}

// GetPaymentResponse retrieves the PaymentResponse value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u PaymentResult) GetPaymentResponse() (result PaymentResponse, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "PaymentResponse" {
		result = *u.PaymentResponse
		ok = true
	}

	return
}

// PayoutOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type PayoutOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u PayoutOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of PayoutOpExt
func (u PayoutOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewPayoutOpExt creates a new  PayoutOpExt.
func NewPayoutOpExt(v LedgerVersion, value interface{}) (result PayoutOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// PayoutOp is an XDR Struct defines as:
//
//   struct PayoutOp
//    {
//        AssetCode asset; // asset, which holders will receive dividends
//        BalanceID sourceBalanceID; // balance, from which payout will be performed
//
//        uint64 maxPayoutAmount; // max amount of asset, that owner wants to pay out
//        uint64 minPayoutAmount; // min tokens amount which will be payed for one balance;
//        uint64 minAssetHolderAmount; // min tokens amount for which holder will received dividends
//
//        Fee fee;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type PayoutOp struct {
	Asset                AssetCode   `json:"asset,omitempty"`
	SourceBalanceId      BalanceId   `json:"sourceBalanceID,omitempty"`
	MaxPayoutAmount      Uint64      `json:"maxPayoutAmount,omitempty"`
	MinPayoutAmount      Uint64      `json:"minPayoutAmount,omitempty"`
	MinAssetHolderAmount Uint64      `json:"minAssetHolderAmount,omitempty"`
	Fee                  Fee         `json:"fee,omitempty"`
	Ext                  PayoutOpExt `json:"ext,omitempty"`
}

// PayoutResultCode is an XDR Enum defines as:
//
//   enum PayoutResultCode
//    {
//        // codes considered as "success" for the operation
//        SUCCESS = 0,    // payout successfully completed
//
//        // codes considered as "failure" for the operation
//        INVALID_AMOUNT = -1, // max payout amount can not be zero
//        INVALID_ASSET = -2,
//        ASSET_NOT_FOUND = -3,
//        ASSET_NOT_TRANSFERABLE = -4, // asset must have policy transferable
//        BALANCE_NOT_FOUND = -5,
//        INSUFFICIENT_FEE_AMOUNT = -6,
//        FEE_EXCEEDS_ACTUAL_AMOUNT = -7,
//        TOTAL_FEE_OVERFLOW = -8,
//        UNDERFUNDED = -9, // not enough amount on source balance
//        HOLDERS_NOT_FOUND = -10, // there is no holders of such asset
//        MIN_AMOUNT_TOO_BIG = -11, // there is no appropriate holders balances
//        LINE_FULL = -12, // destination balance amount overflows
//        STATS_OVERFLOW = -13, // source statistics overflow
//        LIMITS_EXCEEDED = -14, // source account limit exceeded
//        INCORRECT_PRECISION = -15 // asset does not allow amounts with such precision
//    };
//
type PayoutResultCode int32

const (
	PayoutResultCodeSuccess                PayoutResultCode = 0
	PayoutResultCodeInvalidAmount          PayoutResultCode = -1
	PayoutResultCodeInvalidAsset           PayoutResultCode = -2
	PayoutResultCodeAssetNotFound          PayoutResultCode = -3
	PayoutResultCodeAssetNotTransferable   PayoutResultCode = -4
	PayoutResultCodeBalanceNotFound        PayoutResultCode = -5
	PayoutResultCodeInsufficientFeeAmount  PayoutResultCode = -6
	PayoutResultCodeFeeExceedsActualAmount PayoutResultCode = -7
	PayoutResultCodeTotalFeeOverflow       PayoutResultCode = -8
	PayoutResultCodeUnderfunded            PayoutResultCode = -9
	PayoutResultCodeHoldersNotFound        PayoutResultCode = -10
	PayoutResultCodeMinAmountTooBig        PayoutResultCode = -11
	PayoutResultCodeLineFull               PayoutResultCode = -12
	PayoutResultCodeStatsOverflow          PayoutResultCode = -13
	PayoutResultCodeLimitsExceeded         PayoutResultCode = -14
	PayoutResultCodeIncorrectPrecision     PayoutResultCode = -15
)

var PayoutResultCodeAll = []PayoutResultCode{
	PayoutResultCodeSuccess,
	PayoutResultCodeInvalidAmount,
	PayoutResultCodeInvalidAsset,
	PayoutResultCodeAssetNotFound,
	PayoutResultCodeAssetNotTransferable,
	PayoutResultCodeBalanceNotFound,
	PayoutResultCodeInsufficientFeeAmount,
	PayoutResultCodeFeeExceedsActualAmount,
	PayoutResultCodeTotalFeeOverflow,
	PayoutResultCodeUnderfunded,
	PayoutResultCodeHoldersNotFound,
	PayoutResultCodeMinAmountTooBig,
	PayoutResultCodeLineFull,
	PayoutResultCodeStatsOverflow,
	PayoutResultCodeLimitsExceeded,
	PayoutResultCodeIncorrectPrecision,
}

var payoutResultCodeMap = map[int32]string{
	0:   "PayoutResultCodeSuccess",
	-1:  "PayoutResultCodeInvalidAmount",
	-2:  "PayoutResultCodeInvalidAsset",
	-3:  "PayoutResultCodeAssetNotFound",
	-4:  "PayoutResultCodeAssetNotTransferable",
	-5:  "PayoutResultCodeBalanceNotFound",
	-6:  "PayoutResultCodeInsufficientFeeAmount",
	-7:  "PayoutResultCodeFeeExceedsActualAmount",
	-8:  "PayoutResultCodeTotalFeeOverflow",
	-9:  "PayoutResultCodeUnderfunded",
	-10: "PayoutResultCodeHoldersNotFound",
	-11: "PayoutResultCodeMinAmountTooBig",
	-12: "PayoutResultCodeLineFull",
	-13: "PayoutResultCodeStatsOverflow",
	-14: "PayoutResultCodeLimitsExceeded",
	-15: "PayoutResultCodeIncorrectPrecision",
}

var payoutResultCodeShortMap = map[int32]string{
	0:   "success",
	-1:  "invalid_amount",
	-2:  "invalid_asset",
	-3:  "asset_not_found",
	-4:  "asset_not_transferable",
	-5:  "balance_not_found",
	-6:  "insufficient_fee_amount",
	-7:  "fee_exceeds_actual_amount",
	-8:  "total_fee_overflow",
	-9:  "underfunded",
	-10: "holders_not_found",
	-11: "min_amount_too_big",
	-12: "line_full",
	-13: "stats_overflow",
	-14: "limits_exceeded",
	-15: "incorrect_precision",
}

var payoutResultCodeRevMap = map[string]int32{
	"PayoutResultCodeSuccess":                0,
	"PayoutResultCodeInvalidAmount":          -1,
	"PayoutResultCodeInvalidAsset":           -2,
	"PayoutResultCodeAssetNotFound":          -3,
	"PayoutResultCodeAssetNotTransferable":   -4,
	"PayoutResultCodeBalanceNotFound":        -5,
	"PayoutResultCodeInsufficientFeeAmount":  -6,
	"PayoutResultCodeFeeExceedsActualAmount": -7,
	"PayoutResultCodeTotalFeeOverflow":       -8,
	"PayoutResultCodeUnderfunded":            -9,
	"PayoutResultCodeHoldersNotFound":        -10,
	"PayoutResultCodeMinAmountTooBig":        -11,
	"PayoutResultCodeLineFull":               -12,
	"PayoutResultCodeStatsOverflow":          -13,
	"PayoutResultCodeLimitsExceeded":         -14,
	"PayoutResultCodeIncorrectPrecision":     -15,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for PayoutResultCode
func (e PayoutResultCode) ValidEnum(v int32) bool {
	_, ok := payoutResultCodeMap[v]
	return ok
}
func (e PayoutResultCode) isFlag() bool {
	for i := len(PayoutResultCodeAll) - 1; i >= 0; i-- {
		expected := PayoutResultCode(2) << uint64(len(PayoutResultCodeAll)-1) >> uint64(len(PayoutResultCodeAll)-i)
		if expected != PayoutResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e PayoutResultCode) String() string {
	name, _ := payoutResultCodeMap[int32(e)]
	return name
}

func (e PayoutResultCode) ShortString() string {
	name, _ := payoutResultCodeShortMap[int32(e)]
	return name
}

func (e PayoutResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range PayoutResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *PayoutResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = PayoutResultCode(t.Value)
	return nil
}

// PayoutResponseExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type PayoutResponseExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u PayoutResponseExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of PayoutResponseExt
func (u PayoutResponseExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewPayoutResponseExt creates a new  PayoutResponseExt.
func NewPayoutResponseExt(v LedgerVersion, value interface{}) (result PayoutResponseExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// PayoutResponse is an XDR Struct defines as:
//
//   struct PayoutResponse
//    {
//        AccountID receiverID;
//        BalanceID receiverBalanceID;
//        uint64 receivedAmount;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type PayoutResponse struct {
	ReceiverId        AccountId         `json:"receiverID,omitempty"`
	ReceiverBalanceId BalanceId         `json:"receiverBalanceID,omitempty"`
	ReceivedAmount    Uint64            `json:"receivedAmount,omitempty"`
	Ext               PayoutResponseExt `json:"ext,omitempty"`
}

// PayoutSuccessResultExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type PayoutSuccessResultExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u PayoutSuccessResultExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of PayoutSuccessResultExt
func (u PayoutSuccessResultExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewPayoutSuccessResultExt creates a new  PayoutSuccessResultExt.
func NewPayoutSuccessResultExt(v LedgerVersion, value interface{}) (result PayoutSuccessResultExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// PayoutSuccessResult is an XDR Struct defines as:
//
//   struct PayoutSuccessResult
//    {
//        PayoutResponse payoutResponses<>;
//        uint64 actualPayoutAmount;
//        Fee actualFee;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type PayoutSuccessResult struct {
	PayoutResponses    []PayoutResponse       `json:"payoutResponses,omitempty"`
	ActualPayoutAmount Uint64                 `json:"actualPayoutAmount,omitempty"`
	ActualFee          Fee                    `json:"actualFee,omitempty"`
	Ext                PayoutSuccessResultExt `json:"ext,omitempty"`
}

// PayoutResult is an XDR Union defines as:
//
//   union PayoutResult switch (PayoutResultCode code)
//    {
//        case SUCCESS:
//            PayoutSuccessResult success;
//        default:
//            void;
//    };
//
type PayoutResult struct {
	Code    PayoutResultCode     `json:"code,omitempty"`
	Success *PayoutSuccessResult `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u PayoutResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of PayoutResult
func (u PayoutResult) ArmForSwitch(sw int32) (string, bool) {
	switch PayoutResultCode(sw) {
	case PayoutResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewPayoutResult creates a new  PayoutResult.
func NewPayoutResult(code PayoutResultCode, value interface{}) (result PayoutResult, err error) {
	result.Code = code
	switch PayoutResultCode(code) {
	case PayoutResultCodeSuccess:
		tv, ok := value.(PayoutSuccessResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be PayoutSuccessResult")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u PayoutResult) MustSuccess() PayoutSuccessResult {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u PayoutResult) GetSuccess() (result PayoutSuccessResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// RemoveAssetPairOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type RemoveAssetPairOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u RemoveAssetPairOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of RemoveAssetPairOpExt
func (u RemoveAssetPairOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewRemoveAssetPairOpExt creates a new  RemoveAssetPairOpExt.
func NewRemoveAssetPairOpExt(v LedgerVersion, value interface{}) (result RemoveAssetPairOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// RemoveAssetPairOp is an XDR Struct defines as:
//
//   //: `RemoveAssetPairOp` removes specified asset pair
//    struct RemoveAssetPairOp
//    {
//        //: Defines a base asset of an asset pair
//        AssetCode base;
//        //: Defines a base asset of an asset pair
//        AssetCode quote;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type RemoveAssetPairOp struct {
	Base  AssetCode            `json:"base,omitempty"`
	Quote AssetCode            `json:"quote,omitempty"`
	Ext   RemoveAssetPairOpExt `json:"ext,omitempty"`
}

// RemoveAssetPairResultCode is an XDR Enum defines as:
//
//   //: Result codes for `RemoveAssetPairOp`
//    enum RemoveAssetPairResultCode
//    {
//        //: Operation is successfully applied
//        SUCCESS = 0,
//        //: Asset pair not found
//        NOT_FOUND = -1,
//        //: Asset pair can't be deleted as it has active orders
//        HAS_ACTIVE_OFFERS = -2,
//        //: Asset pair can't be deleted as it has active sales
//        HAS_ACTIVE_SALES = -3,
//        //: Base or Quote asset is invalid
//        INVALID_ASSET_CODE = -4
//    };
//
type RemoveAssetPairResultCode int32

const (
	RemoveAssetPairResultCodeSuccess          RemoveAssetPairResultCode = 0
	RemoveAssetPairResultCodeNotFound         RemoveAssetPairResultCode = -1
	RemoveAssetPairResultCodeHasActiveOffers  RemoveAssetPairResultCode = -2
	RemoveAssetPairResultCodeHasActiveSales   RemoveAssetPairResultCode = -3
	RemoveAssetPairResultCodeInvalidAssetCode RemoveAssetPairResultCode = -4
)

var RemoveAssetPairResultCodeAll = []RemoveAssetPairResultCode{
	RemoveAssetPairResultCodeSuccess,
	RemoveAssetPairResultCodeNotFound,
	RemoveAssetPairResultCodeHasActiveOffers,
	RemoveAssetPairResultCodeHasActiveSales,
	RemoveAssetPairResultCodeInvalidAssetCode,
}

var removeAssetPairResultCodeMap = map[int32]string{
	0:  "RemoveAssetPairResultCodeSuccess",
	-1: "RemoveAssetPairResultCodeNotFound",
	-2: "RemoveAssetPairResultCodeHasActiveOffers",
	-3: "RemoveAssetPairResultCodeHasActiveSales",
	-4: "RemoveAssetPairResultCodeInvalidAssetCode",
}

var removeAssetPairResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "not_found",
	-2: "has_active_offers",
	-3: "has_active_sales",
	-4: "invalid_asset_code",
}

var removeAssetPairResultCodeRevMap = map[string]int32{
	"RemoveAssetPairResultCodeSuccess":          0,
	"RemoveAssetPairResultCodeNotFound":         -1,
	"RemoveAssetPairResultCodeHasActiveOffers":  -2,
	"RemoveAssetPairResultCodeHasActiveSales":   -3,
	"RemoveAssetPairResultCodeInvalidAssetCode": -4,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for RemoveAssetPairResultCode
func (e RemoveAssetPairResultCode) ValidEnum(v int32) bool {
	_, ok := removeAssetPairResultCodeMap[v]
	return ok
}
func (e RemoveAssetPairResultCode) isFlag() bool {
	for i := len(RemoveAssetPairResultCodeAll) - 1; i >= 0; i-- {
		expected := RemoveAssetPairResultCode(2) << uint64(len(RemoveAssetPairResultCodeAll)-1) >> uint64(len(RemoveAssetPairResultCodeAll)-i)
		if expected != RemoveAssetPairResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e RemoveAssetPairResultCode) String() string {
	name, _ := removeAssetPairResultCodeMap[int32(e)]
	return name
}

func (e RemoveAssetPairResultCode) ShortString() string {
	name, _ := removeAssetPairResultCodeShortMap[int32(e)]
	return name
}

func (e RemoveAssetPairResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range RemoveAssetPairResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *RemoveAssetPairResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = RemoveAssetPairResultCode(t.Value)
	return nil
}

// RemoveAssetPairSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type RemoveAssetPairSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u RemoveAssetPairSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of RemoveAssetPairSuccessExt
func (u RemoveAssetPairSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewRemoveAssetPairSuccessExt creates a new  RemoveAssetPairSuccessExt.
func NewRemoveAssetPairSuccessExt(v LedgerVersion, value interface{}) (result RemoveAssetPairSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// RemoveAssetPairSuccess is an XDR Struct defines as:
//
//   //: Result of successful `RemoveAssetPairOp` application
//    struct RemoveAssetPairSuccess
//    {
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type RemoveAssetPairSuccess struct {
	Ext RemoveAssetPairSuccessExt `json:"ext,omitempty"`
}

// RemoveAssetPairResult is an XDR Union defines as:
//
//   //: Result of RemoveAssetPair operation application along with the result code
//    union RemoveAssetPairResult switch (RemoveAssetPairResultCode code) {
//        case SUCCESS:
//            RemoveAssetPairSuccess success;
//        default:
//            void;
//    };
//
type RemoveAssetPairResult struct {
	Code    RemoveAssetPairResultCode `json:"code,omitempty"`
	Success *RemoveAssetPairSuccess   `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u RemoveAssetPairResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of RemoveAssetPairResult
func (u RemoveAssetPairResult) ArmForSwitch(sw int32) (string, bool) {
	switch RemoveAssetPairResultCode(sw) {
	case RemoveAssetPairResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewRemoveAssetPairResult creates a new  RemoveAssetPairResult.
func NewRemoveAssetPairResult(code RemoveAssetPairResultCode, value interface{}) (result RemoveAssetPairResult, err error) {
	result.Code = code
	switch RemoveAssetPairResultCode(code) {
	case RemoveAssetPairResultCodeSuccess:
		tv, ok := value.(RemoveAssetPairSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be RemoveAssetPairSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u RemoveAssetPairResult) MustSuccess() RemoveAssetPairSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u RemoveAssetPairResult) GetSuccess() (result RemoveAssetPairSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// RemoveAssetOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type RemoveAssetOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u RemoveAssetOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of RemoveAssetOpExt
func (u RemoveAssetOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewRemoveAssetOpExt creates a new  RemoveAssetOpExt.
func NewRemoveAssetOpExt(v LedgerVersion, value interface{}) (result RemoveAssetOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// RemoveAssetOp is an XDR Struct defines as:
//
//   //: `RemoveAssetOp` changes the state of specified asset to removed
//    struct RemoveAssetOp
//    {
//        //: Defines an asset
//        AssetCode code;
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type RemoveAssetOp struct {
	Code AssetCode        `json:"code,omitempty"`
	Ext  RemoveAssetOpExt `json:"ext,omitempty"`
}

// RemoveAssetResultCode is an XDR Enum defines as:
//
//   //: Result codes for `RemoveAssetOp`
//    enum RemoveAssetResultCode
//    {
//        //: Operation is successfully applied
//        SUCCESS = 0,
//        //: Asset code is invalid
//        INVALID_ASSET_CODE = -1,
//        //: Asset can't be deleted as there exist asset pairs with it
//        HAS_PAIR = -2,
//        //: Asset can't be deleted as it has active offers
//        HAS_ACTIVE_OFFERS = -3,
//        //: Asset can't be deleted as it has active sales
//        HAS_ACTIVE_SALES = -4,
//        //: Asset can't be deleted as it has active atomic swaps
//        HAS_ACTIVE_ATOMIC_SWAPS = -5,
//        //: Asset can't be deleted as it has active swaps
//        HAS_ACTIVE_SWAPS = -6,
//        //: Asset can't be deleted as it is stats quote asset
//        CANNOT_REMOVE_STATS_QUOTE_ASSET = -7,
//        //: Cannot delete asset, as some balances in target asset have non-empty locked amount
//        HAS_PENDING_MOVEMENTS = -8
//    };
//
type RemoveAssetResultCode int32

const (
	RemoveAssetResultCodeSuccess                     RemoveAssetResultCode = 0
	RemoveAssetResultCodeInvalidAssetCode            RemoveAssetResultCode = -1
	RemoveAssetResultCodeHasPair                     RemoveAssetResultCode = -2
	RemoveAssetResultCodeHasActiveOffers             RemoveAssetResultCode = -3
	RemoveAssetResultCodeHasActiveSales              RemoveAssetResultCode = -4
	RemoveAssetResultCodeHasActiveAtomicSwaps        RemoveAssetResultCode = -5
	RemoveAssetResultCodeHasActiveSwaps              RemoveAssetResultCode = -6
	RemoveAssetResultCodeCannotRemoveStatsQuoteAsset RemoveAssetResultCode = -7
	RemoveAssetResultCodeHasPendingMovements         RemoveAssetResultCode = -8
)

var RemoveAssetResultCodeAll = []RemoveAssetResultCode{
	RemoveAssetResultCodeSuccess,
	RemoveAssetResultCodeInvalidAssetCode,
	RemoveAssetResultCodeHasPair,
	RemoveAssetResultCodeHasActiveOffers,
	RemoveAssetResultCodeHasActiveSales,
	RemoveAssetResultCodeHasActiveAtomicSwaps,
	RemoveAssetResultCodeHasActiveSwaps,
	RemoveAssetResultCodeCannotRemoveStatsQuoteAsset,
	RemoveAssetResultCodeHasPendingMovements,
}

var removeAssetResultCodeMap = map[int32]string{
	0:  "RemoveAssetResultCodeSuccess",
	-1: "RemoveAssetResultCodeInvalidAssetCode",
	-2: "RemoveAssetResultCodeHasPair",
	-3: "RemoveAssetResultCodeHasActiveOffers",
	-4: "RemoveAssetResultCodeHasActiveSales",
	-5: "RemoveAssetResultCodeHasActiveAtomicSwaps",
	-6: "RemoveAssetResultCodeHasActiveSwaps",
	-7: "RemoveAssetResultCodeCannotRemoveStatsQuoteAsset",
	-8: "RemoveAssetResultCodeHasPendingMovements",
}

var removeAssetResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "invalid_asset_code",
	-2: "has_pair",
	-3: "has_active_offers",
	-4: "has_active_sales",
	-5: "has_active_atomic_swaps",
	-6: "has_active_swaps",
	-7: "cannot_remove_stats_quote_asset",
	-8: "has_pending_movements",
}

var removeAssetResultCodeRevMap = map[string]int32{
	"RemoveAssetResultCodeSuccess":                     0,
	"RemoveAssetResultCodeInvalidAssetCode":            -1,
	"RemoveAssetResultCodeHasPair":                     -2,
	"RemoveAssetResultCodeHasActiveOffers":             -3,
	"RemoveAssetResultCodeHasActiveSales":              -4,
	"RemoveAssetResultCodeHasActiveAtomicSwaps":        -5,
	"RemoveAssetResultCodeHasActiveSwaps":              -6,
	"RemoveAssetResultCodeCannotRemoveStatsQuoteAsset": -7,
	"RemoveAssetResultCodeHasPendingMovements":         -8,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for RemoveAssetResultCode
func (e RemoveAssetResultCode) ValidEnum(v int32) bool {
	_, ok := removeAssetResultCodeMap[v]
	return ok
}
func (e RemoveAssetResultCode) isFlag() bool {
	for i := len(RemoveAssetResultCodeAll) - 1; i >= 0; i-- {
		expected := RemoveAssetResultCode(2) << uint64(len(RemoveAssetResultCodeAll)-1) >> uint64(len(RemoveAssetResultCodeAll)-i)
		if expected != RemoveAssetResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e RemoveAssetResultCode) String() string {
	name, _ := removeAssetResultCodeMap[int32(e)]
	return name
}

func (e RemoveAssetResultCode) ShortString() string {
	name, _ := removeAssetResultCodeShortMap[int32(e)]
	return name
}

func (e RemoveAssetResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range RemoveAssetResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *RemoveAssetResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = RemoveAssetResultCode(t.Value)
	return nil
}

// RemoveAssetSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type RemoveAssetSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u RemoveAssetSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of RemoveAssetSuccessExt
func (u RemoveAssetSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewRemoveAssetSuccessExt creates a new  RemoveAssetSuccessExt.
func NewRemoveAssetSuccessExt(v LedgerVersion, value interface{}) (result RemoveAssetSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// RemoveAssetSuccess is an XDR Struct defines as:
//
//   //: Result of successful `RemoveAssetOp` application
//    struct RemoveAssetSuccess
//    {
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type RemoveAssetSuccess struct {
	Ext RemoveAssetSuccessExt `json:"ext,omitempty"`
}

// RemoveAssetResult is an XDR Union defines as:
//
//   //: Result of RemoveAsset operation application along with the result code
//    union RemoveAssetResult switch (RemoveAssetResultCode code) {
//        case SUCCESS:
//            RemoveAssetSuccess success;
//        default:
//            void;
//    };
//
type RemoveAssetResult struct {
	Code    RemoveAssetResultCode `json:"code,omitempty"`
	Success *RemoveAssetSuccess   `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u RemoveAssetResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of RemoveAssetResult
func (u RemoveAssetResult) ArmForSwitch(sw int32) (string, bool) {
	switch RemoveAssetResultCode(sw) {
	case RemoveAssetResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewRemoveAssetResult creates a new  RemoveAssetResult.
func NewRemoveAssetResult(code RemoveAssetResultCode, value interface{}) (result RemoveAssetResult, err error) {
	result.Code = code
	switch RemoveAssetResultCode(code) {
	case RemoveAssetResultCodeSuccess:
		tv, ok := value.(RemoveAssetSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be RemoveAssetSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u RemoveAssetResult) MustSuccess() RemoveAssetSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u RemoveAssetResult) GetSuccess() (result RemoveAssetSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// RemoveDataOp is an XDR Struct defines as:
//
//   struct RemoveDataOp
//    {
//        //: ID of the data to remove
//        uint64 dataID;
//        //: Reserved for future extension
//        EmptyExt ext;
//    };
//
type RemoveDataOp struct {
	DataId Uint64   `json:"dataID,omitempty"`
	Ext    EmptyExt `json:"ext,omitempty"`
}

// RemoveDataResultCode is an XDR Enum defines as:
//
//   enum RemoveDataResultCode
//    {
//        //: Data successfully removed
//        SUCCESS = 0,
//        //: Entry with provided ID does not exist
//        NOT_FOUND = -1,
//        //: Only owner or admin can remove data.
//        NOT_AUTHORIZED = -2
//    };
//
type RemoveDataResultCode int32

const (
	RemoveDataResultCodeSuccess       RemoveDataResultCode = 0
	RemoveDataResultCodeNotFound      RemoveDataResultCode = -1
	RemoveDataResultCodeNotAuthorized RemoveDataResultCode = -2
)

var RemoveDataResultCodeAll = []RemoveDataResultCode{
	RemoveDataResultCodeSuccess,
	RemoveDataResultCodeNotFound,
	RemoveDataResultCodeNotAuthorized,
}

var removeDataResultCodeMap = map[int32]string{
	0:  "RemoveDataResultCodeSuccess",
	-1: "RemoveDataResultCodeNotFound",
	-2: "RemoveDataResultCodeNotAuthorized",
}

var removeDataResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "not_found",
	-2: "not_authorized",
}

var removeDataResultCodeRevMap = map[string]int32{
	"RemoveDataResultCodeSuccess":       0,
	"RemoveDataResultCodeNotFound":      -1,
	"RemoveDataResultCodeNotAuthorized": -2,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for RemoveDataResultCode
func (e RemoveDataResultCode) ValidEnum(v int32) bool {
	_, ok := removeDataResultCodeMap[v]
	return ok
}
func (e RemoveDataResultCode) isFlag() bool {
	for i := len(RemoveDataResultCodeAll) - 1; i >= 0; i-- {
		expected := RemoveDataResultCode(2) << uint64(len(RemoveDataResultCodeAll)-1) >> uint64(len(RemoveDataResultCodeAll)-i)
		if expected != RemoveDataResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e RemoveDataResultCode) String() string {
	name, _ := removeDataResultCodeMap[int32(e)]
	return name
}

func (e RemoveDataResultCode) ShortString() string {
	name, _ := removeDataResultCodeShortMap[int32(e)]
	return name
}

func (e RemoveDataResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range RemoveDataResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *RemoveDataResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = RemoveDataResultCode(t.Value)
	return nil
}

// RemoveDataResult is an XDR Union defines as:
//
//   //: Result of operation application
//    union RemoveDataResult switch (RemoveDataResultCode code)
//    {
//    case SUCCESS:
//        //: Reserved for future extension
//        EmptyExt ext;
//    default:
//        void;
//    };
//
type RemoveDataResult struct {
	Code RemoveDataResultCode `json:"code,omitempty"`
	Ext  *EmptyExt            `json:"ext,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u RemoveDataResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of RemoveDataResult
func (u RemoveDataResult) ArmForSwitch(sw int32) (string, bool) {
	switch RemoveDataResultCode(sw) {
	case RemoveDataResultCodeSuccess:
		return "Ext", true
	default:
		return "", true
	}
}

// NewRemoveDataResult creates a new  RemoveDataResult.
func NewRemoveDataResult(code RemoveDataResultCode, value interface{}) (result RemoveDataResult, err error) {
	result.Code = code
	switch RemoveDataResultCode(code) {
	case RemoveDataResultCodeSuccess:
		tv, ok := value.(EmptyExt)
		if !ok {
			err = fmt.Errorf("invalid value, must be EmptyExt")
			return
		}
		result.Ext = &tv
	default:
		// void
	}
	return
}

// MustExt retrieves the Ext value from the union,
// panicing if the value is not set.
func (u RemoveDataResult) MustExt() EmptyExt {
	val, ok := u.GetExt()

	if !ok {
		panic("arm Ext is not set")
	}

	return val
}

// GetExt retrieves the Ext value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u RemoveDataResult) GetExt() (result EmptyExt, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Ext" {
		result = *u.Ext
		ok = true
	}

	return
}

// ReviewRequestOpAction is an XDR Enum defines as:
//
//   //: Actions that can be performed on request that is being reviewed
//    enum ReviewRequestOpAction {
//        //: Approve request
//        APPROVE = 1,
//        //: Reject request
//        REJECT = 2,
//        //: Permanently reject request
//        PERMANENT_REJECT = 3
//    };
//
type ReviewRequestOpAction int32

const (
	ReviewRequestOpActionApprove         ReviewRequestOpAction = 1
	ReviewRequestOpActionReject          ReviewRequestOpAction = 2
	ReviewRequestOpActionPermanentReject ReviewRequestOpAction = 3
)

var ReviewRequestOpActionAll = []ReviewRequestOpAction{
	ReviewRequestOpActionApprove,
	ReviewRequestOpActionReject,
	ReviewRequestOpActionPermanentReject,
}

var reviewRequestOpActionMap = map[int32]string{
	1: "ReviewRequestOpActionApprove",
	2: "ReviewRequestOpActionReject",
	3: "ReviewRequestOpActionPermanentReject",
}

var reviewRequestOpActionShortMap = map[int32]string{
	1: "approve",
	2: "reject",
	3: "permanent_reject",
}

var reviewRequestOpActionRevMap = map[string]int32{
	"ReviewRequestOpActionApprove":         1,
	"ReviewRequestOpActionReject":          2,
	"ReviewRequestOpActionPermanentReject": 3,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ReviewRequestOpAction
func (e ReviewRequestOpAction) ValidEnum(v int32) bool {
	_, ok := reviewRequestOpActionMap[v]
	return ok
}
func (e ReviewRequestOpAction) isFlag() bool {
	for i := len(ReviewRequestOpActionAll) - 1; i >= 0; i-- {
		expected := ReviewRequestOpAction(2) << uint64(len(ReviewRequestOpActionAll)-1) >> uint64(len(ReviewRequestOpActionAll)-i)
		if expected != ReviewRequestOpActionAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ReviewRequestOpAction) String() string {
	name, _ := reviewRequestOpActionMap[int32(e)]
	return name
}

func (e ReviewRequestOpAction) ShortString() string {
	name, _ := reviewRequestOpActionShortMap[int32(e)]
	return name
}

func (e ReviewRequestOpAction) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ReviewRequestOpActionAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ReviewRequestOpAction) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ReviewRequestOpAction(t.Value)
	return nil
}

// LimitsUpdateDetailsExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type LimitsUpdateDetailsExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LimitsUpdateDetailsExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LimitsUpdateDetailsExt
func (u LimitsUpdateDetailsExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLimitsUpdateDetailsExt creates a new  LimitsUpdateDetailsExt.
func NewLimitsUpdateDetailsExt(v LedgerVersion, value interface{}) (result LimitsUpdateDetailsExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LimitsUpdateDetails is an XDR Struct defines as:
//
//   //: Review details of a Limits Update request
//    struct LimitsUpdateDetails {
//        //: Limits entry containing new limits to set
//        LimitsV2Entry newLimitsV2;
//
//        //:reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type LimitsUpdateDetails struct {
	NewLimitsV2 LimitsV2Entry          `json:"newLimitsV2,omitempty"`
	Ext         LimitsUpdateDetailsExt `json:"ext,omitempty"`
}

// WithdrawalDetailsExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type WithdrawalDetailsExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u WithdrawalDetailsExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of WithdrawalDetailsExt
func (u WithdrawalDetailsExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewWithdrawalDetailsExt creates a new  WithdrawalDetailsExt.
func NewWithdrawalDetailsExt(v LedgerVersion, value interface{}) (result WithdrawalDetailsExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// WithdrawalDetails is an XDR Struct defines as:
//
//   //: Review details of a Withdraw Request
//    struct WithdrawalDetails {
//        //: External details updated on a Withdraw review
//        string externalDetails<>;
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type WithdrawalDetails struct {
	ExternalDetails string               `json:"externalDetails,omitempty"`
	Ext             WithdrawalDetailsExt `json:"ext,omitempty"`
}

// AmlAlertDetailsExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type AmlAlertDetailsExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u AmlAlertDetailsExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of AmlAlertDetailsExt
func (u AmlAlertDetailsExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewAmlAlertDetailsExt creates a new  AmlAlertDetailsExt.
func NewAmlAlertDetailsExt(v LedgerVersion, value interface{}) (result AmlAlertDetailsExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// AmlAlertDetails is an XDR Struct defines as:
//
//   //: Details of AML Alert
//    struct AMLAlertDetails {
//        //: Comment on reason of AML Alert
//        string comment<>;
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type AmlAlertDetails struct {
	Comment string             `json:"comment,omitempty"`
	Ext     AmlAlertDetailsExt `json:"ext,omitempty"`
}

// ContractDetailsExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//                void;
//        }
//
type ContractDetailsExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ContractDetailsExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ContractDetailsExt
func (u ContractDetailsExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewContractDetailsExt creates a new  ContractDetailsExt.
func NewContractDetailsExt(v LedgerVersion, value interface{}) (result ContractDetailsExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ContractDetails is an XDR Struct defines as:
//
//   struct ContractDetails {
//        longstring details;
//
//        // Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//                void;
//        }
//        ext;
//    };
//
type ContractDetails struct {
	Details Longstring         `json:"details,omitempty"`
	Ext     ContractDetailsExt `json:"ext,omitempty"`
}

// BillPayDetailsExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type BillPayDetailsExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u BillPayDetailsExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of BillPayDetailsExt
func (u BillPayDetailsExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewBillPayDetailsExt creates a new  BillPayDetailsExt.
func NewBillPayDetailsExt(v LedgerVersion, value interface{}) (result BillPayDetailsExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// BillPayDetails is an XDR Struct defines as:
//
//   //: Details of a payment reviewable request
//    struct BillPayDetails {
//        //: Details of payment
//        PaymentOp paymentDetails;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type BillPayDetails struct {
	PaymentDetails PaymentOp         `json:"paymentDetails,omitempty"`
	Ext            BillPayDetailsExt `json:"ext,omitempty"`
}

// ReviewDetailsExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ReviewDetailsExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ReviewDetailsExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ReviewDetailsExt
func (u ReviewDetailsExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewReviewDetailsExt creates a new  ReviewDetailsExt.
func NewReviewDetailsExt(v LedgerVersion, value interface{}) (result ReviewDetailsExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ReviewDetails is an XDR Struct defines as:
//
//   //: Details of a request review
//    struct ReviewDetails {
//        //: Tasks to add to pending
//        uint32 tasksToAdd;
//        //: Tasks to remove from pending
//        uint32 tasksToRemove;
//        //: Details of the current review
//        string externalDetails<>;
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ReviewDetails struct {
	TasksToAdd      Uint32           `json:"tasksToAdd,omitempty"`
	TasksToRemove   Uint32           `json:"tasksToRemove,omitempty"`
	ExternalDetails string           `json:"externalDetails,omitempty"`
	Ext             ReviewDetailsExt `json:"ext,omitempty"`
}

// SaleExtendedExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type SaleExtendedExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u SaleExtendedExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of SaleExtendedExt
func (u SaleExtendedExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewSaleExtendedExt creates a new  SaleExtendedExt.
func NewSaleExtendedExt(v LedgerVersion, value interface{}) (result SaleExtendedExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// SaleExtended is an XDR Struct defines as:
//
//   //: Extended result of the review request operation containing details specific to a Create Sale Request
//    struct SaleExtended {
//        //: ID of the newly created sale as a result of Create Sale Request successful review
//        uint64 saleID;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type SaleExtended struct {
	SaleId Uint64          `json:"saleID,omitempty"`
	Ext    SaleExtendedExt `json:"ext,omitempty"`
}

// AtomicSwapAskExtendedExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type AtomicSwapAskExtendedExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u AtomicSwapAskExtendedExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of AtomicSwapAskExtendedExt
func (u AtomicSwapAskExtendedExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewAtomicSwapAskExtendedExt creates a new  AtomicSwapAskExtendedExt.
func NewAtomicSwapAskExtendedExt(v LedgerVersion, value interface{}) (result AtomicSwapAskExtendedExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// AtomicSwapAskExtended is an XDR Struct defines as:
//
//   //: Extended result of the review request operation containing details specific to a Create Atomic Swap Bid Request
//    struct AtomicSwapAskExtended
//    {
//        //: ID of the newly created ask as a result of Create Atomic Swap Ask Request successful review
//        uint64 askID;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type AtomicSwapAskExtended struct {
	AskId Uint64                   `json:"askID,omitempty"`
	Ext   AtomicSwapAskExtendedExt `json:"ext,omitempty"`
}

// CreatePollExtendedExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreatePollExtendedExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreatePollExtendedExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreatePollExtendedExt
func (u CreatePollExtendedExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreatePollExtendedExt creates a new  CreatePollExtendedExt.
func NewCreatePollExtendedExt(v LedgerVersion, value interface{}) (result CreatePollExtendedExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreatePollExtended is an XDR Struct defines as:
//
//   //: Extended result of the review request operation containing details specific to a `CREATE_POLL` request
//    struct CreatePollExtended
//    {
//        //: ID of the newly created poll
//        uint64 pollID;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CreatePollExtended struct {
	PollId Uint64                `json:"pollID,omitempty"`
	Ext    CreatePollExtendedExt `json:"ext,omitempty"`
}

// AtomicSwapBidExtendedExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//                void;
//        }
//
type AtomicSwapBidExtendedExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u AtomicSwapBidExtendedExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of AtomicSwapBidExtendedExt
func (u AtomicSwapBidExtendedExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewAtomicSwapBidExtendedExt creates a new  AtomicSwapBidExtendedExt.
func NewAtomicSwapBidExtendedExt(v LedgerVersion, value interface{}) (result AtomicSwapBidExtendedExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// AtomicSwapBidExtended is an XDR Struct defines as:
//
//   //: Extended result of a review request operation containing details specific to a Create Atomic Swap Request
//    struct AtomicSwapBidExtended
//    {
//        //: ID of a ask to apply atomic swap to
//        uint64 askID;
//        //: AccountID of a ask owner
//        AccountID askOwnerID;
//        //: Account id of an bid owner
//        AccountID bidOwnerID;
//        //: Base asset for the atomic swap
//        AssetCode baseAsset;
//        //: Quote asset for the atomic swap
//        AssetCode quoteAsset;
//        //: Amount in base asset to exchange
//        uint64 baseAmount;
//        //: Amount in quote asset to exchange
//        uint64 quoteAmount;
//        //: Price of base asset in terms of quote
//        uint64 price;
//        //: Balance in base asset of a ask owner
//        BalanceID askOwnerBaseBalanceID;
//        //: Balance in base asset of an bid owner
//        BalanceID bidOwnerBaseBalanceID;
//        //: Amount which was unlocked on bid owner base balance after bid removing
//        uint64 unlockedAmount;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//                void;
//        }
//        ext;
//    };
//
type AtomicSwapBidExtended struct {
	AskId                 Uint64                   `json:"askID,omitempty"`
	AskOwnerId            AccountId                `json:"askOwnerID,omitempty"`
	BidOwnerId            AccountId                `json:"bidOwnerID,omitempty"`
	BaseAsset             AssetCode                `json:"baseAsset,omitempty"`
	QuoteAsset            AssetCode                `json:"quoteAsset,omitempty"`
	BaseAmount            Uint64                   `json:"baseAmount,omitempty"`
	QuoteAmount           Uint64                   `json:"quoteAmount,omitempty"`
	Price                 Uint64                   `json:"price,omitempty"`
	AskOwnerBaseBalanceId BalanceId                `json:"askOwnerBaseBalanceID,omitempty"`
	BidOwnerBaseBalanceId BalanceId                `json:"bidOwnerBaseBalanceID,omitempty"`
	UnlockedAmount        Uint64                   `json:"unlockedAmount,omitempty"`
	Ext                   AtomicSwapBidExtendedExt `json:"ext,omitempty"`
}

// CreateDeferredPaymentResult is an XDR Struct defines as:
//
//   struct CreateDeferredPaymentResult
//    {
//        uint64 deferredPaymentID;
//        AccountID destination;
//        AccountID source;
//
//        EmptyExt ext;
//    };
//
type CreateDeferredPaymentResult struct {
	DeferredPaymentId Uint64    `json:"deferredPaymentID,omitempty"`
	Destination       AccountId `json:"destination,omitempty"`
	Source            AccountId `json:"source,omitempty"`
	Ext               EmptyExt  `json:"ext,omitempty"`
}

// DataCreationExtended is an XDR Struct defines as:
//
//   struct DataCreationExtended {
//        //: Owner of the created data entry
//        AccountID owner;
//        //: ID of the created data entry
//        uint64 id;
//        //: Security type of the created data entry
//        uint64 type;
//    };
//
type DataCreationExtended struct {
	Owner AccountId `json:"owner,omitempty"`
	Id    Uint64    `json:"id,omitempty"`
	Type  Uint64    `json:"type,omitempty"`
}

// ExtendedResultTypeExt is an XDR NestedUnion defines as:
//
//   union switch(ReviewableRequestType requestType) {
//        case CREATE_SALE:
//            SaleExtended saleExtended;
//        case NONE:
//            void;
//        case CREATE_ATOMIC_SWAP_BID:
//            AtomicSwapBidExtended atomicSwapBidExtended;
//        case CREATE_ATOMIC_SWAP_ASK:
//            AtomicSwapAskExtended atomicSwapAskExtended;
//        case CREATE_POLL:
//            CreatePollExtended createPoll;
//        case MANAGE_OFFER:
//            ManageOfferResult manageOfferResult;
//        case CREATE_PAYMENT:
//            PaymentResult paymentResult;
//        case PERFORM_REDEMPTION:
//            CreateRedemptionRequestResult createRedemptionResult;
//        case DATA_CREATION:
//            DataCreationExtended dataCreationExtended;
//        case CREATE_DEFERRED_PAYMENT:
//            CreateDeferredPaymentResult createDeferredPaymentResult;
//        case CLOSE_DEFERRED_PAYMENT:
//             CloseDeferredPaymentResult closeDeferredPaymentResult;
//
//        }
//
type ExtendedResultTypeExt struct {
	RequestType                 ReviewableRequestType          `json:"requestType,omitempty"`
	SaleExtended                *SaleExtended                  `json:"saleExtended,omitempty"`
	AtomicSwapBidExtended       *AtomicSwapBidExtended         `json:"atomicSwapBidExtended,omitempty"`
	AtomicSwapAskExtended       *AtomicSwapAskExtended         `json:"atomicSwapAskExtended,omitempty"`
	CreatePoll                  *CreatePollExtended            `json:"createPoll,omitempty"`
	ManageOfferResult           *ManageOfferResult             `json:"manageOfferResult,omitempty"`
	PaymentResult               *PaymentResult                 `json:"paymentResult,omitempty"`
	CreateRedemptionResult      *CreateRedemptionRequestResult `json:"createRedemptionResult,omitempty"`
	DataCreationExtended        *DataCreationExtended          `json:"dataCreationExtended,omitempty"`
	CreateDeferredPaymentResult *CreateDeferredPaymentResult   `json:"createDeferredPaymentResult,omitempty"`
	CloseDeferredPaymentResult  *CloseDeferredPaymentResult    `json:"closeDeferredPaymentResult,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ExtendedResultTypeExt) SwitchFieldName() string {
	return "RequestType"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ExtendedResultTypeExt
func (u ExtendedResultTypeExt) ArmForSwitch(sw int32) (string, bool) {
	switch ReviewableRequestType(sw) {
	case ReviewableRequestTypeCreateSale:
		return "SaleExtended", true
	case ReviewableRequestTypeNone:
		return "", true
	case ReviewableRequestTypeCreateAtomicSwapBid:
		return "AtomicSwapBidExtended", true
	case ReviewableRequestTypeCreateAtomicSwapAsk:
		return "AtomicSwapAskExtended", true
	case ReviewableRequestTypeCreatePoll:
		return "CreatePoll", true
	case ReviewableRequestTypeManageOffer:
		return "ManageOfferResult", true
	case ReviewableRequestTypeCreatePayment:
		return "PaymentResult", true
	case ReviewableRequestTypePerformRedemption:
		return "CreateRedemptionResult", true
	case ReviewableRequestTypeDataCreation:
		return "DataCreationExtended", true
	case ReviewableRequestTypeCreateDeferredPayment:
		return "CreateDeferredPaymentResult", true
	case ReviewableRequestTypeCloseDeferredPayment:
		return "CloseDeferredPaymentResult", true
	}
	return "-", false
}

// NewExtendedResultTypeExt creates a new  ExtendedResultTypeExt.
func NewExtendedResultTypeExt(requestType ReviewableRequestType, value interface{}) (result ExtendedResultTypeExt, err error) {
	result.RequestType = requestType
	switch ReviewableRequestType(requestType) {
	case ReviewableRequestTypeCreateSale:
		tv, ok := value.(SaleExtended)
		if !ok {
			err = fmt.Errorf("invalid value, must be SaleExtended")
			return
		}
		result.SaleExtended = &tv
	case ReviewableRequestTypeNone:
		// void
	case ReviewableRequestTypeCreateAtomicSwapBid:
		tv, ok := value.(AtomicSwapBidExtended)
		if !ok {
			err = fmt.Errorf("invalid value, must be AtomicSwapBidExtended")
			return
		}
		result.AtomicSwapBidExtended = &tv
	case ReviewableRequestTypeCreateAtomicSwapAsk:
		tv, ok := value.(AtomicSwapAskExtended)
		if !ok {
			err = fmt.Errorf("invalid value, must be AtomicSwapAskExtended")
			return
		}
		result.AtomicSwapAskExtended = &tv
	case ReviewableRequestTypeCreatePoll:
		tv, ok := value.(CreatePollExtended)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreatePollExtended")
			return
		}
		result.CreatePoll = &tv
	case ReviewableRequestTypeManageOffer:
		tv, ok := value.(ManageOfferResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageOfferResult")
			return
		}
		result.ManageOfferResult = &tv
	case ReviewableRequestTypeCreatePayment:
		tv, ok := value.(PaymentResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be PaymentResult")
			return
		}
		result.PaymentResult = &tv
	case ReviewableRequestTypePerformRedemption:
		tv, ok := value.(CreateRedemptionRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateRedemptionRequestResult")
			return
		}
		result.CreateRedemptionResult = &tv
	case ReviewableRequestTypeDataCreation:
		tv, ok := value.(DataCreationExtended)
		if !ok {
			err = fmt.Errorf("invalid value, must be DataCreationExtended")
			return
		}
		result.DataCreationExtended = &tv
	case ReviewableRequestTypeCreateDeferredPayment:
		tv, ok := value.(CreateDeferredPaymentResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateDeferredPaymentResult")
			return
		}
		result.CreateDeferredPaymentResult = &tv
	case ReviewableRequestTypeCloseDeferredPayment:
		tv, ok := value.(CloseDeferredPaymentResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CloseDeferredPaymentResult")
			return
		}
		result.CloseDeferredPaymentResult = &tv
	}
	return
}

// MustSaleExtended retrieves the SaleExtended value from the union,
// panicing if the value is not set.
func (u ExtendedResultTypeExt) MustSaleExtended() SaleExtended {
	val, ok := u.GetSaleExtended()

	if !ok {
		panic("arm SaleExtended is not set")
	}

	return val
}

// GetSaleExtended retrieves the SaleExtended value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ExtendedResultTypeExt) GetSaleExtended() (result SaleExtended, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "SaleExtended" {
		result = *u.SaleExtended
		ok = true
	}

	return
}

// MustAtomicSwapBidExtended retrieves the AtomicSwapBidExtended value from the union,
// panicing if the value is not set.
func (u ExtendedResultTypeExt) MustAtomicSwapBidExtended() AtomicSwapBidExtended {
	val, ok := u.GetAtomicSwapBidExtended()

	if !ok {
		panic("arm AtomicSwapBidExtended is not set")
	}

	return val
}

// GetAtomicSwapBidExtended retrieves the AtomicSwapBidExtended value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ExtendedResultTypeExt) GetAtomicSwapBidExtended() (result AtomicSwapBidExtended, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "AtomicSwapBidExtended" {
		result = *u.AtomicSwapBidExtended
		ok = true
	}

	return
}

// MustAtomicSwapAskExtended retrieves the AtomicSwapAskExtended value from the union,
// panicing if the value is not set.
func (u ExtendedResultTypeExt) MustAtomicSwapAskExtended() AtomicSwapAskExtended {
	val, ok := u.GetAtomicSwapAskExtended()

	if !ok {
		panic("arm AtomicSwapAskExtended is not set")
	}

	return val
}

// GetAtomicSwapAskExtended retrieves the AtomicSwapAskExtended value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ExtendedResultTypeExt) GetAtomicSwapAskExtended() (result AtomicSwapAskExtended, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "AtomicSwapAskExtended" {
		result = *u.AtomicSwapAskExtended
		ok = true
	}

	return
}

// MustCreatePoll retrieves the CreatePoll value from the union,
// panicing if the value is not set.
func (u ExtendedResultTypeExt) MustCreatePoll() CreatePollExtended {
	val, ok := u.GetCreatePoll()

	if !ok {
		panic("arm CreatePoll is not set")
	}

	return val
}

// GetCreatePoll retrieves the CreatePoll value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ExtendedResultTypeExt) GetCreatePoll() (result CreatePollExtended, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "CreatePoll" {
		result = *u.CreatePoll
		ok = true
	}

	return
}

// MustManageOfferResult retrieves the ManageOfferResult value from the union,
// panicing if the value is not set.
func (u ExtendedResultTypeExt) MustManageOfferResult() ManageOfferResult {
	val, ok := u.GetManageOfferResult()

	if !ok {
		panic("arm ManageOfferResult is not set")
	}

	return val
}

// GetManageOfferResult retrieves the ManageOfferResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ExtendedResultTypeExt) GetManageOfferResult() (result ManageOfferResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "ManageOfferResult" {
		result = *u.ManageOfferResult
		ok = true
	}

	return
}

// MustPaymentResult retrieves the PaymentResult value from the union,
// panicing if the value is not set.
func (u ExtendedResultTypeExt) MustPaymentResult() PaymentResult {
	val, ok := u.GetPaymentResult()

	if !ok {
		panic("arm PaymentResult is not set")
	}

	return val
}

// GetPaymentResult retrieves the PaymentResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ExtendedResultTypeExt) GetPaymentResult() (result PaymentResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "PaymentResult" {
		result = *u.PaymentResult
		ok = true
	}

	return
}

// MustCreateRedemptionResult retrieves the CreateRedemptionResult value from the union,
// panicing if the value is not set.
func (u ExtendedResultTypeExt) MustCreateRedemptionResult() CreateRedemptionRequestResult {
	val, ok := u.GetCreateRedemptionResult()

	if !ok {
		panic("arm CreateRedemptionResult is not set")
	}

	return val
}

// GetCreateRedemptionResult retrieves the CreateRedemptionResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ExtendedResultTypeExt) GetCreateRedemptionResult() (result CreateRedemptionRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "CreateRedemptionResult" {
		result = *u.CreateRedemptionResult
		ok = true
	}

	return
}

// MustDataCreationExtended retrieves the DataCreationExtended value from the union,
// panicing if the value is not set.
func (u ExtendedResultTypeExt) MustDataCreationExtended() DataCreationExtended {
	val, ok := u.GetDataCreationExtended()

	if !ok {
		panic("arm DataCreationExtended is not set")
	}

	return val
}

// GetDataCreationExtended retrieves the DataCreationExtended value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ExtendedResultTypeExt) GetDataCreationExtended() (result DataCreationExtended, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "DataCreationExtended" {
		result = *u.DataCreationExtended
		ok = true
	}

	return
}

// MustCreateDeferredPaymentResult retrieves the CreateDeferredPaymentResult value from the union,
// panicing if the value is not set.
func (u ExtendedResultTypeExt) MustCreateDeferredPaymentResult() CreateDeferredPaymentResult {
	val, ok := u.GetCreateDeferredPaymentResult()

	if !ok {
		panic("arm CreateDeferredPaymentResult is not set")
	}

	return val
}

// GetCreateDeferredPaymentResult retrieves the CreateDeferredPaymentResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ExtendedResultTypeExt) GetCreateDeferredPaymentResult() (result CreateDeferredPaymentResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "CreateDeferredPaymentResult" {
		result = *u.CreateDeferredPaymentResult
		ok = true
	}

	return
}

// MustCloseDeferredPaymentResult retrieves the CloseDeferredPaymentResult value from the union,
// panicing if the value is not set.
func (u ExtendedResultTypeExt) MustCloseDeferredPaymentResult() CloseDeferredPaymentResult {
	val, ok := u.GetCloseDeferredPaymentResult()

	if !ok {
		panic("arm CloseDeferredPaymentResult is not set")
	}

	return val
}

// GetCloseDeferredPaymentResult retrieves the CloseDeferredPaymentResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ExtendedResultTypeExt) GetCloseDeferredPaymentResult() (result CloseDeferredPaymentResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "CloseDeferredPaymentResult" {
		result = *u.CloseDeferredPaymentResult
		ok = true
	}

	return
}

// ExtendedResultExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ExtendedResultExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ExtendedResultExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ExtendedResultExt
func (u ExtendedResultExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewExtendedResultExt creates a new  ExtendedResultExt.
func NewExtendedResultExt(v LedgerVersion, value interface{}) (result ExtendedResultExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ExtendedResult is an XDR Struct defines as:
//
//   //: Extended result of a Review Request operation containing details specific to certain request types
//    struct ExtendedResult {
//        //: Indicates whether or not the request that is being reviewed was applied
//        bool fulfilled;
//        //: typeExt is used to pass ReviewableRequestType along with details specific to a request type
//        union switch(ReviewableRequestType requestType) {
//        case CREATE_SALE:
//            SaleExtended saleExtended;
//        case NONE:
//            void;
//        case CREATE_ATOMIC_SWAP_BID:
//            AtomicSwapBidExtended atomicSwapBidExtended;
//        case CREATE_ATOMIC_SWAP_ASK:
//            AtomicSwapAskExtended atomicSwapAskExtended;
//        case CREATE_POLL:
//            CreatePollExtended createPoll;
//        case MANAGE_OFFER:
//            ManageOfferResult manageOfferResult;
//        case CREATE_PAYMENT:
//            PaymentResult paymentResult;
//        case PERFORM_REDEMPTION:
//            CreateRedemptionRequestResult createRedemptionResult;
//        case DATA_CREATION:
//            DataCreationExtended dataCreationExtended;
//        case CREATE_DEFERRED_PAYMENT:
//            CreateDeferredPaymentResult createDeferredPaymentResult;
//        case CLOSE_DEFERRED_PAYMENT:
//             CloseDeferredPaymentResult closeDeferredPaymentResult;
//
//        } typeExt;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ExtendedResult struct {
	Fulfilled bool                  `json:"fulfilled,omitempty"`
	TypeExt   ExtendedResultTypeExt `json:"typeExt,omitempty"`
	Ext       ExtendedResultExt     `json:"ext,omitempty"`
}

// ReviewRequestOpRequestDetails is an XDR NestedUnion defines as:
//
//   union switch(ReviewableRequestType requestType) {
//        case CREATE_WITHDRAW:
//            WithdrawalDetails withdrawal;
//        case UPDATE_LIMITS:
//            LimitsUpdateDetails limitsUpdate;
//        case CREATE_AML_ALERT:
//            AMLAlertDetails amlAlertDetails;
//        case CREATE_INVOICE:
//            BillPayDetails billPay;
//        case MANAGE_CONTRACT:
//            ContractDetails contract;
//        default:
//            void;
//        }
//
type ReviewRequestOpRequestDetails struct {
	RequestType     ReviewableRequestType `json:"requestType,omitempty"`
	Withdrawal      *WithdrawalDetails    `json:"withdrawal,omitempty"`
	LimitsUpdate    *LimitsUpdateDetails  `json:"limitsUpdate,omitempty"`
	AmlAlertDetails *AmlAlertDetails      `json:"amlAlertDetails,omitempty"`
	BillPay         *BillPayDetails       `json:"billPay,omitempty"`
	Contract        *ContractDetails      `json:"contract,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ReviewRequestOpRequestDetails) SwitchFieldName() string {
	return "RequestType"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ReviewRequestOpRequestDetails
func (u ReviewRequestOpRequestDetails) ArmForSwitch(sw int32) (string, bool) {
	switch ReviewableRequestType(sw) {
	case ReviewableRequestTypeCreateWithdraw:
		return "Withdrawal", true
	case ReviewableRequestTypeUpdateLimits:
		return "LimitsUpdate", true
	case ReviewableRequestTypeCreateAmlAlert:
		return "AmlAlertDetails", true
	case ReviewableRequestTypeCreateInvoice:
		return "BillPay", true
	case ReviewableRequestTypeManageContract:
		return "Contract", true
	default:
		return "", true
	}
}

// NewReviewRequestOpRequestDetails creates a new  ReviewRequestOpRequestDetails.
func NewReviewRequestOpRequestDetails(requestType ReviewableRequestType, value interface{}) (result ReviewRequestOpRequestDetails, err error) {
	result.RequestType = requestType
	switch ReviewableRequestType(requestType) {
	case ReviewableRequestTypeCreateWithdraw:
		tv, ok := value.(WithdrawalDetails)
		if !ok {
			err = fmt.Errorf("invalid value, must be WithdrawalDetails")
			return
		}
		result.Withdrawal = &tv
	case ReviewableRequestTypeUpdateLimits:
		tv, ok := value.(LimitsUpdateDetails)
		if !ok {
			err = fmt.Errorf("invalid value, must be LimitsUpdateDetails")
			return
		}
		result.LimitsUpdate = &tv
	case ReviewableRequestTypeCreateAmlAlert:
		tv, ok := value.(AmlAlertDetails)
		if !ok {
			err = fmt.Errorf("invalid value, must be AmlAlertDetails")
			return
		}
		result.AmlAlertDetails = &tv
	case ReviewableRequestTypeCreateInvoice:
		tv, ok := value.(BillPayDetails)
		if !ok {
			err = fmt.Errorf("invalid value, must be BillPayDetails")
			return
		}
		result.BillPay = &tv
	case ReviewableRequestTypeManageContract:
		tv, ok := value.(ContractDetails)
		if !ok {
			err = fmt.Errorf("invalid value, must be ContractDetails")
			return
		}
		result.Contract = &tv
	default:
		// void
	}
	return
}

// MustWithdrawal retrieves the Withdrawal value from the union,
// panicing if the value is not set.
func (u ReviewRequestOpRequestDetails) MustWithdrawal() WithdrawalDetails {
	val, ok := u.GetWithdrawal()

	if !ok {
		panic("arm Withdrawal is not set")
	}

	return val
}

// GetWithdrawal retrieves the Withdrawal value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewRequestOpRequestDetails) GetWithdrawal() (result WithdrawalDetails, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "Withdrawal" {
		result = *u.Withdrawal
		ok = true
	}

	return
}

// MustLimitsUpdate retrieves the LimitsUpdate value from the union,
// panicing if the value is not set.
func (u ReviewRequestOpRequestDetails) MustLimitsUpdate() LimitsUpdateDetails {
	val, ok := u.GetLimitsUpdate()

	if !ok {
		panic("arm LimitsUpdate is not set")
	}

	return val
}

// GetLimitsUpdate retrieves the LimitsUpdate value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewRequestOpRequestDetails) GetLimitsUpdate() (result LimitsUpdateDetails, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "LimitsUpdate" {
		result = *u.LimitsUpdate
		ok = true
	}

	return
}

// MustAmlAlertDetails retrieves the AmlAlertDetails value from the union,
// panicing if the value is not set.
func (u ReviewRequestOpRequestDetails) MustAmlAlertDetails() AmlAlertDetails {
	val, ok := u.GetAmlAlertDetails()

	if !ok {
		panic("arm AmlAlertDetails is not set")
	}

	return val
}

// GetAmlAlertDetails retrieves the AmlAlertDetails value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewRequestOpRequestDetails) GetAmlAlertDetails() (result AmlAlertDetails, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "AmlAlertDetails" {
		result = *u.AmlAlertDetails
		ok = true
	}

	return
}

// MustBillPay retrieves the BillPay value from the union,
// panicing if the value is not set.
func (u ReviewRequestOpRequestDetails) MustBillPay() BillPayDetails {
	val, ok := u.GetBillPay()

	if !ok {
		panic("arm BillPay is not set")
	}

	return val
}

// GetBillPay retrieves the BillPay value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewRequestOpRequestDetails) GetBillPay() (result BillPayDetails, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "BillPay" {
		result = *u.BillPay
		ok = true
	}

	return
}

// MustContract retrieves the Contract value from the union,
// panicing if the value is not set.
func (u ReviewRequestOpRequestDetails) MustContract() ContractDetails {
	val, ok := u.GetContract()

	if !ok {
		panic("arm Contract is not set")
	}

	return val
}

// GetContract retrieves the Contract value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewRequestOpRequestDetails) GetContract() (result ContractDetails, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "Contract" {
		result = *u.Contract
		ok = true
	}

	return
}

// ReviewRequestOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ReviewRequestOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ReviewRequestOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ReviewRequestOpExt
func (u ReviewRequestOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewReviewRequestOpExt creates a new  ReviewRequestOpExt.
func NewReviewRequestOpExt(v LedgerVersion, value interface{}) (result ReviewRequestOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ReviewRequestOp is an XDR Struct defines as:
//
//   //: Review Request operation
//    struct ReviewRequestOp
//    {
//        //: ID of a request that is being reviewed
//        uint64 requestID;
//        //: Hash of a request that is being reviewed
//        Hash requestHash;
//        //: requestDetails is used to pass request type along with details specific to it.
//        union switch(ReviewableRequestType requestType) {
//        case CREATE_WITHDRAW:
//            WithdrawalDetails withdrawal;
//        case UPDATE_LIMITS:
//            LimitsUpdateDetails limitsUpdate;
//        case CREATE_AML_ALERT:
//            AMLAlertDetails amlAlertDetails;
//        case CREATE_INVOICE:
//            BillPayDetails billPay;
//        case MANAGE_CONTRACT:
//            ContractDetails contract;
//        default:
//            void;
//        } requestDetails;
//        //: Review action defines an action performed on the pending ReviewableRequest
//        ReviewRequestOpAction action;
//        //: Contains reject reason
//        longstring reason;
//        //: Details of the ReviewRequest operation
//        ReviewDetails reviewDetails;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ReviewRequestOp struct {
	RequestId      Uint64                        `json:"requestID,omitempty"`
	RequestHash    Hash                          `json:"requestHash,omitempty"`
	RequestDetails ReviewRequestOpRequestDetails `json:"requestDetails,omitempty"`
	Action         ReviewRequestOpAction         `json:"action,omitempty"`
	Reason         Longstring                    `json:"reason,omitempty"`
	ReviewDetails  ReviewDetails                 `json:"reviewDetails,omitempty"`
	Ext            ReviewRequestOpExt            `json:"ext,omitempty"`
}

// ReviewRequestResultCode is an XDR Enum defines as:
//
//   //: Result code of the ReviewRequest operation
//    enum ReviewRequestResultCode
//    {
//        //: Codes considered as "success" for an operation
//        //: Operation is applied successfully
//        SUCCESS = 0,
//
//        //: Codes considered as "failure" for an operation
//        //: Reject reason must be empty on approve and not empty on reject/permanent
//        INVALID_REASON = -1,
//        //: Unknown action to perform on ReviewableRequest
//        INVALID_ACTION = -2,
//        //: Actual hash of the request and provided hash are mismatched
//        HASH_MISMATCHED = -3,
//        //: ReviewableRequest is not found
//        NOT_FOUND = -4,
//        //: Actual type of a reviewable request and provided type are mismatched
//        TYPE_MISMATCHED = -5,
//        //: Reject is not allowed. Only permanent reject should be used
//        REJECT_NOT_ALLOWED = -6,
//        //: External details must be a valid JSON
//        INVALID_EXTERNAL_DETAILS = -7,
//        //: Source of ReviewableRequest is blocked
//        REQUESTOR_IS_BLOCKED = -8,
//        //: Permanent reject is not allowed. Only reject should be used
//        PERMANENT_REJECT_NOT_ALLOWED = -9,
//        //: Trying to remove tasks which are not set
//        REMOVING_NOT_SET_TASKS = -100,// cannot remove tasks which are not set
//
//        //: Asset requests
//        //: Trying to create an asset that already exists
//        ASSET_ALREADY_EXISTS = -200,
//        //: Trying to update an asset that does not exist
//        ASSET_DOES_NOT_EXISTS = -210,
//
//        //: Issuance requests
//        //: After the issuance request application, issued amount will exceed max issuance amount
//        MAX_ISSUANCE_AMOUNT_EXCEEDED = -400,
//        //: Trying to issue more than it is available for issuance
//        INSUFFICIENT_AVAILABLE_FOR_ISSUANCE_AMOUNT = -410,
//        //: Funding account will exceed UINT64_MAX
//        FULL_LINE = -420,
//        //: It is not allowed to set system tasks
//        SYSTEM_TASKS_NOT_ALLOWED = -430,
//        //: Incorrect amount precision
//        INCORRECT_PRECISION = -440,
//
//        //: Sale creation requests
//        //: Trying to create a sale for a base asset that does not exist
//        BASE_ASSET_DOES_NOT_EXISTS = -500,
//        //: Trying to create a sale with hard cap that will exceed max issuance amount
//        HARD_CAP_WILL_EXCEED_MAX_ISSUANCE = -510,
//        //: Trying to create a sale with preissued amount that is less than the hard cap
//        INSUFFICIENT_PREISSUED_FOR_HARD_CAP = -520,
//        //: Trying to create a sale for a base asset that cannot be found
//        BASE_ASSET_NOT_FOUND = -530,
//        //: There is no asset pair between default quote asset and quote asset
//        ASSET_PAIR_NOT_FOUND = -540,
//        //: Trying to create a sale with one of the quote assets that doesn't exist
//        QUOTE_ASSET_NOT_FOUND = -550,
//
//        //: Change role
//        //: Trying to remove zero tasks
//        NON_ZERO_TASKS_TO_REMOVE_NOT_ALLOWED = -600,
//        //: There is no account role with provided id
//        ACCOUNT_ROLE_TO_SET_DOES_NOT_EXIST = -610,
//
//
//        //: Update sale details
//        //: Trying to update details of a non-existing sale
//        SALE_NOT_FOUND = -700,
//
//        //: Deprecated: Invoice requests
//        AMOUNT_MISMATCHED = -1010, // amount does not match
//        DESTINATION_BALANCE_MISMATCHED = -1020, // invoice balance and payment balance do not match
//        NOT_ALLOWED_ACCOUNT_DESTINATION = -1030,
//        REQUIRED_SOURCE_PAY_FOR_DESTINATION = -1040, // not allowed shift fee responsibility to destination
//        SOURCE_BALANCE_MISMATCHED = -1050, // source balance must match invoice sender account
//        CONTRACT_NOT_FOUND = -1060,
//        INVOICE_RECEIVER_BALANCE_LOCK_AMOUNT_OVERFLOW = -1070,
//        INVOICE_ALREADY_APPROVED = -1080,
//
//        // codes considered as "failure" for the payment operation
//        //: Deprecated: Invoice requests
//        PAYMENT_V2_MALFORMED = -1100,
//        UNDERFUNDED = -1110,
//        LINE_FULL = -1120,
//        DESTINATION_BALANCE_NOT_FOUND = -1130,
//        BALANCE_ASSETS_MISMATCHED = -1140,
//        SRC_BALANCE_NOT_FOUND = -1150,
//        REFERENCE_DUPLICATION = -1160,
//        STATS_OVERFLOW = -1170,
//        LIMITS_EXCEEDED = -1180,
//        NOT_ALLOWED_BY_ASSET_POLICY = -1190,
//        INVALID_DESTINATION_FEE = -1200,
//        INVALID_DESTINATION_FEE_ASSET = -1210, // destination fee asset must be the same as source balance asset
//        FEE_ASSET_MISMATCHED = -1220,
//        INSUFFICIENT_FEE_AMOUNT = -1230,
//        BALANCE_TO_CHARGE_FEE_FROM_NOT_FOUND = -1240,
//        PAYMENT_AMOUNT_IS_LESS_THAN_DEST_FEE = -1250,
//        DESTINATION_ACCOUNT_NOT_FOUND = -1260,
//
//        //: Limits update requests
//        //: Trying to create a limits update request for both account and account type at the same time
//        CANNOT_CREATE_FOR_ACC_ID_AND_ACC_TYPE = 1300,
//        //: Trying to set invalid limits, i.e. with dayly limit greater than weekly limit
//        INVALID_LIMITS = 1310,
//        //: There is no account with passed ID for limits update request
//        ACCOUNT_NOT_FOUND = -1311,
//        //: There is no role with passed ID for limits update request
//        ROLE_NOT_FOUND = -1312,
//
//        //: Deprecated: Contract requests
//        CONTRACT_DETAILS_TOO_LONG = -1400, // customer details reached length limit
//
//        // Atomic swap
//        BASE_ASSET_CANNOT_BE_SWAPPED = -1500,
//        QUOTE_ASSET_CANNOT_BE_SWAPPED = -1501,
//        ATOMIC_SWAP_BID_OWNER_FULL_LINE = -1504,
//
//        //KYC
//        //:Signer data is invalid - either weight is wrong or details are invalid
//        INVALID_SIGNER_DATA = -1600,
//
//        // offer
//        MANAGE_OFFER_FAILED = -1700,
//
//        // payment
//        PAYMENT_FAILED = -1800,
//
//        // Update Data
//        DATA_NOT_FOUND = -1900
//    };
//
type ReviewRequestResultCode int32

const (
	ReviewRequestResultCodeSuccess                                  ReviewRequestResultCode = 0
	ReviewRequestResultCodeInvalidReason                            ReviewRequestResultCode = -1
	ReviewRequestResultCodeInvalidAction                            ReviewRequestResultCode = -2
	ReviewRequestResultCodeHashMismatched                           ReviewRequestResultCode = -3
	ReviewRequestResultCodeNotFound                                 ReviewRequestResultCode = -4
	ReviewRequestResultCodeTypeMismatched                           ReviewRequestResultCode = -5
	ReviewRequestResultCodeRejectNotAllowed                         ReviewRequestResultCode = -6
	ReviewRequestResultCodeInvalidExternalDetails                   ReviewRequestResultCode = -7
	ReviewRequestResultCodeRequestorIsBlocked                       ReviewRequestResultCode = -8
	ReviewRequestResultCodePermanentRejectNotAllowed                ReviewRequestResultCode = -9
	ReviewRequestResultCodeRemovingNotSetTasks                      ReviewRequestResultCode = -100
	ReviewRequestResultCodeAssetAlreadyExists                       ReviewRequestResultCode = -200
	ReviewRequestResultCodeAssetDoesNotExists                       ReviewRequestResultCode = -210
	ReviewRequestResultCodeMaxIssuanceAmountExceeded                ReviewRequestResultCode = -400
	ReviewRequestResultCodeInsufficientAvailableForIssuanceAmount   ReviewRequestResultCode = -410
	ReviewRequestResultCodeFullLine                                 ReviewRequestResultCode = -420
	ReviewRequestResultCodeSystemTasksNotAllowed                    ReviewRequestResultCode = -430
	ReviewRequestResultCodeIncorrectPrecision                       ReviewRequestResultCode = -440
	ReviewRequestResultCodeBaseAssetDoesNotExists                   ReviewRequestResultCode = -500
	ReviewRequestResultCodeHardCapWillExceedMaxIssuance             ReviewRequestResultCode = -510
	ReviewRequestResultCodeInsufficientPreissuedForHardCap          ReviewRequestResultCode = -520
	ReviewRequestResultCodeBaseAssetNotFound                        ReviewRequestResultCode = -530
	ReviewRequestResultCodeAssetPairNotFound                        ReviewRequestResultCode = -540
	ReviewRequestResultCodeQuoteAssetNotFound                       ReviewRequestResultCode = -550
	ReviewRequestResultCodeNonZeroTasksToRemoveNotAllowed           ReviewRequestResultCode = -600
	ReviewRequestResultCodeAccountRoleToSetDoesNotExist             ReviewRequestResultCode = -610
	ReviewRequestResultCodeSaleNotFound                             ReviewRequestResultCode = -700
	ReviewRequestResultCodeAmountMismatched                         ReviewRequestResultCode = -1010
	ReviewRequestResultCodeDestinationBalanceMismatched             ReviewRequestResultCode = -1020
	ReviewRequestResultCodeNotAllowedAccountDestination             ReviewRequestResultCode = -1030
	ReviewRequestResultCodeRequiredSourcePayForDestination          ReviewRequestResultCode = -1040
	ReviewRequestResultCodeSourceBalanceMismatched                  ReviewRequestResultCode = -1050
	ReviewRequestResultCodeContractNotFound                         ReviewRequestResultCode = -1060
	ReviewRequestResultCodeInvoiceReceiverBalanceLockAmountOverflow ReviewRequestResultCode = -1070
	ReviewRequestResultCodeInvoiceAlreadyApproved                   ReviewRequestResultCode = -1080
	ReviewRequestResultCodePaymentV2Malformed                       ReviewRequestResultCode = -1100
	ReviewRequestResultCodeUnderfunded                              ReviewRequestResultCode = -1110
	ReviewRequestResultCodeLineFull                                 ReviewRequestResultCode = -1120
	ReviewRequestResultCodeDestinationBalanceNotFound               ReviewRequestResultCode = -1130
	ReviewRequestResultCodeBalanceAssetsMismatched                  ReviewRequestResultCode = -1140
	ReviewRequestResultCodeSrcBalanceNotFound                       ReviewRequestResultCode = -1150
	ReviewRequestResultCodeReferenceDuplication                     ReviewRequestResultCode = -1160
	ReviewRequestResultCodeStatsOverflow                            ReviewRequestResultCode = -1170
	ReviewRequestResultCodeLimitsExceeded                           ReviewRequestResultCode = -1180
	ReviewRequestResultCodeNotAllowedByAssetPolicy                  ReviewRequestResultCode = -1190
	ReviewRequestResultCodeInvalidDestinationFee                    ReviewRequestResultCode = -1200
	ReviewRequestResultCodeInvalidDestinationFeeAsset               ReviewRequestResultCode = -1210
	ReviewRequestResultCodeFeeAssetMismatched                       ReviewRequestResultCode = -1220
	ReviewRequestResultCodeInsufficientFeeAmount                    ReviewRequestResultCode = -1230
	ReviewRequestResultCodeBalanceToChargeFeeFromNotFound           ReviewRequestResultCode = -1240
	ReviewRequestResultCodePaymentAmountIsLessThanDestFee           ReviewRequestResultCode = -1250
	ReviewRequestResultCodeDestinationAccountNotFound               ReviewRequestResultCode = -1260
	ReviewRequestResultCodeCannotCreateForAccIdAndAccType           ReviewRequestResultCode = 1300
	ReviewRequestResultCodeInvalidLimits                            ReviewRequestResultCode = 1310
	ReviewRequestResultCodeAccountNotFound                          ReviewRequestResultCode = -1311
	ReviewRequestResultCodeRoleNotFound                             ReviewRequestResultCode = -1312
	ReviewRequestResultCodeContractDetailsTooLong                   ReviewRequestResultCode = -1400
	ReviewRequestResultCodeBaseAssetCannotBeSwapped                 ReviewRequestResultCode = -1500
	ReviewRequestResultCodeQuoteAssetCannotBeSwapped                ReviewRequestResultCode = -1501
	ReviewRequestResultCodeAtomicSwapBidOwnerFullLine               ReviewRequestResultCode = -1504
	ReviewRequestResultCodeInvalidSignerData                        ReviewRequestResultCode = -1600
	ReviewRequestResultCodeManageOfferFailed                        ReviewRequestResultCode = -1700
	ReviewRequestResultCodePaymentFailed                            ReviewRequestResultCode = -1800
	ReviewRequestResultCodeDataNotFound                             ReviewRequestResultCode = -1900
)

var ReviewRequestResultCodeAll = []ReviewRequestResultCode{
	ReviewRequestResultCodeSuccess,
	ReviewRequestResultCodeInvalidReason,
	ReviewRequestResultCodeInvalidAction,
	ReviewRequestResultCodeHashMismatched,
	ReviewRequestResultCodeNotFound,
	ReviewRequestResultCodeTypeMismatched,
	ReviewRequestResultCodeRejectNotAllowed,
	ReviewRequestResultCodeInvalidExternalDetails,
	ReviewRequestResultCodeRequestorIsBlocked,
	ReviewRequestResultCodePermanentRejectNotAllowed,
	ReviewRequestResultCodeRemovingNotSetTasks,
	ReviewRequestResultCodeAssetAlreadyExists,
	ReviewRequestResultCodeAssetDoesNotExists,
	ReviewRequestResultCodeMaxIssuanceAmountExceeded,
	ReviewRequestResultCodeInsufficientAvailableForIssuanceAmount,
	ReviewRequestResultCodeFullLine,
	ReviewRequestResultCodeSystemTasksNotAllowed,
	ReviewRequestResultCodeIncorrectPrecision,
	ReviewRequestResultCodeBaseAssetDoesNotExists,
	ReviewRequestResultCodeHardCapWillExceedMaxIssuance,
	ReviewRequestResultCodeInsufficientPreissuedForHardCap,
	ReviewRequestResultCodeBaseAssetNotFound,
	ReviewRequestResultCodeAssetPairNotFound,
	ReviewRequestResultCodeQuoteAssetNotFound,
	ReviewRequestResultCodeNonZeroTasksToRemoveNotAllowed,
	ReviewRequestResultCodeAccountRoleToSetDoesNotExist,
	ReviewRequestResultCodeSaleNotFound,
	ReviewRequestResultCodeAmountMismatched,
	ReviewRequestResultCodeDestinationBalanceMismatched,
	ReviewRequestResultCodeNotAllowedAccountDestination,
	ReviewRequestResultCodeRequiredSourcePayForDestination,
	ReviewRequestResultCodeSourceBalanceMismatched,
	ReviewRequestResultCodeContractNotFound,
	ReviewRequestResultCodeInvoiceReceiverBalanceLockAmountOverflow,
	ReviewRequestResultCodeInvoiceAlreadyApproved,
	ReviewRequestResultCodePaymentV2Malformed,
	ReviewRequestResultCodeUnderfunded,
	ReviewRequestResultCodeLineFull,
	ReviewRequestResultCodeDestinationBalanceNotFound,
	ReviewRequestResultCodeBalanceAssetsMismatched,
	ReviewRequestResultCodeSrcBalanceNotFound,
	ReviewRequestResultCodeReferenceDuplication,
	ReviewRequestResultCodeStatsOverflow,
	ReviewRequestResultCodeLimitsExceeded,
	ReviewRequestResultCodeNotAllowedByAssetPolicy,
	ReviewRequestResultCodeInvalidDestinationFee,
	ReviewRequestResultCodeInvalidDestinationFeeAsset,
	ReviewRequestResultCodeFeeAssetMismatched,
	ReviewRequestResultCodeInsufficientFeeAmount,
	ReviewRequestResultCodeBalanceToChargeFeeFromNotFound,
	ReviewRequestResultCodePaymentAmountIsLessThanDestFee,
	ReviewRequestResultCodeDestinationAccountNotFound,
	ReviewRequestResultCodeCannotCreateForAccIdAndAccType,
	ReviewRequestResultCodeInvalidLimits,
	ReviewRequestResultCodeAccountNotFound,
	ReviewRequestResultCodeRoleNotFound,
	ReviewRequestResultCodeContractDetailsTooLong,
	ReviewRequestResultCodeBaseAssetCannotBeSwapped,
	ReviewRequestResultCodeQuoteAssetCannotBeSwapped,
	ReviewRequestResultCodeAtomicSwapBidOwnerFullLine,
	ReviewRequestResultCodeInvalidSignerData,
	ReviewRequestResultCodeManageOfferFailed,
	ReviewRequestResultCodePaymentFailed,
	ReviewRequestResultCodeDataNotFound,
}

var reviewRequestResultCodeMap = map[int32]string{
	0:     "ReviewRequestResultCodeSuccess",
	-1:    "ReviewRequestResultCodeInvalidReason",
	-2:    "ReviewRequestResultCodeInvalidAction",
	-3:    "ReviewRequestResultCodeHashMismatched",
	-4:    "ReviewRequestResultCodeNotFound",
	-5:    "ReviewRequestResultCodeTypeMismatched",
	-6:    "ReviewRequestResultCodeRejectNotAllowed",
	-7:    "ReviewRequestResultCodeInvalidExternalDetails",
	-8:    "ReviewRequestResultCodeRequestorIsBlocked",
	-9:    "ReviewRequestResultCodePermanentRejectNotAllowed",
	-100:  "ReviewRequestResultCodeRemovingNotSetTasks",
	-200:  "ReviewRequestResultCodeAssetAlreadyExists",
	-210:  "ReviewRequestResultCodeAssetDoesNotExists",
	-400:  "ReviewRequestResultCodeMaxIssuanceAmountExceeded",
	-410:  "ReviewRequestResultCodeInsufficientAvailableForIssuanceAmount",
	-420:  "ReviewRequestResultCodeFullLine",
	-430:  "ReviewRequestResultCodeSystemTasksNotAllowed",
	-440:  "ReviewRequestResultCodeIncorrectPrecision",
	-500:  "ReviewRequestResultCodeBaseAssetDoesNotExists",
	-510:  "ReviewRequestResultCodeHardCapWillExceedMaxIssuance",
	-520:  "ReviewRequestResultCodeInsufficientPreissuedForHardCap",
	-530:  "ReviewRequestResultCodeBaseAssetNotFound",
	-540:  "ReviewRequestResultCodeAssetPairNotFound",
	-550:  "ReviewRequestResultCodeQuoteAssetNotFound",
	-600:  "ReviewRequestResultCodeNonZeroTasksToRemoveNotAllowed",
	-610:  "ReviewRequestResultCodeAccountRoleToSetDoesNotExist",
	-700:  "ReviewRequestResultCodeSaleNotFound",
	-1010: "ReviewRequestResultCodeAmountMismatched",
	-1020: "ReviewRequestResultCodeDestinationBalanceMismatched",
	-1030: "ReviewRequestResultCodeNotAllowedAccountDestination",
	-1040: "ReviewRequestResultCodeRequiredSourcePayForDestination",
	-1050: "ReviewRequestResultCodeSourceBalanceMismatched",
	-1060: "ReviewRequestResultCodeContractNotFound",
	-1070: "ReviewRequestResultCodeInvoiceReceiverBalanceLockAmountOverflow",
	-1080: "ReviewRequestResultCodeInvoiceAlreadyApproved",
	-1100: "ReviewRequestResultCodePaymentV2Malformed",
	-1110: "ReviewRequestResultCodeUnderfunded",
	-1120: "ReviewRequestResultCodeLineFull",
	-1130: "ReviewRequestResultCodeDestinationBalanceNotFound",
	-1140: "ReviewRequestResultCodeBalanceAssetsMismatched",
	-1150: "ReviewRequestResultCodeSrcBalanceNotFound",
	-1160: "ReviewRequestResultCodeReferenceDuplication",
	-1170: "ReviewRequestResultCodeStatsOverflow",
	-1180: "ReviewRequestResultCodeLimitsExceeded",
	-1190: "ReviewRequestResultCodeNotAllowedByAssetPolicy",
	-1200: "ReviewRequestResultCodeInvalidDestinationFee",
	-1210: "ReviewRequestResultCodeInvalidDestinationFeeAsset",
	-1220: "ReviewRequestResultCodeFeeAssetMismatched",
	-1230: "ReviewRequestResultCodeInsufficientFeeAmount",
	-1240: "ReviewRequestResultCodeBalanceToChargeFeeFromNotFound",
	-1250: "ReviewRequestResultCodePaymentAmountIsLessThanDestFee",
	-1260: "ReviewRequestResultCodeDestinationAccountNotFound",
	1300:  "ReviewRequestResultCodeCannotCreateForAccIdAndAccType",
	1310:  "ReviewRequestResultCodeInvalidLimits",
	-1311: "ReviewRequestResultCodeAccountNotFound",
	-1312: "ReviewRequestResultCodeRoleNotFound",
	-1400: "ReviewRequestResultCodeContractDetailsTooLong",
	-1500: "ReviewRequestResultCodeBaseAssetCannotBeSwapped",
	-1501: "ReviewRequestResultCodeQuoteAssetCannotBeSwapped",
	-1504: "ReviewRequestResultCodeAtomicSwapBidOwnerFullLine",
	-1600: "ReviewRequestResultCodeInvalidSignerData",
	-1700: "ReviewRequestResultCodeManageOfferFailed",
	-1800: "ReviewRequestResultCodePaymentFailed",
	-1900: "ReviewRequestResultCodeDataNotFound",
}

var reviewRequestResultCodeShortMap = map[int32]string{
	0:     "success",
	-1:    "invalid_reason",
	-2:    "invalid_action",
	-3:    "hash_mismatched",
	-4:    "not_found",
	-5:    "type_mismatched",
	-6:    "reject_not_allowed",
	-7:    "invalid_external_details",
	-8:    "requestor_is_blocked",
	-9:    "permanent_reject_not_allowed",
	-100:  "removing_not_set_tasks",
	-200:  "asset_already_exists",
	-210:  "asset_does_not_exists",
	-400:  "max_issuance_amount_exceeded",
	-410:  "insufficient_available_for_issuance_amount",
	-420:  "full_line",
	-430:  "system_tasks_not_allowed",
	-440:  "incorrect_precision",
	-500:  "base_asset_does_not_exists",
	-510:  "hard_cap_will_exceed_max_issuance",
	-520:  "insufficient_preissued_for_hard_cap",
	-530:  "base_asset_not_found",
	-540:  "asset_pair_not_found",
	-550:  "quote_asset_not_found",
	-600:  "non_zero_tasks_to_remove_not_allowed",
	-610:  "account_role_to_set_does_not_exist",
	-700:  "sale_not_found",
	-1010: "amount_mismatched",
	-1020: "destination_balance_mismatched",
	-1030: "not_allowed_account_destination",
	-1040: "required_source_pay_for_destination",
	-1050: "source_balance_mismatched",
	-1060: "contract_not_found",
	-1070: "invoice_receiver_balance_lock_amount_overflow",
	-1080: "invoice_already_approved",
	-1100: "payment_v2_malformed",
	-1110: "underfunded",
	-1120: "line_full",
	-1130: "destination_balance_not_found",
	-1140: "balance_assets_mismatched",
	-1150: "src_balance_not_found",
	-1160: "reference_duplication",
	-1170: "stats_overflow",
	-1180: "limits_exceeded",
	-1190: "not_allowed_by_asset_policy",
	-1200: "invalid_destination_fee",
	-1210: "invalid_destination_fee_asset",
	-1220: "fee_asset_mismatched",
	-1230: "insufficient_fee_amount",
	-1240: "balance_to_charge_fee_from_not_found",
	-1250: "payment_amount_is_less_than_dest_fee",
	-1260: "destination_account_not_found",
	1300:  "cannot_create_for_acc_id_and_acc_type",
	1310:  "invalid_limits",
	-1311: "account_not_found",
	-1312: "role_not_found",
	-1400: "contract_details_too_long",
	-1500: "base_asset_cannot_be_swapped",
	-1501: "quote_asset_cannot_be_swapped",
	-1504: "atomic_swap_bid_owner_full_line",
	-1600: "invalid_signer_data",
	-1700: "manage_offer_failed",
	-1800: "payment_failed",
	-1900: "data_not_found",
}

var reviewRequestResultCodeRevMap = map[string]int32{
	"ReviewRequestResultCodeSuccess":                                  0,
	"ReviewRequestResultCodeInvalidReason":                            -1,
	"ReviewRequestResultCodeInvalidAction":                            -2,
	"ReviewRequestResultCodeHashMismatched":                           -3,
	"ReviewRequestResultCodeNotFound":                                 -4,
	"ReviewRequestResultCodeTypeMismatched":                           -5,
	"ReviewRequestResultCodeRejectNotAllowed":                         -6,
	"ReviewRequestResultCodeInvalidExternalDetails":                   -7,
	"ReviewRequestResultCodeRequestorIsBlocked":                       -8,
	"ReviewRequestResultCodePermanentRejectNotAllowed":                -9,
	"ReviewRequestResultCodeRemovingNotSetTasks":                      -100,
	"ReviewRequestResultCodeAssetAlreadyExists":                       -200,
	"ReviewRequestResultCodeAssetDoesNotExists":                       -210,
	"ReviewRequestResultCodeMaxIssuanceAmountExceeded":                -400,
	"ReviewRequestResultCodeInsufficientAvailableForIssuanceAmount":   -410,
	"ReviewRequestResultCodeFullLine":                                 -420,
	"ReviewRequestResultCodeSystemTasksNotAllowed":                    -430,
	"ReviewRequestResultCodeIncorrectPrecision":                       -440,
	"ReviewRequestResultCodeBaseAssetDoesNotExists":                   -500,
	"ReviewRequestResultCodeHardCapWillExceedMaxIssuance":             -510,
	"ReviewRequestResultCodeInsufficientPreissuedForHardCap":          -520,
	"ReviewRequestResultCodeBaseAssetNotFound":                        -530,
	"ReviewRequestResultCodeAssetPairNotFound":                        -540,
	"ReviewRequestResultCodeQuoteAssetNotFound":                       -550,
	"ReviewRequestResultCodeNonZeroTasksToRemoveNotAllowed":           -600,
	"ReviewRequestResultCodeAccountRoleToSetDoesNotExist":             -610,
	"ReviewRequestResultCodeSaleNotFound":                             -700,
	"ReviewRequestResultCodeAmountMismatched":                         -1010,
	"ReviewRequestResultCodeDestinationBalanceMismatched":             -1020,
	"ReviewRequestResultCodeNotAllowedAccountDestination":             -1030,
	"ReviewRequestResultCodeRequiredSourcePayForDestination":          -1040,
	"ReviewRequestResultCodeSourceBalanceMismatched":                  -1050,
	"ReviewRequestResultCodeContractNotFound":                         -1060,
	"ReviewRequestResultCodeInvoiceReceiverBalanceLockAmountOverflow": -1070,
	"ReviewRequestResultCodeInvoiceAlreadyApproved":                   -1080,
	"ReviewRequestResultCodePaymentV2Malformed":                       -1100,
	"ReviewRequestResultCodeUnderfunded":                              -1110,
	"ReviewRequestResultCodeLineFull":                                 -1120,
	"ReviewRequestResultCodeDestinationBalanceNotFound":               -1130,
	"ReviewRequestResultCodeBalanceAssetsMismatched":                  -1140,
	"ReviewRequestResultCodeSrcBalanceNotFound":                       -1150,
	"ReviewRequestResultCodeReferenceDuplication":                     -1160,
	"ReviewRequestResultCodeStatsOverflow":                            -1170,
	"ReviewRequestResultCodeLimitsExceeded":                           -1180,
	"ReviewRequestResultCodeNotAllowedByAssetPolicy":                  -1190,
	"ReviewRequestResultCodeInvalidDestinationFee":                    -1200,
	"ReviewRequestResultCodeInvalidDestinationFeeAsset":               -1210,
	"ReviewRequestResultCodeFeeAssetMismatched":                       -1220,
	"ReviewRequestResultCodeInsufficientFeeAmount":                    -1230,
	"ReviewRequestResultCodeBalanceToChargeFeeFromNotFound":           -1240,
	"ReviewRequestResultCodePaymentAmountIsLessThanDestFee":           -1250,
	"ReviewRequestResultCodeDestinationAccountNotFound":               -1260,
	"ReviewRequestResultCodeCannotCreateForAccIdAndAccType":           1300,
	"ReviewRequestResultCodeInvalidLimits":                            1310,
	"ReviewRequestResultCodeAccountNotFound":                          -1311,
	"ReviewRequestResultCodeRoleNotFound":                             -1312,
	"ReviewRequestResultCodeContractDetailsTooLong":                   -1400,
	"ReviewRequestResultCodeBaseAssetCannotBeSwapped":                 -1500,
	"ReviewRequestResultCodeQuoteAssetCannotBeSwapped":                -1501,
	"ReviewRequestResultCodeAtomicSwapBidOwnerFullLine":               -1504,
	"ReviewRequestResultCodeInvalidSignerData":                        -1600,
	"ReviewRequestResultCodeManageOfferFailed":                        -1700,
	"ReviewRequestResultCodePaymentFailed":                            -1800,
	"ReviewRequestResultCodeDataNotFound":                             -1900,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ReviewRequestResultCode
func (e ReviewRequestResultCode) ValidEnum(v int32) bool {
	_, ok := reviewRequestResultCodeMap[v]
	return ok
}
func (e ReviewRequestResultCode) isFlag() bool {
	for i := len(ReviewRequestResultCodeAll) - 1; i >= 0; i-- {
		expected := ReviewRequestResultCode(2) << uint64(len(ReviewRequestResultCodeAll)-1) >> uint64(len(ReviewRequestResultCodeAll)-i)
		if expected != ReviewRequestResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ReviewRequestResultCode) String() string {
	name, _ := reviewRequestResultCodeMap[int32(e)]
	return name
}

func (e ReviewRequestResultCode) ShortString() string {
	name, _ := reviewRequestResultCodeShortMap[int32(e)]
	return name
}

func (e ReviewRequestResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ReviewRequestResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ReviewRequestResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ReviewRequestResultCode(t.Value)
	return nil
}

// ReviewRequestResult is an XDR Union defines as:
//
//   //: Result of applying the review request with result code
//    union ReviewRequestResult switch (ReviewRequestResultCode code)
//    {
//    case SUCCESS:
//        ExtendedResult success;
//    case MANAGE_OFFER_FAILED:
//        ManageOfferResultCode manageOfferCode;
//    case PAYMENT_FAILED:
//        PaymentResultCode paymentCode;
//    default:
//        void;
//    };
//
type ReviewRequestResult struct {
	Code            ReviewRequestResultCode `json:"code,omitempty"`
	Success         *ExtendedResult         `json:"success,omitempty"`
	ManageOfferCode *ManageOfferResultCode  `json:"manageOfferCode,omitempty"`
	PaymentCode     *PaymentResultCode      `json:"paymentCode,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ReviewRequestResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ReviewRequestResult
func (u ReviewRequestResult) ArmForSwitch(sw int32) (string, bool) {
	switch ReviewRequestResultCode(sw) {
	case ReviewRequestResultCodeSuccess:
		return "Success", true
	case ReviewRequestResultCodeManageOfferFailed:
		return "ManageOfferCode", true
	case ReviewRequestResultCodePaymentFailed:
		return "PaymentCode", true
	default:
		return "", true
	}
}

// NewReviewRequestResult creates a new  ReviewRequestResult.
func NewReviewRequestResult(code ReviewRequestResultCode, value interface{}) (result ReviewRequestResult, err error) {
	result.Code = code
	switch ReviewRequestResultCode(code) {
	case ReviewRequestResultCodeSuccess:
		tv, ok := value.(ExtendedResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be ExtendedResult")
			return
		}
		result.Success = &tv
	case ReviewRequestResultCodeManageOfferFailed:
		tv, ok := value.(ManageOfferResultCode)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageOfferResultCode")
			return
		}
		result.ManageOfferCode = &tv
	case ReviewRequestResultCodePaymentFailed:
		tv, ok := value.(PaymentResultCode)
		if !ok {
			err = fmt.Errorf("invalid value, must be PaymentResultCode")
			return
		}
		result.PaymentCode = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u ReviewRequestResult) MustSuccess() ExtendedResult {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewRequestResult) GetSuccess() (result ExtendedResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// MustManageOfferCode retrieves the ManageOfferCode value from the union,
// panicing if the value is not set.
func (u ReviewRequestResult) MustManageOfferCode() ManageOfferResultCode {
	val, ok := u.GetManageOfferCode()

	if !ok {
		panic("arm ManageOfferCode is not set")
	}

	return val
}

// GetManageOfferCode retrieves the ManageOfferCode value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewRequestResult) GetManageOfferCode() (result ManageOfferResultCode, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "ManageOfferCode" {
		result = *u.ManageOfferCode
		ok = true
	}

	return
}

// MustPaymentCode retrieves the PaymentCode value from the union,
// panicing if the value is not set.
func (u ReviewRequestResult) MustPaymentCode() PaymentResultCode {
	val, ok := u.GetPaymentCode()

	if !ok {
		panic("arm PaymentCode is not set")
	}

	return val
}

// GetPaymentCode retrieves the PaymentCode value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewRequestResult) GetPaymentCode() (result PaymentResultCode, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "PaymentCode" {
		result = *u.PaymentCode
		ok = true
	}

	return
}

// SetFeesOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//
type SetFeesOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u SetFeesOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of SetFeesOpExt
func (u SetFeesOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewSetFeesOpExt creates a new  SetFeesOpExt.
func NewSetFeesOpExt(v LedgerVersion, value interface{}) (result SetFeesOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// SetFeesOp is an XDR Struct defines as:
//
//   //: Allows to establish or remove a relationship between a particular fee entry with the different entities
//        struct SetFeesOp
//        {
//            //: Fee entry to set
//            FeeEntry* fee;
//            //: `isDelete` indicates that a fee should be either set or removed
//            bool isDelete;
//            //: reserved for future use
//            union switch (LedgerVersion v)
//            {
//            case EMPTY_VERSION:
//                void;
//            }
//            ext;
//        };
//
type SetFeesOp struct {
	Fee      *FeeEntry    `json:"fee,omitempty"`
	IsDelete bool         `json:"isDelete,omitempty"`
	Ext      SetFeesOpExt `json:"ext,omitempty"`
}

// SetFeesResultCode is an XDR Enum defines as:
//
//   //: Result codes for SetFees operation
//        enum SetFeesResultCode
//        {
//            // codes considered as "success" for the operation
//            //: `SetFeesOp` was successfully applied and a fee was successfully set or deleted
//            SUCCESS = 0,
//
//            // codes considered as "failure" for an operation
//            //: Fee amount is invalid (e.g. negative amount is ranked invalid)
//            INVALID_AMOUNT = -1,
//            //: `FeeType` is invalid (any `FeeType` that is not contained in the `FeeType` enum is ranked invalid)
//            INVALID_FEE_TYPE = -2,
//            //: `AssetCode` is not presented in the system
//            ASSET_NOT_FOUND = -3,
//            //: `AssetCode` is invalid (e.g. `AssetCode` that does not consist of alphanumeric symbols)
//            INVALID_ASSET = -4,
//            //: Malformed operation (e.g. `upperBound` from the `FeeEntry` structure is less than `lowerBound`)
//            MALFORMED = -5,
//            //: Malformed range is defined by `FeeEntry.lowerBound` and `FeeEntry.upperBound` (`lowerBound` must be equal to 0 & `upperBound` must be equal to `INT64_MAX`)
//            MALFORMED_RANGE = -6,
//            //: Range defined by `lowerBound` and `upperBound` in `FeeEntry` overlaps with at least one another `FeeEntry` range
//            RANGE_OVERLAP = -7,
//            //: There is no fee to delete (this code could be returned only on deleting a fee)
//            NOT_FOUND = -8,
//            //: `FeeEntry` does not have a default subtype or the fee asset is not base
//            SUB_TYPE_NOT_EXIST = -9,
//            //: Reserved for future use
//            INVALID_FEE_VERSION = -10,
//            //: Reserved for future use
//            INVALID_FEE_ASSET = -11,
//            //: Reserved for future use
//            FEE_ASSET_NOT_ALLOWED = -12, // feeAsset can be set only if feeType is PAYMENT
//            //: Reserved for future use
//            CROSS_ASSET_FEE_NOT_ALLOWED = -13, // feeAsset on payment fee type can differ from asset only if payment fee subtype is OUTGOING
//            //: Reserved for future use
//            FEE_ASSET_NOT_FOUND = -14,
//            //: Reserved for future use
//            ASSET_PAIR_NOT_FOUND = -15, // cannot create cross asset fee entry without existing asset pair
//            //: Reserved for future use
//            INVALID_ASSET_PAIR_PRICE = -16,
//            //: Calculated fee hash differs from a hash taken from the database
//            INVALID_FEE_HASH = -17,
//            //: Fixed fee amount must fit asset precision
//            INVALID_AMOUNT_PRECISION = -18,
//            //: There is no account with passed ID
//            ACCOUNT_NOT_FOUND = -19,
//            //: There is no role with passed ID
//            ROLE_NOT_FOUND = -20
//        };
//
type SetFeesResultCode int32

const (
	SetFeesResultCodeSuccess                 SetFeesResultCode = 0
	SetFeesResultCodeInvalidAmount           SetFeesResultCode = -1
	SetFeesResultCodeInvalidFeeType          SetFeesResultCode = -2
	SetFeesResultCodeAssetNotFound           SetFeesResultCode = -3
	SetFeesResultCodeInvalidAsset            SetFeesResultCode = -4
	SetFeesResultCodeMalformed               SetFeesResultCode = -5
	SetFeesResultCodeMalformedRange          SetFeesResultCode = -6
	SetFeesResultCodeRangeOverlap            SetFeesResultCode = -7
	SetFeesResultCodeNotFound                SetFeesResultCode = -8
	SetFeesResultCodeSubTypeNotExist         SetFeesResultCode = -9
	SetFeesResultCodeInvalidFeeVersion       SetFeesResultCode = -10
	SetFeesResultCodeInvalidFeeAsset         SetFeesResultCode = -11
	SetFeesResultCodeFeeAssetNotAllowed      SetFeesResultCode = -12
	SetFeesResultCodeCrossAssetFeeNotAllowed SetFeesResultCode = -13
	SetFeesResultCodeFeeAssetNotFound        SetFeesResultCode = -14
	SetFeesResultCodeAssetPairNotFound       SetFeesResultCode = -15
	SetFeesResultCodeInvalidAssetPairPrice   SetFeesResultCode = -16
	SetFeesResultCodeInvalidFeeHash          SetFeesResultCode = -17
	SetFeesResultCodeInvalidAmountPrecision  SetFeesResultCode = -18
	SetFeesResultCodeAccountNotFound         SetFeesResultCode = -19
	SetFeesResultCodeRoleNotFound            SetFeesResultCode = -20
)

var SetFeesResultCodeAll = []SetFeesResultCode{
	SetFeesResultCodeSuccess,
	SetFeesResultCodeInvalidAmount,
	SetFeesResultCodeInvalidFeeType,
	SetFeesResultCodeAssetNotFound,
	SetFeesResultCodeInvalidAsset,
	SetFeesResultCodeMalformed,
	SetFeesResultCodeMalformedRange,
	SetFeesResultCodeRangeOverlap,
	SetFeesResultCodeNotFound,
	SetFeesResultCodeSubTypeNotExist,
	SetFeesResultCodeInvalidFeeVersion,
	SetFeesResultCodeInvalidFeeAsset,
	SetFeesResultCodeFeeAssetNotAllowed,
	SetFeesResultCodeCrossAssetFeeNotAllowed,
	SetFeesResultCodeFeeAssetNotFound,
	SetFeesResultCodeAssetPairNotFound,
	SetFeesResultCodeInvalidAssetPairPrice,
	SetFeesResultCodeInvalidFeeHash,
	SetFeesResultCodeInvalidAmountPrecision,
	SetFeesResultCodeAccountNotFound,
	SetFeesResultCodeRoleNotFound,
}

var setFeesResultCodeMap = map[int32]string{
	0:   "SetFeesResultCodeSuccess",
	-1:  "SetFeesResultCodeInvalidAmount",
	-2:  "SetFeesResultCodeInvalidFeeType",
	-3:  "SetFeesResultCodeAssetNotFound",
	-4:  "SetFeesResultCodeInvalidAsset",
	-5:  "SetFeesResultCodeMalformed",
	-6:  "SetFeesResultCodeMalformedRange",
	-7:  "SetFeesResultCodeRangeOverlap",
	-8:  "SetFeesResultCodeNotFound",
	-9:  "SetFeesResultCodeSubTypeNotExist",
	-10: "SetFeesResultCodeInvalidFeeVersion",
	-11: "SetFeesResultCodeInvalidFeeAsset",
	-12: "SetFeesResultCodeFeeAssetNotAllowed",
	-13: "SetFeesResultCodeCrossAssetFeeNotAllowed",
	-14: "SetFeesResultCodeFeeAssetNotFound",
	-15: "SetFeesResultCodeAssetPairNotFound",
	-16: "SetFeesResultCodeInvalidAssetPairPrice",
	-17: "SetFeesResultCodeInvalidFeeHash",
	-18: "SetFeesResultCodeInvalidAmountPrecision",
	-19: "SetFeesResultCodeAccountNotFound",
	-20: "SetFeesResultCodeRoleNotFound",
}

var setFeesResultCodeShortMap = map[int32]string{
	0:   "success",
	-1:  "invalid_amount",
	-2:  "invalid_fee_type",
	-3:  "asset_not_found",
	-4:  "invalid_asset",
	-5:  "malformed",
	-6:  "malformed_range",
	-7:  "range_overlap",
	-8:  "not_found",
	-9:  "sub_type_not_exist",
	-10: "invalid_fee_version",
	-11: "invalid_fee_asset",
	-12: "fee_asset_not_allowed",
	-13: "cross_asset_fee_not_allowed",
	-14: "fee_asset_not_found",
	-15: "asset_pair_not_found",
	-16: "invalid_asset_pair_price",
	-17: "invalid_fee_hash",
	-18: "invalid_amount_precision",
	-19: "account_not_found",
	-20: "role_not_found",
}

var setFeesResultCodeRevMap = map[string]int32{
	"SetFeesResultCodeSuccess":                 0,
	"SetFeesResultCodeInvalidAmount":           -1,
	"SetFeesResultCodeInvalidFeeType":          -2,
	"SetFeesResultCodeAssetNotFound":           -3,
	"SetFeesResultCodeInvalidAsset":            -4,
	"SetFeesResultCodeMalformed":               -5,
	"SetFeesResultCodeMalformedRange":          -6,
	"SetFeesResultCodeRangeOverlap":            -7,
	"SetFeesResultCodeNotFound":                -8,
	"SetFeesResultCodeSubTypeNotExist":         -9,
	"SetFeesResultCodeInvalidFeeVersion":       -10,
	"SetFeesResultCodeInvalidFeeAsset":         -11,
	"SetFeesResultCodeFeeAssetNotAllowed":      -12,
	"SetFeesResultCodeCrossAssetFeeNotAllowed": -13,
	"SetFeesResultCodeFeeAssetNotFound":        -14,
	"SetFeesResultCodeAssetPairNotFound":       -15,
	"SetFeesResultCodeInvalidAssetPairPrice":   -16,
	"SetFeesResultCodeInvalidFeeHash":          -17,
	"SetFeesResultCodeInvalidAmountPrecision":  -18,
	"SetFeesResultCodeAccountNotFound":         -19,
	"SetFeesResultCodeRoleNotFound":            -20,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for SetFeesResultCode
func (e SetFeesResultCode) ValidEnum(v int32) bool {
	_, ok := setFeesResultCodeMap[v]
	return ok
}
func (e SetFeesResultCode) isFlag() bool {
	for i := len(SetFeesResultCodeAll) - 1; i >= 0; i-- {
		expected := SetFeesResultCode(2) << uint64(len(SetFeesResultCodeAll)-1) >> uint64(len(SetFeesResultCodeAll)-i)
		if expected != SetFeesResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e SetFeesResultCode) String() string {
	name, _ := setFeesResultCodeMap[int32(e)]
	return name
}

func (e SetFeesResultCode) ShortString() string {
	name, _ := setFeesResultCodeShortMap[int32(e)]
	return name
}

func (e SetFeesResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range SetFeesResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *SetFeesResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = SetFeesResultCode(t.Value)
	return nil
}

// SetFeesResultSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//                    {
//                    case EMPTY_VERSION:
//                        void;
//                    }
//
type SetFeesResultSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u SetFeesResultSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of SetFeesResultSuccessExt
func (u SetFeesResultSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewSetFeesResultSuccessExt creates a new  SetFeesResultSuccessExt.
func NewSetFeesResultSuccessExt(v LedgerVersion, value interface{}) (result SetFeesResultSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// SetFeesResultSuccess is an XDR NestedStruct defines as:
//
//   struct {
//                    //: reserved for future use
//                    union switch (LedgerVersion v)
//                    {
//                    case EMPTY_VERSION:
//                        void;
//                    }
//                    ext;
//                }
//
type SetFeesResultSuccess struct {
	Ext SetFeesResultSuccessExt `json:"ext,omitempty"`
}

// SetFeesResult is an XDR Union defines as:
//
//   //: Is used to pass result of operation applying
//        union SetFeesResult switch (SetFeesResultCode code)
//        {
//            case SUCCESS:
//                struct {
//                    //: reserved for future use
//                    union switch (LedgerVersion v)
//                    {
//                    case EMPTY_VERSION:
//                        void;
//                    }
//                    ext;
//                } success;
//            default:
//                void;
//        };
//
type SetFeesResult struct {
	Code    SetFeesResultCode     `json:"code,omitempty"`
	Success *SetFeesResultSuccess `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u SetFeesResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of SetFeesResult
func (u SetFeesResult) ArmForSwitch(sw int32) (string, bool) {
	switch SetFeesResultCode(sw) {
	case SetFeesResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewSetFeesResult creates a new  SetFeesResult.
func NewSetFeesResult(code SetFeesResultCode, value interface{}) (result SetFeesResult, err error) {
	result.Code = code
	switch SetFeesResultCode(code) {
	case SetFeesResultCodeSuccess:
		tv, ok := value.(SetFeesResultSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be SetFeesResultSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u SetFeesResult) MustSuccess() SetFeesResultSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u SetFeesResult) GetSuccess() (result SetFeesResultSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// StampOpExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type StampOpExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u StampOpExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of StampOpExt
func (u StampOpExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewStampOpExt creates a new  StampOpExt.
func NewStampOpExt(v LedgerVersion, value interface{}) (result StampOpExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// StampOp is an XDR Struct defines as:
//
//   //: StampOp is used to save current ledger hash and current license hash
//    struct StampOp
//    {
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type StampOp struct {
	Ext StampOpExt `json:"ext,omitempty"`
}

// StampResultCode is an XDR Enum defines as:
//
//   enum StampResultCode
//    {
//        //: Stamp was successful
//        SUCCESS = 0
//
//    };
//
type StampResultCode int32

const (
	StampResultCodeSuccess StampResultCode = 0
)

var StampResultCodeAll = []StampResultCode{
	StampResultCodeSuccess,
}

var stampResultCodeMap = map[int32]string{
	0: "StampResultCodeSuccess",
}

var stampResultCodeShortMap = map[int32]string{
	0: "success",
}

var stampResultCodeRevMap = map[string]int32{
	"StampResultCodeSuccess": 0,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for StampResultCode
func (e StampResultCode) ValidEnum(v int32) bool {
	_, ok := stampResultCodeMap[v]
	return ok
}
func (e StampResultCode) isFlag() bool {
	for i := len(StampResultCodeAll) - 1; i >= 0; i-- {
		expected := StampResultCode(2) << uint64(len(StampResultCodeAll)-1) >> uint64(len(StampResultCodeAll)-i)
		if expected != StampResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e StampResultCode) String() string {
	name, _ := stampResultCodeMap[int32(e)]
	return name
}

func (e StampResultCode) ShortString() string {
	name, _ := stampResultCodeShortMap[int32(e)]
	return name
}

func (e StampResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range StampResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *StampResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = StampResultCode(t.Value)
	return nil
}

// StampSuccessExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type StampSuccessExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u StampSuccessExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of StampSuccessExt
func (u StampSuccessExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewStampSuccessExt creates a new  StampSuccessExt.
func NewStampSuccessExt(v LedgerVersion, value interface{}) (result StampSuccessExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// StampSuccess is an XDR Struct defines as:
//
//   //: StampSuccess is used to pass saved ledger hash and license hash
//    struct StampSuccess {
//        //: ledger hash saved into a database
//        Hash ledgerHash;
//
//        //: current license hash
//        Hash licenseHash;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type StampSuccess struct {
	LedgerHash  Hash            `json:"ledgerHash,omitempty"`
	LicenseHash Hash            `json:"licenseHash,omitempty"`
	Ext         StampSuccessExt `json:"ext,omitempty"`
}

// StampResult is an XDR Union defines as:
//
//   //: StampResult is a result of Stamp operation application
//    union StampResult switch (StampResultCode code)
//    {
//    case SUCCESS:
//        StampSuccess success;
//    default:
//        void;
//    };
//
type StampResult struct {
	Code    StampResultCode `json:"code,omitempty"`
	Success *StampSuccess   `json:"success,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u StampResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of StampResult
func (u StampResult) ArmForSwitch(sw int32) (string, bool) {
	switch StampResultCode(sw) {
	case StampResultCodeSuccess:
		return "Success", true
	default:
		return "", true
	}
}

// NewStampResult creates a new  StampResult.
func NewStampResult(code StampResultCode, value interface{}) (result StampResult, err error) {
	result.Code = code
	switch StampResultCode(code) {
	case StampResultCodeSuccess:
		tv, ok := value.(StampSuccess)
		if !ok {
			err = fmt.Errorf("invalid value, must be StampSuccess")
			return
		}
		result.Success = &tv
	default:
		// void
	}
	return
}

// MustSuccess retrieves the Success value from the union,
// panicing if the value is not set.
func (u StampResult) MustSuccess() StampSuccess {
	val, ok := u.GetSuccess()

	if !ok {
		panic("arm Success is not set")
	}

	return val
}

// GetSuccess retrieves the Success value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u StampResult) GetSuccess() (result StampSuccess, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Success" {
		result = *u.Success
		ok = true
	}

	return
}

// UpdateDataOp is an XDR Struct defines as:
//
//   struct UpdateDataOp
//    {
//        //: ID of the data entry to update
//        uint64 dataID;
//        //: New value to set
//        longstring value;
//        //: Reserved for future extension
//        EmptyExt ext;
//    };
//
type UpdateDataOp struct {
	DataId Uint64     `json:"dataID,omitempty"`
	Value  Longstring `json:"value,omitempty"`
	Ext    EmptyExt   `json:"ext,omitempty"`
}

// UpdateDataResultCode is an XDR Enum defines as:
//
//   enum UpdateDataResultCode
//    {
//        //: Data was successfully updated
//        SUCCESS = 0,
//        //: `value` must be in a valid JSON format
//        INVALID_DATA = -1,
//        //: Entry with provided ID does not exist
//        NOT_FOUND = -2,
//        //: Only owner or admin can update data entry
//        NOT_AUTHORIZED = -3
//    };
//
type UpdateDataResultCode int32

const (
	UpdateDataResultCodeSuccess       UpdateDataResultCode = 0
	UpdateDataResultCodeInvalidData   UpdateDataResultCode = -1
	UpdateDataResultCodeNotFound      UpdateDataResultCode = -2
	UpdateDataResultCodeNotAuthorized UpdateDataResultCode = -3
)

var UpdateDataResultCodeAll = []UpdateDataResultCode{
	UpdateDataResultCodeSuccess,
	UpdateDataResultCodeInvalidData,
	UpdateDataResultCodeNotFound,
	UpdateDataResultCodeNotAuthorized,
}

var updateDataResultCodeMap = map[int32]string{
	0:  "UpdateDataResultCodeSuccess",
	-1: "UpdateDataResultCodeInvalidData",
	-2: "UpdateDataResultCodeNotFound",
	-3: "UpdateDataResultCodeNotAuthorized",
}

var updateDataResultCodeShortMap = map[int32]string{
	0:  "success",
	-1: "invalid_data",
	-2: "not_found",
	-3: "not_authorized",
}

var updateDataResultCodeRevMap = map[string]int32{
	"UpdateDataResultCodeSuccess":       0,
	"UpdateDataResultCodeInvalidData":   -1,
	"UpdateDataResultCodeNotFound":      -2,
	"UpdateDataResultCodeNotAuthorized": -3,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for UpdateDataResultCode
func (e UpdateDataResultCode) ValidEnum(v int32) bool {
	_, ok := updateDataResultCodeMap[v]
	return ok
}
func (e UpdateDataResultCode) isFlag() bool {
	for i := len(UpdateDataResultCodeAll) - 1; i >= 0; i-- {
		expected := UpdateDataResultCode(2) << uint64(len(UpdateDataResultCodeAll)-1) >> uint64(len(UpdateDataResultCodeAll)-i)
		if expected != UpdateDataResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e UpdateDataResultCode) String() string {
	name, _ := updateDataResultCodeMap[int32(e)]
	return name
}

func (e UpdateDataResultCode) ShortString() string {
	name, _ := updateDataResultCodeShortMap[int32(e)]
	return name
}

func (e UpdateDataResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range UpdateDataResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *UpdateDataResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = UpdateDataResultCode(t.Value)
	return nil
}

// UpdateDataResult is an XDR Union defines as:
//
//   //: Result of operation application
//    union UpdateDataResult switch (UpdateDataResultCode code)
//    {
//    case SUCCESS:
//        //: Reserved for future extension
//        EmptyExt ext;
//    default:
//        void;
//    };
//
type UpdateDataResult struct {
	Code UpdateDataResultCode `json:"code,omitempty"`
	Ext  *EmptyExt            `json:"ext,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u UpdateDataResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of UpdateDataResult
func (u UpdateDataResult) ArmForSwitch(sw int32) (string, bool) {
	switch UpdateDataResultCode(sw) {
	case UpdateDataResultCodeSuccess:
		return "Ext", true
	default:
		return "", true
	}
}

// NewUpdateDataResult creates a new  UpdateDataResult.
func NewUpdateDataResult(code UpdateDataResultCode, value interface{}) (result UpdateDataResult, err error) {
	result.Code = code
	switch UpdateDataResultCode(code) {
	case UpdateDataResultCodeSuccess:
		tv, ok := value.(EmptyExt)
		if !ok {
			err = fmt.Errorf("invalid value, must be EmptyExt")
			return
		}
		result.Ext = &tv
	default:
		// void
	}
	return
}

// MustExt retrieves the Ext value from the union,
// panicing if the value is not set.
func (u UpdateDataResult) MustExt() EmptyExt {
	val, ok := u.GetExt()

	if !ok {
		panic("arm Ext is not set")
	}

	return val
}

// GetExt retrieves the Ext value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u UpdateDataResult) GetExt() (result EmptyExt, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Ext" {
		result = *u.Ext
		ok = true
	}

	return
}

// ErrorCode is an XDR Enum defines as:
//
//   enum ErrorCode
//    {
//        MISC = 0, // Unspecific error
//        DATA = 1, // Malformed data
//        CONF = 2, // Misconfiguration error
//        AUTH = 3, // Authentication failure
//        LOAD = 4  // System overloaded
//    };
//
type ErrorCode int32

const (
	ErrorCodeMisc ErrorCode = 0
	ErrorCodeData ErrorCode = 1
	ErrorCodeConf ErrorCode = 2
	ErrorCodeAuth ErrorCode = 3
	ErrorCodeLoad ErrorCode = 4
)

var ErrorCodeAll = []ErrorCode{
	ErrorCodeMisc,
	ErrorCodeData,
	ErrorCodeConf,
	ErrorCodeAuth,
	ErrorCodeLoad,
}

var errorCodeMap = map[int32]string{
	0: "ErrorCodeMisc",
	1: "ErrorCodeData",
	2: "ErrorCodeConf",
	3: "ErrorCodeAuth",
	4: "ErrorCodeLoad",
}

var errorCodeShortMap = map[int32]string{
	0: "misc",
	1: "data",
	2: "conf",
	3: "auth",
	4: "load",
}

var errorCodeRevMap = map[string]int32{
	"ErrorCodeMisc": 0,
	"ErrorCodeData": 1,
	"ErrorCodeConf": 2,
	"ErrorCodeAuth": 3,
	"ErrorCodeLoad": 4,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for ErrorCode
func (e ErrorCode) ValidEnum(v int32) bool {
	_, ok := errorCodeMap[v]
	return ok
}
func (e ErrorCode) isFlag() bool {
	for i := len(ErrorCodeAll) - 1; i >= 0; i-- {
		expected := ErrorCode(2) << uint64(len(ErrorCodeAll)-1) >> uint64(len(ErrorCodeAll)-i)
		if expected != ErrorCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e ErrorCode) String() string {
	name, _ := errorCodeMap[int32(e)]
	return name
}

func (e ErrorCode) ShortString() string {
	name, _ := errorCodeShortMap[int32(e)]
	return name
}

func (e ErrorCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range ErrorCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *ErrorCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = ErrorCode(t.Value)
	return nil
}

// Error is an XDR Struct defines as:
//
//   struct Error
//    {
//        ErrorCode code;
//        string msg<100>;
//    };
//
type Error struct {
	Code ErrorCode `json:"code,omitempty"`
	Msg  string    `json:"msg,omitempty" xdrmaxsize:"100"`
}

// AuthCert is an XDR Struct defines as:
//
//   struct AuthCert
//    {
//        Curve25519Public pubkey;
//        uint64 expiration;
//        Signature sig;
//    };
//
type AuthCert struct {
	Pubkey     Curve25519Public `json:"pubkey,omitempty"`
	Expiration Uint64           `json:"expiration,omitempty"`
	Sig        Signature        `json:"sig,omitempty"`
}

// Hello is an XDR Struct defines as:
//
//   struct Hello
//    {
//        uint32 ledgerVersion;
//        uint32 overlayVersion;
//        uint32 overlayMinVersion;
//        Hash networkID;
//        string versionStr<100>;
//        int listeningPort;
//        NodeID peerID;
//        AuthCert cert;
//        uint256 nonce;
//    };
//
type Hello struct {
	LedgerVersion     Uint32   `json:"ledgerVersion,omitempty"`
	OverlayVersion    Uint32   `json:"overlayVersion,omitempty"`
	OverlayMinVersion Uint32   `json:"overlayMinVersion,omitempty"`
	NetworkId         Hash     `json:"networkID,omitempty"`
	VersionStr        string   `json:"versionStr,omitempty" xdrmaxsize:"100"`
	ListeningPort     int32    `json:"listeningPort,omitempty"`
	PeerId            NodeId   `json:"peerID,omitempty"`
	Cert              AuthCert `json:"cert,omitempty"`
	Nonce             Uint256  `json:"nonce,omitempty"`
}

// Auth is an XDR Struct defines as:
//
//   struct Auth
//    {
//        // Empty message, just to confirm
//        // establishment of MAC keys.
//        int unused;
//    };
//
type Auth struct {
	Unused int32 `json:"unused,omitempty"`
}

// IpAddrType is an XDR Enum defines as:
//
//   enum IPAddrType
//    {
//        IPv4 = 0,
//        IPv6 = 1
//    };
//
type IpAddrType int32

const (
	IpAddrTypeIPv4 IpAddrType = 0
	IpAddrTypeIPv6 IpAddrType = 1
)

var IpAddrTypeAll = []IpAddrType{
	IpAddrTypeIPv4,
	IpAddrTypeIPv6,
}

var ipAddrTypeMap = map[int32]string{
	0: "IpAddrTypeIPv4",
	1: "IpAddrTypeIPv6",
}

var ipAddrTypeShortMap = map[int32]string{
	0: "i_pv4",
	1: "i_pv6",
}

var ipAddrTypeRevMap = map[string]int32{
	"IpAddrTypeIPv4": 0,
	"IpAddrTypeIPv6": 1,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for IpAddrType
func (e IpAddrType) ValidEnum(v int32) bool {
	_, ok := ipAddrTypeMap[v]
	return ok
}
func (e IpAddrType) isFlag() bool {
	for i := len(IpAddrTypeAll) - 1; i >= 0; i-- {
		expected := IpAddrType(2) << uint64(len(IpAddrTypeAll)-1) >> uint64(len(IpAddrTypeAll)-i)
		if expected != IpAddrTypeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e IpAddrType) String() string {
	name, _ := ipAddrTypeMap[int32(e)]
	return name
}

func (e IpAddrType) ShortString() string {
	name, _ := ipAddrTypeShortMap[int32(e)]
	return name
}

func (e IpAddrType) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range IpAddrTypeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *IpAddrType) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = IpAddrType(t.Value)
	return nil
}

// PeerAddressIp is an XDR NestedUnion defines as:
//
//   union switch (IPAddrType type)
//        {
//        case IPv4:
//            opaque ipv4[4];
//        case IPv6:
//            opaque ipv6[16];
//        }
//
type PeerAddressIp struct {
	Type IpAddrType `json:"type,omitempty"`
	Ipv4 *[4]byte   `json:"ipv4,omitempty"`
	Ipv6 *[16]byte  `json:"ipv6,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u PeerAddressIp) SwitchFieldName() string {
	return "Type"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of PeerAddressIp
func (u PeerAddressIp) ArmForSwitch(sw int32) (string, bool) {
	switch IpAddrType(sw) {
	case IpAddrTypeIPv4:
		return "Ipv4", true
	case IpAddrTypeIPv6:
		return "Ipv6", true
	}
	return "-", false
}

// NewPeerAddressIp creates a new  PeerAddressIp.
func NewPeerAddressIp(aType IpAddrType, value interface{}) (result PeerAddressIp, err error) {
	result.Type = aType
	switch IpAddrType(aType) {
	case IpAddrTypeIPv4:
		tv, ok := value.([4]byte)
		if !ok {
			err = fmt.Errorf("invalid value, must be [4]byte")
			return
		}
		result.Ipv4 = &tv
	case IpAddrTypeIPv6:
		tv, ok := value.([16]byte)
		if !ok {
			err = fmt.Errorf("invalid value, must be [16]byte")
			return
		}
		result.Ipv6 = &tv
	}
	return
}

// MustIpv4 retrieves the Ipv4 value from the union,
// panicing if the value is not set.
func (u PeerAddressIp) MustIpv4() [4]byte {
	val, ok := u.GetIpv4()

	if !ok {
		panic("arm Ipv4 is not set")
	}

	return val
}

// GetIpv4 retrieves the Ipv4 value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u PeerAddressIp) GetIpv4() (result [4]byte, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Ipv4" {
		result = *u.Ipv4
		ok = true
	}

	return
}

// MustIpv6 retrieves the Ipv6 value from the union,
// panicing if the value is not set.
func (u PeerAddressIp) MustIpv6() [16]byte {
	val, ok := u.GetIpv6()

	if !ok {
		panic("arm Ipv6 is not set")
	}

	return val
}

// GetIpv6 retrieves the Ipv6 value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u PeerAddressIp) GetIpv6() (result [16]byte, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Ipv6" {
		result = *u.Ipv6
		ok = true
	}

	return
}

// PeerAddress is an XDR Struct defines as:
//
//   struct PeerAddress
//    {
//        union switch (IPAddrType type)
//        {
//        case IPv4:
//            opaque ipv4[4];
//        case IPv6:
//            opaque ipv6[16];
//        }
//        ip;
//        uint32 port;
//        uint32 numFailures;
//    };
//
type PeerAddress struct {
	Ip          PeerAddressIp `json:"ip,omitempty"`
	Port        Uint32        `json:"port,omitempty"`
	NumFailures Uint32        `json:"numFailures,omitempty"`
}

// MessageType is an XDR Enum defines as:
//
//   enum MessageType
//    {
//        ERROR_MSG = 0,
//        AUTH = 2,
//        DONT_HAVE = 3,
//
//        GET_PEERS = 4, // gets a list of peers this guy knows about
//        PEERS = 5,
//
//        GET_TX_SET = 6, // gets a particular txset by hash
//        TX_SET = 7,
//
//        TRANSACTION = 8, // pass on a tx you have heard about
//
//        // SCP
//        GET_SCP_QUORUMSET = 9,
//        SCP_QUORUMSET = 10,
//        SCP_MESSAGE = 11,
//        GET_SCP_STATE = 12,
//
//        // new messages
//        HELLO = 13
//    };
//
type MessageType int32

const (
	MessageTypeErrorMsg        MessageType = 0
	MessageTypeAuth            MessageType = 2
	MessageTypeDontHave        MessageType = 3
	MessageTypeGetPeers        MessageType = 4
	MessageTypePeers           MessageType = 5
	MessageTypeGetTxSet        MessageType = 6
	MessageTypeTxSet           MessageType = 7
	MessageTypeTransaction     MessageType = 8
	MessageTypeGetScpQuorumset MessageType = 9
	MessageTypeScpQuorumset    MessageType = 10
	MessageTypeScpMessage      MessageType = 11
	MessageTypeGetScpState     MessageType = 12
	MessageTypeHello           MessageType = 13
)

var MessageTypeAll = []MessageType{
	MessageTypeErrorMsg,
	MessageTypeAuth,
	MessageTypeDontHave,
	MessageTypeGetPeers,
	MessageTypePeers,
	MessageTypeGetTxSet,
	MessageTypeTxSet,
	MessageTypeTransaction,
	MessageTypeGetScpQuorumset,
	MessageTypeScpQuorumset,
	MessageTypeScpMessage,
	MessageTypeGetScpState,
	MessageTypeHello,
}

var messageTypeMap = map[int32]string{
	0:  "MessageTypeErrorMsg",
	2:  "MessageTypeAuth",
	3:  "MessageTypeDontHave",
	4:  "MessageTypeGetPeers",
	5:  "MessageTypePeers",
	6:  "MessageTypeGetTxSet",
	7:  "MessageTypeTxSet",
	8:  "MessageTypeTransaction",
	9:  "MessageTypeGetScpQuorumset",
	10: "MessageTypeScpQuorumset",
	11: "MessageTypeScpMessage",
	12: "MessageTypeGetScpState",
	13: "MessageTypeHello",
}

var messageTypeShortMap = map[int32]string{
	0:  "error_msg",
	2:  "auth",
	3:  "dont_have",
	4:  "get_peers",
	5:  "peers",
	6:  "get_tx_set",
	7:  "tx_set",
	8:  "transaction",
	9:  "get_scp_quorumset",
	10: "scp_quorumset",
	11: "scp_message",
	12: "get_scp_state",
	13: "hello",
}

var messageTypeRevMap = map[string]int32{
	"MessageTypeErrorMsg":        0,
	"MessageTypeAuth":            2,
	"MessageTypeDontHave":        3,
	"MessageTypeGetPeers":        4,
	"MessageTypePeers":           5,
	"MessageTypeGetTxSet":        6,
	"MessageTypeTxSet":           7,
	"MessageTypeTransaction":     8,
	"MessageTypeGetScpQuorumset": 9,
	"MessageTypeScpQuorumset":    10,
	"MessageTypeScpMessage":      11,
	"MessageTypeGetScpState":     12,
	"MessageTypeHello":           13,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for MessageType
func (e MessageType) ValidEnum(v int32) bool {
	_, ok := messageTypeMap[v]
	return ok
}
func (e MessageType) isFlag() bool {
	for i := len(MessageTypeAll) - 1; i >= 0; i-- {
		expected := MessageType(2) << uint64(len(MessageTypeAll)-1) >> uint64(len(MessageTypeAll)-i)
		if expected != MessageTypeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e MessageType) String() string {
	name, _ := messageTypeMap[int32(e)]
	return name
}

func (e MessageType) ShortString() string {
	name, _ := messageTypeShortMap[int32(e)]
	return name
}

func (e MessageType) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range MessageTypeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *MessageType) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = MessageType(t.Value)
	return nil
}

// DontHave is an XDR Struct defines as:
//
//   struct DontHave
//    {
//        MessageType type;
//        uint256 reqHash;
//    };
//
type DontHave struct {
	Type    MessageType `json:"type,omitempty"`
	ReqHash Uint256     `json:"reqHash,omitempty"`
}

// StellarMessage is an XDR Union defines as:
//
//   union StellarMessage switch (MessageType type)
//    {
//    case ERROR_MSG:
//        Error error;
//    case HELLO:
//        Hello hello;
//    case AUTH:
//        Auth auth;
//    case DONT_HAVE:
//        DontHave dontHave;
//    case GET_PEERS:
//        void;
//    case PEERS:
//        PeerAddress peers<>;
//
//    case GET_TX_SET:
//        uint256 txSetHash;
//    case TX_SET:
//        TransactionSet txSet;
//
//    case TRANSACTION:
//        TransactionEnvelope transaction;
//
//    // SCP
//    case GET_SCP_QUORUMSET:
//        uint256 qSetHash;
//    case SCP_QUORUMSET:
//        SCPQuorumSet qSet;
//    case SCP_MESSAGE:
//        SCPEnvelope envelope;
//    case GET_SCP_STATE:
//        uint32 getSCPLedgerSeq; // ledger seq requested ; if 0, requests the latest
//    };
//
type StellarMessage struct {
	Type            MessageType          `json:"type,omitempty"`
	Error           *Error               `json:"error,omitempty"`
	Hello           *Hello               `json:"hello,omitempty"`
	Auth            *Auth                `json:"auth,omitempty"`
	DontHave        *DontHave            `json:"dontHave,omitempty"`
	Peers           *[]PeerAddress       `json:"peers,omitempty"`
	TxSetHash       *Uint256             `json:"txSetHash,omitempty"`
	TxSet           *TransactionSet      `json:"txSet,omitempty"`
	Transaction     *TransactionEnvelope `json:"transaction,omitempty"`
	QSetHash        *Uint256             `json:"qSetHash,omitempty"`
	QSet            *ScpQuorumSet        `json:"qSet,omitempty"`
	Envelope        *ScpEnvelope         `json:"envelope,omitempty"`
	GetScpLedgerSeq *Uint32              `json:"getSCPLedgerSeq,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u StellarMessage) SwitchFieldName() string {
	return "Type"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of StellarMessage
func (u StellarMessage) ArmForSwitch(sw int32) (string, bool) {
	switch MessageType(sw) {
	case MessageTypeErrorMsg:
		return "Error", true
	case MessageTypeHello:
		return "Hello", true
	case MessageTypeAuth:
		return "Auth", true
	case MessageTypeDontHave:
		return "DontHave", true
	case MessageTypeGetPeers:
		return "", true
	case MessageTypePeers:
		return "Peers", true
	case MessageTypeGetTxSet:
		return "TxSetHash", true
	case MessageTypeTxSet:
		return "TxSet", true
	case MessageTypeTransaction:
		return "Transaction", true
	case MessageTypeGetScpQuorumset:
		return "QSetHash", true
	case MessageTypeScpQuorumset:
		return "QSet", true
	case MessageTypeScpMessage:
		return "Envelope", true
	case MessageTypeGetScpState:
		return "GetScpLedgerSeq", true
	}
	return "-", false
}

// NewStellarMessage creates a new  StellarMessage.
func NewStellarMessage(aType MessageType, value interface{}) (result StellarMessage, err error) {
	result.Type = aType
	switch MessageType(aType) {
	case MessageTypeErrorMsg:
		tv, ok := value.(Error)
		if !ok {
			err = fmt.Errorf("invalid value, must be Error")
			return
		}
		result.Error = &tv
	case MessageTypeHello:
		tv, ok := value.(Hello)
		if !ok {
			err = fmt.Errorf("invalid value, must be Hello")
			return
		}
		result.Hello = &tv
	case MessageTypeAuth:
		tv, ok := value.(Auth)
		if !ok {
			err = fmt.Errorf("invalid value, must be Auth")
			return
		}
		result.Auth = &tv
	case MessageTypeDontHave:
		tv, ok := value.(DontHave)
		if !ok {
			err = fmt.Errorf("invalid value, must be DontHave")
			return
		}
		result.DontHave = &tv
	case MessageTypeGetPeers:
		// void
	case MessageTypePeers:
		tv, ok := value.([]PeerAddress)
		if !ok {
			err = fmt.Errorf("invalid value, must be []PeerAddress")
			return
		}
		result.Peers = &tv
	case MessageTypeGetTxSet:
		tv, ok := value.(Uint256)
		if !ok {
			err = fmt.Errorf("invalid value, must be Uint256")
			return
		}
		result.TxSetHash = &tv
	case MessageTypeTxSet:
		tv, ok := value.(TransactionSet)
		if !ok {
			err = fmt.Errorf("invalid value, must be TransactionSet")
			return
		}
		result.TxSet = &tv
	case MessageTypeTransaction:
		tv, ok := value.(TransactionEnvelope)
		if !ok {
			err = fmt.Errorf("invalid value, must be TransactionEnvelope")
			return
		}
		result.Transaction = &tv
	case MessageTypeGetScpQuorumset:
		tv, ok := value.(Uint256)
		if !ok {
			err = fmt.Errorf("invalid value, must be Uint256")
			return
		}
		result.QSetHash = &tv
	case MessageTypeScpQuorumset:
		tv, ok := value.(ScpQuorumSet)
		if !ok {
			err = fmt.Errorf("invalid value, must be ScpQuorumSet")
			return
		}
		result.QSet = &tv
	case MessageTypeScpMessage:
		tv, ok := value.(ScpEnvelope)
		if !ok {
			err = fmt.Errorf("invalid value, must be ScpEnvelope")
			return
		}
		result.Envelope = &tv
	case MessageTypeGetScpState:
		tv, ok := value.(Uint32)
		if !ok {
			err = fmt.Errorf("invalid value, must be Uint32")
			return
		}
		result.GetScpLedgerSeq = &tv
	}
	return
}

// MustError retrieves the Error value from the union,
// panicing if the value is not set.
func (u StellarMessage) MustError() Error {
	val, ok := u.GetError()

	if !ok {
		panic("arm Error is not set")
	}

	return val
}

// GetError retrieves the Error value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u StellarMessage) GetError() (result Error, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Error" {
		result = *u.Error
		ok = true
	}

	return
}

// MustHello retrieves the Hello value from the union,
// panicing if the value is not set.
func (u StellarMessage) MustHello() Hello {
	val, ok := u.GetHello()

	if !ok {
		panic("arm Hello is not set")
	}

	return val
}

// GetHello retrieves the Hello value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u StellarMessage) GetHello() (result Hello, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Hello" {
		result = *u.Hello
		ok = true
	}

	return
}

// MustAuth retrieves the Auth value from the union,
// panicing if the value is not set.
func (u StellarMessage) MustAuth() Auth {
	val, ok := u.GetAuth()

	if !ok {
		panic("arm Auth is not set")
	}

	return val
}

// GetAuth retrieves the Auth value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u StellarMessage) GetAuth() (result Auth, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Auth" {
		result = *u.Auth
		ok = true
	}

	return
}

// MustDontHave retrieves the DontHave value from the union,
// panicing if the value is not set.
func (u StellarMessage) MustDontHave() DontHave {
	val, ok := u.GetDontHave()

	if !ok {
		panic("arm DontHave is not set")
	}

	return val
}

// GetDontHave retrieves the DontHave value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u StellarMessage) GetDontHave() (result DontHave, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "DontHave" {
		result = *u.DontHave
		ok = true
	}

	return
}

// MustPeers retrieves the Peers value from the union,
// panicing if the value is not set.
func (u StellarMessage) MustPeers() []PeerAddress {
	val, ok := u.GetPeers()

	if !ok {
		panic("arm Peers is not set")
	}

	return val
}

// GetPeers retrieves the Peers value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u StellarMessage) GetPeers() (result []PeerAddress, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Peers" {
		result = *u.Peers
		ok = true
	}

	return
}

// MustTxSetHash retrieves the TxSetHash value from the union,
// panicing if the value is not set.
func (u StellarMessage) MustTxSetHash() Uint256 {
	val, ok := u.GetTxSetHash()

	if !ok {
		panic("arm TxSetHash is not set")
	}

	return val
}

// GetTxSetHash retrieves the TxSetHash value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u StellarMessage) GetTxSetHash() (result Uint256, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "TxSetHash" {
		result = *u.TxSetHash
		ok = true
	}

	return
}

// MustTxSet retrieves the TxSet value from the union,
// panicing if the value is not set.
func (u StellarMessage) MustTxSet() TransactionSet {
	val, ok := u.GetTxSet()

	if !ok {
		panic("arm TxSet is not set")
	}

	return val
}

// GetTxSet retrieves the TxSet value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u StellarMessage) GetTxSet() (result TransactionSet, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "TxSet" {
		result = *u.TxSet
		ok = true
	}

	return
}

// MustTransaction retrieves the Transaction value from the union,
// panicing if the value is not set.
func (u StellarMessage) MustTransaction() TransactionEnvelope {
	val, ok := u.GetTransaction()

	if !ok {
		panic("arm Transaction is not set")
	}

	return val
}

// GetTransaction retrieves the Transaction value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u StellarMessage) GetTransaction() (result TransactionEnvelope, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Transaction" {
		result = *u.Transaction
		ok = true
	}

	return
}

// MustQSetHash retrieves the QSetHash value from the union,
// panicing if the value is not set.
func (u StellarMessage) MustQSetHash() Uint256 {
	val, ok := u.GetQSetHash()

	if !ok {
		panic("arm QSetHash is not set")
	}

	return val
}

// GetQSetHash retrieves the QSetHash value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u StellarMessage) GetQSetHash() (result Uint256, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "QSetHash" {
		result = *u.QSetHash
		ok = true
	}

	return
}

// MustQSet retrieves the QSet value from the union,
// panicing if the value is not set.
func (u StellarMessage) MustQSet() ScpQuorumSet {
	val, ok := u.GetQSet()

	if !ok {
		panic("arm QSet is not set")
	}

	return val
}

// GetQSet retrieves the QSet value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u StellarMessage) GetQSet() (result ScpQuorumSet, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "QSet" {
		result = *u.QSet
		ok = true
	}

	return
}

// MustEnvelope retrieves the Envelope value from the union,
// panicing if the value is not set.
func (u StellarMessage) MustEnvelope() ScpEnvelope {
	val, ok := u.GetEnvelope()

	if !ok {
		panic("arm Envelope is not set")
	}

	return val
}

// GetEnvelope retrieves the Envelope value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u StellarMessage) GetEnvelope() (result ScpEnvelope, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Envelope" {
		result = *u.Envelope
		ok = true
	}

	return
}

// MustGetScpLedgerSeq retrieves the GetScpLedgerSeq value from the union,
// panicing if the value is not set.
func (u StellarMessage) MustGetScpLedgerSeq() Uint32 {
	val, ok := u.GetGetScpLedgerSeq()

	if !ok {
		panic("arm GetScpLedgerSeq is not set")
	}

	return val
}

// GetGetScpLedgerSeq retrieves the GetScpLedgerSeq value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u StellarMessage) GetGetScpLedgerSeq() (result Uint32, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "GetScpLedgerSeq" {
		result = *u.GetScpLedgerSeq
		ok = true
	}

	return
}

// AuthenticatedMessageV0 is an XDR NestedStruct defines as:
//
//   struct
//    {
//       uint64 sequence;
//       StellarMessage message;
//       HmacSha256Mac mac;
//        }
//
type AuthenticatedMessageV0 struct {
	Sequence Uint64         `json:"sequence,omitempty"`
	Message  StellarMessage `json:"message,omitempty"`
	Mac      HmacSha256Mac  `json:"mac,omitempty"`
}

// AuthenticatedMessage is an XDR Union defines as:
//
//   union AuthenticatedMessage switch (LedgerVersion v)
//    {
//    case EMPTY_VERSION:
//        struct
//    {
//       uint64 sequence;
//       StellarMessage message;
//       HmacSha256Mac mac;
//        } v0;
//    };
//
type AuthenticatedMessage struct {
	V  LedgerVersion           `json:"v,omitempty"`
	V0 *AuthenticatedMessageV0 `json:"v0,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u AuthenticatedMessage) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of AuthenticatedMessage
func (u AuthenticatedMessage) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "V0", true
	}
	return "-", false
}

// NewAuthenticatedMessage creates a new  AuthenticatedMessage.
func NewAuthenticatedMessage(v LedgerVersion, value interface{}) (result AuthenticatedMessage, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		tv, ok := value.(AuthenticatedMessageV0)
		if !ok {
			err = fmt.Errorf("invalid value, must be AuthenticatedMessageV0")
			return
		}
		result.V0 = &tv
	}
	return
}

// MustV0 retrieves the V0 value from the union,
// panicing if the value is not set.
func (u AuthenticatedMessage) MustV0() AuthenticatedMessageV0 {
	val, ok := u.GetV0()

	if !ok {
		panic("arm V0 is not set")
	}

	return val
}

// GetV0 retrieves the V0 value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u AuthenticatedMessage) GetV0() (result AuthenticatedMessageV0, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.V))

	if armName == "V0" {
		result = *u.V0
		ok = true
	}

	return
}

// ReviewableRequestResourceCreateSale is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: type of sale
//            uint64 type;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        }
//
type ReviewableRequestResourceCreateSale struct {
	Type Uint64   `json:"type,omitempty"`
	Ext  EmptyExt `json:"ext,omitempty"`
}

// ReviewableRequestResourceCreateIssuance is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: code of asset
//            AssetCode assetCode;
//            //: type of asset
//            uint64 assetType;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        }
//
type ReviewableRequestResourceCreateIssuance struct {
	AssetCode AssetCode `json:"assetCode,omitempty"`
	AssetType Uint64    `json:"assetType,omitempty"`
	Ext       EmptyExt  `json:"ext,omitempty"`
}

// ReviewableRequestResourceCreateWithdraw is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: code of asset
//            AssetCode assetCode;
//            //: type of asset
//            uint64 assetType;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        }
//
type ReviewableRequestResourceCreateWithdraw struct {
	AssetCode AssetCode `json:"assetCode,omitempty"`
	AssetType Uint64    `json:"assetType,omitempty"`
	Ext       EmptyExt  `json:"ext,omitempty"`
}

// ReviewableRequestResourceCreateAtomicSwapAskExtCreateAtomicSwapAsk is an XDR NestedStruct defines as:
//
//   struct
//            {
//                //: code of asset
//                AssetCode assetCode;
//                //: type of asset
//                uint64 assetType;
//
//                //: reserved for future extension
//                EmptyExt ext;
//            }
//
type ReviewableRequestResourceCreateAtomicSwapAskExtCreateAtomicSwapAsk struct {
	AssetCode AssetCode `json:"assetCode,omitempty"`
	AssetType Uint64    `json:"assetType,omitempty"`
	Ext       EmptyExt  `json:"ext,omitempty"`
}

// ReviewableRequestResourceCreateAtomicSwapAskExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        case ATOMIC_SWAP_RETURNING:
//            //: is used to restrict the usage of a reviewable request with create_atomic_swap_ask type
//            struct
//            {
//                //: code of asset
//                AssetCode assetCode;
//                //: type of asset
//                uint64 assetType;
//
//                //: reserved for future extension
//                EmptyExt ext;
//            } createAtomicSwapAsk;
//        }
//
type ReviewableRequestResourceCreateAtomicSwapAskExt struct {
	V                   LedgerVersion                                                       `json:"v,omitempty"`
	CreateAtomicSwapAsk *ReviewableRequestResourceCreateAtomicSwapAskExtCreateAtomicSwapAsk `json:"createAtomicSwapAsk,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ReviewableRequestResourceCreateAtomicSwapAskExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ReviewableRequestResourceCreateAtomicSwapAskExt
func (u ReviewableRequestResourceCreateAtomicSwapAskExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	case LedgerVersionAtomicSwapReturning:
		return "CreateAtomicSwapAsk", true
	}
	return "-", false
}

// NewReviewableRequestResourceCreateAtomicSwapAskExt creates a new  ReviewableRequestResourceCreateAtomicSwapAskExt.
func NewReviewableRequestResourceCreateAtomicSwapAskExt(v LedgerVersion, value interface{}) (result ReviewableRequestResourceCreateAtomicSwapAskExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	case LedgerVersionAtomicSwapReturning:
		tv, ok := value.(ReviewableRequestResourceCreateAtomicSwapAskExtCreateAtomicSwapAsk)
		if !ok {
			err = fmt.Errorf("invalid value, must be ReviewableRequestResourceCreateAtomicSwapAskExtCreateAtomicSwapAsk")
			return
		}
		result.CreateAtomicSwapAsk = &tv
	}
	return
}

// MustCreateAtomicSwapAsk retrieves the CreateAtomicSwapAsk value from the union,
// panicing if the value is not set.
func (u ReviewableRequestResourceCreateAtomicSwapAskExt) MustCreateAtomicSwapAsk() ReviewableRequestResourceCreateAtomicSwapAskExtCreateAtomicSwapAsk {
	val, ok := u.GetCreateAtomicSwapAsk()

	if !ok {
		panic("arm CreateAtomicSwapAsk is not set")
	}

	return val
}

// GetCreateAtomicSwapAsk retrieves the CreateAtomicSwapAsk value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestResourceCreateAtomicSwapAskExt) GetCreateAtomicSwapAsk() (result ReviewableRequestResourceCreateAtomicSwapAskExtCreateAtomicSwapAsk, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.V))

	if armName == "CreateAtomicSwapAsk" {
		result = *u.CreateAtomicSwapAsk
		ok = true
	}

	return
}

// ReviewableRequestResourceCreateAtomicSwapBidExtCreateAtomicSwapBid is an XDR NestedStruct defines as:
//
//   struct
//            {
//                //: code of asset
//                AssetCode assetCode;
//                //: type of asset
//                uint64 assetType;
//
//                //: reserved for future extension
//                EmptyExt ext;
//            }
//
type ReviewableRequestResourceCreateAtomicSwapBidExtCreateAtomicSwapBid struct {
	AssetCode AssetCode `json:"assetCode,omitempty"`
	AssetType Uint64    `json:"assetType,omitempty"`
	Ext       EmptyExt  `json:"ext,omitempty"`
}

// ReviewableRequestResourceCreateAtomicSwapBidExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        case ATOMIC_SWAP_RETURNING:
//            //: is used to restrict the usage of a reviewable request with create_atomic_swap_bid type
//            struct
//            {
//                //: code of asset
//                AssetCode assetCode;
//                //: type of asset
//                uint64 assetType;
//
//                //: reserved for future extension
//                EmptyExt ext;
//            } createAtomicSwapBid;
//        }
//
type ReviewableRequestResourceCreateAtomicSwapBidExt struct {
	V                   LedgerVersion                                                       `json:"v,omitempty"`
	CreateAtomicSwapBid *ReviewableRequestResourceCreateAtomicSwapBidExtCreateAtomicSwapBid `json:"createAtomicSwapBid,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ReviewableRequestResourceCreateAtomicSwapBidExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ReviewableRequestResourceCreateAtomicSwapBidExt
func (u ReviewableRequestResourceCreateAtomicSwapBidExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	case LedgerVersionAtomicSwapReturning:
		return "CreateAtomicSwapBid", true
	}
	return "-", false
}

// NewReviewableRequestResourceCreateAtomicSwapBidExt creates a new  ReviewableRequestResourceCreateAtomicSwapBidExt.
func NewReviewableRequestResourceCreateAtomicSwapBidExt(v LedgerVersion, value interface{}) (result ReviewableRequestResourceCreateAtomicSwapBidExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	case LedgerVersionAtomicSwapReturning:
		tv, ok := value.(ReviewableRequestResourceCreateAtomicSwapBidExtCreateAtomicSwapBid)
		if !ok {
			err = fmt.Errorf("invalid value, must be ReviewableRequestResourceCreateAtomicSwapBidExtCreateAtomicSwapBid")
			return
		}
		result.CreateAtomicSwapBid = &tv
	}
	return
}

// MustCreateAtomicSwapBid retrieves the CreateAtomicSwapBid value from the union,
// panicing if the value is not set.
func (u ReviewableRequestResourceCreateAtomicSwapBidExt) MustCreateAtomicSwapBid() ReviewableRequestResourceCreateAtomicSwapBidExtCreateAtomicSwapBid {
	val, ok := u.GetCreateAtomicSwapBid()

	if !ok {
		panic("arm CreateAtomicSwapBid is not set")
	}

	return val
}

// GetCreateAtomicSwapBid retrieves the CreateAtomicSwapBid value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestResourceCreateAtomicSwapBidExt) GetCreateAtomicSwapBid() (result ReviewableRequestResourceCreateAtomicSwapBidExtCreateAtomicSwapBid, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.V))

	if armName == "CreateAtomicSwapBid" {
		result = *u.CreateAtomicSwapBid
		ok = true
	}

	return
}

// ReviewableRequestResourceCreatePoll is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: permission type of poll
//            uint32 permissionType;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        }
//
type ReviewableRequestResourceCreatePoll struct {
	PermissionType Uint32   `json:"permissionType,omitempty"`
	Ext            EmptyExt `json:"ext,omitempty"`
}

// ReviewableRequestResourceManageOffer is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: type of base asset
//            uint64 baseAssetType;
//            //: type of quote asset
//            uint64 quoteAssetType;
//
//            //: code of base asset
//            AssetCode baseAssetCode;
//            //: code of quote asset
//            AssetCode quoteAssetCode;
//
//            bool isBuy;
//            //: 0 means creation,
//            //: 1 means removing,
//            //: 2 means participate in sale,
//            //: 3 means remove participation in sale,
//            //: UINT32_MAX means any action.
//            uint32 manageAction;
//
//            //: ID of the order book.
//            uint64 orderBookID;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        }
//
type ReviewableRequestResourceManageOffer struct {
	BaseAssetType  Uint64    `json:"baseAssetType,omitempty"`
	QuoteAssetType Uint64    `json:"quoteAssetType,omitempty"`
	BaseAssetCode  AssetCode `json:"baseAssetCode,omitempty"`
	QuoteAssetCode AssetCode `json:"quoteAssetCode,omitempty"`
	IsBuy          bool      `json:"isBuy,omitempty"`
	ManageAction   Uint32    `json:"manageAction,omitempty"`
	OrderBookId    Uint64    `json:"orderBookID,omitempty"`
	Ext            EmptyExt  `json:"ext,omitempty"`
}

// ReviewableRequestResourceCreatePayment is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: Code of asset in which payment is being made
//            AssetCode assetCode;
//            //: Type of asset in which payment is being made
//            uint64 assetType;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        }
//
type ReviewableRequestResourceCreatePayment struct {
	AssetCode AssetCode `json:"assetCode,omitempty"`
	AssetType Uint64    `json:"assetType,omitempty"`
	Ext       EmptyExt  `json:"ext,omitempty"`
}

// ReviewableRequestResourcePerformRedemption is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: Code of asset in which redemption is being made
//            AssetCode assetCode;
//            //: Type of asset in which redemption is being made
//            uint64 assetType;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        }
//
type ReviewableRequestResourcePerformRedemption struct {
	AssetCode AssetCode `json:"assetCode,omitempty"`
	AssetType Uint64    `json:"assetType,omitempty"`
	Ext       EmptyExt  `json:"ext,omitempty"`
}

// ReviewableRequestResourceDataCreation is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: Numeric type of the data
//            uint64 type;
//            //: Reserved for future extension
//            EmptyExt ext;
//        }
//
type ReviewableRequestResourceDataCreation struct {
	Type Uint64   `json:"type,omitempty"`
	Ext  EmptyExt `json:"ext,omitempty"`
}

// ReviewableRequestResourceDataUpdate is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: Numeric type of the data
//            uint64 type;
//            //: Reserved for future extension
//            EmptyExt ext;
//        }
//
type ReviewableRequestResourceDataUpdate struct {
	Type Uint64   `json:"type,omitempty"`
	Ext  EmptyExt `json:"ext,omitempty"`
}

// ReviewableRequestResourceDataRemove is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: Numeric type of the data
//            uint64 type;
//            //: Reserved for future extension
//            EmptyExt ext;
//        }
//
type ReviewableRequestResourceDataRemove struct {
	Type Uint64   `json:"type,omitempty"`
	Ext  EmptyExt `json:"ext,omitempty"`
}

// ReviewableRequestResourceCreateDeferredPayment is an XDR NestedStruct defines as:
//
//   struct
//        {
//            AssetCode assetCode;
//
//            uint64 assetType;
//            EmptyExt ext;
//        }
//
type ReviewableRequestResourceCreateDeferredPayment struct {
	AssetCode AssetCode `json:"assetCode,omitempty"`
	AssetType Uint64    `json:"assetType,omitempty"`
	Ext       EmptyExt  `json:"ext,omitempty"`
}

// ReviewableRequestResourceCloseDeferredPayment is an XDR NestedStruct defines as:
//
//   struct
//        {
//            AssetCode assetCode;
//
//            uint64 assetType;
//            EmptyExt ext;
//        }
//
type ReviewableRequestResourceCloseDeferredPayment struct {
	AssetCode AssetCode `json:"assetCode,omitempty"`
	AssetType Uint64    `json:"assetType,omitempty"`
	Ext       EmptyExt  `json:"ext,omitempty"`
}

// ReviewableRequestResource is an XDR Union defines as:
//
//   //: Describes properties of some reviewable request types that
//    //: can be used to restrict the usage of reviewable requests
//    union ReviewableRequestResource switch (ReviewableRequestType requestType)
//    {
//    case CREATE_SALE:
//        //: is used to restrict the usage of a reviewable request with create_sale type
//        struct
//        {
//            //: type of sale
//            uint64 type;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        } createSale;
//    case CREATE_ISSUANCE:
//        //: is used to restrict the usage of a reviewable request with create_issuance type
//        struct
//        {
//            //: code of asset
//            AssetCode assetCode;
//            //: type of asset
//            uint64 assetType;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        } createIssuance;
//    case CREATE_WITHDRAW:
//        //: is used to restrict the usage of a reviewable request with create_withdraw type
//        struct
//        {
//            //: code of asset
//            AssetCode assetCode;
//            //: type of asset
//            uint64 assetType;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        } createWithdraw;
//    case CREATE_ATOMIC_SWAP_ASK:
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        case ATOMIC_SWAP_RETURNING:
//            //: is used to restrict the usage of a reviewable request with create_atomic_swap_ask type
//            struct
//            {
//                //: code of asset
//                AssetCode assetCode;
//                //: type of asset
//                uint64 assetType;
//
//                //: reserved for future extension
//                EmptyExt ext;
//            } createAtomicSwapAsk;
//        } createAtomicSwapAskExt;
//    case CREATE_ATOMIC_SWAP_BID:
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        case ATOMIC_SWAP_RETURNING:
//            //: is used to restrict the usage of a reviewable request with create_atomic_swap_bid type
//            struct
//            {
//                //: code of asset
//                AssetCode assetCode;
//                //: type of asset
//                uint64 assetType;
//
//                //: reserved for future extension
//                EmptyExt ext;
//            } createAtomicSwapBid;
//        } createAtomicSwapBidExt;
//    case CREATE_POLL:
//        //: is used to restrict the creating of a `CREATE_POLL` reviewable request type
//        struct
//        {
//            //: permission type of poll
//            uint32 permissionType;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        } createPoll;
//    case MANAGE_OFFER:
//        struct
//        {
//            //: type of base asset
//            uint64 baseAssetType;
//            //: type of quote asset
//            uint64 quoteAssetType;
//
//            //: code of base asset
//            AssetCode baseAssetCode;
//            //: code of quote asset
//            AssetCode quoteAssetCode;
//
//            bool isBuy;
//            //: 0 means creation,
//            //: 1 means removing,
//            //: 2 means participate in sale,
//            //: 3 means remove participation in sale,
//            //: UINT32_MAX means any action.
//            uint32 manageAction;
//
//            //: ID of the order book.
//            uint64 orderBookID;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        } manageOffer;
//    case CREATE_PAYMENT:
//        struct
//        {
//            //: Code of asset in which payment is being made
//            AssetCode assetCode;
//            //: Type of asset in which payment is being made
//            uint64 assetType;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        } createPayment;
//    case PERFORM_REDEMPTION:
//        struct
//        {
//            //: Code of asset in which redemption is being made
//            AssetCode assetCode;
//            //: Type of asset in which redemption is being made
//            uint64 assetType;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        } performRedemption;
//    case DATA_CREATION:
//        struct
//        {
//            //: Numeric type of the data
//            uint64 type;
//            //: Reserved for future extension
//            EmptyExt ext;
//        } dataCreation;
//    case DATA_UPDATE:
//        struct
//        {
//            //: Numeric type of the data
//            uint64 type;
//            //: Reserved for future extension
//            EmptyExt ext;
//        } dataUpdate;
//    case DATA_REMOVE:
//        struct
//        {
//            //: Numeric type of the data
//            uint64 type;
//            //: Reserved for future extension
//            EmptyExt ext;
//        } dataRemove;
//    case CREATE_DEFERRED_PAYMENT:
//        struct
//        {
//            AssetCode assetCode;
//
//            uint64 assetType;
//            EmptyExt ext;
//        } createDeferredPayment;
//    case CLOSE_DEFERRED_PAYMENT:
//        struct
//        {
//            AssetCode assetCode;
//
//            uint64 assetType;
//            EmptyExt ext;
//        } closeDeferredPayment;
//    default:
//        //: reserved for future extension
//        EmptyExt ext;
//    };
//
type ReviewableRequestResource struct {
	RequestType            ReviewableRequestType                            `json:"requestType,omitempty"`
	CreateSale             *ReviewableRequestResourceCreateSale             `json:"createSale,omitempty"`
	CreateIssuance         *ReviewableRequestResourceCreateIssuance         `json:"createIssuance,omitempty"`
	CreateWithdraw         *ReviewableRequestResourceCreateWithdraw         `json:"createWithdraw,omitempty"`
	CreateAtomicSwapAskExt *ReviewableRequestResourceCreateAtomicSwapAskExt `json:"createAtomicSwapAskExt,omitempty"`
	CreateAtomicSwapBidExt *ReviewableRequestResourceCreateAtomicSwapBidExt `json:"createAtomicSwapBidExt,omitempty"`
	CreatePoll             *ReviewableRequestResourceCreatePoll             `json:"createPoll,omitempty"`
	ManageOffer            *ReviewableRequestResourceManageOffer            `json:"manageOffer,omitempty"`
	CreatePayment          *ReviewableRequestResourceCreatePayment          `json:"createPayment,omitempty"`
	PerformRedemption      *ReviewableRequestResourcePerformRedemption      `json:"performRedemption,omitempty"`
	DataCreation           *ReviewableRequestResourceDataCreation           `json:"dataCreation,omitempty"`
	DataUpdate             *ReviewableRequestResourceDataUpdate             `json:"dataUpdate,omitempty"`
	DataRemove             *ReviewableRequestResourceDataRemove             `json:"dataRemove,omitempty"`
	CreateDeferredPayment  *ReviewableRequestResourceCreateDeferredPayment  `json:"createDeferredPayment,omitempty"`
	CloseDeferredPayment   *ReviewableRequestResourceCloseDeferredPayment   `json:"closeDeferredPayment,omitempty"`
	Ext                    *EmptyExt                                        `json:"ext,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ReviewableRequestResource) SwitchFieldName() string {
	return "RequestType"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ReviewableRequestResource
func (u ReviewableRequestResource) ArmForSwitch(sw int32) (string, bool) {
	switch ReviewableRequestType(sw) {
	case ReviewableRequestTypeCreateSale:
		return "CreateSale", true
	case ReviewableRequestTypeCreateIssuance:
		return "CreateIssuance", true
	case ReviewableRequestTypeCreateWithdraw:
		return "CreateWithdraw", true
	case ReviewableRequestTypeCreateAtomicSwapAsk:
		return "CreateAtomicSwapAskExt", true
	case ReviewableRequestTypeCreateAtomicSwapBid:
		return "CreateAtomicSwapBidExt", true
	case ReviewableRequestTypeCreatePoll:
		return "CreatePoll", true
	case ReviewableRequestTypeManageOffer:
		return "ManageOffer", true
	case ReviewableRequestTypeCreatePayment:
		return "CreatePayment", true
	case ReviewableRequestTypePerformRedemption:
		return "PerformRedemption", true
	case ReviewableRequestTypeDataCreation:
		return "DataCreation", true
	case ReviewableRequestTypeDataUpdate:
		return "DataUpdate", true
	case ReviewableRequestTypeDataRemove:
		return "DataRemove", true
	case ReviewableRequestTypeCreateDeferredPayment:
		return "CreateDeferredPayment", true
	case ReviewableRequestTypeCloseDeferredPayment:
		return "CloseDeferredPayment", true
	default:
		return "Ext", true
	}
}

// NewReviewableRequestResource creates a new  ReviewableRequestResource.
func NewReviewableRequestResource(requestType ReviewableRequestType, value interface{}) (result ReviewableRequestResource, err error) {
	result.RequestType = requestType
	switch ReviewableRequestType(requestType) {
	case ReviewableRequestTypeCreateSale:
		tv, ok := value.(ReviewableRequestResourceCreateSale)
		if !ok {
			err = fmt.Errorf("invalid value, must be ReviewableRequestResourceCreateSale")
			return
		}
		result.CreateSale = &tv
	case ReviewableRequestTypeCreateIssuance:
		tv, ok := value.(ReviewableRequestResourceCreateIssuance)
		if !ok {
			err = fmt.Errorf("invalid value, must be ReviewableRequestResourceCreateIssuance")
			return
		}
		result.CreateIssuance = &tv
	case ReviewableRequestTypeCreateWithdraw:
		tv, ok := value.(ReviewableRequestResourceCreateWithdraw)
		if !ok {
			err = fmt.Errorf("invalid value, must be ReviewableRequestResourceCreateWithdraw")
			return
		}
		result.CreateWithdraw = &tv
	case ReviewableRequestTypeCreateAtomicSwapAsk:
		tv, ok := value.(ReviewableRequestResourceCreateAtomicSwapAskExt)
		if !ok {
			err = fmt.Errorf("invalid value, must be ReviewableRequestResourceCreateAtomicSwapAskExt")
			return
		}
		result.CreateAtomicSwapAskExt = &tv
	case ReviewableRequestTypeCreateAtomicSwapBid:
		tv, ok := value.(ReviewableRequestResourceCreateAtomicSwapBidExt)
		if !ok {
			err = fmt.Errorf("invalid value, must be ReviewableRequestResourceCreateAtomicSwapBidExt")
			return
		}
		result.CreateAtomicSwapBidExt = &tv
	case ReviewableRequestTypeCreatePoll:
		tv, ok := value.(ReviewableRequestResourceCreatePoll)
		if !ok {
			err = fmt.Errorf("invalid value, must be ReviewableRequestResourceCreatePoll")
			return
		}
		result.CreatePoll = &tv
	case ReviewableRequestTypeManageOffer:
		tv, ok := value.(ReviewableRequestResourceManageOffer)
		if !ok {
			err = fmt.Errorf("invalid value, must be ReviewableRequestResourceManageOffer")
			return
		}
		result.ManageOffer = &tv
	case ReviewableRequestTypeCreatePayment:
		tv, ok := value.(ReviewableRequestResourceCreatePayment)
		if !ok {
			err = fmt.Errorf("invalid value, must be ReviewableRequestResourceCreatePayment")
			return
		}
		result.CreatePayment = &tv
	case ReviewableRequestTypePerformRedemption:
		tv, ok := value.(ReviewableRequestResourcePerformRedemption)
		if !ok {
			err = fmt.Errorf("invalid value, must be ReviewableRequestResourcePerformRedemption")
			return
		}
		result.PerformRedemption = &tv
	case ReviewableRequestTypeDataCreation:
		tv, ok := value.(ReviewableRequestResourceDataCreation)
		if !ok {
			err = fmt.Errorf("invalid value, must be ReviewableRequestResourceDataCreation")
			return
		}
		result.DataCreation = &tv
	case ReviewableRequestTypeDataUpdate:
		tv, ok := value.(ReviewableRequestResourceDataUpdate)
		if !ok {
			err = fmt.Errorf("invalid value, must be ReviewableRequestResourceDataUpdate")
			return
		}
		result.DataUpdate = &tv
	case ReviewableRequestTypeDataRemove:
		tv, ok := value.(ReviewableRequestResourceDataRemove)
		if !ok {
			err = fmt.Errorf("invalid value, must be ReviewableRequestResourceDataRemove")
			return
		}
		result.DataRemove = &tv
	case ReviewableRequestTypeCreateDeferredPayment:
		tv, ok := value.(ReviewableRequestResourceCreateDeferredPayment)
		if !ok {
			err = fmt.Errorf("invalid value, must be ReviewableRequestResourceCreateDeferredPayment")
			return
		}
		result.CreateDeferredPayment = &tv
	case ReviewableRequestTypeCloseDeferredPayment:
		tv, ok := value.(ReviewableRequestResourceCloseDeferredPayment)
		if !ok {
			err = fmt.Errorf("invalid value, must be ReviewableRequestResourceCloseDeferredPayment")
			return
		}
		result.CloseDeferredPayment = &tv
	default:
		tv, ok := value.(EmptyExt)
		if !ok {
			err = fmt.Errorf("invalid value, must be EmptyExt")
			return
		}
		result.Ext = &tv
	}
	return
}

// MustCreateSale retrieves the CreateSale value from the union,
// panicing if the value is not set.
func (u ReviewableRequestResource) MustCreateSale() ReviewableRequestResourceCreateSale {
	val, ok := u.GetCreateSale()

	if !ok {
		panic("arm CreateSale is not set")
	}

	return val
}

// GetCreateSale retrieves the CreateSale value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestResource) GetCreateSale() (result ReviewableRequestResourceCreateSale, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "CreateSale" {
		result = *u.CreateSale
		ok = true
	}

	return
}

// MustCreateIssuance retrieves the CreateIssuance value from the union,
// panicing if the value is not set.
func (u ReviewableRequestResource) MustCreateIssuance() ReviewableRequestResourceCreateIssuance {
	val, ok := u.GetCreateIssuance()

	if !ok {
		panic("arm CreateIssuance is not set")
	}

	return val
}

// GetCreateIssuance retrieves the CreateIssuance value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestResource) GetCreateIssuance() (result ReviewableRequestResourceCreateIssuance, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "CreateIssuance" {
		result = *u.CreateIssuance
		ok = true
	}

	return
}

// MustCreateWithdraw retrieves the CreateWithdraw value from the union,
// panicing if the value is not set.
func (u ReviewableRequestResource) MustCreateWithdraw() ReviewableRequestResourceCreateWithdraw {
	val, ok := u.GetCreateWithdraw()

	if !ok {
		panic("arm CreateWithdraw is not set")
	}

	return val
}

// GetCreateWithdraw retrieves the CreateWithdraw value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestResource) GetCreateWithdraw() (result ReviewableRequestResourceCreateWithdraw, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "CreateWithdraw" {
		result = *u.CreateWithdraw
		ok = true
	}

	return
}

// MustCreateAtomicSwapAskExt retrieves the CreateAtomicSwapAskExt value from the union,
// panicing if the value is not set.
func (u ReviewableRequestResource) MustCreateAtomicSwapAskExt() ReviewableRequestResourceCreateAtomicSwapAskExt {
	val, ok := u.GetCreateAtomicSwapAskExt()

	if !ok {
		panic("arm CreateAtomicSwapAskExt is not set")
	}

	return val
}

// GetCreateAtomicSwapAskExt retrieves the CreateAtomicSwapAskExt value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestResource) GetCreateAtomicSwapAskExt() (result ReviewableRequestResourceCreateAtomicSwapAskExt, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "CreateAtomicSwapAskExt" {
		result = *u.CreateAtomicSwapAskExt
		ok = true
	}

	return
}

// MustCreateAtomicSwapBidExt retrieves the CreateAtomicSwapBidExt value from the union,
// panicing if the value is not set.
func (u ReviewableRequestResource) MustCreateAtomicSwapBidExt() ReviewableRequestResourceCreateAtomicSwapBidExt {
	val, ok := u.GetCreateAtomicSwapBidExt()

	if !ok {
		panic("arm CreateAtomicSwapBidExt is not set")
	}

	return val
}

// GetCreateAtomicSwapBidExt retrieves the CreateAtomicSwapBidExt value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestResource) GetCreateAtomicSwapBidExt() (result ReviewableRequestResourceCreateAtomicSwapBidExt, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "CreateAtomicSwapBidExt" {
		result = *u.CreateAtomicSwapBidExt
		ok = true
	}

	return
}

// MustCreatePoll retrieves the CreatePoll value from the union,
// panicing if the value is not set.
func (u ReviewableRequestResource) MustCreatePoll() ReviewableRequestResourceCreatePoll {
	val, ok := u.GetCreatePoll()

	if !ok {
		panic("arm CreatePoll is not set")
	}

	return val
}

// GetCreatePoll retrieves the CreatePoll value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestResource) GetCreatePoll() (result ReviewableRequestResourceCreatePoll, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "CreatePoll" {
		result = *u.CreatePoll
		ok = true
	}

	return
}

// MustManageOffer retrieves the ManageOffer value from the union,
// panicing if the value is not set.
func (u ReviewableRequestResource) MustManageOffer() ReviewableRequestResourceManageOffer {
	val, ok := u.GetManageOffer()

	if !ok {
		panic("arm ManageOffer is not set")
	}

	return val
}

// GetManageOffer retrieves the ManageOffer value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestResource) GetManageOffer() (result ReviewableRequestResourceManageOffer, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "ManageOffer" {
		result = *u.ManageOffer
		ok = true
	}

	return
}

// MustCreatePayment retrieves the CreatePayment value from the union,
// panicing if the value is not set.
func (u ReviewableRequestResource) MustCreatePayment() ReviewableRequestResourceCreatePayment {
	val, ok := u.GetCreatePayment()

	if !ok {
		panic("arm CreatePayment is not set")
	}

	return val
}

// GetCreatePayment retrieves the CreatePayment value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestResource) GetCreatePayment() (result ReviewableRequestResourceCreatePayment, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "CreatePayment" {
		result = *u.CreatePayment
		ok = true
	}

	return
}

// MustPerformRedemption retrieves the PerformRedemption value from the union,
// panicing if the value is not set.
func (u ReviewableRequestResource) MustPerformRedemption() ReviewableRequestResourcePerformRedemption {
	val, ok := u.GetPerformRedemption()

	if !ok {
		panic("arm PerformRedemption is not set")
	}

	return val
}

// GetPerformRedemption retrieves the PerformRedemption value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestResource) GetPerformRedemption() (result ReviewableRequestResourcePerformRedemption, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "PerformRedemption" {
		result = *u.PerformRedemption
		ok = true
	}

	return
}

// MustDataCreation retrieves the DataCreation value from the union,
// panicing if the value is not set.
func (u ReviewableRequestResource) MustDataCreation() ReviewableRequestResourceDataCreation {
	val, ok := u.GetDataCreation()

	if !ok {
		panic("arm DataCreation is not set")
	}

	return val
}

// GetDataCreation retrieves the DataCreation value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestResource) GetDataCreation() (result ReviewableRequestResourceDataCreation, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "DataCreation" {
		result = *u.DataCreation
		ok = true
	}

	return
}

// MustDataUpdate retrieves the DataUpdate value from the union,
// panicing if the value is not set.
func (u ReviewableRequestResource) MustDataUpdate() ReviewableRequestResourceDataUpdate {
	val, ok := u.GetDataUpdate()

	if !ok {
		panic("arm DataUpdate is not set")
	}

	return val
}

// GetDataUpdate retrieves the DataUpdate value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestResource) GetDataUpdate() (result ReviewableRequestResourceDataUpdate, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "DataUpdate" {
		result = *u.DataUpdate
		ok = true
	}

	return
}

// MustDataRemove retrieves the DataRemove value from the union,
// panicing if the value is not set.
func (u ReviewableRequestResource) MustDataRemove() ReviewableRequestResourceDataRemove {
	val, ok := u.GetDataRemove()

	if !ok {
		panic("arm DataRemove is not set")
	}

	return val
}

// GetDataRemove retrieves the DataRemove value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestResource) GetDataRemove() (result ReviewableRequestResourceDataRemove, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "DataRemove" {
		result = *u.DataRemove
		ok = true
	}

	return
}

// MustCreateDeferredPayment retrieves the CreateDeferredPayment value from the union,
// panicing if the value is not set.
func (u ReviewableRequestResource) MustCreateDeferredPayment() ReviewableRequestResourceCreateDeferredPayment {
	val, ok := u.GetCreateDeferredPayment()

	if !ok {
		panic("arm CreateDeferredPayment is not set")
	}

	return val
}

// GetCreateDeferredPayment retrieves the CreateDeferredPayment value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestResource) GetCreateDeferredPayment() (result ReviewableRequestResourceCreateDeferredPayment, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "CreateDeferredPayment" {
		result = *u.CreateDeferredPayment
		ok = true
	}

	return
}

// MustCloseDeferredPayment retrieves the CloseDeferredPayment value from the union,
// panicing if the value is not set.
func (u ReviewableRequestResource) MustCloseDeferredPayment() ReviewableRequestResourceCloseDeferredPayment {
	val, ok := u.GetCloseDeferredPayment()

	if !ok {
		panic("arm CloseDeferredPayment is not set")
	}

	return val
}

// GetCloseDeferredPayment retrieves the CloseDeferredPayment value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestResource) GetCloseDeferredPayment() (result ReviewableRequestResourceCloseDeferredPayment, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "CloseDeferredPayment" {
		result = *u.CloseDeferredPayment
		ok = true
	}

	return
}

// MustExt retrieves the Ext value from the union,
// panicing if the value is not set.
func (u ReviewableRequestResource) MustExt() EmptyExt {
	val, ok := u.GetExt()

	if !ok {
		panic("arm Ext is not set")
	}

	return val
}

// GetExt retrieves the Ext value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ReviewableRequestResource) GetExt() (result EmptyExt, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.RequestType))

	if armName == "Ext" {
		result = *u.Ext
		ok = true
	}

	return
}

// CustomRuleResource is an XDR Struct defines as:
//
//   //: Describes custom rule resource that can be used outside of the Core for flexible access control
//    struct CustomRuleResource {
//        //: Action attributes
//        longstring *action;
//        //: Resource attributes
//        longstring resource;
//
//        EmptyExt ext;
//    };
//
type CustomRuleResource struct {
	Action   *Longstring `json:"action,omitempty"`
	Resource Longstring  `json:"resource,omitempty"`
	Ext      EmptyExt    `json:"ext,omitempty"`
}

// AccountRuleResourceAsset is an XDR NestedStruct defines as:
//
//   struct
//        {
//            AssetCode assetCode;
//            uint64 assetType;
//
//            EmptyExt ext;
//        }
//
type AccountRuleResourceAsset struct {
	AssetCode AssetCode `json:"assetCode,omitempty"`
	AssetType Uint64    `json:"assetType,omitempty"`
	Ext       EmptyExt  `json:"ext,omitempty"`
}

// AccountRuleResourceReviewableRequest is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: Describes properties of some reviewable request types that
//            //: can be used to restrict the usage of reviewable requests
//            ReviewableRequestResource details;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        }
//
type AccountRuleResourceReviewableRequest struct {
	Details ReviewableRequestResource `json:"details,omitempty"`
	Ext     EmptyExt                  `json:"ext,omitempty"`
}

// AccountRuleResourceOffer is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: type of base asset
//            uint64 baseAssetType;
//            //: type of quote asset
//            uint64 quoteAssetType;
//
//            //: code of base asset
//            AssetCode baseAssetCode;
//            //: code of quote asset
//            AssetCode quoteAssetCode;
//
//            bool isBuy;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        }
//
type AccountRuleResourceOffer struct {
	BaseAssetType  Uint64    `json:"baseAssetType,omitempty"`
	QuoteAssetType Uint64    `json:"quoteAssetType,omitempty"`
	BaseAssetCode  AssetCode `json:"baseAssetCode,omitempty"`
	QuoteAssetCode AssetCode `json:"quoteAssetCode,omitempty"`
	IsBuy          bool      `json:"isBuy,omitempty"`
	Ext            EmptyExt  `json:"ext,omitempty"`
}

// AccountRuleResourceSale is an XDR NestedStruct defines as:
//
//   struct
//        {
//            uint64 saleID;
//            uint64 saleType;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        }
//
type AccountRuleResourceSale struct {
	SaleId   Uint64   `json:"saleID,omitempty"`
	SaleType Uint64   `json:"saleType,omitempty"`
	Ext      EmptyExt `json:"ext,omitempty"`
}

// AccountRuleResourceAtomicSwapAsk is an XDR NestedStruct defines as:
//
//   struct
//        {
//            uint64 assetType;
//            AssetCode assetCode;
//
//            EmptyExt ext;
//        }
//
type AccountRuleResourceAtomicSwapAsk struct {
	AssetType Uint64    `json:"assetType,omitempty"`
	AssetCode AssetCode `json:"assetCode,omitempty"`
	Ext       EmptyExt  `json:"ext,omitempty"`
}

// AccountRuleResourceKeyValue is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: prefix of key
//            longstring keyPrefix;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        }
//
type AccountRuleResourceKeyValue struct {
	KeyPrefix Longstring `json:"keyPrefix,omitempty"`
	Ext       EmptyExt   `json:"ext,omitempty"`
}

// AccountRuleResourcePoll is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: ID of the poll
//            uint64 pollID;
//
//            //: permission type of poll
//            uint32 permissionType;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        }
//
type AccountRuleResourcePoll struct {
	PollId         Uint64   `json:"pollID,omitempty"`
	PermissionType Uint32   `json:"permissionType,omitempty"`
	Ext            EmptyExt `json:"ext,omitempty"`
}

// AccountRuleResourceVote is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: ID of the poll
//            uint64 pollID;
//
//            //: permission type of poll
//            uint32 permissionType;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        }
//
type AccountRuleResourceVote struct {
	PollId         Uint64   `json:"pollID,omitempty"`
	PermissionType Uint32   `json:"permissionType,omitempty"`
	Ext            EmptyExt `json:"ext,omitempty"`
}

// AccountRuleResourceInitiateKycRecovery is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: Role id
//            uint64 roleID;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        }
//
type AccountRuleResourceInitiateKycRecovery struct {
	RoleId Uint64   `json:"roleID,omitempty"`
	Ext    EmptyExt `json:"ext,omitempty"`
}

// AccountRuleResourceAccountSpecificRuleExtAccountSpecificRule is an XDR NestedStruct defines as:
//
//   struct
//            {
//                //: Describes properties of some ledger key that
//                //: can be used to restrict the usage of account specific rules
//                LedgerKey ledgerKey;
//
//                //: reserved for future extension
//                EmptyExt ext;
//            }
//
type AccountRuleResourceAccountSpecificRuleExtAccountSpecificRule struct {
	LedgerKey LedgerKey `json:"ledgerKey,omitempty"`
	Ext       EmptyExt  `json:"ext,omitempty"`
}

// AccountRuleResourceAccountSpecificRuleExt is an XDR NestedUnion defines as:
//
//   union switch(LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        case ADD_ACC_SPECIFIC_RULE_RESOURCE:
//            struct
//            {
//                //: Describes properties of some ledger key that
//                //: can be used to restrict the usage of account specific rules
//                LedgerKey ledgerKey;
//
//                //: reserved for future extension
//                EmptyExt ext;
//            } accountSpecificRule;
//        }
//
type AccountRuleResourceAccountSpecificRuleExt struct {
	V                   LedgerVersion                                                 `json:"v,omitempty"`
	AccountSpecificRule *AccountRuleResourceAccountSpecificRuleExtAccountSpecificRule `json:"accountSpecificRule,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u AccountRuleResourceAccountSpecificRuleExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of AccountRuleResourceAccountSpecificRuleExt
func (u AccountRuleResourceAccountSpecificRuleExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	case LedgerVersionAddAccSpecificRuleResource:
		return "AccountSpecificRule", true
	}
	return "-", false
}

// NewAccountRuleResourceAccountSpecificRuleExt creates a new  AccountRuleResourceAccountSpecificRuleExt.
func NewAccountRuleResourceAccountSpecificRuleExt(v LedgerVersion, value interface{}) (result AccountRuleResourceAccountSpecificRuleExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	case LedgerVersionAddAccSpecificRuleResource:
		tv, ok := value.(AccountRuleResourceAccountSpecificRuleExtAccountSpecificRule)
		if !ok {
			err = fmt.Errorf("invalid value, must be AccountRuleResourceAccountSpecificRuleExtAccountSpecificRule")
			return
		}
		result.AccountSpecificRule = &tv
	}
	return
}

// MustAccountSpecificRule retrieves the AccountSpecificRule value from the union,
// panicing if the value is not set.
func (u AccountRuleResourceAccountSpecificRuleExt) MustAccountSpecificRule() AccountRuleResourceAccountSpecificRuleExtAccountSpecificRule {
	val, ok := u.GetAccountSpecificRule()

	if !ok {
		panic("arm AccountSpecificRule is not set")
	}

	return val
}

// GetAccountSpecificRule retrieves the AccountSpecificRule value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u AccountRuleResourceAccountSpecificRuleExt) GetAccountSpecificRule() (result AccountRuleResourceAccountSpecificRuleExtAccountSpecificRule, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.V))

	if armName == "AccountSpecificRule" {
		result = *u.AccountSpecificRule
		ok = true
	}

	return
}

// AccountRuleResourceSwap is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: code of the asset
//            AssetCode assetCode;
//            //: type of asset
//            uint64 assetType;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        }
//
type AccountRuleResourceSwap struct {
	AssetCode AssetCode `json:"assetCode,omitempty"`
	AssetType Uint64    `json:"assetType,omitempty"`
	Ext       EmptyExt  `json:"ext,omitempty"`
}

// AccountRuleResourceData is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: Numeric type of the data
//            uint64 type;
//            //: Reserved for future extension
//            EmptyExt ext;
//        }
//
type AccountRuleResourceData struct {
	Type Uint64   `json:"type,omitempty"`
	Ext  EmptyExt `json:"ext,omitempty"`
}

// AccountRuleResource is an XDR Union defines as:
//
//   //: Describes properties of some entries that can be used to restrict the usage of entries
//    union AccountRuleResource switch (LedgerEntryType type)
//    {
//    case ASSET:
//        //: Describes properties that are equal to managed asset entry fields
//        struct
//        {
//            AssetCode assetCode;
//            uint64 assetType;
//
//            EmptyExt ext;
//        } asset;
//    case REVIEWABLE_REQUEST:
//        //: Describes properties that are equal to managed reviewable request entry fields
//        struct
//        {
//            //: Describes properties of some reviewable request types that
//            //: can be used to restrict the usage of reviewable requests
//            ReviewableRequestResource details;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        } reviewableRequest;
//    case ANY:
//        void;
//    case OFFER_ENTRY:
//        //: Describes properties that are equal to managed offer entry fields and their properties
//        struct
//        {
//            //: type of base asset
//            uint64 baseAssetType;
//            //: type of quote asset
//            uint64 quoteAssetType;
//
//            //: code of base asset
//            AssetCode baseAssetCode;
//            //: code of quote asset
//            AssetCode quoteAssetCode;
//
//            bool isBuy;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        } offer;
//    case SALE:
//        //: Describes properties that are equal to managed offer entry fields
//        struct
//        {
//            uint64 saleID;
//            uint64 saleType;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        } sale;
//    case ATOMIC_SWAP_ASK:
//        struct
//        {
//            uint64 assetType;
//            AssetCode assetCode;
//
//            EmptyExt ext;
//        } atomicSwapAsk;
//    case KEY_VALUE:
//        struct
//        {
//            //: prefix of key
//            longstring keyPrefix;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        } keyValue;
//    case POLL:
//        struct
//        {
//            //: ID of the poll
//            uint64 pollID;
//
//            //: permission type of poll
//            uint32 permissionType;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        } poll;
//    case VOTE:
//        struct
//        {
//            //: ID of the poll
//            uint64 pollID;
//
//            //: permission type of poll
//            uint32 permissionType;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        } vote;
//    case INITIATE_KYC_RECOVERY:
//        struct
//        {
//            //: Role id
//            uint64 roleID;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        } initiateKYCRecovery;
//    case ACCOUNT_SPECIFIC_RULE:
//        union switch(LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        case ADD_ACC_SPECIFIC_RULE_RESOURCE:
//            struct
//            {
//                //: Describes properties of some ledger key that
//                //: can be used to restrict the usage of account specific rules
//                LedgerKey ledgerKey;
//
//                //: reserved for future extension
//                EmptyExt ext;
//            } accountSpecificRule;
//        } accountSpecificRuleExt;
//    case SWAP:
//        struct
//        {
//            //: code of the asset
//            AssetCode assetCode;
//            //: type of asset
//            uint64 assetType;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        } swap;
//    case DATA:
//        struct
//        {
//            //: Numeric type of the data
//            uint64 type;
//            //: Reserved for future extension
//            EmptyExt ext;
//        } data;
//    case CUSTOM:
//        CustomRuleResource custom;
//    default:
//        //: reserved for future extension
//        EmptyExt ext;
//    };
//
type AccountRuleResource struct {
	Type                   LedgerEntryType                            `json:"type,omitempty"`
	Asset                  *AccountRuleResourceAsset                  `json:"asset,omitempty"`
	ReviewableRequest      *AccountRuleResourceReviewableRequest      `json:"reviewableRequest,omitempty"`
	Offer                  *AccountRuleResourceOffer                  `json:"offer,omitempty"`
	Sale                   *AccountRuleResourceSale                   `json:"sale,omitempty"`
	AtomicSwapAsk          *AccountRuleResourceAtomicSwapAsk          `json:"atomicSwapAsk,omitempty"`
	KeyValue               *AccountRuleResourceKeyValue               `json:"keyValue,omitempty"`
	Poll                   *AccountRuleResourcePoll                   `json:"poll,omitempty"`
	Vote                   *AccountRuleResourceVote                   `json:"vote,omitempty"`
	InitiateKycRecovery    *AccountRuleResourceInitiateKycRecovery    `json:"initiateKYCRecovery,omitempty"`
	AccountSpecificRuleExt *AccountRuleResourceAccountSpecificRuleExt `json:"accountSpecificRuleExt,omitempty"`
	Swap                   *AccountRuleResourceSwap                   `json:"swap,omitempty"`
	Data                   *AccountRuleResourceData                   `json:"data,omitempty"`
	Custom                 *CustomRuleResource                        `json:"custom,omitempty"`
	Ext                    *EmptyExt                                  `json:"ext,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u AccountRuleResource) SwitchFieldName() string {
	return "Type"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of AccountRuleResource
func (u AccountRuleResource) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerEntryType(sw) {
	case LedgerEntryTypeAsset:
		return "Asset", true
	case LedgerEntryTypeReviewableRequest:
		return "ReviewableRequest", true
	case LedgerEntryTypeAny:
		return "", true
	case LedgerEntryTypeOfferEntry:
		return "Offer", true
	case LedgerEntryTypeSale:
		return "Sale", true
	case LedgerEntryTypeAtomicSwapAsk:
		return "AtomicSwapAsk", true
	case LedgerEntryTypeKeyValue:
		return "KeyValue", true
	case LedgerEntryTypePoll:
		return "Poll", true
	case LedgerEntryTypeVote:
		return "Vote", true
	case LedgerEntryTypeInitiateKycRecovery:
		return "InitiateKycRecovery", true
	case LedgerEntryTypeAccountSpecificRule:
		return "AccountSpecificRuleExt", true
	case LedgerEntryTypeSwap:
		return "Swap", true
	case LedgerEntryTypeData:
		return "Data", true
	case LedgerEntryTypeCustom:
		return "Custom", true
	default:
		return "Ext", true
	}
}

// NewAccountRuleResource creates a new  AccountRuleResource.
func NewAccountRuleResource(aType LedgerEntryType, value interface{}) (result AccountRuleResource, err error) {
	result.Type = aType
	switch LedgerEntryType(aType) {
	case LedgerEntryTypeAsset:
		tv, ok := value.(AccountRuleResourceAsset)
		if !ok {
			err = fmt.Errorf("invalid value, must be AccountRuleResourceAsset")
			return
		}
		result.Asset = &tv
	case LedgerEntryTypeReviewableRequest:
		tv, ok := value.(AccountRuleResourceReviewableRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be AccountRuleResourceReviewableRequest")
			return
		}
		result.ReviewableRequest = &tv
	case LedgerEntryTypeAny:
		// void
	case LedgerEntryTypeOfferEntry:
		tv, ok := value.(AccountRuleResourceOffer)
		if !ok {
			err = fmt.Errorf("invalid value, must be AccountRuleResourceOffer")
			return
		}
		result.Offer = &tv
	case LedgerEntryTypeSale:
		tv, ok := value.(AccountRuleResourceSale)
		if !ok {
			err = fmt.Errorf("invalid value, must be AccountRuleResourceSale")
			return
		}
		result.Sale = &tv
	case LedgerEntryTypeAtomicSwapAsk:
		tv, ok := value.(AccountRuleResourceAtomicSwapAsk)
		if !ok {
			err = fmt.Errorf("invalid value, must be AccountRuleResourceAtomicSwapAsk")
			return
		}
		result.AtomicSwapAsk = &tv
	case LedgerEntryTypeKeyValue:
		tv, ok := value.(AccountRuleResourceKeyValue)
		if !ok {
			err = fmt.Errorf("invalid value, must be AccountRuleResourceKeyValue")
			return
		}
		result.KeyValue = &tv
	case LedgerEntryTypePoll:
		tv, ok := value.(AccountRuleResourcePoll)
		if !ok {
			err = fmt.Errorf("invalid value, must be AccountRuleResourcePoll")
			return
		}
		result.Poll = &tv
	case LedgerEntryTypeVote:
		tv, ok := value.(AccountRuleResourceVote)
		if !ok {
			err = fmt.Errorf("invalid value, must be AccountRuleResourceVote")
			return
		}
		result.Vote = &tv
	case LedgerEntryTypeInitiateKycRecovery:
		tv, ok := value.(AccountRuleResourceInitiateKycRecovery)
		if !ok {
			err = fmt.Errorf("invalid value, must be AccountRuleResourceInitiateKycRecovery")
			return
		}
		result.InitiateKycRecovery = &tv
	case LedgerEntryTypeAccountSpecificRule:
		tv, ok := value.(AccountRuleResourceAccountSpecificRuleExt)
		if !ok {
			err = fmt.Errorf("invalid value, must be AccountRuleResourceAccountSpecificRuleExt")
			return
		}
		result.AccountSpecificRuleExt = &tv
	case LedgerEntryTypeSwap:
		tv, ok := value.(AccountRuleResourceSwap)
		if !ok {
			err = fmt.Errorf("invalid value, must be AccountRuleResourceSwap")
			return
		}
		result.Swap = &tv
	case LedgerEntryTypeData:
		tv, ok := value.(AccountRuleResourceData)
		if !ok {
			err = fmt.Errorf("invalid value, must be AccountRuleResourceData")
			return
		}
		result.Data = &tv
	case LedgerEntryTypeCustom:
		tv, ok := value.(CustomRuleResource)
		if !ok {
			err = fmt.Errorf("invalid value, must be CustomRuleResource")
			return
		}
		result.Custom = &tv
	default:
		tv, ok := value.(EmptyExt)
		if !ok {
			err = fmt.Errorf("invalid value, must be EmptyExt")
			return
		}
		result.Ext = &tv
	}
	return
}

// MustAsset retrieves the Asset value from the union,
// panicing if the value is not set.
func (u AccountRuleResource) MustAsset() AccountRuleResourceAsset {
	val, ok := u.GetAsset()

	if !ok {
		panic("arm Asset is not set")
	}

	return val
}

// GetAsset retrieves the Asset value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u AccountRuleResource) GetAsset() (result AccountRuleResourceAsset, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Asset" {
		result = *u.Asset
		ok = true
	}

	return
}

// MustReviewableRequest retrieves the ReviewableRequest value from the union,
// panicing if the value is not set.
func (u AccountRuleResource) MustReviewableRequest() AccountRuleResourceReviewableRequest {
	val, ok := u.GetReviewableRequest()

	if !ok {
		panic("arm ReviewableRequest is not set")
	}

	return val
}

// GetReviewableRequest retrieves the ReviewableRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u AccountRuleResource) GetReviewableRequest() (result AccountRuleResourceReviewableRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ReviewableRequest" {
		result = *u.ReviewableRequest
		ok = true
	}

	return
}

// MustOffer retrieves the Offer value from the union,
// panicing if the value is not set.
func (u AccountRuleResource) MustOffer() AccountRuleResourceOffer {
	val, ok := u.GetOffer()

	if !ok {
		panic("arm Offer is not set")
	}

	return val
}

// GetOffer retrieves the Offer value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u AccountRuleResource) GetOffer() (result AccountRuleResourceOffer, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Offer" {
		result = *u.Offer
		ok = true
	}

	return
}

// MustSale retrieves the Sale value from the union,
// panicing if the value is not set.
func (u AccountRuleResource) MustSale() AccountRuleResourceSale {
	val, ok := u.GetSale()

	if !ok {
		panic("arm Sale is not set")
	}

	return val
}

// GetSale retrieves the Sale value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u AccountRuleResource) GetSale() (result AccountRuleResourceSale, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Sale" {
		result = *u.Sale
		ok = true
	}

	return
}

// MustAtomicSwapAsk retrieves the AtomicSwapAsk value from the union,
// panicing if the value is not set.
func (u AccountRuleResource) MustAtomicSwapAsk() AccountRuleResourceAtomicSwapAsk {
	val, ok := u.GetAtomicSwapAsk()

	if !ok {
		panic("arm AtomicSwapAsk is not set")
	}

	return val
}

// GetAtomicSwapAsk retrieves the AtomicSwapAsk value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u AccountRuleResource) GetAtomicSwapAsk() (result AccountRuleResourceAtomicSwapAsk, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "AtomicSwapAsk" {
		result = *u.AtomicSwapAsk
		ok = true
	}

	return
}

// MustKeyValue retrieves the KeyValue value from the union,
// panicing if the value is not set.
func (u AccountRuleResource) MustKeyValue() AccountRuleResourceKeyValue {
	val, ok := u.GetKeyValue()

	if !ok {
		panic("arm KeyValue is not set")
	}

	return val
}

// GetKeyValue retrieves the KeyValue value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u AccountRuleResource) GetKeyValue() (result AccountRuleResourceKeyValue, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "KeyValue" {
		result = *u.KeyValue
		ok = true
	}

	return
}

// MustPoll retrieves the Poll value from the union,
// panicing if the value is not set.
func (u AccountRuleResource) MustPoll() AccountRuleResourcePoll {
	val, ok := u.GetPoll()

	if !ok {
		panic("arm Poll is not set")
	}

	return val
}

// GetPoll retrieves the Poll value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u AccountRuleResource) GetPoll() (result AccountRuleResourcePoll, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Poll" {
		result = *u.Poll
		ok = true
	}

	return
}

// MustVote retrieves the Vote value from the union,
// panicing if the value is not set.
func (u AccountRuleResource) MustVote() AccountRuleResourceVote {
	val, ok := u.GetVote()

	if !ok {
		panic("arm Vote is not set")
	}

	return val
}

// GetVote retrieves the Vote value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u AccountRuleResource) GetVote() (result AccountRuleResourceVote, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Vote" {
		result = *u.Vote
		ok = true
	}

	return
}

// MustInitiateKycRecovery retrieves the InitiateKycRecovery value from the union,
// panicing if the value is not set.
func (u AccountRuleResource) MustInitiateKycRecovery() AccountRuleResourceInitiateKycRecovery {
	val, ok := u.GetInitiateKycRecovery()

	if !ok {
		panic("arm InitiateKycRecovery is not set")
	}

	return val
}

// GetInitiateKycRecovery retrieves the InitiateKycRecovery value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u AccountRuleResource) GetInitiateKycRecovery() (result AccountRuleResourceInitiateKycRecovery, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "InitiateKycRecovery" {
		result = *u.InitiateKycRecovery
		ok = true
	}

	return
}

// MustAccountSpecificRuleExt retrieves the AccountSpecificRuleExt value from the union,
// panicing if the value is not set.
func (u AccountRuleResource) MustAccountSpecificRuleExt() AccountRuleResourceAccountSpecificRuleExt {
	val, ok := u.GetAccountSpecificRuleExt()

	if !ok {
		panic("arm AccountSpecificRuleExt is not set")
	}

	return val
}

// GetAccountSpecificRuleExt retrieves the AccountSpecificRuleExt value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u AccountRuleResource) GetAccountSpecificRuleExt() (result AccountRuleResourceAccountSpecificRuleExt, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "AccountSpecificRuleExt" {
		result = *u.AccountSpecificRuleExt
		ok = true
	}

	return
}

// MustSwap retrieves the Swap value from the union,
// panicing if the value is not set.
func (u AccountRuleResource) MustSwap() AccountRuleResourceSwap {
	val, ok := u.GetSwap()

	if !ok {
		panic("arm Swap is not set")
	}

	return val
}

// GetSwap retrieves the Swap value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u AccountRuleResource) GetSwap() (result AccountRuleResourceSwap, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Swap" {
		result = *u.Swap
		ok = true
	}

	return
}

// MustData retrieves the Data value from the union,
// panicing if the value is not set.
func (u AccountRuleResource) MustData() AccountRuleResourceData {
	val, ok := u.GetData()

	if !ok {
		panic("arm Data is not set")
	}

	return val
}

// GetData retrieves the Data value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u AccountRuleResource) GetData() (result AccountRuleResourceData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Data" {
		result = *u.Data
		ok = true
	}

	return
}

// MustCustom retrieves the Custom value from the union,
// panicing if the value is not set.
func (u AccountRuleResource) MustCustom() CustomRuleResource {
	val, ok := u.GetCustom()

	if !ok {
		panic("arm Custom is not set")
	}

	return val
}

// GetCustom retrieves the Custom value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u AccountRuleResource) GetCustom() (result CustomRuleResource, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Custom" {
		result = *u.Custom
		ok = true
	}

	return
}

// MustExt retrieves the Ext value from the union,
// panicing if the value is not set.
func (u AccountRuleResource) MustExt() EmptyExt {
	val, ok := u.GetExt()

	if !ok {
		panic("arm Ext is not set")
	}

	return val
}

// GetExt retrieves the Ext value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u AccountRuleResource) GetExt() (result EmptyExt, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Ext" {
		result = *u.Ext
		ok = true
	}

	return
}

// AccountRuleAction is an XDR Enum defines as:
//
//   //: Actions that can be applied to account rule resource
//    enum AccountRuleAction
//    {
//        ANY = 1,
//        CREATE = 2,
//        CREATE_FOR_OTHER = 3,
//        CREATE_WITH_TASKS = 4,
//        MANAGE = 5,
//        SEND = 6,
//        WITHDRAW = 7,
//        RECEIVE_ISSUANCE = 8,
//        RECEIVE_PAYMENT = 9,
//        RECEIVE_ATOMIC_SWAP = 10,
//        PARTICIPATE = 11,
//        BIND = 12,
//        UPDATE_MAX_ISSUANCE = 13,
//        CHECK = 14,
//        CANCEL = 15,
//        CLOSE = 16,
//        REMOVE = 17,
//        UPDATE_END_TIME = 18,
//        CREATE_FOR_OTHER_WITH_TASKS = 19,
//        REMOVE_FOR_OTHER = 20,
//        EXCHANGE = 21,
//        RECEIVE_REDEMPTION = 22,
//        UPDATE = 23,
//        UPDATE_FOR_OTHER = 24,
//        CUSTOM = 25
//    };
//
type AccountRuleAction int32

const (
	AccountRuleActionAny                     AccountRuleAction = 1
	AccountRuleActionCreate                  AccountRuleAction = 2
	AccountRuleActionCreateForOther          AccountRuleAction = 3
	AccountRuleActionCreateWithTasks         AccountRuleAction = 4
	AccountRuleActionManage                  AccountRuleAction = 5
	AccountRuleActionSend                    AccountRuleAction = 6
	AccountRuleActionWithdraw                AccountRuleAction = 7
	AccountRuleActionReceiveIssuance         AccountRuleAction = 8
	AccountRuleActionReceivePayment          AccountRuleAction = 9
	AccountRuleActionReceiveAtomicSwap       AccountRuleAction = 10
	AccountRuleActionParticipate             AccountRuleAction = 11
	AccountRuleActionBind                    AccountRuleAction = 12
	AccountRuleActionUpdateMaxIssuance       AccountRuleAction = 13
	AccountRuleActionCheck                   AccountRuleAction = 14
	AccountRuleActionCancel                  AccountRuleAction = 15
	AccountRuleActionClose                   AccountRuleAction = 16
	AccountRuleActionRemove                  AccountRuleAction = 17
	AccountRuleActionUpdateEndTime           AccountRuleAction = 18
	AccountRuleActionCreateForOtherWithTasks AccountRuleAction = 19
	AccountRuleActionRemoveForOther          AccountRuleAction = 20
	AccountRuleActionExchange                AccountRuleAction = 21
	AccountRuleActionReceiveRedemption       AccountRuleAction = 22
	AccountRuleActionUpdate                  AccountRuleAction = 23
	AccountRuleActionUpdateForOther          AccountRuleAction = 24
	AccountRuleActionCustom                  AccountRuleAction = 25
)

var AccountRuleActionAll = []AccountRuleAction{
	AccountRuleActionAny,
	AccountRuleActionCreate,
	AccountRuleActionCreateForOther,
	AccountRuleActionCreateWithTasks,
	AccountRuleActionManage,
	AccountRuleActionSend,
	AccountRuleActionWithdraw,
	AccountRuleActionReceiveIssuance,
	AccountRuleActionReceivePayment,
	AccountRuleActionReceiveAtomicSwap,
	AccountRuleActionParticipate,
	AccountRuleActionBind,
	AccountRuleActionUpdateMaxIssuance,
	AccountRuleActionCheck,
	AccountRuleActionCancel,
	AccountRuleActionClose,
	AccountRuleActionRemove,
	AccountRuleActionUpdateEndTime,
	AccountRuleActionCreateForOtherWithTasks,
	AccountRuleActionRemoveForOther,
	AccountRuleActionExchange,
	AccountRuleActionReceiveRedemption,
	AccountRuleActionUpdate,
	AccountRuleActionUpdateForOther,
	AccountRuleActionCustom,
}

var accountRuleActionMap = map[int32]string{
	1:  "AccountRuleActionAny",
	2:  "AccountRuleActionCreate",
	3:  "AccountRuleActionCreateForOther",
	4:  "AccountRuleActionCreateWithTasks",
	5:  "AccountRuleActionManage",
	6:  "AccountRuleActionSend",
	7:  "AccountRuleActionWithdraw",
	8:  "AccountRuleActionReceiveIssuance",
	9:  "AccountRuleActionReceivePayment",
	10: "AccountRuleActionReceiveAtomicSwap",
	11: "AccountRuleActionParticipate",
	12: "AccountRuleActionBind",
	13: "AccountRuleActionUpdateMaxIssuance",
	14: "AccountRuleActionCheck",
	15: "AccountRuleActionCancel",
	16: "AccountRuleActionClose",
	17: "AccountRuleActionRemove",
	18: "AccountRuleActionUpdateEndTime",
	19: "AccountRuleActionCreateForOtherWithTasks",
	20: "AccountRuleActionRemoveForOther",
	21: "AccountRuleActionExchange",
	22: "AccountRuleActionReceiveRedemption",
	23: "AccountRuleActionUpdate",
	24: "AccountRuleActionUpdateForOther",
	25: "AccountRuleActionCustom",
}

var accountRuleActionShortMap = map[int32]string{
	1:  "any",
	2:  "create",
	3:  "create_for_other",
	4:  "create_with_tasks",
	5:  "manage",
	6:  "send",
	7:  "withdraw",
	8:  "receive_issuance",
	9:  "receive_payment",
	10: "receive_atomic_swap",
	11: "participate",
	12: "bind",
	13: "update_max_issuance",
	14: "check",
	15: "cancel",
	16: "close",
	17: "remove",
	18: "update_end_time",
	19: "create_for_other_with_tasks",
	20: "remove_for_other",
	21: "exchange",
	22: "receive_redemption",
	23: "update",
	24: "update_for_other",
	25: "custom",
}

var accountRuleActionRevMap = map[string]int32{
	"AccountRuleActionAny":                     1,
	"AccountRuleActionCreate":                  2,
	"AccountRuleActionCreateForOther":          3,
	"AccountRuleActionCreateWithTasks":         4,
	"AccountRuleActionManage":                  5,
	"AccountRuleActionSend":                    6,
	"AccountRuleActionWithdraw":                7,
	"AccountRuleActionReceiveIssuance":         8,
	"AccountRuleActionReceivePayment":          9,
	"AccountRuleActionReceiveAtomicSwap":       10,
	"AccountRuleActionParticipate":             11,
	"AccountRuleActionBind":                    12,
	"AccountRuleActionUpdateMaxIssuance":       13,
	"AccountRuleActionCheck":                   14,
	"AccountRuleActionCancel":                  15,
	"AccountRuleActionClose":                   16,
	"AccountRuleActionRemove":                  17,
	"AccountRuleActionUpdateEndTime":           18,
	"AccountRuleActionCreateForOtherWithTasks": 19,
	"AccountRuleActionRemoveForOther":          20,
	"AccountRuleActionExchange":                21,
	"AccountRuleActionReceiveRedemption":       22,
	"AccountRuleActionUpdate":                  23,
	"AccountRuleActionUpdateForOther":          24,
	"AccountRuleActionCustom":                  25,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for AccountRuleAction
func (e AccountRuleAction) ValidEnum(v int32) bool {
	_, ok := accountRuleActionMap[v]
	return ok
}
func (e AccountRuleAction) isFlag() bool {
	for i := len(AccountRuleActionAll) - 1; i >= 0; i-- {
		expected := AccountRuleAction(2) << uint64(len(AccountRuleActionAll)-1) >> uint64(len(AccountRuleActionAll)-i)
		if expected != AccountRuleActionAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e AccountRuleAction) String() string {
	name, _ := accountRuleActionMap[int32(e)]
	return name
}

func (e AccountRuleAction) ShortString() string {
	name, _ := accountRuleActionShortMap[int32(e)]
	return name
}

func (e AccountRuleAction) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range AccountRuleActionAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *AccountRuleAction) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = AccountRuleAction(t.Value)
	return nil
}

// SignerRuleResourceReviewableRequest is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: Describes properties of some reviewable request types that
//            //: can be used to restrict the usage of reviewable requests
//            ReviewableRequestResource details;
//
//            //: Bit mask of tasks that is allowed to add to reviewable request pending tasks
//            uint64 tasksToAdd;
//            //: Bit mask of tasks that is allowed to remove from reviewable request pending tasks
//            uint64 tasksToRemove;
//            //: Bit mask of tasks that is allowed to use as reviewable request pending tasks
//            uint64 allTasks;
//
//            EmptyExt ext;
//        }
//
type SignerRuleResourceReviewableRequest struct {
	Details       ReviewableRequestResource `json:"details,omitempty"`
	TasksToAdd    Uint64                    `json:"tasksToAdd,omitempty"`
	TasksToRemove Uint64                    `json:"tasksToRemove,omitempty"`
	AllTasks      Uint64                    `json:"allTasks,omitempty"`
	Ext           EmptyExt                  `json:"ext,omitempty"`
}

// SignerRuleResourceAsset is an XDR NestedStruct defines as:
//
//   struct
//        {
//            AssetCode assetCode;
//            uint64 assetType;
//
//            EmptyExt ext;
//        }
//
type SignerRuleResourceAsset struct {
	AssetCode AssetCode `json:"assetCode,omitempty"`
	AssetType Uint64    `json:"assetType,omitempty"`
	Ext       EmptyExt  `json:"ext,omitempty"`
}

// SignerRuleResourceOffer is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: type of base asset
//            uint64 baseAssetType;
//            //: type of quote asset
//            uint64 quoteAssetType;
//
//            //: code of base asset
//            AssetCode baseAssetCode;
//            //: code of quote asset
//            AssetCode quoteAssetCode;
//
//            bool isBuy;
//
//            EmptyExt ext;
//        }
//
type SignerRuleResourceOffer struct {
	BaseAssetType  Uint64    `json:"baseAssetType,omitempty"`
	QuoteAssetType Uint64    `json:"quoteAssetType,omitempty"`
	BaseAssetCode  AssetCode `json:"baseAssetCode,omitempty"`
	QuoteAssetCode AssetCode `json:"quoteAssetCode,omitempty"`
	IsBuy          bool      `json:"isBuy,omitempty"`
	Ext            EmptyExt  `json:"ext,omitempty"`
}

// SignerRuleResourceSale is an XDR NestedStruct defines as:
//
//   struct
//        {
//            uint64 saleID;
//            uint64 saleType;
//
//            EmptyExt ext;
//        }
//
type SignerRuleResourceSale struct {
	SaleId   Uint64   `json:"saleID,omitempty"`
	SaleType Uint64   `json:"saleType,omitempty"`
	Ext      EmptyExt `json:"ext,omitempty"`
}

// SignerRuleResourceAtomicSwapAsk is an XDR NestedStruct defines as:
//
//   struct
//        {
//            uint64 assetType;
//            AssetCode assetCode;
//
//            EmptyExt ext;
//        }
//
type SignerRuleResourceAtomicSwapAsk struct {
	AssetType Uint64    `json:"assetType,omitempty"`
	AssetCode AssetCode `json:"assetCode,omitempty"`
	Ext       EmptyExt  `json:"ext,omitempty"`
}

// SignerRuleResourceSignerRule is an XDR NestedStruct defines as:
//
//   struct
//        {
//            bool isDefault;
//
//            EmptyExt ext;
//        }
//
type SignerRuleResourceSignerRule struct {
	IsDefault bool     `json:"isDefault,omitempty"`
	Ext       EmptyExt `json:"ext,omitempty"`
}

// SignerRuleResourceSignerRole is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: For signer role creating resource will be triggered if `roleID` equals `0`
//            uint64 roleID;
//
//            EmptyExt ext;
//        }
//
type SignerRuleResourceSignerRole struct {
	RoleId Uint64   `json:"roleID,omitempty"`
	Ext    EmptyExt `json:"ext,omitempty"`
}

// SignerRuleResourceSigner is an XDR NestedStruct defines as:
//
//   struct
//        {
//            uint64 roleID;
//
//            EmptyExt ext;
//        }
//
type SignerRuleResourceSigner struct {
	RoleId Uint64   `json:"roleID,omitempty"`
	Ext    EmptyExt `json:"ext,omitempty"`
}

// SignerRuleResourceKeyValue is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: prefix of key
//            longstring keyPrefix;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        }
//
type SignerRuleResourceKeyValue struct {
	KeyPrefix Longstring `json:"keyPrefix,omitempty"`
	Ext       EmptyExt   `json:"ext,omitempty"`
}

// SignerRuleResourcePoll is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: ID of the poll
//            uint64 pollID;
//
//            //: permission type of poll
//            uint32 permissionType;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        }
//
type SignerRuleResourcePoll struct {
	PollId         Uint64   `json:"pollID,omitempty"`
	PermissionType Uint32   `json:"permissionType,omitempty"`
	Ext            EmptyExt `json:"ext,omitempty"`
}

// SignerRuleResourceVote is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: ID of the poll
//            uint64 pollID;
//
//            //: permission type of poll
//            uint32 permissionType;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        }
//
type SignerRuleResourceVote struct {
	PollId         Uint64   `json:"pollID,omitempty"`
	PermissionType Uint32   `json:"permissionType,omitempty"`
	Ext            EmptyExt `json:"ext,omitempty"`
}

// SignerRuleResourceInitiateKycRecovery is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: Role id
//            uint64 roleID;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        }
//
type SignerRuleResourceInitiateKycRecovery struct {
	RoleId Uint64   `json:"roleID,omitempty"`
	Ext    EmptyExt `json:"ext,omitempty"`
}

// SignerRuleResourceAccountSpecificRuleExtAccountSpecificRule is an XDR NestedStruct defines as:
//
//   struct
//            {
//                //: Describes properties of some ledger key that
//                //: can be used to restrict the usage of account specific rules
//                LedgerKey ledgerKey;
//
//                //: reserved for future extension
//                EmptyExt ext;
//            }
//
type SignerRuleResourceAccountSpecificRuleExtAccountSpecificRule struct {
	LedgerKey LedgerKey `json:"ledgerKey,omitempty"`
	Ext       EmptyExt  `json:"ext,omitempty"`
}

// SignerRuleResourceAccountSpecificRuleExt is an XDR NestedUnion defines as:
//
//   union switch(LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        case ADD_ACC_SPECIFIC_RULE_RESOURCE:
//            struct
//            {
//                //: Describes properties of some ledger key that
//                //: can be used to restrict the usage of account specific rules
//                LedgerKey ledgerKey;
//
//                //: reserved for future extension
//                EmptyExt ext;
//            } accountSpecificRule;
//        }
//
type SignerRuleResourceAccountSpecificRuleExt struct {
	V                   LedgerVersion                                                `json:"v,omitempty"`
	AccountSpecificRule *SignerRuleResourceAccountSpecificRuleExtAccountSpecificRule `json:"accountSpecificRule,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u SignerRuleResourceAccountSpecificRuleExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of SignerRuleResourceAccountSpecificRuleExt
func (u SignerRuleResourceAccountSpecificRuleExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	case LedgerVersionAddAccSpecificRuleResource:
		return "AccountSpecificRule", true
	}
	return "-", false
}

// NewSignerRuleResourceAccountSpecificRuleExt creates a new  SignerRuleResourceAccountSpecificRuleExt.
func NewSignerRuleResourceAccountSpecificRuleExt(v LedgerVersion, value interface{}) (result SignerRuleResourceAccountSpecificRuleExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	case LedgerVersionAddAccSpecificRuleResource:
		tv, ok := value.(SignerRuleResourceAccountSpecificRuleExtAccountSpecificRule)
		if !ok {
			err = fmt.Errorf("invalid value, must be SignerRuleResourceAccountSpecificRuleExtAccountSpecificRule")
			return
		}
		result.AccountSpecificRule = &tv
	}
	return
}

// MustAccountSpecificRule retrieves the AccountSpecificRule value from the union,
// panicing if the value is not set.
func (u SignerRuleResourceAccountSpecificRuleExt) MustAccountSpecificRule() SignerRuleResourceAccountSpecificRuleExtAccountSpecificRule {
	val, ok := u.GetAccountSpecificRule()

	if !ok {
		panic("arm AccountSpecificRule is not set")
	}

	return val
}

// GetAccountSpecificRule retrieves the AccountSpecificRule value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u SignerRuleResourceAccountSpecificRuleExt) GetAccountSpecificRule() (result SignerRuleResourceAccountSpecificRuleExtAccountSpecificRule, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.V))

	if armName == "AccountSpecificRule" {
		result = *u.AccountSpecificRule
		ok = true
	}

	return
}

// SignerRuleResourceSwap is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: code of the asset
//            AssetCode assetCode;
//            //: type of the asset
//            uint64 assetType;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        }
//
type SignerRuleResourceSwap struct {
	AssetCode AssetCode `json:"assetCode,omitempty"`
	AssetType Uint64    `json:"assetType,omitempty"`
	Ext       EmptyExt  `json:"ext,omitempty"`
}

// SignerRuleResourceData is an XDR NestedStruct defines as:
//
//   struct
//        {
//            //: Numeric type of the data
//            uint64 type;
//            //: Reserved for future extension
//            EmptyExt ext;
//        }
//
type SignerRuleResourceData struct {
	Type Uint64   `json:"type,omitempty"`
	Ext  EmptyExt `json:"ext,omitempty"`
}

// SignerRuleResource is an XDR Union defines as:
//
//   //: Describes properties of some entries that can be used to restrict the usage of entries
//    union SignerRuleResource switch (LedgerEntryType type)
//    {
//    case REVIEWABLE_REQUEST:
//        //: Describes properties that are equal to managed reviewable request entry fields
//        struct
//        {
//            //: Describes properties of some reviewable request types that
//            //: can be used to restrict the usage of reviewable requests
//            ReviewableRequestResource details;
//
//            //: Bit mask of tasks that is allowed to add to reviewable request pending tasks
//            uint64 tasksToAdd;
//            //: Bit mask of tasks that is allowed to remove from reviewable request pending tasks
//            uint64 tasksToRemove;
//            //: Bit mask of tasks that is allowed to use as reviewable request pending tasks
//            uint64 allTasks;
//
//            EmptyExt ext;
//        } reviewableRequest;
//    case ASSET:
//        //: Describes properties that are equal to managed asset entry fields
//        struct
//        {
//            AssetCode assetCode;
//            uint64 assetType;
//
//            EmptyExt ext;
//        } asset;
//    case ANY:
//        void;
//    case OFFER_ENTRY:
//        //: Describes properties that are equal to managed offer entry fields and their properties
//        struct
//        {
//            //: type of base asset
//            uint64 baseAssetType;
//            //: type of quote asset
//            uint64 quoteAssetType;
//
//            //: code of base asset
//            AssetCode baseAssetCode;
//            //: code of quote asset
//            AssetCode quoteAssetCode;
//
//            bool isBuy;
//
//            EmptyExt ext;
//        } offer;
//    case SALE:
//        //: Describes properties that are equal to managed offer entry fields
//        struct
//        {
//            uint64 saleID;
//            uint64 saleType;
//
//            EmptyExt ext;
//        } sale;
//    case ATOMIC_SWAP_ASK:
//        struct
//        {
//            uint64 assetType;
//            AssetCode assetCode;
//
//            EmptyExt ext;
//        } atomicSwapAsk;
//    case SIGNER_RULE:
//        //: Describes properties that are equal to managed signer rule entry fields
//        struct
//        {
//            bool isDefault;
//
//            EmptyExt ext;
//        } signerRule;
//    case SIGNER_ROLE:
//        //: Describes properties that are equal to managed signer role entry fields
//        struct
//        {
//            //: For signer role creating resource will be triggered if `roleID` equals `0`
//            uint64 roleID;
//
//            EmptyExt ext;
//        } signerRole;
//    case SIGNER:
//        //: Describes properties that are equal to managed signer entry fields
//        struct
//        {
//            uint64 roleID;
//
//            EmptyExt ext;
//        } signer;
//    case KEY_VALUE:
//        //: Describes properties that are equal to managed key value entry fields
//        struct
//        {
//            //: prefix of key
//            longstring keyPrefix;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        } keyValue;
//    case POLL:
//        struct
//        {
//            //: ID of the poll
//            uint64 pollID;
//
//            //: permission type of poll
//            uint32 permissionType;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        } poll;
//    case VOTE:
//        struct
//        {
//            //: ID of the poll
//            uint64 pollID;
//
//            //: permission type of poll
//            uint32 permissionType;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        } vote;
//    case INITIATE_KYC_RECOVERY:
//        struct
//        {
//            //: Role id
//            uint64 roleID;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        } initiateKYCRecovery;
//    case ACCOUNT_SPECIFIC_RULE:
//        //: reserved for future extension
//        union switch(LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        case ADD_ACC_SPECIFIC_RULE_RESOURCE:
//            struct
//            {
//                //: Describes properties of some ledger key that
//                //: can be used to restrict the usage of account specific rules
//                LedgerKey ledgerKey;
//
//                //: reserved for future extension
//                EmptyExt ext;
//            } accountSpecificRule;
//        } accountSpecificRuleExt;
//    case SWAP:
//        struct
//        {
//            //: code of the asset
//            AssetCode assetCode;
//            //: type of the asset
//            uint64 assetType;
//
//            //: reserved for future extension
//            EmptyExt ext;
//        } swap;
//    case DATA:
//        struct
//        {
//            //: Numeric type of the data
//            uint64 type;
//            //: Reserved for future extension
//            EmptyExt ext;
//        } data;
//    case CUSTOM:
//        CustomRuleResource custom;
//    default:
//        //: reserved for future extension
//        EmptyExt ext;
//    };
//
type SignerRuleResource struct {
	Type                   LedgerEntryType                           `json:"type,omitempty"`
	ReviewableRequest      *SignerRuleResourceReviewableRequest      `json:"reviewableRequest,omitempty"`
	Asset                  *SignerRuleResourceAsset                  `json:"asset,omitempty"`
	Offer                  *SignerRuleResourceOffer                  `json:"offer,omitempty"`
	Sale                   *SignerRuleResourceSale                   `json:"sale,omitempty"`
	AtomicSwapAsk          *SignerRuleResourceAtomicSwapAsk          `json:"atomicSwapAsk,omitempty"`
	SignerRule             *SignerRuleResourceSignerRule             `json:"signerRule,omitempty"`
	SignerRole             *SignerRuleResourceSignerRole             `json:"signerRole,omitempty"`
	Signer                 *SignerRuleResourceSigner                 `json:"signer,omitempty"`
	KeyValue               *SignerRuleResourceKeyValue               `json:"keyValue,omitempty"`
	Poll                   *SignerRuleResourcePoll                   `json:"poll,omitempty"`
	Vote                   *SignerRuleResourceVote                   `json:"vote,omitempty"`
	InitiateKycRecovery    *SignerRuleResourceInitiateKycRecovery    `json:"initiateKYCRecovery,omitempty"`
	AccountSpecificRuleExt *SignerRuleResourceAccountSpecificRuleExt `json:"accountSpecificRuleExt,omitempty"`
	Swap                   *SignerRuleResourceSwap                   `json:"swap,omitempty"`
	Data                   *SignerRuleResourceData                   `json:"data,omitempty"`
	Custom                 *CustomRuleResource                       `json:"custom,omitempty"`
	Ext                    *EmptyExt                                 `json:"ext,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u SignerRuleResource) SwitchFieldName() string {
	return "Type"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of SignerRuleResource
func (u SignerRuleResource) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerEntryType(sw) {
	case LedgerEntryTypeReviewableRequest:
		return "ReviewableRequest", true
	case LedgerEntryTypeAsset:
		return "Asset", true
	case LedgerEntryTypeAny:
		return "", true
	case LedgerEntryTypeOfferEntry:
		return "Offer", true
	case LedgerEntryTypeSale:
		return "Sale", true
	case LedgerEntryTypeAtomicSwapAsk:
		return "AtomicSwapAsk", true
	case LedgerEntryTypeSignerRule:
		return "SignerRule", true
	case LedgerEntryTypeSignerRole:
		return "SignerRole", true
	case LedgerEntryTypeSigner:
		return "Signer", true
	case LedgerEntryTypeKeyValue:
		return "KeyValue", true
	case LedgerEntryTypePoll:
		return "Poll", true
	case LedgerEntryTypeVote:
		return "Vote", true
	case LedgerEntryTypeInitiateKycRecovery:
		return "InitiateKycRecovery", true
	case LedgerEntryTypeAccountSpecificRule:
		return "AccountSpecificRuleExt", true
	case LedgerEntryTypeSwap:
		return "Swap", true
	case LedgerEntryTypeData:
		return "Data", true
	case LedgerEntryTypeCustom:
		return "Custom", true
	default:
		return "Ext", true
	}
}

// NewSignerRuleResource creates a new  SignerRuleResource.
func NewSignerRuleResource(aType LedgerEntryType, value interface{}) (result SignerRuleResource, err error) {
	result.Type = aType
	switch LedgerEntryType(aType) {
	case LedgerEntryTypeReviewableRequest:
		tv, ok := value.(SignerRuleResourceReviewableRequest)
		if !ok {
			err = fmt.Errorf("invalid value, must be SignerRuleResourceReviewableRequest")
			return
		}
		result.ReviewableRequest = &tv
	case LedgerEntryTypeAsset:
		tv, ok := value.(SignerRuleResourceAsset)
		if !ok {
			err = fmt.Errorf("invalid value, must be SignerRuleResourceAsset")
			return
		}
		result.Asset = &tv
	case LedgerEntryTypeAny:
		// void
	case LedgerEntryTypeOfferEntry:
		tv, ok := value.(SignerRuleResourceOffer)
		if !ok {
			err = fmt.Errorf("invalid value, must be SignerRuleResourceOffer")
			return
		}
		result.Offer = &tv
	case LedgerEntryTypeSale:
		tv, ok := value.(SignerRuleResourceSale)
		if !ok {
			err = fmt.Errorf("invalid value, must be SignerRuleResourceSale")
			return
		}
		result.Sale = &tv
	case LedgerEntryTypeAtomicSwapAsk:
		tv, ok := value.(SignerRuleResourceAtomicSwapAsk)
		if !ok {
			err = fmt.Errorf("invalid value, must be SignerRuleResourceAtomicSwapAsk")
			return
		}
		result.AtomicSwapAsk = &tv
	case LedgerEntryTypeSignerRule:
		tv, ok := value.(SignerRuleResourceSignerRule)
		if !ok {
			err = fmt.Errorf("invalid value, must be SignerRuleResourceSignerRule")
			return
		}
		result.SignerRule = &tv
	case LedgerEntryTypeSignerRole:
		tv, ok := value.(SignerRuleResourceSignerRole)
		if !ok {
			err = fmt.Errorf("invalid value, must be SignerRuleResourceSignerRole")
			return
		}
		result.SignerRole = &tv
	case LedgerEntryTypeSigner:
		tv, ok := value.(SignerRuleResourceSigner)
		if !ok {
			err = fmt.Errorf("invalid value, must be SignerRuleResourceSigner")
			return
		}
		result.Signer = &tv
	case LedgerEntryTypeKeyValue:
		tv, ok := value.(SignerRuleResourceKeyValue)
		if !ok {
			err = fmt.Errorf("invalid value, must be SignerRuleResourceKeyValue")
			return
		}
		result.KeyValue = &tv
	case LedgerEntryTypePoll:
		tv, ok := value.(SignerRuleResourcePoll)
		if !ok {
			err = fmt.Errorf("invalid value, must be SignerRuleResourcePoll")
			return
		}
		result.Poll = &tv
	case LedgerEntryTypeVote:
		tv, ok := value.(SignerRuleResourceVote)
		if !ok {
			err = fmt.Errorf("invalid value, must be SignerRuleResourceVote")
			return
		}
		result.Vote = &tv
	case LedgerEntryTypeInitiateKycRecovery:
		tv, ok := value.(SignerRuleResourceInitiateKycRecovery)
		if !ok {
			err = fmt.Errorf("invalid value, must be SignerRuleResourceInitiateKycRecovery")
			return
		}
		result.InitiateKycRecovery = &tv
	case LedgerEntryTypeAccountSpecificRule:
		tv, ok := value.(SignerRuleResourceAccountSpecificRuleExt)
		if !ok {
			err = fmt.Errorf("invalid value, must be SignerRuleResourceAccountSpecificRuleExt")
			return
		}
		result.AccountSpecificRuleExt = &tv
	case LedgerEntryTypeSwap:
		tv, ok := value.(SignerRuleResourceSwap)
		if !ok {
			err = fmt.Errorf("invalid value, must be SignerRuleResourceSwap")
			return
		}
		result.Swap = &tv
	case LedgerEntryTypeData:
		tv, ok := value.(SignerRuleResourceData)
		if !ok {
			err = fmt.Errorf("invalid value, must be SignerRuleResourceData")
			return
		}
		result.Data = &tv
	case LedgerEntryTypeCustom:
		tv, ok := value.(CustomRuleResource)
		if !ok {
			err = fmt.Errorf("invalid value, must be CustomRuleResource")
			return
		}
		result.Custom = &tv
	default:
		tv, ok := value.(EmptyExt)
		if !ok {
			err = fmt.Errorf("invalid value, must be EmptyExt")
			return
		}
		result.Ext = &tv
	}
	return
}

// MustReviewableRequest retrieves the ReviewableRequest value from the union,
// panicing if the value is not set.
func (u SignerRuleResource) MustReviewableRequest() SignerRuleResourceReviewableRequest {
	val, ok := u.GetReviewableRequest()

	if !ok {
		panic("arm ReviewableRequest is not set")
	}

	return val
}

// GetReviewableRequest retrieves the ReviewableRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u SignerRuleResource) GetReviewableRequest() (result SignerRuleResourceReviewableRequest, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ReviewableRequest" {
		result = *u.ReviewableRequest
		ok = true
	}

	return
}

// MustAsset retrieves the Asset value from the union,
// panicing if the value is not set.
func (u SignerRuleResource) MustAsset() SignerRuleResourceAsset {
	val, ok := u.GetAsset()

	if !ok {
		panic("arm Asset is not set")
	}

	return val
}

// GetAsset retrieves the Asset value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u SignerRuleResource) GetAsset() (result SignerRuleResourceAsset, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Asset" {
		result = *u.Asset
		ok = true
	}

	return
}

// MustOffer retrieves the Offer value from the union,
// panicing if the value is not set.
func (u SignerRuleResource) MustOffer() SignerRuleResourceOffer {
	val, ok := u.GetOffer()

	if !ok {
		panic("arm Offer is not set")
	}

	return val
}

// GetOffer retrieves the Offer value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u SignerRuleResource) GetOffer() (result SignerRuleResourceOffer, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Offer" {
		result = *u.Offer
		ok = true
	}

	return
}

// MustSale retrieves the Sale value from the union,
// panicing if the value is not set.
func (u SignerRuleResource) MustSale() SignerRuleResourceSale {
	val, ok := u.GetSale()

	if !ok {
		panic("arm Sale is not set")
	}

	return val
}

// GetSale retrieves the Sale value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u SignerRuleResource) GetSale() (result SignerRuleResourceSale, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Sale" {
		result = *u.Sale
		ok = true
	}

	return
}

// MustAtomicSwapAsk retrieves the AtomicSwapAsk value from the union,
// panicing if the value is not set.
func (u SignerRuleResource) MustAtomicSwapAsk() SignerRuleResourceAtomicSwapAsk {
	val, ok := u.GetAtomicSwapAsk()

	if !ok {
		panic("arm AtomicSwapAsk is not set")
	}

	return val
}

// GetAtomicSwapAsk retrieves the AtomicSwapAsk value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u SignerRuleResource) GetAtomicSwapAsk() (result SignerRuleResourceAtomicSwapAsk, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "AtomicSwapAsk" {
		result = *u.AtomicSwapAsk
		ok = true
	}

	return
}

// MustSignerRule retrieves the SignerRule value from the union,
// panicing if the value is not set.
func (u SignerRuleResource) MustSignerRule() SignerRuleResourceSignerRule {
	val, ok := u.GetSignerRule()

	if !ok {
		panic("arm SignerRule is not set")
	}

	return val
}

// GetSignerRule retrieves the SignerRule value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u SignerRuleResource) GetSignerRule() (result SignerRuleResourceSignerRule, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "SignerRule" {
		result = *u.SignerRule
		ok = true
	}

	return
}

// MustSignerRole retrieves the SignerRole value from the union,
// panicing if the value is not set.
func (u SignerRuleResource) MustSignerRole() SignerRuleResourceSignerRole {
	val, ok := u.GetSignerRole()

	if !ok {
		panic("arm SignerRole is not set")
	}

	return val
}

// GetSignerRole retrieves the SignerRole value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u SignerRuleResource) GetSignerRole() (result SignerRuleResourceSignerRole, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "SignerRole" {
		result = *u.SignerRole
		ok = true
	}

	return
}

// MustSigner retrieves the Signer value from the union,
// panicing if the value is not set.
func (u SignerRuleResource) MustSigner() SignerRuleResourceSigner {
	val, ok := u.GetSigner()

	if !ok {
		panic("arm Signer is not set")
	}

	return val
}

// GetSigner retrieves the Signer value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u SignerRuleResource) GetSigner() (result SignerRuleResourceSigner, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Signer" {
		result = *u.Signer
		ok = true
	}

	return
}

// MustKeyValue retrieves the KeyValue value from the union,
// panicing if the value is not set.
func (u SignerRuleResource) MustKeyValue() SignerRuleResourceKeyValue {
	val, ok := u.GetKeyValue()

	if !ok {
		panic("arm KeyValue is not set")
	}

	return val
}

// GetKeyValue retrieves the KeyValue value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u SignerRuleResource) GetKeyValue() (result SignerRuleResourceKeyValue, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "KeyValue" {
		result = *u.KeyValue
		ok = true
	}

	return
}

// MustPoll retrieves the Poll value from the union,
// panicing if the value is not set.
func (u SignerRuleResource) MustPoll() SignerRuleResourcePoll {
	val, ok := u.GetPoll()

	if !ok {
		panic("arm Poll is not set")
	}

	return val
}

// GetPoll retrieves the Poll value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u SignerRuleResource) GetPoll() (result SignerRuleResourcePoll, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Poll" {
		result = *u.Poll
		ok = true
	}

	return
}

// MustVote retrieves the Vote value from the union,
// panicing if the value is not set.
func (u SignerRuleResource) MustVote() SignerRuleResourceVote {
	val, ok := u.GetVote()

	if !ok {
		panic("arm Vote is not set")
	}

	return val
}

// GetVote retrieves the Vote value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u SignerRuleResource) GetVote() (result SignerRuleResourceVote, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Vote" {
		result = *u.Vote
		ok = true
	}

	return
}

// MustInitiateKycRecovery retrieves the InitiateKycRecovery value from the union,
// panicing if the value is not set.
func (u SignerRuleResource) MustInitiateKycRecovery() SignerRuleResourceInitiateKycRecovery {
	val, ok := u.GetInitiateKycRecovery()

	if !ok {
		panic("arm InitiateKycRecovery is not set")
	}

	return val
}

// GetInitiateKycRecovery retrieves the InitiateKycRecovery value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u SignerRuleResource) GetInitiateKycRecovery() (result SignerRuleResourceInitiateKycRecovery, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "InitiateKycRecovery" {
		result = *u.InitiateKycRecovery
		ok = true
	}

	return
}

// MustAccountSpecificRuleExt retrieves the AccountSpecificRuleExt value from the union,
// panicing if the value is not set.
func (u SignerRuleResource) MustAccountSpecificRuleExt() SignerRuleResourceAccountSpecificRuleExt {
	val, ok := u.GetAccountSpecificRuleExt()

	if !ok {
		panic("arm AccountSpecificRuleExt is not set")
	}

	return val
}

// GetAccountSpecificRuleExt retrieves the AccountSpecificRuleExt value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u SignerRuleResource) GetAccountSpecificRuleExt() (result SignerRuleResourceAccountSpecificRuleExt, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "AccountSpecificRuleExt" {
		result = *u.AccountSpecificRuleExt
		ok = true
	}

	return
}

// MustSwap retrieves the Swap value from the union,
// panicing if the value is not set.
func (u SignerRuleResource) MustSwap() SignerRuleResourceSwap {
	val, ok := u.GetSwap()

	if !ok {
		panic("arm Swap is not set")
	}

	return val
}

// GetSwap retrieves the Swap value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u SignerRuleResource) GetSwap() (result SignerRuleResourceSwap, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Swap" {
		result = *u.Swap
		ok = true
	}

	return
}

// MustData retrieves the Data value from the union,
// panicing if the value is not set.
func (u SignerRuleResource) MustData() SignerRuleResourceData {
	val, ok := u.GetData()

	if !ok {
		panic("arm Data is not set")
	}

	return val
}

// GetData retrieves the Data value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u SignerRuleResource) GetData() (result SignerRuleResourceData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Data" {
		result = *u.Data
		ok = true
	}

	return
}

// MustCustom retrieves the Custom value from the union,
// panicing if the value is not set.
func (u SignerRuleResource) MustCustom() CustomRuleResource {
	val, ok := u.GetCustom()

	if !ok {
		panic("arm Custom is not set")
	}

	return val
}

// GetCustom retrieves the Custom value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u SignerRuleResource) GetCustom() (result CustomRuleResource, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Custom" {
		result = *u.Custom
		ok = true
	}

	return
}

// MustExt retrieves the Ext value from the union,
// panicing if the value is not set.
func (u SignerRuleResource) MustExt() EmptyExt {
	val, ok := u.GetExt()

	if !ok {
		panic("arm Ext is not set")
	}

	return val
}

// GetExt retrieves the Ext value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u SignerRuleResource) GetExt() (result EmptyExt, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Ext" {
		result = *u.Ext
		ok = true
	}

	return
}

// SignerRuleAction is an XDR Enum defines as:
//
//   //: Actions that can be applied to a signer rule resource
//    enum SignerRuleAction
//    {
//        ANY = 1,
//        CREATE = 2,
//        CREATE_FOR_OTHER = 3,
//        UPDATE = 4,
//        MANAGE = 5,
//        SEND = 6,
//        REMOVE = 7,
//        CANCEL = 8,
//        REVIEW = 9,
//        RECEIVE_ATOMIC_SWAP = 10,
//        PARTICIPATE = 11,
//        BIND = 12,
//        UPDATE_MAX_ISSUANCE = 13,
//        CHECK = 14,
//        CLOSE = 15,
//        UPDATE_END_TIME = 16,
//        CREATE_WITH_TASKS = 17,
//        CREATE_FOR_OTHER_WITH_TASKS = 18,
//        REMOVE_FOR_OTHER = 19,
//        EXCHANGE = 20,
//        UPDATE_FOR_OTHER = 21,
//        CUSTOM = 22
//    };
//
type SignerRuleAction int32

const (
	SignerRuleActionAny                     SignerRuleAction = 1
	SignerRuleActionCreate                  SignerRuleAction = 2
	SignerRuleActionCreateForOther          SignerRuleAction = 3
	SignerRuleActionUpdate                  SignerRuleAction = 4
	SignerRuleActionManage                  SignerRuleAction = 5
	SignerRuleActionSend                    SignerRuleAction = 6
	SignerRuleActionRemove                  SignerRuleAction = 7
	SignerRuleActionCancel                  SignerRuleAction = 8
	SignerRuleActionReview                  SignerRuleAction = 9
	SignerRuleActionReceiveAtomicSwap       SignerRuleAction = 10
	SignerRuleActionParticipate             SignerRuleAction = 11
	SignerRuleActionBind                    SignerRuleAction = 12
	SignerRuleActionUpdateMaxIssuance       SignerRuleAction = 13
	SignerRuleActionCheck                   SignerRuleAction = 14
	SignerRuleActionClose                   SignerRuleAction = 15
	SignerRuleActionUpdateEndTime           SignerRuleAction = 16
	SignerRuleActionCreateWithTasks         SignerRuleAction = 17
	SignerRuleActionCreateForOtherWithTasks SignerRuleAction = 18
	SignerRuleActionRemoveForOther          SignerRuleAction = 19
	SignerRuleActionExchange                SignerRuleAction = 20
	SignerRuleActionUpdateForOther          SignerRuleAction = 21
	SignerRuleActionCustom                  SignerRuleAction = 22
)

var SignerRuleActionAll = []SignerRuleAction{
	SignerRuleActionAny,
	SignerRuleActionCreate,
	SignerRuleActionCreateForOther,
	SignerRuleActionUpdate,
	SignerRuleActionManage,
	SignerRuleActionSend,
	SignerRuleActionRemove,
	SignerRuleActionCancel,
	SignerRuleActionReview,
	SignerRuleActionReceiveAtomicSwap,
	SignerRuleActionParticipate,
	SignerRuleActionBind,
	SignerRuleActionUpdateMaxIssuance,
	SignerRuleActionCheck,
	SignerRuleActionClose,
	SignerRuleActionUpdateEndTime,
	SignerRuleActionCreateWithTasks,
	SignerRuleActionCreateForOtherWithTasks,
	SignerRuleActionRemoveForOther,
	SignerRuleActionExchange,
	SignerRuleActionUpdateForOther,
	SignerRuleActionCustom,
}

var signerRuleActionMap = map[int32]string{
	1:  "SignerRuleActionAny",
	2:  "SignerRuleActionCreate",
	3:  "SignerRuleActionCreateForOther",
	4:  "SignerRuleActionUpdate",
	5:  "SignerRuleActionManage",
	6:  "SignerRuleActionSend",
	7:  "SignerRuleActionRemove",
	8:  "SignerRuleActionCancel",
	9:  "SignerRuleActionReview",
	10: "SignerRuleActionReceiveAtomicSwap",
	11: "SignerRuleActionParticipate",
	12: "SignerRuleActionBind",
	13: "SignerRuleActionUpdateMaxIssuance",
	14: "SignerRuleActionCheck",
	15: "SignerRuleActionClose",
	16: "SignerRuleActionUpdateEndTime",
	17: "SignerRuleActionCreateWithTasks",
	18: "SignerRuleActionCreateForOtherWithTasks",
	19: "SignerRuleActionRemoveForOther",
	20: "SignerRuleActionExchange",
	21: "SignerRuleActionUpdateForOther",
	22: "SignerRuleActionCustom",
}

var signerRuleActionShortMap = map[int32]string{
	1:  "any",
	2:  "create",
	3:  "create_for_other",
	4:  "update",
	5:  "manage",
	6:  "send",
	7:  "remove",
	8:  "cancel",
	9:  "review",
	10: "receive_atomic_swap",
	11: "participate",
	12: "bind",
	13: "update_max_issuance",
	14: "check",
	15: "close",
	16: "update_end_time",
	17: "create_with_tasks",
	18: "create_for_other_with_tasks",
	19: "remove_for_other",
	20: "exchange",
	21: "update_for_other",
	22: "custom",
}

var signerRuleActionRevMap = map[string]int32{
	"SignerRuleActionAny":                     1,
	"SignerRuleActionCreate":                  2,
	"SignerRuleActionCreateForOther":          3,
	"SignerRuleActionUpdate":                  4,
	"SignerRuleActionManage":                  5,
	"SignerRuleActionSend":                    6,
	"SignerRuleActionRemove":                  7,
	"SignerRuleActionCancel":                  8,
	"SignerRuleActionReview":                  9,
	"SignerRuleActionReceiveAtomicSwap":       10,
	"SignerRuleActionParticipate":             11,
	"SignerRuleActionBind":                    12,
	"SignerRuleActionUpdateMaxIssuance":       13,
	"SignerRuleActionCheck":                   14,
	"SignerRuleActionClose":                   15,
	"SignerRuleActionUpdateEndTime":           16,
	"SignerRuleActionCreateWithTasks":         17,
	"SignerRuleActionCreateForOtherWithTasks": 18,
	"SignerRuleActionRemoveForOther":          19,
	"SignerRuleActionExchange":                20,
	"SignerRuleActionUpdateForOther":          21,
	"SignerRuleActionCustom":                  22,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for SignerRuleAction
func (e SignerRuleAction) ValidEnum(v int32) bool {
	_, ok := signerRuleActionMap[v]
	return ok
}
func (e SignerRuleAction) isFlag() bool {
	for i := len(SignerRuleActionAll) - 1; i >= 0; i-- {
		expected := SignerRuleAction(2) << uint64(len(SignerRuleActionAll)-1) >> uint64(len(SignerRuleActionAll)-i)
		if expected != SignerRuleActionAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e SignerRuleAction) String() string {
	name, _ := signerRuleActionMap[int32(e)]
	return name
}

func (e SignerRuleAction) ShortString() string {
	name, _ := signerRuleActionShortMap[int32(e)]
	return name
}

func (e SignerRuleAction) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range SignerRuleActionAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *SignerRuleAction) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = SignerRuleAction(t.Value)
	return nil
}

// AmlAlertRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type AmlAlertRequestExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u AmlAlertRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of AmlAlertRequestExt
func (u AmlAlertRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewAmlAlertRequestExt creates a new  AmlAlertRequestExt.
func NewAmlAlertRequestExt(v LedgerVersion, value interface{}) (result AmlAlertRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// AmlAlertRequest is an XDR Struct defines as:
//
//   //: Body of a reviewable AMLAlertRequest, contains parameters regarding AML alert
//    struct AMLAlertRequest {
//        //: Target balance to void tokens from
//        BalanceID balanceID;
//
//        //: Amount to void
//        uint64 amount;
//
//        //: Arbitrary stringified json object that can be used to attach data to be reviewed by an admin
//        longstring creatorDetails; // details set by requester
//
//        //: Reserved for future use
//    	union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type AmlAlertRequest struct {
	BalanceId      BalanceId          `json:"balanceID,omitempty"`
	Amount         Uint64             `json:"amount,omitempty"`
	CreatorDetails Longstring         `json:"creatorDetails,omitempty"`
	Ext            AmlAlertRequestExt `json:"ext,omitempty"`
}

// AssetCreationRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type AssetCreationRequestExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u AssetCreationRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of AssetCreationRequestExt
func (u AssetCreationRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewAssetCreationRequestExt creates a new  AssetCreationRequestExt.
func NewAssetCreationRequestExt(v LedgerVersion, value interface{}) (result AssetCreationRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// AssetCreationRequest is an XDR Struct defines as:
//
//   //: AssetCreationRequest is used to create an asset with provided parameters
//    struct AssetCreationRequest {
//        //: Code of an asset to create
//        AssetCode code;
//        //: Public key of a signer that will perform pre issuance
//        AccountID preissuedAssetSigner;
//        //: Maximal amount to be issued
//        uint64 maxIssuanceAmount;
//        //: Amount to pre issue on asset creation
//        uint64 initialPreissuedAmount;
//        //: Bit mask of policies to create an asset with
//        uint32 policies;
//        //: Arbitrary stringified JSON object that can be used to attach data to be reviewed by an admin
//        longstring creatorDetails; // details set by requester
//         //: Type of asset, selected arbitrarily. Can be used to restrict the usage of an asset
//        uint64 type;
//        //: Used to keep track of rejected requests updates (`SequenceNumber` increases after each rejected AssetCreationRequest update)
//        uint32 sequenceNumber;
//        //: Number of significant decimal places
//        uint32 trailingDigitsCount;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type AssetCreationRequest struct {
	Code                   AssetCode               `json:"code,omitempty"`
	PreissuedAssetSigner   AccountId               `json:"preissuedAssetSigner,omitempty"`
	MaxIssuanceAmount      Uint64                  `json:"maxIssuanceAmount,omitempty"`
	InitialPreissuedAmount Uint64                  `json:"initialPreissuedAmount,omitempty"`
	Policies               Uint32                  `json:"policies,omitempty"`
	CreatorDetails         Longstring              `json:"creatorDetails,omitempty"`
	Type                   Uint64                  `json:"type,omitempty"`
	SequenceNumber         Uint32                  `json:"sequenceNumber,omitempty"`
	TrailingDigitsCount    Uint32                  `json:"trailingDigitsCount,omitempty"`
	Ext                    AssetCreationRequestExt `json:"ext,omitempty"`
}

// AssetUpdateRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type AssetUpdateRequestExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u AssetUpdateRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of AssetUpdateRequestExt
func (u AssetUpdateRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewAssetUpdateRequestExt creates a new  AssetUpdateRequestExt.
func NewAssetUpdateRequestExt(v LedgerVersion, value interface{}) (result AssetUpdateRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// AssetUpdateRequest is an XDR Struct defines as:
//
//   //: AssetUpdateRequest is used to update an asset with provided parameters
//    struct AssetUpdateRequest {
//        //: Code of an asset to update
//        AssetCode code;
//        //: Arbitrary stringified JSON object that can be used to attach data to be reviewed by an admin
//        longstring creatorDetails; // details set by requester
//        //: New policies to set will override the existing ones
//        uint32 policies;
//        //: Used to keep track of rejected requests update (`SequenceNumber` increases after each rejected AssetUpdateRequest update).
//        uint32 sequenceNumber;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type AssetUpdateRequest struct {
	Code           AssetCode             `json:"code,omitempty"`
	CreatorDetails Longstring            `json:"creatorDetails,omitempty"`
	Policies       Uint32                `json:"policies,omitempty"`
	SequenceNumber Uint32                `json:"sequenceNumber,omitempty"`
	Ext            AssetUpdateRequestExt `json:"ext,omitempty"`
}

// AssetChangePreissuedSignerExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type AssetChangePreissuedSignerExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u AssetChangePreissuedSignerExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of AssetChangePreissuedSignerExt
func (u AssetChangePreissuedSignerExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewAssetChangePreissuedSignerExt creates a new  AssetChangePreissuedSignerExt.
func NewAssetChangePreissuedSignerExt(v LedgerVersion, value interface{}) (result AssetChangePreissuedSignerExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// AssetChangePreissuedSigner is an XDR Struct defines as:
//
//   //: AssetChangePreissuedSigner is used to update a pre issued asset signer
//    struct AssetChangePreissuedSigner
//    {
//        //: code of an asset to update
//        AssetCode code;
//        //: Public key of a signer that will be the new pre issuer
//        AccountID accountID;
//        //: Content signature of a pre issuer signer
//        //: Content equals hash of `<code>:<accountID>`
//        DecoratedSignature signature;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type AssetChangePreissuedSigner struct {
	Code      AssetCode                     `json:"code,omitempty"`
	AccountId AccountId                     `json:"accountID,omitempty"`
	Signature DecoratedSignature            `json:"signature,omitempty"`
	Ext       AssetChangePreissuedSignerExt `json:"ext,omitempty"`
}

// CreateAtomicSwapAskRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateAtomicSwapAskRequestExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateAtomicSwapAskRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateAtomicSwapAskRequestExt
func (u CreateAtomicSwapAskRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateAtomicSwapAskRequestExt creates a new  CreateAtomicSwapAskRequestExt.
func NewCreateAtomicSwapAskRequestExt(v LedgerVersion, value interface{}) (result CreateAtomicSwapAskRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateAtomicSwapAskRequest is an XDR Struct defines as:
//
//   //: CreateAtomicSwapAskRequest is used to create atomic swap ask entry with passed fields
//    struct CreateAtomicSwapAskRequest
//    {
//        //: ID of balance with base asset
//        BalanceID baseBalance;
//        //: Amount to be sold through atomic swaps
//        uint64 amount;
//        //: Arbitrary stringified json object provided by a requester
//        longstring creatorDetails; // details set by requester
//        //: Array of assets with price which can be used to ask base asset
//        AtomicSwapAskQuoteAsset quoteAssets<>;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type CreateAtomicSwapAskRequest struct {
	BaseBalance    BalanceId                     `json:"baseBalance,omitempty"`
	Amount         Uint64                        `json:"amount,omitempty"`
	CreatorDetails Longstring                    `json:"creatorDetails,omitempty"`
	QuoteAssets    []AtomicSwapAskQuoteAsset     `json:"quoteAssets,omitempty"`
	Ext            CreateAtomicSwapAskRequestExt `json:"ext,omitempty"`
}

// CreateAtomicSwapBidRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateAtomicSwapBidRequestExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateAtomicSwapBidRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateAtomicSwapBidRequestExt
func (u CreateAtomicSwapBidRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateAtomicSwapBidRequestExt creates a new  CreateAtomicSwapBidRequestExt.
func NewCreateAtomicSwapBidRequestExt(v LedgerVersion, value interface{}) (result CreateAtomicSwapBidRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateAtomicSwapBidRequest is an XDR Struct defines as:
//
//   //: CreateAtomicSwapBidRequest is used to create atomic swap bid request with passed fields
//    struct CreateAtomicSwapBidRequest
//    {
//        //: ID of existing bid
//        uint64 askID;
//        //: Amount in base asset to ask
//        uint64 baseAmount;
//        //: Code of asset which will be used to ask base asset
//        AssetCode quoteAsset;
//        //: Arbitrary stringified json object provided by a requester
//        longstring creatorDetails; // details set by requester
//
//        //: reserved for the future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type CreateAtomicSwapBidRequest struct {
	AskId          Uint64                        `json:"askID,omitempty"`
	BaseAmount     Uint64                        `json:"baseAmount,omitempty"`
	QuoteAsset     AssetCode                     `json:"quoteAsset,omitempty"`
	CreatorDetails Longstring                    `json:"creatorDetails,omitempty"`
	Ext            CreateAtomicSwapBidRequestExt `json:"ext,omitempty"`
}

// ChangeRoleRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ChangeRoleRequestExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ChangeRoleRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ChangeRoleRequestExt
func (u ChangeRoleRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewChangeRoleRequestExt creates a new  ChangeRoleRequestExt.
func NewChangeRoleRequestExt(v LedgerVersion, value interface{}) (result ChangeRoleRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ChangeRoleRequest is an XDR Struct defines as:
//
//   struct ChangeRoleRequest
//    {
//    	AccountID destinationAccount;
//    	uint64 accountRoleToSet;
//
//    	// Sequence number increases when request is rejected
//    	uint32 sequenceNumber;
//
//        longstring creatorDetails; // details set by requester
//
//        // Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ChangeRoleRequest struct {
	DestinationAccount AccountId            `json:"destinationAccount,omitempty"`
	AccountRoleToSet   Uint64               `json:"accountRoleToSet,omitempty"`
	SequenceNumber     Uint32               `json:"sequenceNumber,omitempty"`
	CreatorDetails     Longstring           `json:"creatorDetails,omitempty"`
	Ext                ChangeRoleRequestExt `json:"ext,omitempty"`
}

// CloseDeferredPaymentDestinationType is an XDR Enum defines as:
//
//   //: Defines the type of destination of the payment
//    enum CloseDeferredPaymentDestinationType {
//        ACCOUNT = 0,
//        BALANCE = 1
//    };
//
type CloseDeferredPaymentDestinationType int32

const (
	CloseDeferredPaymentDestinationTypeAccount CloseDeferredPaymentDestinationType = 0
	CloseDeferredPaymentDestinationTypeBalance CloseDeferredPaymentDestinationType = 1
)

var CloseDeferredPaymentDestinationTypeAll = []CloseDeferredPaymentDestinationType{
	CloseDeferredPaymentDestinationTypeAccount,
	CloseDeferredPaymentDestinationTypeBalance,
}

var closeDeferredPaymentDestinationTypeMap = map[int32]string{
	0: "CloseDeferredPaymentDestinationTypeAccount",
	1: "CloseDeferredPaymentDestinationTypeBalance",
}

var closeDeferredPaymentDestinationTypeShortMap = map[int32]string{
	0: "account",
	1: "balance",
}

var closeDeferredPaymentDestinationTypeRevMap = map[string]int32{
	"CloseDeferredPaymentDestinationTypeAccount": 0,
	"CloseDeferredPaymentDestinationTypeBalance": 1,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CloseDeferredPaymentDestinationType
func (e CloseDeferredPaymentDestinationType) ValidEnum(v int32) bool {
	_, ok := closeDeferredPaymentDestinationTypeMap[v]
	return ok
}
func (e CloseDeferredPaymentDestinationType) isFlag() bool {
	for i := len(CloseDeferredPaymentDestinationTypeAll) - 1; i >= 0; i-- {
		expected := CloseDeferredPaymentDestinationType(2) << uint64(len(CloseDeferredPaymentDestinationTypeAll)-1) >> uint64(len(CloseDeferredPaymentDestinationTypeAll)-i)
		if expected != CloseDeferredPaymentDestinationTypeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CloseDeferredPaymentDestinationType) String() string {
	name, _ := closeDeferredPaymentDestinationTypeMap[int32(e)]
	return name
}

func (e CloseDeferredPaymentDestinationType) ShortString() string {
	name, _ := closeDeferredPaymentDestinationTypeShortMap[int32(e)]
	return name
}

func (e CloseDeferredPaymentDestinationType) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CloseDeferredPaymentDestinationTypeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CloseDeferredPaymentDestinationType) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CloseDeferredPaymentDestinationType(t.Value)
	return nil
}

// CloseDeferredPaymentRequestDestination is an XDR NestedUnion defines as:
//
//   union switch (CloseDeferredPaymentDestinationType type) {
//            case ACCOUNT:
//                AccountID accountID;
//            case BALANCE:
//                BalanceID balanceID;
//        }
//
type CloseDeferredPaymentRequestDestination struct {
	Type      CloseDeferredPaymentDestinationType `json:"type,omitempty"`
	AccountId *AccountId                          `json:"accountID,omitempty"`
	BalanceId *BalanceId                          `json:"balanceID,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CloseDeferredPaymentRequestDestination) SwitchFieldName() string {
	return "Type"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CloseDeferredPaymentRequestDestination
func (u CloseDeferredPaymentRequestDestination) ArmForSwitch(sw int32) (string, bool) {
	switch CloseDeferredPaymentDestinationType(sw) {
	case CloseDeferredPaymentDestinationTypeAccount:
		return "AccountId", true
	case CloseDeferredPaymentDestinationTypeBalance:
		return "BalanceId", true
	}
	return "-", false
}

// NewCloseDeferredPaymentRequestDestination creates a new  CloseDeferredPaymentRequestDestination.
func NewCloseDeferredPaymentRequestDestination(aType CloseDeferredPaymentDestinationType, value interface{}) (result CloseDeferredPaymentRequestDestination, err error) {
	result.Type = aType
	switch CloseDeferredPaymentDestinationType(aType) {
	case CloseDeferredPaymentDestinationTypeAccount:
		tv, ok := value.(AccountId)
		if !ok {
			err = fmt.Errorf("invalid value, must be AccountId")
			return
		}
		result.AccountId = &tv
	case CloseDeferredPaymentDestinationTypeBalance:
		tv, ok := value.(BalanceId)
		if !ok {
			err = fmt.Errorf("invalid value, must be BalanceId")
			return
		}
		result.BalanceId = &tv
	}
	return
}

// MustAccountId retrieves the AccountId value from the union,
// panicing if the value is not set.
func (u CloseDeferredPaymentRequestDestination) MustAccountId() AccountId {
	val, ok := u.GetAccountId()

	if !ok {
		panic("arm AccountId is not set")
	}

	return val
}

// GetAccountId retrieves the AccountId value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CloseDeferredPaymentRequestDestination) GetAccountId() (result AccountId, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "AccountId" {
		result = *u.AccountId
		ok = true
	}

	return
}

// MustBalanceId retrieves the BalanceId value from the union,
// panicing if the value is not set.
func (u CloseDeferredPaymentRequestDestination) MustBalanceId() BalanceId {
	val, ok := u.GetBalanceId()

	if !ok {
		panic("arm BalanceId is not set")
	}

	return val
}

// GetBalanceId retrieves the BalanceId value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CloseDeferredPaymentRequestDestination) GetBalanceId() (result BalanceId, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "BalanceId" {
		result = *u.BalanceId
		ok = true
	}

	return
}

// CloseDeferredPaymentRequest is an XDR Struct defines as:
//
//   struct CloseDeferredPaymentRequest {
//        uint64 deferredPaymentID;
//
//        //: `destination` defines the type of instance that receives the payment based on given PaymentDestinationType
//        union switch (CloseDeferredPaymentDestinationType type) {
//            case ACCOUNT:
//                AccountID accountID;
//            case BALANCE:
//                BalanceID balanceID;
//        } destination;
//
//        //: Arbitrary stringified json object that can be used to attach data to be reviewed by an admin
//        longstring creatorDetails; // details set by requester
//
//        uint64 amount;
//
//        uint32 sequenceNumber;
//
//        EmptyExt ext;
//    };
//
type CloseDeferredPaymentRequest struct {
	DeferredPaymentId Uint64                                 `json:"deferredPaymentID,omitempty"`
	Destination       CloseDeferredPaymentRequestDestination `json:"destination,omitempty"`
	CreatorDetails    Longstring                             `json:"creatorDetails,omitempty"`
	Amount            Uint64                                 `json:"amount,omitempty"`
	SequenceNumber    Uint32                                 `json:"sequenceNumber,omitempty"`
	Ext               EmptyExt                               `json:"ext,omitempty"`
}

// ContractRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type ContractRequestExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ContractRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ContractRequestExt
func (u ContractRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewContractRequestExt creates a new  ContractRequestExt.
func NewContractRequestExt(v LedgerVersion, value interface{}) (result ContractRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// ContractRequest is an XDR Struct defines as:
//
//   struct ContractRequest
//    {
//        AccountID customer;
//        AccountID escrow;
//        longstring creatorDetails; // details set by requester
//
//        uint64 startTime;
//        uint64 endTime;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type ContractRequest struct {
	Customer       AccountId          `json:"customer,omitempty"`
	Escrow         AccountId          `json:"escrow,omitempty"`
	CreatorDetails Longstring         `json:"creatorDetails,omitempty"`
	StartTime      Uint64             `json:"startTime,omitempty"`
	EndTime        Uint64             `json:"endTime,omitempty"`
	Ext            ContractRequestExt `json:"ext,omitempty"`
}

// DataCreationRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type DataCreationRequestExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u DataCreationRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of DataCreationRequestExt
func (u DataCreationRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewDataCreationRequestExt creates a new  DataCreationRequestExt.
func NewDataCreationRequestExt(v LedgerVersion, value interface{}) (result DataCreationRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// DataCreationRequest is an XDR Struct defines as:
//
//   struct DataCreationRequest {
//        //: Numeric type, used for access control
//        uint64 type;
//
//        // Sequence number increases when request is rejected
//    	uint32 sequenceNumber;
//
//        //: Owner of data to create
//        AccountID owner;
//
//        //: Value stored
//        longstring value;
//
//        //: Arbitrary stringified json object that can be used to attach data to be reviewed by an admin
//        longstring creatorDetails; // details set by requester
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type DataCreationRequest struct {
	Type           Uint64                 `json:"type,omitempty"`
	SequenceNumber Uint32                 `json:"sequenceNumber,omitempty"`
	Owner          AccountId              `json:"owner,omitempty"`
	Value          Longstring             `json:"value,omitempty"`
	CreatorDetails Longstring             `json:"creatorDetails,omitempty"`
	Ext            DataCreationRequestExt `json:"ext,omitempty"`
}

// CreateDeferredPaymentRequest is an XDR Struct defines as:
//
//   struct CreateDeferredPaymentRequest {
//        BalanceID sourceBalance;
//        AccountID destination;
//
//        uint64 amount;
//        uint32 sequenceNumber;
//
//        longstring creatorDetails; // details set by requester
//
//        EmptyExt ext;
//    };
//
type CreateDeferredPaymentRequest struct {
	SourceBalance  BalanceId  `json:"sourceBalance,omitempty"`
	Destination    AccountId  `json:"destination,omitempty"`
	Amount         Uint64     `json:"amount,omitempty"`
	SequenceNumber Uint32     `json:"sequenceNumber,omitempty"`
	CreatorDetails Longstring `json:"creatorDetails,omitempty"`
	Ext            EmptyExt   `json:"ext,omitempty"`
}

// CreatePollRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreatePollRequestExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreatePollRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreatePollRequestExt
func (u CreatePollRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreatePollRequestExt creates a new  CreatePollRequestExt.
func NewCreatePollRequestExt(v LedgerVersion, value interface{}) (result CreatePollRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreatePollRequest is an XDR Struct defines as:
//
//   //: CreatePollRequest is used to create poll entry with passed fields
//    struct CreatePollRequest
//    {
//        //: is used to restrict using of poll through rules
//        uint32 permissionType;
//
//        //: Number of allowed choices
//        uint32 numberOfChoices;
//
//        //: Specification of poll
//        PollData data;
//
//        //: Arbitrary stringified json object with details about the poll
//        longstring creatorDetails; // details set by requester
//
//        //: The date from which voting in the poll will be allowed
//        uint64 startTime;
//
//        //: The date until which voting in the poll will be allowed
//        uint64 endTime;
//
//        //: ID of account which is responsible for poll result submitting
//        AccountID resultProviderID;
//
//        //: True means that signature of `resultProvider` is required to participate in poll voting
//        bool voteConfirmationRequired;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type CreatePollRequest struct {
	PermissionType           Uint32               `json:"permissionType,omitempty"`
	NumberOfChoices          Uint32               `json:"numberOfChoices,omitempty"`
	Data                     PollData             `json:"data,omitempty"`
	CreatorDetails           Longstring           `json:"creatorDetails,omitempty"`
	StartTime                Uint64               `json:"startTime,omitempty"`
	EndTime                  Uint64               `json:"endTime,omitempty"`
	ResultProviderId         AccountId            `json:"resultProviderID,omitempty"`
	VoteConfirmationRequired bool                 `json:"voteConfirmationRequired,omitempty"`
	Ext                      CreatePollRequestExt `json:"ext,omitempty"`
}

// InvoiceRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type InvoiceRequestExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u InvoiceRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of InvoiceRequestExt
func (u InvoiceRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewInvoiceRequestExt creates a new  InvoiceRequestExt.
func NewInvoiceRequestExt(v LedgerVersion, value interface{}) (result InvoiceRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// InvoiceRequest is an XDR Struct defines as:
//
//   struct InvoiceRequest
//    {
//        AssetCode asset;
//        uint64 amount; // not allowed to set 0
//        BalanceID senderBalance;
//        BalanceID receiverBalance;
//
//        uint64 *contractID;
//        bool isApproved;
//        longstring creatorDetails; // details set by requester
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type InvoiceRequest struct {
	Asset           AssetCode         `json:"asset,omitempty"`
	Amount          Uint64            `json:"amount,omitempty"`
	SenderBalance   BalanceId         `json:"senderBalance,omitempty"`
	ReceiverBalance BalanceId         `json:"receiverBalance,omitempty"`
	ContractId      *Uint64           `json:"contractID,omitempty"`
	IsApproved      bool              `json:"isApproved,omitempty"`
	CreatorDetails  Longstring        `json:"creatorDetails,omitempty"`
	Ext             InvoiceRequestExt `json:"ext,omitempty"`
}

// PreIssuanceRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type PreIssuanceRequestExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u PreIssuanceRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of PreIssuanceRequestExt
func (u PreIssuanceRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewPreIssuanceRequestExt creates a new  PreIssuanceRequestExt.
func NewPreIssuanceRequestExt(v LedgerVersion, value interface{}) (result PreIssuanceRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// PreIssuanceRequest is an XDR Struct defines as:
//
//   //: Is used to pass required values to perform pre issuance
//    struct PreIssuanceRequest
//    {
//        //: Code of an asset whose `available_for_issuance_amount` will increase
//        AssetCode asset;
//        //: Amount that will be added to current available for issuance amount
//        uint64 amount;
//        //: Pre issuer signer's signature of the `<reference>:<amount>:<asset>` hash
//        DecoratedSignature signature;
//        //: Unique string for such type of a reviewable request
//        string64 reference;
//        //: Arbitrary stringified json object provided by a requester
//        longstring creatorDetails; // details set by requester
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type PreIssuanceRequest struct {
	Asset          AssetCode             `json:"asset,omitempty"`
	Amount         Uint64                `json:"amount,omitempty"`
	Signature      DecoratedSignature    `json:"signature,omitempty"`
	Reference      String64              `json:"reference,omitempty"`
	CreatorDetails Longstring            `json:"creatorDetails,omitempty"`
	Ext            PreIssuanceRequestExt `json:"ext,omitempty"`
}

// IssuanceRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type IssuanceRequestExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u IssuanceRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of IssuanceRequestExt
func (u IssuanceRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewIssuanceRequestExt creates a new  IssuanceRequestExt.
func NewIssuanceRequestExt(v LedgerVersion, value interface{}) (result IssuanceRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// IssuanceRequest is an XDR Struct defines as:
//
//   //: Body of reviewable `IssuanceRequest`, contains parameters regarding issuance
//    struct IssuanceRequest {
//        //: Code of an asset to issue
//    	AssetCode asset;
//       //: Amount to issue
//    	uint64 amount;
//        //: Balance to issue on
//    	BalanceID receiver;
//        //: Arbitrary stringified json object that can be used to attach data to be reviewed by an admin
//    	longstring creatorDetails; // details of the issuance (External system id, etc.)
//        //: Total fee to pay, consists of fixed fee and percent fee, calculated automatically
//    	Fee fee; //totalFee to be payed (calculated automatically)
//    	//: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//      ext;
//    };
//
type IssuanceRequest struct {
	Asset          AssetCode          `json:"asset,omitempty"`
	Amount         Uint64             `json:"amount,omitempty"`
	Receiver       BalanceId          `json:"receiver,omitempty"`
	CreatorDetails Longstring         `json:"creatorDetails,omitempty"`
	Fee            Fee                `json:"fee,omitempty"`
	Ext            IssuanceRequestExt `json:"ext,omitempty"`
}

// KycRecoveryRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type KycRecoveryRequestExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u KycRecoveryRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of KycRecoveryRequestExt
func (u KycRecoveryRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewKycRecoveryRequestExt creates a new  KycRecoveryRequestExt.
func NewKycRecoveryRequestExt(v LedgerVersion, value interface{}) (result KycRecoveryRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// KycRecoveryRequest is an XDR Struct defines as:
//
//   //: KYCRecoveryRequest is used to change signers of target account
//    struct KYCRecoveryRequest {
//        //: Account to be recovered
//        AccountID targetAccount;
//        //: New signers for the target account
//        UpdateSignerData signersData<>;
//
//        //: Arbitrary stringified json object that can be used to attach data to be reviewed by an admin
//        longstring creatorDetails; // details set by requester
//        //: Sequence number increases when request is rejected
//        uint32 sequenceNumber;
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type KycRecoveryRequest struct {
	TargetAccount  AccountId             `json:"targetAccount,omitempty"`
	SignersData    []UpdateSignerData    `json:"signersData,omitempty"`
	CreatorDetails Longstring            `json:"creatorDetails,omitempty"`
	SequenceNumber Uint32                `json:"sequenceNumber,omitempty"`
	Ext            KycRecoveryRequestExt `json:"ext,omitempty"`
}

// LimitsUpdateRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type LimitsUpdateRequestExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u LimitsUpdateRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of LimitsUpdateRequestExt
func (u LimitsUpdateRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewLimitsUpdateRequestExt creates a new  LimitsUpdateRequestExt.
func NewLimitsUpdateRequestExt(v LedgerVersion, value interface{}) (result LimitsUpdateRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// LimitsUpdateRequest is an XDR Struct defines as:
//
//   //: Body of reviewable `LimitsUpdateRequest` contains details regarding limit updates
//    struct LimitsUpdateRequest
//    {
//        //: Arbitrary stringified JSON object that can be used to attach data to be reviewed by an admin
//        longstring creatorDetails;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type LimitsUpdateRequest struct {
	CreatorDetails Longstring             `json:"creatorDetails,omitempty"`
	Ext            LimitsUpdateRequestExt `json:"ext,omitempty"`
}

// ManageOfferRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        case MOVEMENT_REQUESTS_DETAILS:
//            longstring creatorDetails;
//        }
//
type ManageOfferRequestExt struct {
	V              LedgerVersion `json:"v,omitempty"`
	CreatorDetails *Longstring   `json:"creatorDetails,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u ManageOfferRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of ManageOfferRequestExt
func (u ManageOfferRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	case LedgerVersionMovementRequestsDetails:
		return "CreatorDetails", true
	}
	return "-", false
}

// NewManageOfferRequestExt creates a new  ManageOfferRequestExt.
func NewManageOfferRequestExt(v LedgerVersion, value interface{}) (result ManageOfferRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	case LedgerVersionMovementRequestsDetails:
		tv, ok := value.(Longstring)
		if !ok {
			err = fmt.Errorf("invalid value, must be Longstring")
			return
		}
		result.CreatorDetails = &tv
	}
	return
}

// MustCreatorDetails retrieves the CreatorDetails value from the union,
// panicing if the value is not set.
func (u ManageOfferRequestExt) MustCreatorDetails() Longstring {
	val, ok := u.GetCreatorDetails()

	if !ok {
		panic("arm CreatorDetails is not set")
	}

	return val
}

// GetCreatorDetails retrieves the CreatorDetails value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u ManageOfferRequestExt) GetCreatorDetails() (result Longstring, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.V))

	if armName == "CreatorDetails" {
		result = *u.CreatorDetails
		ok = true
	}

	return
}

// ManageOfferRequest is an XDR Struct defines as:
//
//   struct ManageOfferRequest
//    {
//        ManageOfferOp op;
//
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        case MOVEMENT_REQUESTS_DETAILS:
//            longstring creatorDetails;
//        } ext;
//    };
//
type ManageOfferRequest struct {
	Op  ManageOfferOp         `json:"op,omitempty"`
	Ext ManageOfferRequestExt `json:"ext,omitempty"`
}

// CreatePaymentRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        case MOVEMENT_REQUESTS_DETAILS:
//            longstring creatorDetails;
//        }
//
type CreatePaymentRequestExt struct {
	V              LedgerVersion `json:"v,omitempty"`
	CreatorDetails *Longstring   `json:"creatorDetails,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreatePaymentRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreatePaymentRequestExt
func (u CreatePaymentRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	case LedgerVersionMovementRequestsDetails:
		return "CreatorDetails", true
	}
	return "-", false
}

// NewCreatePaymentRequestExt creates a new  CreatePaymentRequestExt.
func NewCreatePaymentRequestExt(v LedgerVersion, value interface{}) (result CreatePaymentRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	case LedgerVersionMovementRequestsDetails:
		tv, ok := value.(Longstring)
		if !ok {
			err = fmt.Errorf("invalid value, must be Longstring")
			return
		}
		result.CreatorDetails = &tv
	}
	return
}

// MustCreatorDetails retrieves the CreatorDetails value from the union,
// panicing if the value is not set.
func (u CreatePaymentRequestExt) MustCreatorDetails() Longstring {
	val, ok := u.GetCreatorDetails()

	if !ok {
		panic("arm CreatorDetails is not set")
	}

	return val
}

// GetCreatorDetails retrieves the CreatorDetails value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u CreatePaymentRequestExt) GetCreatorDetails() (result Longstring, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.V))

	if armName == "CreatorDetails" {
		result = *u.CreatorDetails
		ok = true
	}

	return
}

// CreatePaymentRequest is an XDR Struct defines as:
//
//   struct CreatePaymentRequest
//    {
//        PaymentOp paymentOp;
//
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        case MOVEMENT_REQUESTS_DETAILS:
//            longstring creatorDetails;
//        } ext;
//    };
//
type CreatePaymentRequest struct {
	PaymentOp PaymentOp               `json:"paymentOp,omitempty"`
	Ext       CreatePaymentRequestExt `json:"ext,omitempty"`
}

// RedemptionRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type RedemptionRequestExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u RedemptionRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of RedemptionRequestExt
func (u RedemptionRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewRedemptionRequestExt creates a new  RedemptionRequestExt.
func NewRedemptionRequestExt(v LedgerVersion, value interface{}) (result RedemptionRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// RedemptionRequest is an XDR Struct defines as:
//
//   //: Body of a reviewable RedemptionRequest, contains parameters regarding AML alert
//    struct RedemptionRequest {
//        //: Balance to charge assets from. Balance must be in asset owned by requester.
//        BalanceID sourceBalanceID;
//        //: Account to transfer funds
//        AccountID destination;
//
//        //: Amount of redemption
//        uint64 amount;
//
//        //: Arbitrary stringified json object that can be used to attach data to be reviewed by an admin
//        longstring creatorDetails; // details set by requester
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type RedemptionRequest struct {
	SourceBalanceId BalanceId            `json:"sourceBalanceID,omitempty"`
	Destination     AccountId            `json:"destination,omitempty"`
	Amount          Uint64               `json:"amount,omitempty"`
	CreatorDetails  Longstring           `json:"creatorDetails,omitempty"`
	Ext             RedemptionRequestExt `json:"ext,omitempty"`
}

// DataRemoveRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type DataRemoveRequestExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u DataRemoveRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of DataRemoveRequestExt
func (u DataRemoveRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewDataRemoveRequestExt creates a new  DataRemoveRequestExt.
func NewDataRemoveRequestExt(v LedgerVersion, value interface{}) (result DataRemoveRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// DataRemoveRequest is an XDR Struct defines as:
//
//   struct DataRemoveRequest {
//        //: Id of the data entry
//        uint64 id;
//
//        // Sequence number increases when request is rejected
//    	uint32 sequenceNumber;
//
//        //: Arbitrary stringified json object that can be used to attach data to be reviewed by an admin
//        longstring creatorDetails; // details set by requester
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type DataRemoveRequest struct {
	Id             Uint64               `json:"id,omitempty"`
	SequenceNumber Uint32               `json:"sequenceNumber,omitempty"`
	CreatorDetails Longstring           `json:"creatorDetails,omitempty"`
	Ext            DataRemoveRequestExt `json:"ext,omitempty"`
}

// SaleCreationRequestQuoteAssetExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type SaleCreationRequestQuoteAssetExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u SaleCreationRequestQuoteAssetExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of SaleCreationRequestQuoteAssetExt
func (u SaleCreationRequestQuoteAssetExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewSaleCreationRequestQuoteAssetExt creates a new  SaleCreationRequestQuoteAssetExt.
func NewSaleCreationRequestQuoteAssetExt(v LedgerVersion, value interface{}) (result SaleCreationRequestQuoteAssetExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// SaleCreationRequestQuoteAsset is an XDR Struct defines as:
//
//   //: SaleCreationRequestQuoteAsset is a structure that contains an asset code with price
//    struct SaleCreationRequestQuoteAsset {
//        //: AssetCode of quote asset
//        AssetCode quoteAsset; // asset in which participation will be accepted
//        //: Price of sale base asset in relation to a quote asset
//        uint64 price; // price for 1 baseAsset in relation to a quote asset
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type SaleCreationRequestQuoteAsset struct {
	QuoteAsset AssetCode                        `json:"quoteAsset,omitempty"`
	Price      Uint64                           `json:"price,omitempty"`
	Ext        SaleCreationRequestQuoteAssetExt `json:"ext,omitempty"`
}

// CreateAccountSaleRuleDataExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type CreateAccountSaleRuleDataExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u CreateAccountSaleRuleDataExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of CreateAccountSaleRuleDataExt
func (u CreateAccountSaleRuleDataExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewCreateAccountSaleRuleDataExt creates a new  CreateAccountSaleRuleDataExt.
func NewCreateAccountSaleRuleDataExt(v LedgerVersion, value interface{}) (result CreateAccountSaleRuleDataExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// CreateAccountSaleRuleData is an XDR Struct defines as:
//
//   //: CreateAccountSaleRuleData is used to pass necessary params to create a new account sale rule
//    struct CreateAccountSaleRuleData
//    {
//        //: Certain account for which rule is applied, null means rule is global
//        AccountID* accountID;
//        //: True if such rule is deniable, otherwise allows
//        bool forbids;
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        } ext;
//    };
//
type CreateAccountSaleRuleData struct {
	AccountId *AccountId                   `json:"accountID,omitempty"`
	Forbids   bool                         `json:"forbids,omitempty"`
	Ext       CreateAccountSaleRuleDataExt `json:"ext,omitempty"`
}

// SaleCreationRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        case ADD_SALE_WHITELISTS:
//            //: array of rules that define participation rules. One global rule must be specified.
//            CreateAccountSaleRuleData saleRules<>;
//        }
//
type SaleCreationRequestExt struct {
	V         LedgerVersion                `json:"v,omitempty"`
	SaleRules *[]CreateAccountSaleRuleData `json:"saleRules,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u SaleCreationRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of SaleCreationRequestExt
func (u SaleCreationRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	case LedgerVersionAddSaleWhitelists:
		return "SaleRules", true
	}
	return "-", false
}

// NewSaleCreationRequestExt creates a new  SaleCreationRequestExt.
func NewSaleCreationRequestExt(v LedgerVersion, value interface{}) (result SaleCreationRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	case LedgerVersionAddSaleWhitelists:
		tv, ok := value.([]CreateAccountSaleRuleData)
		if !ok {
			err = fmt.Errorf("invalid value, must be []CreateAccountSaleRuleData")
			return
		}
		result.SaleRules = &tv
	}
	return
}

// MustSaleRules retrieves the SaleRules value from the union,
// panicing if the value is not set.
func (u SaleCreationRequestExt) MustSaleRules() []CreateAccountSaleRuleData {
	val, ok := u.GetSaleRules()

	if !ok {
		panic("arm SaleRules is not set")
	}

	return val
}

// GetSaleRules retrieves the SaleRules value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u SaleCreationRequestExt) GetSaleRules() (result []CreateAccountSaleRuleData, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.V))

	if armName == "SaleRules" {
		result = *u.SaleRules
		ok = true
	}

	return
}

// SaleCreationRequest is an XDR Struct defines as:
//
//   //: SaleCreationRequest is used to create a sale with provided parameters
//    struct SaleCreationRequest
//    {
//        //: Some custom sale type that can be used while setting account rules
//        uint64 saleType;
//        //: Asset code of an asset to sell on sale
//        AssetCode baseAsset; // asset for which sale will be performed
//        //: Asset code of an asset used to calculcate soft cap and hard cap
//        AssetCode defaultQuoteAsset; // asset for soft and hard cap
//        //: Time when the sale should start
//        uint64 startTime; // start time of the sale
//        //: Time when the sale should end
//        uint64 endTime; // close time of the sale
//        //: Minimal amount (in default quote asset) that has to be sold on sale for it to be considered successful
//        uint64 softCap; // minimum amount of quote asset to be received at which sale will be considered a successful
//        //: Maximal amount (in default quote asset) to be received during the sale. Sale closes immediately after reaching the hard cap
//        uint64 hardCap; // max amount of quote asset to be received
//        //: Arbitrary stringified JSON object that can be used to attach data to be reviewed by an admin
//        longstring creatorDetails; // details set by requester
//        //: Parameters specific to a particular sale type
//        SaleTypeExt saleTypeExt;
//        //:
//        uint64 requiredBaseAssetForHardCap;
//        //: Used to keep track of rejected requests updates. `SequenceNumber` increases after each rejected SaleCreationRequest update.
//        uint32 sequenceNumber;
//        //: Array of quote assets that are available for participation
//        SaleCreationRequestQuoteAsset quoteAssets<100>;
//        //: Use `EMPTY_VERSION` to allow anyone participate in sale,
//        //: use `ADD_SALE_WHITELISTS` to specify sale participation rules
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        case ADD_SALE_WHITELISTS:
//            //: array of rules that define participation rules. One global rule must be specified.
//            CreateAccountSaleRuleData saleRules<>;
//        }
//        ext;
//    };
//
type SaleCreationRequest struct {
	SaleType                    Uint64                          `json:"saleType,omitempty"`
	BaseAsset                   AssetCode                       `json:"baseAsset,omitempty"`
	DefaultQuoteAsset           AssetCode                       `json:"defaultQuoteAsset,omitempty"`
	StartTime                   Uint64                          `json:"startTime,omitempty"`
	EndTime                     Uint64                          `json:"endTime,omitempty"`
	SoftCap                     Uint64                          `json:"softCap,omitempty"`
	HardCap                     Uint64                          `json:"hardCap,omitempty"`
	CreatorDetails              Longstring                      `json:"creatorDetails,omitempty"`
	SaleTypeExt                 SaleTypeExt                     `json:"saleTypeExt,omitempty"`
	RequiredBaseAssetForHardCap Uint64                          `json:"requiredBaseAssetForHardCap,omitempty"`
	SequenceNumber              Uint32                          `json:"sequenceNumber,omitempty"`
	QuoteAssets                 []SaleCreationRequestQuoteAsset `json:"quoteAssets,omitempty" xdrmaxsize:"100"`
	Ext                         SaleCreationRequestExt          `json:"ext,omitempty"`
}

// DataUpdateRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type DataUpdateRequestExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u DataUpdateRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of DataUpdateRequestExt
func (u DataUpdateRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewDataUpdateRequestExt creates a new  DataUpdateRequestExt.
func NewDataUpdateRequestExt(v LedgerVersion, value interface{}) (result DataUpdateRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// DataUpdateRequest is an XDR Struct defines as:
//
//   struct DataUpdateRequest {
//        //: Id of the data entry
//        uint64 id;
//
//        // Sequence number increases when request is rejected
//    	uint32 sequenceNumber;
//
//        //: Value stored
//        longstring value;
//
//        //: Arbitrary stringified json object that can be used to attach data to be reviewed by an admin
//        longstring creatorDetails; // details set by requester
//
//        //: reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type DataUpdateRequest struct {
	Id             Uint64               `json:"id,omitempty"`
	SequenceNumber Uint32               `json:"sequenceNumber,omitempty"`
	Value          Longstring           `json:"value,omitempty"`
	CreatorDetails Longstring           `json:"creatorDetails,omitempty"`
	Ext            DataUpdateRequestExt `json:"ext,omitempty"`
}

// UpdateSaleDetailsRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type UpdateSaleDetailsRequestExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u UpdateSaleDetailsRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of UpdateSaleDetailsRequestExt
func (u UpdateSaleDetailsRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewUpdateSaleDetailsRequestExt creates a new  UpdateSaleDetailsRequestExt.
func NewUpdateSaleDetailsRequestExt(v LedgerVersion, value interface{}) (result UpdateSaleDetailsRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// UpdateSaleDetailsRequest is an XDR Struct defines as:
//
//   //: UpdateSaleDetailsRequest is used to update details of an existing sale
//    struct UpdateSaleDetailsRequest {
//        //: ID of the sale whose details should be updated
//        uint64 saleID; // ID of sale to update details
//        //: Arbitrary stringified JSON object that can be used to attach data to be reviewed by an admin
//        longstring creatorDetails; // details set by requester
//        //: Used to keep track of rejected requests update.  `SequenceNumber increases` after each rejected UpdateSaleDetailsRequest update
//        uint32 sequenceNumber;
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type UpdateSaleDetailsRequest struct {
	SaleId         Uint64                      `json:"saleID,omitempty"`
	CreatorDetails Longstring                  `json:"creatorDetails,omitempty"`
	SequenceNumber Uint32                      `json:"sequenceNumber,omitempty"`
	Ext            UpdateSaleDetailsRequestExt `json:"ext,omitempty"`
}

// WithdrawalRequestExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type WithdrawalRequestExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u WithdrawalRequestExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of WithdrawalRequestExt
func (u WithdrawalRequestExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewWithdrawalRequestExt creates a new  WithdrawalRequestExt.
func NewWithdrawalRequestExt(v LedgerVersion, value interface{}) (result WithdrawalRequestExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// WithdrawalRequest is an XDR Struct defines as:
//
//   //: WithdrawalRequest contains details regarding a withdraw
//    struct WithdrawalRequest {
//        //: Balance to withdraw from
//        BalanceID balance; // balance id from which withdrawal will be performed
//        //: Amount to withdraw
//        uint64 amount; // amount to be withdrawn
//        //: Amount in stats quote asset
//        uint64 universalAmount; // amount in stats asset
//        //: Total fee to pay, contains fixed amount and calculated percent of the withdrawn amount
//        Fee fee; // expected fee to be paid
//        //: Arbitrary stringified json object that can be used to attach data to be reviewed by an admin
//        longstring creatorDetails; // details set by requester
//
//        //: Reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type WithdrawalRequest struct {
	Balance         BalanceId            `json:"balance,omitempty"`
	Amount          Uint64               `json:"amount,omitempty"`
	UniversalAmount Uint64               `json:"universalAmount,omitempty"`
	Fee             Fee                  `json:"fee,omitempty"`
	CreatorDetails  Longstring           `json:"creatorDetails,omitempty"`
	Ext             WithdrawalRequestExt `json:"ext,omitempty"`
}

// OperationBody is an XDR NestedUnion defines as:
//
//   union switch (OperationType type)
//        {
//        case CREATE_ACCOUNT:
//            CreateAccountOp createAccountOp;
//    	case CREATE_ISSUANCE_REQUEST:
//    		CreateIssuanceRequestOp createIssuanceRequestOp;
//        case SET_FEES:
//            SetFeesOp setFeesOp;
//    	case CREATE_WITHDRAWAL_REQUEST:
//    		CreateWithdrawalRequestOp createWithdrawalRequestOp;
//    	case MANAGE_BALANCE:
//    		ManageBalanceOp manageBalanceOp;
//        case MANAGE_ASSET:
//            ManageAssetOp manageAssetOp;
//        case CREATE_PREISSUANCE_REQUEST:
//            CreatePreIssuanceRequestOp createPreIssuanceRequest;
//        case MANAGE_LIMITS:
//            ManageLimitsOp manageLimitsOp;
//    	case MANAGE_ASSET_PAIR:
//    		ManageAssetPairOp manageAssetPairOp;
//    	case MANAGE_OFFER:
//    		ManageOfferOp manageOfferOp;
//        case MANAGE_INVOICE_REQUEST:
//            ManageInvoiceRequestOp manageInvoiceRequestOp;
//    	case REVIEW_REQUEST:
//    		ReviewRequestOp reviewRequestOp;
//    	case CREATE_SALE_REQUEST:
//    		CreateSaleCreationRequestOp createSaleCreationRequestOp;
//    	case CHECK_SALE_STATE:
//    		CheckSaleStateOp checkSaleStateOp;
//    	case PAYOUT:
//    	    PayoutOp payoutOp;
//    	case CREATE_AML_ALERT:
//    	    CreateAMLAlertRequestOp createAMLAlertRequestOp;
//    	case MANAGE_KEY_VALUE:
//    	    ManageKeyValueOp manageKeyValueOp;
//    	case CREATE_CHANGE_ROLE_REQUEST:
//    		CreateChangeRoleRequestOp createChangeRoleRequestOp;
//        case MANAGE_EXTERNAL_SYSTEM_ACCOUNT_ID_POOL_ENTRY:
//            ManageExternalSystemAccountIdPoolEntryOp manageExternalSystemAccountIdPoolEntryOp;
//        case BIND_EXTERNAL_SYSTEM_ACCOUNT_ID:
//            BindExternalSystemAccountIdOp bindExternalSystemAccountIdOp;
//        case PAYMENT:
//            PaymentOp paymentOp;
//        case MANAGE_SALE:
//            ManageSaleOp manageSaleOp;
//        case CREATE_MANAGE_LIMITS_REQUEST:
//            CreateManageLimitsRequestOp createManageLimitsRequestOp;
//        case MANAGE_CONTRACT_REQUEST:
//            ManageContractRequestOp manageContractRequestOp;
//        case MANAGE_CONTRACT:
//            ManageContractOp manageContractOp;
//        case CANCEL_SALE_REQUEST:
//            CancelSaleCreationRequestOp cancelSaleCreationRequestOp;
//        case CREATE_ATOMIC_SWAP_ASK_REQUEST:
//            CreateAtomicSwapAskRequestOp createAtomicSwapAskRequestOp;
//        case CANCEL_ATOMIC_SWAP_ASK:
//            CancelAtomicSwapAskOp cancelAtomicSwapAskOp;
//        case CREATE_ATOMIC_SWAP_BID_REQUEST:
//            CreateAtomicSwapBidRequestOp createAtomicSwapBidRequestOp;
//        case MANAGE_ACCOUNT_ROLE:
//            ManageAccountRoleOp manageAccountRoleOp;
//        case MANAGE_ACCOUNT_RULE:
//            ManageAccountRuleOp manageAccountRuleOp;
//        case MANAGE_SIGNER:
//            ManageSignerOp manageSignerOp;
//        case MANAGE_SIGNER_ROLE:
//            ManageSignerRoleOp manageSignerRoleOp;
//        case MANAGE_SIGNER_RULE:
//            ManageSignerRuleOp manageSignerRuleOp;
//        case STAMP:
//            StampOp stampOp;
//        case LICENSE:
//            LicenseOp licenseOp;
//        case MANAGE_CREATE_POLL_REQUEST:
//            ManageCreatePollRequestOp manageCreatePollRequestOp;
//        case MANAGE_POLL:
//            ManagePollOp managePollOp;
//        case MANAGE_VOTE:
//            ManageVoteOp manageVoteOp;
//        case MANAGE_ACCOUNT_SPECIFIC_RULE:
//            ManageAccountSpecificRuleOp manageAccountSpecificRuleOp;
//        case CANCEL_CHANGE_ROLE_REQUEST:
//            CancelChangeRoleRequestOp cancelChangeRoleRequestOp;
//        case REMOVE_ASSET_PAIR:
//            RemoveAssetPairOp removeAssetPairOp;
//        case INITIATE_KYC_RECOVERY:
//            InitiateKYCRecoveryOp initiateKYCRecoveryOp;
//        case CREATE_KYC_RECOVERY_REQUEST:
//            CreateKYCRecoveryRequestOp createKYCRecoveryRequestOp;
//        case CREATE_MANAGE_OFFER_REQUEST:
//            CreateManageOfferRequestOp createManageOfferRequestOp;
//        case CREATE_PAYMENT_REQUEST:
//            CreatePaymentRequestOp createPaymentRequestOp;
//        case REMOVE_ASSET:
//            RemoveAssetOp removeAssetOp;
//        case OPEN_SWAP:
//            OpenSwapOp openSwapOp;
//        case CLOSE_SWAP:
//            CloseSwapOp closeSwapOp;
//        case CREATE_REDEMPTION_REQUEST:
//            CreateRedemptionRequestOp createRedemptionRequestOp;
//        case CREATE_DATA:
//            CreateDataOp createDataOp;
//        case UPDATE_DATA:
//            UpdateDataOp updateDataOp;
//        case REMOVE_DATA:
//            RemoveDataOp removeDataOp;
//        case CREATE_DATA_CREATION_REQUEST:
//            CreateDataCreationRequestOp createDataCreationRequestOp;
//        case CANCEL_DATA_CREATION_REQUEST:
//            CancelDataCreationRequestOp cancelDataCreationRequestOp;
//        case CREATE_DATA_UPDATE_REQUEST:
//            CreateDataUpdateRequestOp createDataUpdateRequestOp;
//        case CREATE_DATA_REMOVE_REQUEST:
//            CreateDataRemoveRequestOp createDataRemoveRequestOp;
//        case CANCEL_DATA_UPDATE_REQUEST:
//            CancelDataUpdateRequestOp cancelDataUpdateRequestOp;
//        case CANCEL_DATA_REMOVE_REQUEST:
//            CancelDataRemoveRequestOp cancelDataRemoveRequestOp;
//        case CREATE_DEFERRED_PAYMENT_CREATION_REQUEST:
//            CreateDeferredPaymentCreationRequestOp createDeferredPaymentCreationRequestOp;
//        case CANCEL_DEFERRED_PAYMENT_CREATION_REQUEST:
//            CancelDeferredPaymentCreationRequestOp cancelDeferredPaymentCreationRequestOp;
//        case CREATE_CLOSE_DEFERRED_PAYMENT_REQUEST:
//            CreateCloseDeferredPaymentRequestOp createCloseDeferredPaymentRequestOp;
//        case CANCEL_CLOSE_DEFERRED_PAYMENT_REQUEST:
//            CancelCloseDeferredPaymentRequestOp cancelCloseDeferredPaymentRequestOp;
//
//        }
//
type OperationBody struct {
	Type                                     OperationType                             `json:"type,omitempty"`
	CreateAccountOp                          *CreateAccountOp                          `json:"createAccountOp,omitempty"`
	CreateIssuanceRequestOp                  *CreateIssuanceRequestOp                  `json:"createIssuanceRequestOp,omitempty"`
	SetFeesOp                                *SetFeesOp                                `json:"setFeesOp,omitempty"`
	CreateWithdrawalRequestOp                *CreateWithdrawalRequestOp                `json:"createWithdrawalRequestOp,omitempty"`
	ManageBalanceOp                          *ManageBalanceOp                          `json:"manageBalanceOp,omitempty"`
	ManageAssetOp                            *ManageAssetOp                            `json:"manageAssetOp,omitempty"`
	CreatePreIssuanceRequest                 *CreatePreIssuanceRequestOp               `json:"createPreIssuanceRequest,omitempty"`
	ManageLimitsOp                           *ManageLimitsOp                           `json:"manageLimitsOp,omitempty"`
	ManageAssetPairOp                        *ManageAssetPairOp                        `json:"manageAssetPairOp,omitempty"`
	ManageOfferOp                            *ManageOfferOp                            `json:"manageOfferOp,omitempty"`
	ManageInvoiceRequestOp                   *ManageInvoiceRequestOp                   `json:"manageInvoiceRequestOp,omitempty"`
	ReviewRequestOp                          *ReviewRequestOp                          `json:"reviewRequestOp,omitempty"`
	CreateSaleCreationRequestOp              *CreateSaleCreationRequestOp              `json:"createSaleCreationRequestOp,omitempty"`
	CheckSaleStateOp                         *CheckSaleStateOp                         `json:"checkSaleStateOp,omitempty"`
	PayoutOp                                 *PayoutOp                                 `json:"payoutOp,omitempty"`
	CreateAmlAlertRequestOp                  *CreateAmlAlertRequestOp                  `json:"createAMLAlertRequestOp,omitempty"`
	ManageKeyValueOp                         *ManageKeyValueOp                         `json:"manageKeyValueOp,omitempty"`
	CreateChangeRoleRequestOp                *CreateChangeRoleRequestOp                `json:"createChangeRoleRequestOp,omitempty"`
	ManageExternalSystemAccountIdPoolEntryOp *ManageExternalSystemAccountIdPoolEntryOp `json:"manageExternalSystemAccountIdPoolEntryOp,omitempty"`
	BindExternalSystemAccountIdOp            *BindExternalSystemAccountIdOp            `json:"bindExternalSystemAccountIdOp,omitempty"`
	PaymentOp                                *PaymentOp                                `json:"paymentOp,omitempty"`
	ManageSaleOp                             *ManageSaleOp                             `json:"manageSaleOp,omitempty"`
	CreateManageLimitsRequestOp              *CreateManageLimitsRequestOp              `json:"createManageLimitsRequestOp,omitempty"`
	ManageContractRequestOp                  *ManageContractRequestOp                  `json:"manageContractRequestOp,omitempty"`
	ManageContractOp                         *ManageContractOp                         `json:"manageContractOp,omitempty"`
	CancelSaleCreationRequestOp              *CancelSaleCreationRequestOp              `json:"cancelSaleCreationRequestOp,omitempty"`
	CreateAtomicSwapAskRequestOp             *CreateAtomicSwapAskRequestOp             `json:"createAtomicSwapAskRequestOp,omitempty"`
	CancelAtomicSwapAskOp                    *CancelAtomicSwapAskOp                    `json:"cancelAtomicSwapAskOp,omitempty"`
	CreateAtomicSwapBidRequestOp             *CreateAtomicSwapBidRequestOp             `json:"createAtomicSwapBidRequestOp,omitempty"`
	ManageAccountRoleOp                      *ManageAccountRoleOp                      `json:"manageAccountRoleOp,omitempty"`
	ManageAccountRuleOp                      *ManageAccountRuleOp                      `json:"manageAccountRuleOp,omitempty"`
	ManageSignerOp                           *ManageSignerOp                           `json:"manageSignerOp,omitempty"`
	ManageSignerRoleOp                       *ManageSignerRoleOp                       `json:"manageSignerRoleOp,omitempty"`
	ManageSignerRuleOp                       *ManageSignerRuleOp                       `json:"manageSignerRuleOp,omitempty"`
	StampOp                                  *StampOp                                  `json:"stampOp,omitempty"`
	LicenseOp                                *LicenseOp                                `json:"licenseOp,omitempty"`
	ManageCreatePollRequestOp                *ManageCreatePollRequestOp                `json:"manageCreatePollRequestOp,omitempty"`
	ManagePollOp                             *ManagePollOp                             `json:"managePollOp,omitempty"`
	ManageVoteOp                             *ManageVoteOp                             `json:"manageVoteOp,omitempty"`
	ManageAccountSpecificRuleOp              *ManageAccountSpecificRuleOp              `json:"manageAccountSpecificRuleOp,omitempty"`
	CancelChangeRoleRequestOp                *CancelChangeRoleRequestOp                `json:"cancelChangeRoleRequestOp,omitempty"`
	RemoveAssetPairOp                        *RemoveAssetPairOp                        `json:"removeAssetPairOp,omitempty"`
	InitiateKycRecoveryOp                    *InitiateKycRecoveryOp                    `json:"initiateKYCRecoveryOp,omitempty"`
	CreateKycRecoveryRequestOp               *CreateKycRecoveryRequestOp               `json:"createKYCRecoveryRequestOp,omitempty"`
	CreateManageOfferRequestOp               *CreateManageOfferRequestOp               `json:"createManageOfferRequestOp,omitempty"`
	CreatePaymentRequestOp                   *CreatePaymentRequestOp                   `json:"createPaymentRequestOp,omitempty"`
	RemoveAssetOp                            *RemoveAssetOp                            `json:"removeAssetOp,omitempty"`
	OpenSwapOp                               *OpenSwapOp                               `json:"openSwapOp,omitempty"`
	CloseSwapOp                              *CloseSwapOp                              `json:"closeSwapOp,omitempty"`
	CreateRedemptionRequestOp                *CreateRedemptionRequestOp                `json:"createRedemptionRequestOp,omitempty"`
	CreateDataOp                             *CreateDataOp                             `json:"createDataOp,omitempty"`
	UpdateDataOp                             *UpdateDataOp                             `json:"updateDataOp,omitempty"`
	RemoveDataOp                             *RemoveDataOp                             `json:"removeDataOp,omitempty"`
	CreateDataCreationRequestOp              *CreateDataCreationRequestOp              `json:"createDataCreationRequestOp,omitempty"`
	CancelDataCreationRequestOp              *CancelDataCreationRequestOp              `json:"cancelDataCreationRequestOp,omitempty"`
	CreateDataUpdateRequestOp                *CreateDataUpdateRequestOp                `json:"createDataUpdateRequestOp,omitempty"`
	CreateDataRemoveRequestOp                *CreateDataRemoveRequestOp                `json:"createDataRemoveRequestOp,omitempty"`
	CancelDataUpdateRequestOp                *CancelDataUpdateRequestOp                `json:"cancelDataUpdateRequestOp,omitempty"`
	CancelDataRemoveRequestOp                *CancelDataRemoveRequestOp                `json:"cancelDataRemoveRequestOp,omitempty"`
	CreateDeferredPaymentCreationRequestOp   *CreateDeferredPaymentCreationRequestOp   `json:"createDeferredPaymentCreationRequestOp,omitempty"`
	CancelDeferredPaymentCreationRequestOp   *CancelDeferredPaymentCreationRequestOp   `json:"cancelDeferredPaymentCreationRequestOp,omitempty"`
	CreateCloseDeferredPaymentRequestOp      *CreateCloseDeferredPaymentRequestOp      `json:"createCloseDeferredPaymentRequestOp,omitempty"`
	CancelCloseDeferredPaymentRequestOp      *CancelCloseDeferredPaymentRequestOp      `json:"cancelCloseDeferredPaymentRequestOp,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u OperationBody) SwitchFieldName() string {
	return "Type"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of OperationBody
func (u OperationBody) ArmForSwitch(sw int32) (string, bool) {
	switch OperationType(sw) {
	case OperationTypeCreateAccount:
		return "CreateAccountOp", true
	case OperationTypeCreateIssuanceRequest:
		return "CreateIssuanceRequestOp", true
	case OperationTypeSetFees:
		return "SetFeesOp", true
	case OperationTypeCreateWithdrawalRequest:
		return "CreateWithdrawalRequestOp", true
	case OperationTypeManageBalance:
		return "ManageBalanceOp", true
	case OperationTypeManageAsset:
		return "ManageAssetOp", true
	case OperationTypeCreatePreissuanceRequest:
		return "CreatePreIssuanceRequest", true
	case OperationTypeManageLimits:
		return "ManageLimitsOp", true
	case OperationTypeManageAssetPair:
		return "ManageAssetPairOp", true
	case OperationTypeManageOffer:
		return "ManageOfferOp", true
	case OperationTypeManageInvoiceRequest:
		return "ManageInvoiceRequestOp", true
	case OperationTypeReviewRequest:
		return "ReviewRequestOp", true
	case OperationTypeCreateSaleRequest:
		return "CreateSaleCreationRequestOp", true
	case OperationTypeCheckSaleState:
		return "CheckSaleStateOp", true
	case OperationTypePayout:
		return "PayoutOp", true
	case OperationTypeCreateAmlAlert:
		return "CreateAmlAlertRequestOp", true
	case OperationTypeManageKeyValue:
		return "ManageKeyValueOp", true
	case OperationTypeCreateChangeRoleRequest:
		return "CreateChangeRoleRequestOp", true
	case OperationTypeManageExternalSystemAccountIdPoolEntry:
		return "ManageExternalSystemAccountIdPoolEntryOp", true
	case OperationTypeBindExternalSystemAccountId:
		return "BindExternalSystemAccountIdOp", true
	case OperationTypePayment:
		return "PaymentOp", true
	case OperationTypeManageSale:
		return "ManageSaleOp", true
	case OperationTypeCreateManageLimitsRequest:
		return "CreateManageLimitsRequestOp", true
	case OperationTypeManageContractRequest:
		return "ManageContractRequestOp", true
	case OperationTypeManageContract:
		return "ManageContractOp", true
	case OperationTypeCancelSaleRequest:
		return "CancelSaleCreationRequestOp", true
	case OperationTypeCreateAtomicSwapAskRequest:
		return "CreateAtomicSwapAskRequestOp", true
	case OperationTypeCancelAtomicSwapAsk:
		return "CancelAtomicSwapAskOp", true
	case OperationTypeCreateAtomicSwapBidRequest:
		return "CreateAtomicSwapBidRequestOp", true
	case OperationTypeManageAccountRole:
		return "ManageAccountRoleOp", true
	case OperationTypeManageAccountRule:
		return "ManageAccountRuleOp", true
	case OperationTypeManageSigner:
		return "ManageSignerOp", true
	case OperationTypeManageSignerRole:
		return "ManageSignerRoleOp", true
	case OperationTypeManageSignerRule:
		return "ManageSignerRuleOp", true
	case OperationTypeStamp:
		return "StampOp", true
	case OperationTypeLicense:
		return "LicenseOp", true
	case OperationTypeManageCreatePollRequest:
		return "ManageCreatePollRequestOp", true
	case OperationTypeManagePoll:
		return "ManagePollOp", true
	case OperationTypeManageVote:
		return "ManageVoteOp", true
	case OperationTypeManageAccountSpecificRule:
		return "ManageAccountSpecificRuleOp", true
	case OperationTypeCancelChangeRoleRequest:
		return "CancelChangeRoleRequestOp", true
	case OperationTypeRemoveAssetPair:
		return "RemoveAssetPairOp", true
	case OperationTypeInitiateKycRecovery:
		return "InitiateKycRecoveryOp", true
	case OperationTypeCreateKycRecoveryRequest:
		return "CreateKycRecoveryRequestOp", true
	case OperationTypeCreateManageOfferRequest:
		return "CreateManageOfferRequestOp", true
	case OperationTypeCreatePaymentRequest:
		return "CreatePaymentRequestOp", true
	case OperationTypeRemoveAsset:
		return "RemoveAssetOp", true
	case OperationTypeOpenSwap:
		return "OpenSwapOp", true
	case OperationTypeCloseSwap:
		return "CloseSwapOp", true
	case OperationTypeCreateRedemptionRequest:
		return "CreateRedemptionRequestOp", true
	case OperationTypeCreateData:
		return "CreateDataOp", true
	case OperationTypeUpdateData:
		return "UpdateDataOp", true
	case OperationTypeRemoveData:
		return "RemoveDataOp", true
	case OperationTypeCreateDataCreationRequest:
		return "CreateDataCreationRequestOp", true
	case OperationTypeCancelDataCreationRequest:
		return "CancelDataCreationRequestOp", true
	case OperationTypeCreateDataUpdateRequest:
		return "CreateDataUpdateRequestOp", true
	case OperationTypeCreateDataRemoveRequest:
		return "CreateDataRemoveRequestOp", true
	case OperationTypeCancelDataUpdateRequest:
		return "CancelDataUpdateRequestOp", true
	case OperationTypeCancelDataRemoveRequest:
		return "CancelDataRemoveRequestOp", true
	case OperationTypeCreateDeferredPaymentCreationRequest:
		return "CreateDeferredPaymentCreationRequestOp", true
	case OperationTypeCancelDeferredPaymentCreationRequest:
		return "CancelDeferredPaymentCreationRequestOp", true
	case OperationTypeCreateCloseDeferredPaymentRequest:
		return "CreateCloseDeferredPaymentRequestOp", true
	case OperationTypeCancelCloseDeferredPaymentRequest:
		return "CancelCloseDeferredPaymentRequestOp", true
	}
	return "-", false
}

// NewOperationBody creates a new  OperationBody.
func NewOperationBody(aType OperationType, value interface{}) (result OperationBody, err error) {
	result.Type = aType
	switch OperationType(aType) {
	case OperationTypeCreateAccount:
		tv, ok := value.(CreateAccountOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateAccountOp")
			return
		}
		result.CreateAccountOp = &tv
	case OperationTypeCreateIssuanceRequest:
		tv, ok := value.(CreateIssuanceRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateIssuanceRequestOp")
			return
		}
		result.CreateIssuanceRequestOp = &tv
	case OperationTypeSetFees:
		tv, ok := value.(SetFeesOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be SetFeesOp")
			return
		}
		result.SetFeesOp = &tv
	case OperationTypeCreateWithdrawalRequest:
		tv, ok := value.(CreateWithdrawalRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateWithdrawalRequestOp")
			return
		}
		result.CreateWithdrawalRequestOp = &tv
	case OperationTypeManageBalance:
		tv, ok := value.(ManageBalanceOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageBalanceOp")
			return
		}
		result.ManageBalanceOp = &tv
	case OperationTypeManageAsset:
		tv, ok := value.(ManageAssetOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageAssetOp")
			return
		}
		result.ManageAssetOp = &tv
	case OperationTypeCreatePreissuanceRequest:
		tv, ok := value.(CreatePreIssuanceRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreatePreIssuanceRequestOp")
			return
		}
		result.CreatePreIssuanceRequest = &tv
	case OperationTypeManageLimits:
		tv, ok := value.(ManageLimitsOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageLimitsOp")
			return
		}
		result.ManageLimitsOp = &tv
	case OperationTypeManageAssetPair:
		tv, ok := value.(ManageAssetPairOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageAssetPairOp")
			return
		}
		result.ManageAssetPairOp = &tv
	case OperationTypeManageOffer:
		tv, ok := value.(ManageOfferOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageOfferOp")
			return
		}
		result.ManageOfferOp = &tv
	case OperationTypeManageInvoiceRequest:
		tv, ok := value.(ManageInvoiceRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageInvoiceRequestOp")
			return
		}
		result.ManageInvoiceRequestOp = &tv
	case OperationTypeReviewRequest:
		tv, ok := value.(ReviewRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be ReviewRequestOp")
			return
		}
		result.ReviewRequestOp = &tv
	case OperationTypeCreateSaleRequest:
		tv, ok := value.(CreateSaleCreationRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateSaleCreationRequestOp")
			return
		}
		result.CreateSaleCreationRequestOp = &tv
	case OperationTypeCheckSaleState:
		tv, ok := value.(CheckSaleStateOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CheckSaleStateOp")
			return
		}
		result.CheckSaleStateOp = &tv
	case OperationTypePayout:
		tv, ok := value.(PayoutOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be PayoutOp")
			return
		}
		result.PayoutOp = &tv
	case OperationTypeCreateAmlAlert:
		tv, ok := value.(CreateAmlAlertRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateAmlAlertRequestOp")
			return
		}
		result.CreateAmlAlertRequestOp = &tv
	case OperationTypeManageKeyValue:
		tv, ok := value.(ManageKeyValueOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageKeyValueOp")
			return
		}
		result.ManageKeyValueOp = &tv
	case OperationTypeCreateChangeRoleRequest:
		tv, ok := value.(CreateChangeRoleRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateChangeRoleRequestOp")
			return
		}
		result.CreateChangeRoleRequestOp = &tv
	case OperationTypeManageExternalSystemAccountIdPoolEntry:
		tv, ok := value.(ManageExternalSystemAccountIdPoolEntryOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageExternalSystemAccountIdPoolEntryOp")
			return
		}
		result.ManageExternalSystemAccountIdPoolEntryOp = &tv
	case OperationTypeBindExternalSystemAccountId:
		tv, ok := value.(BindExternalSystemAccountIdOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be BindExternalSystemAccountIdOp")
			return
		}
		result.BindExternalSystemAccountIdOp = &tv
	case OperationTypePayment:
		tv, ok := value.(PaymentOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be PaymentOp")
			return
		}
		result.PaymentOp = &tv
	case OperationTypeManageSale:
		tv, ok := value.(ManageSaleOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageSaleOp")
			return
		}
		result.ManageSaleOp = &tv
	case OperationTypeCreateManageLimitsRequest:
		tv, ok := value.(CreateManageLimitsRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateManageLimitsRequestOp")
			return
		}
		result.CreateManageLimitsRequestOp = &tv
	case OperationTypeManageContractRequest:
		tv, ok := value.(ManageContractRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageContractRequestOp")
			return
		}
		result.ManageContractRequestOp = &tv
	case OperationTypeManageContract:
		tv, ok := value.(ManageContractOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageContractOp")
			return
		}
		result.ManageContractOp = &tv
	case OperationTypeCancelSaleRequest:
		tv, ok := value.(CancelSaleCreationRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CancelSaleCreationRequestOp")
			return
		}
		result.CancelSaleCreationRequestOp = &tv
	case OperationTypeCreateAtomicSwapAskRequest:
		tv, ok := value.(CreateAtomicSwapAskRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateAtomicSwapAskRequestOp")
			return
		}
		result.CreateAtomicSwapAskRequestOp = &tv
	case OperationTypeCancelAtomicSwapAsk:
		tv, ok := value.(CancelAtomicSwapAskOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CancelAtomicSwapAskOp")
			return
		}
		result.CancelAtomicSwapAskOp = &tv
	case OperationTypeCreateAtomicSwapBidRequest:
		tv, ok := value.(CreateAtomicSwapBidRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateAtomicSwapBidRequestOp")
			return
		}
		result.CreateAtomicSwapBidRequestOp = &tv
	case OperationTypeManageAccountRole:
		tv, ok := value.(ManageAccountRoleOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageAccountRoleOp")
			return
		}
		result.ManageAccountRoleOp = &tv
	case OperationTypeManageAccountRule:
		tv, ok := value.(ManageAccountRuleOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageAccountRuleOp")
			return
		}
		result.ManageAccountRuleOp = &tv
	case OperationTypeManageSigner:
		tv, ok := value.(ManageSignerOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageSignerOp")
			return
		}
		result.ManageSignerOp = &tv
	case OperationTypeManageSignerRole:
		tv, ok := value.(ManageSignerRoleOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageSignerRoleOp")
			return
		}
		result.ManageSignerRoleOp = &tv
	case OperationTypeManageSignerRule:
		tv, ok := value.(ManageSignerRuleOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageSignerRuleOp")
			return
		}
		result.ManageSignerRuleOp = &tv
	case OperationTypeStamp:
		tv, ok := value.(StampOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be StampOp")
			return
		}
		result.StampOp = &tv
	case OperationTypeLicense:
		tv, ok := value.(LicenseOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be LicenseOp")
			return
		}
		result.LicenseOp = &tv
	case OperationTypeManageCreatePollRequest:
		tv, ok := value.(ManageCreatePollRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageCreatePollRequestOp")
			return
		}
		result.ManageCreatePollRequestOp = &tv
	case OperationTypeManagePoll:
		tv, ok := value.(ManagePollOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManagePollOp")
			return
		}
		result.ManagePollOp = &tv
	case OperationTypeManageVote:
		tv, ok := value.(ManageVoteOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageVoteOp")
			return
		}
		result.ManageVoteOp = &tv
	case OperationTypeManageAccountSpecificRule:
		tv, ok := value.(ManageAccountSpecificRuleOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageAccountSpecificRuleOp")
			return
		}
		result.ManageAccountSpecificRuleOp = &tv
	case OperationTypeCancelChangeRoleRequest:
		tv, ok := value.(CancelChangeRoleRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CancelChangeRoleRequestOp")
			return
		}
		result.CancelChangeRoleRequestOp = &tv
	case OperationTypeRemoveAssetPair:
		tv, ok := value.(RemoveAssetPairOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be RemoveAssetPairOp")
			return
		}
		result.RemoveAssetPairOp = &tv
	case OperationTypeInitiateKycRecovery:
		tv, ok := value.(InitiateKycRecoveryOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be InitiateKycRecoveryOp")
			return
		}
		result.InitiateKycRecoveryOp = &tv
	case OperationTypeCreateKycRecoveryRequest:
		tv, ok := value.(CreateKycRecoveryRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateKycRecoveryRequestOp")
			return
		}
		result.CreateKycRecoveryRequestOp = &tv
	case OperationTypeCreateManageOfferRequest:
		tv, ok := value.(CreateManageOfferRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateManageOfferRequestOp")
			return
		}
		result.CreateManageOfferRequestOp = &tv
	case OperationTypeCreatePaymentRequest:
		tv, ok := value.(CreatePaymentRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreatePaymentRequestOp")
			return
		}
		result.CreatePaymentRequestOp = &tv
	case OperationTypeRemoveAsset:
		tv, ok := value.(RemoveAssetOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be RemoveAssetOp")
			return
		}
		result.RemoveAssetOp = &tv
	case OperationTypeOpenSwap:
		tv, ok := value.(OpenSwapOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be OpenSwapOp")
			return
		}
		result.OpenSwapOp = &tv
	case OperationTypeCloseSwap:
		tv, ok := value.(CloseSwapOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CloseSwapOp")
			return
		}
		result.CloseSwapOp = &tv
	case OperationTypeCreateRedemptionRequest:
		tv, ok := value.(CreateRedemptionRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateRedemptionRequestOp")
			return
		}
		result.CreateRedemptionRequestOp = &tv
	case OperationTypeCreateData:
		tv, ok := value.(CreateDataOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateDataOp")
			return
		}
		result.CreateDataOp = &tv
	case OperationTypeUpdateData:
		tv, ok := value.(UpdateDataOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be UpdateDataOp")
			return
		}
		result.UpdateDataOp = &tv
	case OperationTypeRemoveData:
		tv, ok := value.(RemoveDataOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be RemoveDataOp")
			return
		}
		result.RemoveDataOp = &tv
	case OperationTypeCreateDataCreationRequest:
		tv, ok := value.(CreateDataCreationRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateDataCreationRequestOp")
			return
		}
		result.CreateDataCreationRequestOp = &tv
	case OperationTypeCancelDataCreationRequest:
		tv, ok := value.(CancelDataCreationRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CancelDataCreationRequestOp")
			return
		}
		result.CancelDataCreationRequestOp = &tv
	case OperationTypeCreateDataUpdateRequest:
		tv, ok := value.(CreateDataUpdateRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateDataUpdateRequestOp")
			return
		}
		result.CreateDataUpdateRequestOp = &tv
	case OperationTypeCreateDataRemoveRequest:
		tv, ok := value.(CreateDataRemoveRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateDataRemoveRequestOp")
			return
		}
		result.CreateDataRemoveRequestOp = &tv
	case OperationTypeCancelDataUpdateRequest:
		tv, ok := value.(CancelDataUpdateRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CancelDataUpdateRequestOp")
			return
		}
		result.CancelDataUpdateRequestOp = &tv
	case OperationTypeCancelDataRemoveRequest:
		tv, ok := value.(CancelDataRemoveRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CancelDataRemoveRequestOp")
			return
		}
		result.CancelDataRemoveRequestOp = &tv
	case OperationTypeCreateDeferredPaymentCreationRequest:
		tv, ok := value.(CreateDeferredPaymentCreationRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateDeferredPaymentCreationRequestOp")
			return
		}
		result.CreateDeferredPaymentCreationRequestOp = &tv
	case OperationTypeCancelDeferredPaymentCreationRequest:
		tv, ok := value.(CancelDeferredPaymentCreationRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CancelDeferredPaymentCreationRequestOp")
			return
		}
		result.CancelDeferredPaymentCreationRequestOp = &tv
	case OperationTypeCreateCloseDeferredPaymentRequest:
		tv, ok := value.(CreateCloseDeferredPaymentRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateCloseDeferredPaymentRequestOp")
			return
		}
		result.CreateCloseDeferredPaymentRequestOp = &tv
	case OperationTypeCancelCloseDeferredPaymentRequest:
		tv, ok := value.(CancelCloseDeferredPaymentRequestOp)
		if !ok {
			err = fmt.Errorf("invalid value, must be CancelCloseDeferredPaymentRequestOp")
			return
		}
		result.CancelCloseDeferredPaymentRequestOp = &tv
	}
	return
}

// MustCreateAccountOp retrieves the CreateAccountOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCreateAccountOp() CreateAccountOp {
	val, ok := u.GetCreateAccountOp()

	if !ok {
		panic("arm CreateAccountOp is not set")
	}

	return val
}

// GetCreateAccountOp retrieves the CreateAccountOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCreateAccountOp() (result CreateAccountOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateAccountOp" {
		result = *u.CreateAccountOp
		ok = true
	}

	return
}

// MustCreateIssuanceRequestOp retrieves the CreateIssuanceRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCreateIssuanceRequestOp() CreateIssuanceRequestOp {
	val, ok := u.GetCreateIssuanceRequestOp()

	if !ok {
		panic("arm CreateIssuanceRequestOp is not set")
	}

	return val
}

// GetCreateIssuanceRequestOp retrieves the CreateIssuanceRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCreateIssuanceRequestOp() (result CreateIssuanceRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateIssuanceRequestOp" {
		result = *u.CreateIssuanceRequestOp
		ok = true
	}

	return
}

// MustSetFeesOp retrieves the SetFeesOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustSetFeesOp() SetFeesOp {
	val, ok := u.GetSetFeesOp()

	if !ok {
		panic("arm SetFeesOp is not set")
	}

	return val
}

// GetSetFeesOp retrieves the SetFeesOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetSetFeesOp() (result SetFeesOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "SetFeesOp" {
		result = *u.SetFeesOp
		ok = true
	}

	return
}

// MustCreateWithdrawalRequestOp retrieves the CreateWithdrawalRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCreateWithdrawalRequestOp() CreateWithdrawalRequestOp {
	val, ok := u.GetCreateWithdrawalRequestOp()

	if !ok {
		panic("arm CreateWithdrawalRequestOp is not set")
	}

	return val
}

// GetCreateWithdrawalRequestOp retrieves the CreateWithdrawalRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCreateWithdrawalRequestOp() (result CreateWithdrawalRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateWithdrawalRequestOp" {
		result = *u.CreateWithdrawalRequestOp
		ok = true
	}

	return
}

// MustManageBalanceOp retrieves the ManageBalanceOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustManageBalanceOp() ManageBalanceOp {
	val, ok := u.GetManageBalanceOp()

	if !ok {
		panic("arm ManageBalanceOp is not set")
	}

	return val
}

// GetManageBalanceOp retrieves the ManageBalanceOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetManageBalanceOp() (result ManageBalanceOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageBalanceOp" {
		result = *u.ManageBalanceOp
		ok = true
	}

	return
}

// MustManageAssetOp retrieves the ManageAssetOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustManageAssetOp() ManageAssetOp {
	val, ok := u.GetManageAssetOp()

	if !ok {
		panic("arm ManageAssetOp is not set")
	}

	return val
}

// GetManageAssetOp retrieves the ManageAssetOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetManageAssetOp() (result ManageAssetOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageAssetOp" {
		result = *u.ManageAssetOp
		ok = true
	}

	return
}

// MustCreatePreIssuanceRequest retrieves the CreatePreIssuanceRequest value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCreatePreIssuanceRequest() CreatePreIssuanceRequestOp {
	val, ok := u.GetCreatePreIssuanceRequest()

	if !ok {
		panic("arm CreatePreIssuanceRequest is not set")
	}

	return val
}

// GetCreatePreIssuanceRequest retrieves the CreatePreIssuanceRequest value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCreatePreIssuanceRequest() (result CreatePreIssuanceRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreatePreIssuanceRequest" {
		result = *u.CreatePreIssuanceRequest
		ok = true
	}

	return
}

// MustManageLimitsOp retrieves the ManageLimitsOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustManageLimitsOp() ManageLimitsOp {
	val, ok := u.GetManageLimitsOp()

	if !ok {
		panic("arm ManageLimitsOp is not set")
	}

	return val
}

// GetManageLimitsOp retrieves the ManageLimitsOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetManageLimitsOp() (result ManageLimitsOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageLimitsOp" {
		result = *u.ManageLimitsOp
		ok = true
	}

	return
}

// MustManageAssetPairOp retrieves the ManageAssetPairOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustManageAssetPairOp() ManageAssetPairOp {
	val, ok := u.GetManageAssetPairOp()

	if !ok {
		panic("arm ManageAssetPairOp is not set")
	}

	return val
}

// GetManageAssetPairOp retrieves the ManageAssetPairOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetManageAssetPairOp() (result ManageAssetPairOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageAssetPairOp" {
		result = *u.ManageAssetPairOp
		ok = true
	}

	return
}

// MustManageOfferOp retrieves the ManageOfferOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustManageOfferOp() ManageOfferOp {
	val, ok := u.GetManageOfferOp()

	if !ok {
		panic("arm ManageOfferOp is not set")
	}

	return val
}

// GetManageOfferOp retrieves the ManageOfferOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetManageOfferOp() (result ManageOfferOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageOfferOp" {
		result = *u.ManageOfferOp
		ok = true
	}

	return
}

// MustManageInvoiceRequestOp retrieves the ManageInvoiceRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustManageInvoiceRequestOp() ManageInvoiceRequestOp {
	val, ok := u.GetManageInvoiceRequestOp()

	if !ok {
		panic("arm ManageInvoiceRequestOp is not set")
	}

	return val
}

// GetManageInvoiceRequestOp retrieves the ManageInvoiceRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetManageInvoiceRequestOp() (result ManageInvoiceRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageInvoiceRequestOp" {
		result = *u.ManageInvoiceRequestOp
		ok = true
	}

	return
}

// MustReviewRequestOp retrieves the ReviewRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustReviewRequestOp() ReviewRequestOp {
	val, ok := u.GetReviewRequestOp()

	if !ok {
		panic("arm ReviewRequestOp is not set")
	}

	return val
}

// GetReviewRequestOp retrieves the ReviewRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetReviewRequestOp() (result ReviewRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ReviewRequestOp" {
		result = *u.ReviewRequestOp
		ok = true
	}

	return
}

// MustCreateSaleCreationRequestOp retrieves the CreateSaleCreationRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCreateSaleCreationRequestOp() CreateSaleCreationRequestOp {
	val, ok := u.GetCreateSaleCreationRequestOp()

	if !ok {
		panic("arm CreateSaleCreationRequestOp is not set")
	}

	return val
}

// GetCreateSaleCreationRequestOp retrieves the CreateSaleCreationRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCreateSaleCreationRequestOp() (result CreateSaleCreationRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateSaleCreationRequestOp" {
		result = *u.CreateSaleCreationRequestOp
		ok = true
	}

	return
}

// MustCheckSaleStateOp retrieves the CheckSaleStateOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCheckSaleStateOp() CheckSaleStateOp {
	val, ok := u.GetCheckSaleStateOp()

	if !ok {
		panic("arm CheckSaleStateOp is not set")
	}

	return val
}

// GetCheckSaleStateOp retrieves the CheckSaleStateOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCheckSaleStateOp() (result CheckSaleStateOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CheckSaleStateOp" {
		result = *u.CheckSaleStateOp
		ok = true
	}

	return
}

// MustPayoutOp retrieves the PayoutOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustPayoutOp() PayoutOp {
	val, ok := u.GetPayoutOp()

	if !ok {
		panic("arm PayoutOp is not set")
	}

	return val
}

// GetPayoutOp retrieves the PayoutOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetPayoutOp() (result PayoutOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "PayoutOp" {
		result = *u.PayoutOp
		ok = true
	}

	return
}

// MustCreateAmlAlertRequestOp retrieves the CreateAmlAlertRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCreateAmlAlertRequestOp() CreateAmlAlertRequestOp {
	val, ok := u.GetCreateAmlAlertRequestOp()

	if !ok {
		panic("arm CreateAmlAlertRequestOp is not set")
	}

	return val
}

// GetCreateAmlAlertRequestOp retrieves the CreateAmlAlertRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCreateAmlAlertRequestOp() (result CreateAmlAlertRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateAmlAlertRequestOp" {
		result = *u.CreateAmlAlertRequestOp
		ok = true
	}

	return
}

// MustManageKeyValueOp retrieves the ManageKeyValueOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustManageKeyValueOp() ManageKeyValueOp {
	val, ok := u.GetManageKeyValueOp()

	if !ok {
		panic("arm ManageKeyValueOp is not set")
	}

	return val
}

// GetManageKeyValueOp retrieves the ManageKeyValueOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetManageKeyValueOp() (result ManageKeyValueOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageKeyValueOp" {
		result = *u.ManageKeyValueOp
		ok = true
	}

	return
}

// MustCreateChangeRoleRequestOp retrieves the CreateChangeRoleRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCreateChangeRoleRequestOp() CreateChangeRoleRequestOp {
	val, ok := u.GetCreateChangeRoleRequestOp()

	if !ok {
		panic("arm CreateChangeRoleRequestOp is not set")
	}

	return val
}

// GetCreateChangeRoleRequestOp retrieves the CreateChangeRoleRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCreateChangeRoleRequestOp() (result CreateChangeRoleRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateChangeRoleRequestOp" {
		result = *u.CreateChangeRoleRequestOp
		ok = true
	}

	return
}

// MustManageExternalSystemAccountIdPoolEntryOp retrieves the ManageExternalSystemAccountIdPoolEntryOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustManageExternalSystemAccountIdPoolEntryOp() ManageExternalSystemAccountIdPoolEntryOp {
	val, ok := u.GetManageExternalSystemAccountIdPoolEntryOp()

	if !ok {
		panic("arm ManageExternalSystemAccountIdPoolEntryOp is not set")
	}

	return val
}

// GetManageExternalSystemAccountIdPoolEntryOp retrieves the ManageExternalSystemAccountIdPoolEntryOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetManageExternalSystemAccountIdPoolEntryOp() (result ManageExternalSystemAccountIdPoolEntryOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageExternalSystemAccountIdPoolEntryOp" {
		result = *u.ManageExternalSystemAccountIdPoolEntryOp
		ok = true
	}

	return
}

// MustBindExternalSystemAccountIdOp retrieves the BindExternalSystemAccountIdOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustBindExternalSystemAccountIdOp() BindExternalSystemAccountIdOp {
	val, ok := u.GetBindExternalSystemAccountIdOp()

	if !ok {
		panic("arm BindExternalSystemAccountIdOp is not set")
	}

	return val
}

// GetBindExternalSystemAccountIdOp retrieves the BindExternalSystemAccountIdOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetBindExternalSystemAccountIdOp() (result BindExternalSystemAccountIdOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "BindExternalSystemAccountIdOp" {
		result = *u.BindExternalSystemAccountIdOp
		ok = true
	}

	return
}

// MustPaymentOp retrieves the PaymentOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustPaymentOp() PaymentOp {
	val, ok := u.GetPaymentOp()

	if !ok {
		panic("arm PaymentOp is not set")
	}

	return val
}

// GetPaymentOp retrieves the PaymentOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetPaymentOp() (result PaymentOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "PaymentOp" {
		result = *u.PaymentOp
		ok = true
	}

	return
}

// MustManageSaleOp retrieves the ManageSaleOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustManageSaleOp() ManageSaleOp {
	val, ok := u.GetManageSaleOp()

	if !ok {
		panic("arm ManageSaleOp is not set")
	}

	return val
}

// GetManageSaleOp retrieves the ManageSaleOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetManageSaleOp() (result ManageSaleOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageSaleOp" {
		result = *u.ManageSaleOp
		ok = true
	}

	return
}

// MustCreateManageLimitsRequestOp retrieves the CreateManageLimitsRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCreateManageLimitsRequestOp() CreateManageLimitsRequestOp {
	val, ok := u.GetCreateManageLimitsRequestOp()

	if !ok {
		panic("arm CreateManageLimitsRequestOp is not set")
	}

	return val
}

// GetCreateManageLimitsRequestOp retrieves the CreateManageLimitsRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCreateManageLimitsRequestOp() (result CreateManageLimitsRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateManageLimitsRequestOp" {
		result = *u.CreateManageLimitsRequestOp
		ok = true
	}

	return
}

// MustManageContractRequestOp retrieves the ManageContractRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustManageContractRequestOp() ManageContractRequestOp {
	val, ok := u.GetManageContractRequestOp()

	if !ok {
		panic("arm ManageContractRequestOp is not set")
	}

	return val
}

// GetManageContractRequestOp retrieves the ManageContractRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetManageContractRequestOp() (result ManageContractRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageContractRequestOp" {
		result = *u.ManageContractRequestOp
		ok = true
	}

	return
}

// MustManageContractOp retrieves the ManageContractOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustManageContractOp() ManageContractOp {
	val, ok := u.GetManageContractOp()

	if !ok {
		panic("arm ManageContractOp is not set")
	}

	return val
}

// GetManageContractOp retrieves the ManageContractOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetManageContractOp() (result ManageContractOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageContractOp" {
		result = *u.ManageContractOp
		ok = true
	}

	return
}

// MustCancelSaleCreationRequestOp retrieves the CancelSaleCreationRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCancelSaleCreationRequestOp() CancelSaleCreationRequestOp {
	val, ok := u.GetCancelSaleCreationRequestOp()

	if !ok {
		panic("arm CancelSaleCreationRequestOp is not set")
	}

	return val
}

// GetCancelSaleCreationRequestOp retrieves the CancelSaleCreationRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCancelSaleCreationRequestOp() (result CancelSaleCreationRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CancelSaleCreationRequestOp" {
		result = *u.CancelSaleCreationRequestOp
		ok = true
	}

	return
}

// MustCreateAtomicSwapAskRequestOp retrieves the CreateAtomicSwapAskRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCreateAtomicSwapAskRequestOp() CreateAtomicSwapAskRequestOp {
	val, ok := u.GetCreateAtomicSwapAskRequestOp()

	if !ok {
		panic("arm CreateAtomicSwapAskRequestOp is not set")
	}

	return val
}

// GetCreateAtomicSwapAskRequestOp retrieves the CreateAtomicSwapAskRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCreateAtomicSwapAskRequestOp() (result CreateAtomicSwapAskRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateAtomicSwapAskRequestOp" {
		result = *u.CreateAtomicSwapAskRequestOp
		ok = true
	}

	return
}

// MustCancelAtomicSwapAskOp retrieves the CancelAtomicSwapAskOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCancelAtomicSwapAskOp() CancelAtomicSwapAskOp {
	val, ok := u.GetCancelAtomicSwapAskOp()

	if !ok {
		panic("arm CancelAtomicSwapAskOp is not set")
	}

	return val
}

// GetCancelAtomicSwapAskOp retrieves the CancelAtomicSwapAskOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCancelAtomicSwapAskOp() (result CancelAtomicSwapAskOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CancelAtomicSwapAskOp" {
		result = *u.CancelAtomicSwapAskOp
		ok = true
	}

	return
}

// MustCreateAtomicSwapBidRequestOp retrieves the CreateAtomicSwapBidRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCreateAtomicSwapBidRequestOp() CreateAtomicSwapBidRequestOp {
	val, ok := u.GetCreateAtomicSwapBidRequestOp()

	if !ok {
		panic("arm CreateAtomicSwapBidRequestOp is not set")
	}

	return val
}

// GetCreateAtomicSwapBidRequestOp retrieves the CreateAtomicSwapBidRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCreateAtomicSwapBidRequestOp() (result CreateAtomicSwapBidRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateAtomicSwapBidRequestOp" {
		result = *u.CreateAtomicSwapBidRequestOp
		ok = true
	}

	return
}

// MustManageAccountRoleOp retrieves the ManageAccountRoleOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustManageAccountRoleOp() ManageAccountRoleOp {
	val, ok := u.GetManageAccountRoleOp()

	if !ok {
		panic("arm ManageAccountRoleOp is not set")
	}

	return val
}

// GetManageAccountRoleOp retrieves the ManageAccountRoleOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetManageAccountRoleOp() (result ManageAccountRoleOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageAccountRoleOp" {
		result = *u.ManageAccountRoleOp
		ok = true
	}

	return
}

// MustManageAccountRuleOp retrieves the ManageAccountRuleOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustManageAccountRuleOp() ManageAccountRuleOp {
	val, ok := u.GetManageAccountRuleOp()

	if !ok {
		panic("arm ManageAccountRuleOp is not set")
	}

	return val
}

// GetManageAccountRuleOp retrieves the ManageAccountRuleOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetManageAccountRuleOp() (result ManageAccountRuleOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageAccountRuleOp" {
		result = *u.ManageAccountRuleOp
		ok = true
	}

	return
}

// MustManageSignerOp retrieves the ManageSignerOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustManageSignerOp() ManageSignerOp {
	val, ok := u.GetManageSignerOp()

	if !ok {
		panic("arm ManageSignerOp is not set")
	}

	return val
}

// GetManageSignerOp retrieves the ManageSignerOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetManageSignerOp() (result ManageSignerOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageSignerOp" {
		result = *u.ManageSignerOp
		ok = true
	}

	return
}

// MustManageSignerRoleOp retrieves the ManageSignerRoleOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustManageSignerRoleOp() ManageSignerRoleOp {
	val, ok := u.GetManageSignerRoleOp()

	if !ok {
		panic("arm ManageSignerRoleOp is not set")
	}

	return val
}

// GetManageSignerRoleOp retrieves the ManageSignerRoleOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetManageSignerRoleOp() (result ManageSignerRoleOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageSignerRoleOp" {
		result = *u.ManageSignerRoleOp
		ok = true
	}

	return
}

// MustManageSignerRuleOp retrieves the ManageSignerRuleOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustManageSignerRuleOp() ManageSignerRuleOp {
	val, ok := u.GetManageSignerRuleOp()

	if !ok {
		panic("arm ManageSignerRuleOp is not set")
	}

	return val
}

// GetManageSignerRuleOp retrieves the ManageSignerRuleOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetManageSignerRuleOp() (result ManageSignerRuleOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageSignerRuleOp" {
		result = *u.ManageSignerRuleOp
		ok = true
	}

	return
}

// MustStampOp retrieves the StampOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustStampOp() StampOp {
	val, ok := u.GetStampOp()

	if !ok {
		panic("arm StampOp is not set")
	}

	return val
}

// GetStampOp retrieves the StampOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetStampOp() (result StampOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "StampOp" {
		result = *u.StampOp
		ok = true
	}

	return
}

// MustLicenseOp retrieves the LicenseOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustLicenseOp() LicenseOp {
	val, ok := u.GetLicenseOp()

	if !ok {
		panic("arm LicenseOp is not set")
	}

	return val
}

// GetLicenseOp retrieves the LicenseOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetLicenseOp() (result LicenseOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "LicenseOp" {
		result = *u.LicenseOp
		ok = true
	}

	return
}

// MustManageCreatePollRequestOp retrieves the ManageCreatePollRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustManageCreatePollRequestOp() ManageCreatePollRequestOp {
	val, ok := u.GetManageCreatePollRequestOp()

	if !ok {
		panic("arm ManageCreatePollRequestOp is not set")
	}

	return val
}

// GetManageCreatePollRequestOp retrieves the ManageCreatePollRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetManageCreatePollRequestOp() (result ManageCreatePollRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageCreatePollRequestOp" {
		result = *u.ManageCreatePollRequestOp
		ok = true
	}

	return
}

// MustManagePollOp retrieves the ManagePollOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustManagePollOp() ManagePollOp {
	val, ok := u.GetManagePollOp()

	if !ok {
		panic("arm ManagePollOp is not set")
	}

	return val
}

// GetManagePollOp retrieves the ManagePollOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetManagePollOp() (result ManagePollOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManagePollOp" {
		result = *u.ManagePollOp
		ok = true
	}

	return
}

// MustManageVoteOp retrieves the ManageVoteOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustManageVoteOp() ManageVoteOp {
	val, ok := u.GetManageVoteOp()

	if !ok {
		panic("arm ManageVoteOp is not set")
	}

	return val
}

// GetManageVoteOp retrieves the ManageVoteOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetManageVoteOp() (result ManageVoteOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageVoteOp" {
		result = *u.ManageVoteOp
		ok = true
	}

	return
}

// MustManageAccountSpecificRuleOp retrieves the ManageAccountSpecificRuleOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustManageAccountSpecificRuleOp() ManageAccountSpecificRuleOp {
	val, ok := u.GetManageAccountSpecificRuleOp()

	if !ok {
		panic("arm ManageAccountSpecificRuleOp is not set")
	}

	return val
}

// GetManageAccountSpecificRuleOp retrieves the ManageAccountSpecificRuleOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetManageAccountSpecificRuleOp() (result ManageAccountSpecificRuleOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageAccountSpecificRuleOp" {
		result = *u.ManageAccountSpecificRuleOp
		ok = true
	}

	return
}

// MustCancelChangeRoleRequestOp retrieves the CancelChangeRoleRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCancelChangeRoleRequestOp() CancelChangeRoleRequestOp {
	val, ok := u.GetCancelChangeRoleRequestOp()

	if !ok {
		panic("arm CancelChangeRoleRequestOp is not set")
	}

	return val
}

// GetCancelChangeRoleRequestOp retrieves the CancelChangeRoleRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCancelChangeRoleRequestOp() (result CancelChangeRoleRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CancelChangeRoleRequestOp" {
		result = *u.CancelChangeRoleRequestOp
		ok = true
	}

	return
}

// MustRemoveAssetPairOp retrieves the RemoveAssetPairOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustRemoveAssetPairOp() RemoveAssetPairOp {
	val, ok := u.GetRemoveAssetPairOp()

	if !ok {
		panic("arm RemoveAssetPairOp is not set")
	}

	return val
}

// GetRemoveAssetPairOp retrieves the RemoveAssetPairOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetRemoveAssetPairOp() (result RemoveAssetPairOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "RemoveAssetPairOp" {
		result = *u.RemoveAssetPairOp
		ok = true
	}

	return
}

// MustInitiateKycRecoveryOp retrieves the InitiateKycRecoveryOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustInitiateKycRecoveryOp() InitiateKycRecoveryOp {
	val, ok := u.GetInitiateKycRecoveryOp()

	if !ok {
		panic("arm InitiateKycRecoveryOp is not set")
	}

	return val
}

// GetInitiateKycRecoveryOp retrieves the InitiateKycRecoveryOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetInitiateKycRecoveryOp() (result InitiateKycRecoveryOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "InitiateKycRecoveryOp" {
		result = *u.InitiateKycRecoveryOp
		ok = true
	}

	return
}

// MustCreateKycRecoveryRequestOp retrieves the CreateKycRecoveryRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCreateKycRecoveryRequestOp() CreateKycRecoveryRequestOp {
	val, ok := u.GetCreateKycRecoveryRequestOp()

	if !ok {
		panic("arm CreateKycRecoveryRequestOp is not set")
	}

	return val
}

// GetCreateKycRecoveryRequestOp retrieves the CreateKycRecoveryRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCreateKycRecoveryRequestOp() (result CreateKycRecoveryRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateKycRecoveryRequestOp" {
		result = *u.CreateKycRecoveryRequestOp
		ok = true
	}

	return
}

// MustCreateManageOfferRequestOp retrieves the CreateManageOfferRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCreateManageOfferRequestOp() CreateManageOfferRequestOp {
	val, ok := u.GetCreateManageOfferRequestOp()

	if !ok {
		panic("arm CreateManageOfferRequestOp is not set")
	}

	return val
}

// GetCreateManageOfferRequestOp retrieves the CreateManageOfferRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCreateManageOfferRequestOp() (result CreateManageOfferRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateManageOfferRequestOp" {
		result = *u.CreateManageOfferRequestOp
		ok = true
	}

	return
}

// MustCreatePaymentRequestOp retrieves the CreatePaymentRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCreatePaymentRequestOp() CreatePaymentRequestOp {
	val, ok := u.GetCreatePaymentRequestOp()

	if !ok {
		panic("arm CreatePaymentRequestOp is not set")
	}

	return val
}

// GetCreatePaymentRequestOp retrieves the CreatePaymentRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCreatePaymentRequestOp() (result CreatePaymentRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreatePaymentRequestOp" {
		result = *u.CreatePaymentRequestOp
		ok = true
	}

	return
}

// MustRemoveAssetOp retrieves the RemoveAssetOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustRemoveAssetOp() RemoveAssetOp {
	val, ok := u.GetRemoveAssetOp()

	if !ok {
		panic("arm RemoveAssetOp is not set")
	}

	return val
}

// GetRemoveAssetOp retrieves the RemoveAssetOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetRemoveAssetOp() (result RemoveAssetOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "RemoveAssetOp" {
		result = *u.RemoveAssetOp
		ok = true
	}

	return
}

// MustOpenSwapOp retrieves the OpenSwapOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustOpenSwapOp() OpenSwapOp {
	val, ok := u.GetOpenSwapOp()

	if !ok {
		panic("arm OpenSwapOp is not set")
	}

	return val
}

// GetOpenSwapOp retrieves the OpenSwapOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetOpenSwapOp() (result OpenSwapOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "OpenSwapOp" {
		result = *u.OpenSwapOp
		ok = true
	}

	return
}

// MustCloseSwapOp retrieves the CloseSwapOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCloseSwapOp() CloseSwapOp {
	val, ok := u.GetCloseSwapOp()

	if !ok {
		panic("arm CloseSwapOp is not set")
	}

	return val
}

// GetCloseSwapOp retrieves the CloseSwapOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCloseSwapOp() (result CloseSwapOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CloseSwapOp" {
		result = *u.CloseSwapOp
		ok = true
	}

	return
}

// MustCreateRedemptionRequestOp retrieves the CreateRedemptionRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCreateRedemptionRequestOp() CreateRedemptionRequestOp {
	val, ok := u.GetCreateRedemptionRequestOp()

	if !ok {
		panic("arm CreateRedemptionRequestOp is not set")
	}

	return val
}

// GetCreateRedemptionRequestOp retrieves the CreateRedemptionRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCreateRedemptionRequestOp() (result CreateRedemptionRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateRedemptionRequestOp" {
		result = *u.CreateRedemptionRequestOp
		ok = true
	}

	return
}

// MustCreateDataOp retrieves the CreateDataOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCreateDataOp() CreateDataOp {
	val, ok := u.GetCreateDataOp()

	if !ok {
		panic("arm CreateDataOp is not set")
	}

	return val
}

// GetCreateDataOp retrieves the CreateDataOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCreateDataOp() (result CreateDataOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateDataOp" {
		result = *u.CreateDataOp
		ok = true
	}

	return
}

// MustUpdateDataOp retrieves the UpdateDataOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustUpdateDataOp() UpdateDataOp {
	val, ok := u.GetUpdateDataOp()

	if !ok {
		panic("arm UpdateDataOp is not set")
	}

	return val
}

// GetUpdateDataOp retrieves the UpdateDataOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetUpdateDataOp() (result UpdateDataOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "UpdateDataOp" {
		result = *u.UpdateDataOp
		ok = true
	}

	return
}

// MustRemoveDataOp retrieves the RemoveDataOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustRemoveDataOp() RemoveDataOp {
	val, ok := u.GetRemoveDataOp()

	if !ok {
		panic("arm RemoveDataOp is not set")
	}

	return val
}

// GetRemoveDataOp retrieves the RemoveDataOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetRemoveDataOp() (result RemoveDataOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "RemoveDataOp" {
		result = *u.RemoveDataOp
		ok = true
	}

	return
}

// MustCreateDataCreationRequestOp retrieves the CreateDataCreationRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCreateDataCreationRequestOp() CreateDataCreationRequestOp {
	val, ok := u.GetCreateDataCreationRequestOp()

	if !ok {
		panic("arm CreateDataCreationRequestOp is not set")
	}

	return val
}

// GetCreateDataCreationRequestOp retrieves the CreateDataCreationRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCreateDataCreationRequestOp() (result CreateDataCreationRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateDataCreationRequestOp" {
		result = *u.CreateDataCreationRequestOp
		ok = true
	}

	return
}

// MustCancelDataCreationRequestOp retrieves the CancelDataCreationRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCancelDataCreationRequestOp() CancelDataCreationRequestOp {
	val, ok := u.GetCancelDataCreationRequestOp()

	if !ok {
		panic("arm CancelDataCreationRequestOp is not set")
	}

	return val
}

// GetCancelDataCreationRequestOp retrieves the CancelDataCreationRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCancelDataCreationRequestOp() (result CancelDataCreationRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CancelDataCreationRequestOp" {
		result = *u.CancelDataCreationRequestOp
		ok = true
	}

	return
}

// MustCreateDataUpdateRequestOp retrieves the CreateDataUpdateRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCreateDataUpdateRequestOp() CreateDataUpdateRequestOp {
	val, ok := u.GetCreateDataUpdateRequestOp()

	if !ok {
		panic("arm CreateDataUpdateRequestOp is not set")
	}

	return val
}

// GetCreateDataUpdateRequestOp retrieves the CreateDataUpdateRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCreateDataUpdateRequestOp() (result CreateDataUpdateRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateDataUpdateRequestOp" {
		result = *u.CreateDataUpdateRequestOp
		ok = true
	}

	return
}

// MustCreateDataRemoveRequestOp retrieves the CreateDataRemoveRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCreateDataRemoveRequestOp() CreateDataRemoveRequestOp {
	val, ok := u.GetCreateDataRemoveRequestOp()

	if !ok {
		panic("arm CreateDataRemoveRequestOp is not set")
	}

	return val
}

// GetCreateDataRemoveRequestOp retrieves the CreateDataRemoveRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCreateDataRemoveRequestOp() (result CreateDataRemoveRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateDataRemoveRequestOp" {
		result = *u.CreateDataRemoveRequestOp
		ok = true
	}

	return
}

// MustCancelDataUpdateRequestOp retrieves the CancelDataUpdateRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCancelDataUpdateRequestOp() CancelDataUpdateRequestOp {
	val, ok := u.GetCancelDataUpdateRequestOp()

	if !ok {
		panic("arm CancelDataUpdateRequestOp is not set")
	}

	return val
}

// GetCancelDataUpdateRequestOp retrieves the CancelDataUpdateRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCancelDataUpdateRequestOp() (result CancelDataUpdateRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CancelDataUpdateRequestOp" {
		result = *u.CancelDataUpdateRequestOp
		ok = true
	}

	return
}

// MustCancelDataRemoveRequestOp retrieves the CancelDataRemoveRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCancelDataRemoveRequestOp() CancelDataRemoveRequestOp {
	val, ok := u.GetCancelDataRemoveRequestOp()

	if !ok {
		panic("arm CancelDataRemoveRequestOp is not set")
	}

	return val
}

// GetCancelDataRemoveRequestOp retrieves the CancelDataRemoveRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCancelDataRemoveRequestOp() (result CancelDataRemoveRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CancelDataRemoveRequestOp" {
		result = *u.CancelDataRemoveRequestOp
		ok = true
	}

	return
}

// MustCreateDeferredPaymentCreationRequestOp retrieves the CreateDeferredPaymentCreationRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCreateDeferredPaymentCreationRequestOp() CreateDeferredPaymentCreationRequestOp {
	val, ok := u.GetCreateDeferredPaymentCreationRequestOp()

	if !ok {
		panic("arm CreateDeferredPaymentCreationRequestOp is not set")
	}

	return val
}

// GetCreateDeferredPaymentCreationRequestOp retrieves the CreateDeferredPaymentCreationRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCreateDeferredPaymentCreationRequestOp() (result CreateDeferredPaymentCreationRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateDeferredPaymentCreationRequestOp" {
		result = *u.CreateDeferredPaymentCreationRequestOp
		ok = true
	}

	return
}

// MustCancelDeferredPaymentCreationRequestOp retrieves the CancelDeferredPaymentCreationRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCancelDeferredPaymentCreationRequestOp() CancelDeferredPaymentCreationRequestOp {
	val, ok := u.GetCancelDeferredPaymentCreationRequestOp()

	if !ok {
		panic("arm CancelDeferredPaymentCreationRequestOp is not set")
	}

	return val
}

// GetCancelDeferredPaymentCreationRequestOp retrieves the CancelDeferredPaymentCreationRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCancelDeferredPaymentCreationRequestOp() (result CancelDeferredPaymentCreationRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CancelDeferredPaymentCreationRequestOp" {
		result = *u.CancelDeferredPaymentCreationRequestOp
		ok = true
	}

	return
}

// MustCreateCloseDeferredPaymentRequestOp retrieves the CreateCloseDeferredPaymentRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCreateCloseDeferredPaymentRequestOp() CreateCloseDeferredPaymentRequestOp {
	val, ok := u.GetCreateCloseDeferredPaymentRequestOp()

	if !ok {
		panic("arm CreateCloseDeferredPaymentRequestOp is not set")
	}

	return val
}

// GetCreateCloseDeferredPaymentRequestOp retrieves the CreateCloseDeferredPaymentRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCreateCloseDeferredPaymentRequestOp() (result CreateCloseDeferredPaymentRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateCloseDeferredPaymentRequestOp" {
		result = *u.CreateCloseDeferredPaymentRequestOp
		ok = true
	}

	return
}

// MustCancelCloseDeferredPaymentRequestOp retrieves the CancelCloseDeferredPaymentRequestOp value from the union,
// panicing if the value is not set.
func (u OperationBody) MustCancelCloseDeferredPaymentRequestOp() CancelCloseDeferredPaymentRequestOp {
	val, ok := u.GetCancelCloseDeferredPaymentRequestOp()

	if !ok {
		panic("arm CancelCloseDeferredPaymentRequestOp is not set")
	}

	return val
}

// GetCancelCloseDeferredPaymentRequestOp retrieves the CancelCloseDeferredPaymentRequestOp value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationBody) GetCancelCloseDeferredPaymentRequestOp() (result CancelCloseDeferredPaymentRequestOp, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CancelCloseDeferredPaymentRequestOp" {
		result = *u.CancelCloseDeferredPaymentRequestOp
		ok = true
	}

	return
}

// Operation is an XDR Struct defines as:
//
//   //: An operation is the lowest unit of work that a transaction does
//    struct Operation
//    {
//        //: sourceAccount is the account used to run the operation
//        //: if not set, the runtime defaults to "sourceAccount" specified at
//        //: the transaction level
//        AccountID* sourceAccount;
//
//        union switch (OperationType type)
//        {
//        case CREATE_ACCOUNT:
//            CreateAccountOp createAccountOp;
//    	case CREATE_ISSUANCE_REQUEST:
//    		CreateIssuanceRequestOp createIssuanceRequestOp;
//        case SET_FEES:
//            SetFeesOp setFeesOp;
//    	case CREATE_WITHDRAWAL_REQUEST:
//    		CreateWithdrawalRequestOp createWithdrawalRequestOp;
//    	case MANAGE_BALANCE:
//    		ManageBalanceOp manageBalanceOp;
//        case MANAGE_ASSET:
//            ManageAssetOp manageAssetOp;
//        case CREATE_PREISSUANCE_REQUEST:
//            CreatePreIssuanceRequestOp createPreIssuanceRequest;
//        case MANAGE_LIMITS:
//            ManageLimitsOp manageLimitsOp;
//    	case MANAGE_ASSET_PAIR:
//    		ManageAssetPairOp manageAssetPairOp;
//    	case MANAGE_OFFER:
//    		ManageOfferOp manageOfferOp;
//        case MANAGE_INVOICE_REQUEST:
//            ManageInvoiceRequestOp manageInvoiceRequestOp;
//    	case REVIEW_REQUEST:
//    		ReviewRequestOp reviewRequestOp;
//    	case CREATE_SALE_REQUEST:
//    		CreateSaleCreationRequestOp createSaleCreationRequestOp;
//    	case CHECK_SALE_STATE:
//    		CheckSaleStateOp checkSaleStateOp;
//    	case PAYOUT:
//    	    PayoutOp payoutOp;
//    	case CREATE_AML_ALERT:
//    	    CreateAMLAlertRequestOp createAMLAlertRequestOp;
//    	case MANAGE_KEY_VALUE:
//    	    ManageKeyValueOp manageKeyValueOp;
//    	case CREATE_CHANGE_ROLE_REQUEST:
//    		CreateChangeRoleRequestOp createChangeRoleRequestOp;
//        case MANAGE_EXTERNAL_SYSTEM_ACCOUNT_ID_POOL_ENTRY:
//            ManageExternalSystemAccountIdPoolEntryOp manageExternalSystemAccountIdPoolEntryOp;
//        case BIND_EXTERNAL_SYSTEM_ACCOUNT_ID:
//            BindExternalSystemAccountIdOp bindExternalSystemAccountIdOp;
//        case PAYMENT:
//            PaymentOp paymentOp;
//        case MANAGE_SALE:
//            ManageSaleOp manageSaleOp;
//        case CREATE_MANAGE_LIMITS_REQUEST:
//            CreateManageLimitsRequestOp createManageLimitsRequestOp;
//        case MANAGE_CONTRACT_REQUEST:
//            ManageContractRequestOp manageContractRequestOp;
//        case MANAGE_CONTRACT:
//            ManageContractOp manageContractOp;
//        case CANCEL_SALE_REQUEST:
//            CancelSaleCreationRequestOp cancelSaleCreationRequestOp;
//        case CREATE_ATOMIC_SWAP_ASK_REQUEST:
//            CreateAtomicSwapAskRequestOp createAtomicSwapAskRequestOp;
//        case CANCEL_ATOMIC_SWAP_ASK:
//            CancelAtomicSwapAskOp cancelAtomicSwapAskOp;
//        case CREATE_ATOMIC_SWAP_BID_REQUEST:
//            CreateAtomicSwapBidRequestOp createAtomicSwapBidRequestOp;
//        case MANAGE_ACCOUNT_ROLE:
//            ManageAccountRoleOp manageAccountRoleOp;
//        case MANAGE_ACCOUNT_RULE:
//            ManageAccountRuleOp manageAccountRuleOp;
//        case MANAGE_SIGNER:
//            ManageSignerOp manageSignerOp;
//        case MANAGE_SIGNER_ROLE:
//            ManageSignerRoleOp manageSignerRoleOp;
//        case MANAGE_SIGNER_RULE:
//            ManageSignerRuleOp manageSignerRuleOp;
//        case STAMP:
//            StampOp stampOp;
//        case LICENSE:
//            LicenseOp licenseOp;
//        case MANAGE_CREATE_POLL_REQUEST:
//            ManageCreatePollRequestOp manageCreatePollRequestOp;
//        case MANAGE_POLL:
//            ManagePollOp managePollOp;
//        case MANAGE_VOTE:
//            ManageVoteOp manageVoteOp;
//        case MANAGE_ACCOUNT_SPECIFIC_RULE:
//            ManageAccountSpecificRuleOp manageAccountSpecificRuleOp;
//        case CANCEL_CHANGE_ROLE_REQUEST:
//            CancelChangeRoleRequestOp cancelChangeRoleRequestOp;
//        case REMOVE_ASSET_PAIR:
//            RemoveAssetPairOp removeAssetPairOp;
//        case INITIATE_KYC_RECOVERY:
//            InitiateKYCRecoveryOp initiateKYCRecoveryOp;
//        case CREATE_KYC_RECOVERY_REQUEST:
//            CreateKYCRecoveryRequestOp createKYCRecoveryRequestOp;
//        case CREATE_MANAGE_OFFER_REQUEST:
//            CreateManageOfferRequestOp createManageOfferRequestOp;
//        case CREATE_PAYMENT_REQUEST:
//            CreatePaymentRequestOp createPaymentRequestOp;
//        case REMOVE_ASSET:
//            RemoveAssetOp removeAssetOp;
//        case OPEN_SWAP:
//            OpenSwapOp openSwapOp;
//        case CLOSE_SWAP:
//            CloseSwapOp closeSwapOp;
//        case CREATE_REDEMPTION_REQUEST:
//            CreateRedemptionRequestOp createRedemptionRequestOp;
//        case CREATE_DATA:
//            CreateDataOp createDataOp;
//        case UPDATE_DATA:
//            UpdateDataOp updateDataOp;
//        case REMOVE_DATA:
//            RemoveDataOp removeDataOp;
//        case CREATE_DATA_CREATION_REQUEST:
//            CreateDataCreationRequestOp createDataCreationRequestOp;
//        case CANCEL_DATA_CREATION_REQUEST:
//            CancelDataCreationRequestOp cancelDataCreationRequestOp;
//        case CREATE_DATA_UPDATE_REQUEST:
//            CreateDataUpdateRequestOp createDataUpdateRequestOp;
//        case CREATE_DATA_REMOVE_REQUEST:
//            CreateDataRemoveRequestOp createDataRemoveRequestOp;
//        case CANCEL_DATA_UPDATE_REQUEST:
//            CancelDataUpdateRequestOp cancelDataUpdateRequestOp;
//        case CANCEL_DATA_REMOVE_REQUEST:
//            CancelDataRemoveRequestOp cancelDataRemoveRequestOp;
//        case CREATE_DEFERRED_PAYMENT_CREATION_REQUEST:
//            CreateDeferredPaymentCreationRequestOp createDeferredPaymentCreationRequestOp;
//        case CANCEL_DEFERRED_PAYMENT_CREATION_REQUEST:
//            CancelDeferredPaymentCreationRequestOp cancelDeferredPaymentCreationRequestOp;
//        case CREATE_CLOSE_DEFERRED_PAYMENT_REQUEST:
//            CreateCloseDeferredPaymentRequestOp createCloseDeferredPaymentRequestOp;
//        case CANCEL_CLOSE_DEFERRED_PAYMENT_REQUEST:
//            CancelCloseDeferredPaymentRequestOp cancelCloseDeferredPaymentRequestOp;
//
//        }
//
//        body;
//    };
//
type Operation struct {
	SourceAccount *AccountId    `json:"sourceAccount,omitempty"`
	Body          OperationBody `json:"body,omitempty"`
}

// MemoType is an XDR Enum defines as:
//
//   enum MemoType
//    {
//        MEMO_NONE = 0,
//        MEMO_TEXT = 1,
//        MEMO_ID = 2,
//        MEMO_HASH = 3,
//        MEMO_RETURN = 4
//    };
//
type MemoType int32

const (
	MemoTypeMemoNone   MemoType = 0
	MemoTypeMemoText   MemoType = 1
	MemoTypeMemoId     MemoType = 2
	MemoTypeMemoHash   MemoType = 3
	MemoTypeMemoReturn MemoType = 4
)

var MemoTypeAll = []MemoType{
	MemoTypeMemoNone,
	MemoTypeMemoText,
	MemoTypeMemoId,
	MemoTypeMemoHash,
	MemoTypeMemoReturn,
}

var memoTypeMap = map[int32]string{
	0: "MemoTypeMemoNone",
	1: "MemoTypeMemoText",
	2: "MemoTypeMemoId",
	3: "MemoTypeMemoHash",
	4: "MemoTypeMemoReturn",
}

var memoTypeShortMap = map[int32]string{
	0: "memo_none",
	1: "memo_text",
	2: "memo_id",
	3: "memo_hash",
	4: "memo_return",
}

var memoTypeRevMap = map[string]int32{
	"MemoTypeMemoNone":   0,
	"MemoTypeMemoText":   1,
	"MemoTypeMemoId":     2,
	"MemoTypeMemoHash":   3,
	"MemoTypeMemoReturn": 4,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for MemoType
func (e MemoType) ValidEnum(v int32) bool {
	_, ok := memoTypeMap[v]
	return ok
}
func (e MemoType) isFlag() bool {
	for i := len(MemoTypeAll) - 1; i >= 0; i-- {
		expected := MemoType(2) << uint64(len(MemoTypeAll)-1) >> uint64(len(MemoTypeAll)-i)
		if expected != MemoTypeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e MemoType) String() string {
	name, _ := memoTypeMap[int32(e)]
	return name
}

func (e MemoType) ShortString() string {
	name, _ := memoTypeShortMap[int32(e)]
	return name
}

func (e MemoType) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range MemoTypeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *MemoType) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = MemoType(t.Value)
	return nil
}

// Memo is an XDR Union defines as:
//
//   union Memo switch (MemoType type)
//    {
//    case MEMO_NONE:
//        void;
//    case MEMO_TEXT:
//        string text<28>;
//    case MEMO_ID:
//        uint64 id;
//    case MEMO_HASH:
//        Hash hash; // the hash of what to pull from the content server
//    case MEMO_RETURN:
//        Hash retHash; // the hash of the tx you are rejecting
//    };
//
type Memo struct {
	Type    MemoType `json:"type,omitempty"`
	Text    *string  `json:"text,omitempty" xdrmaxsize:"28"`
	Id      *Uint64  `json:"id,omitempty"`
	Hash    *Hash    `json:"hash,omitempty"`
	RetHash *Hash    `json:"retHash,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u Memo) SwitchFieldName() string {
	return "Type"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of Memo
func (u Memo) ArmForSwitch(sw int32) (string, bool) {
	switch MemoType(sw) {
	case MemoTypeMemoNone:
		return "", true
	case MemoTypeMemoText:
		return "Text", true
	case MemoTypeMemoId:
		return "Id", true
	case MemoTypeMemoHash:
		return "Hash", true
	case MemoTypeMemoReturn:
		return "RetHash", true
	}
	return "-", false
}

// NewMemo creates a new  Memo.
func NewMemo(aType MemoType, value interface{}) (result Memo, err error) {
	result.Type = aType
	switch MemoType(aType) {
	case MemoTypeMemoNone:
		// void
	case MemoTypeMemoText:
		tv, ok := value.(string)
		if !ok {
			err = fmt.Errorf("invalid value, must be string")
			return
		}
		result.Text = &tv
	case MemoTypeMemoId:
		tv, ok := value.(Uint64)
		if !ok {
			err = fmt.Errorf("invalid value, must be Uint64")
			return
		}
		result.Id = &tv
	case MemoTypeMemoHash:
		tv, ok := value.(Hash)
		if !ok {
			err = fmt.Errorf("invalid value, must be Hash")
			return
		}
		result.Hash = &tv
	case MemoTypeMemoReturn:
		tv, ok := value.(Hash)
		if !ok {
			err = fmt.Errorf("invalid value, must be Hash")
			return
		}
		result.RetHash = &tv
	}
	return
}

// MustText retrieves the Text value from the union,
// panicing if the value is not set.
func (u Memo) MustText() string {
	val, ok := u.GetText()

	if !ok {
		panic("arm Text is not set")
	}

	return val
}

// GetText retrieves the Text value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u Memo) GetText() (result string, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Text" {
		result = *u.Text
		ok = true
	}

	return
}

// MustId retrieves the Id value from the union,
// panicing if the value is not set.
func (u Memo) MustId() Uint64 {
	val, ok := u.GetId()

	if !ok {
		panic("arm Id is not set")
	}

	return val
}

// GetId retrieves the Id value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u Memo) GetId() (result Uint64, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Id" {
		result = *u.Id
		ok = true
	}

	return
}

// MustHash retrieves the Hash value from the union,
// panicing if the value is not set.
func (u Memo) MustHash() Hash {
	val, ok := u.GetHash()

	if !ok {
		panic("arm Hash is not set")
	}

	return val
}

// GetHash retrieves the Hash value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u Memo) GetHash() (result Hash, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Hash" {
		result = *u.Hash
		ok = true
	}

	return
}

// MustRetHash retrieves the RetHash value from the union,
// panicing if the value is not set.
func (u Memo) MustRetHash() Hash {
	val, ok := u.GetRetHash()

	if !ok {
		panic("arm RetHash is not set")
	}

	return val
}

// GetRetHash retrieves the RetHash value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u Memo) GetRetHash() (result Hash, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "RetHash" {
		result = *u.RetHash
		ok = true
	}

	return
}

// TimeBounds is an XDR Struct defines as:
//
//   struct TimeBounds
//    {
//        //: specifies inclusive min ledger close time after which transaction is valid
//        uint64 minTime;
//        //: specifies inclusive max ledger close time before which transaction is valid.
//        //: note: transaction will be rejected if max time exceeds close time of current ledger on more then [`tx_expiration_period`](https://tokend.gitlab.io/horizon/#operation/info)
//        uint64 maxTime; // 0 here means no maxTime
//    };
//
type TimeBounds struct {
	MinTime Uint64 `json:"minTime,omitempty"`
	MaxTime Uint64 `json:"maxTime,omitempty"`
}

// TransactionExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type TransactionExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u TransactionExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of TransactionExt
func (u TransactionExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewTransactionExt creates a new  TransactionExt.
func NewTransactionExt(v LedgerVersion, value interface{}) (result TransactionExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// Transaction is an XDR Struct defines as:
//
//   //: Transaction is a container for a set of operations
//    //:    - is executed by an account
//    //:    - operations are executed in order as one ACID transaction
//    //: (either all operations are applied or none are if any returns a failing code)
//    struct Transaction
//    {
//        //: account used to run the transaction
//        AccountID sourceAccount;
//
//        //: random number used to ensure there is no hash collisions
//        Salt salt;
//
//        //: validity range (inclusive) for the last ledger close time
//        TimeBounds timeBounds;
//
//        //: allows to attach additional data to the transactions
//        Memo memo;
//
//        //: list of operations to be applied. Max size is 100
//        Operation operations<100>;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type Transaction struct {
	SourceAccount AccountId      `json:"sourceAccount,omitempty"`
	Salt          Salt           `json:"salt,omitempty"`
	TimeBounds    TimeBounds     `json:"timeBounds,omitempty"`
	Memo          Memo           `json:"memo,omitempty"`
	Operations    []Operation    `json:"operations,omitempty" xdrmaxsize:"100"`
	Ext           TransactionExt `json:"ext,omitempty"`
}

// TransactionEnvelope is an XDR Struct defines as:
//
//   struct TransactionEnvelope
//    {
//        Transaction tx;
//        //: list of signatures used to authorize transaction
//        DecoratedSignature signatures<20>;
//    };
//
type TransactionEnvelope struct {
	Tx         Transaction          `json:"tx,omitempty"`
	Signatures []DecoratedSignature `json:"signatures,omitempty" xdrmaxsize:"20"`
}

// OperationResultCode is an XDR Enum defines as:
//
//   enum OperationResultCode
//    {
//        opINNER = 0, // inner object result is valid
//
//        opBAD_AUTH = -1,      // too few valid signatures / wrong network
//        opNO_ACCOUNT = -2,    // source account was not found
//    	opNOT_ALLOWED = -3,   // operation is not allowed for this type of source account
//    	opACCOUNT_BLOCKED = -4, // account is blocked
//        opNO_COUNTERPARTY = -5,
//        opCOUNTERPARTY_BLOCKED = -6,
//        opCOUNTERPARTY_WRONG_TYPE = -7,
//        opBAD_AUTH_EXTRA = -8,
//        opNO_ROLE_PERMISSION = -9, // not allowed for this role of source account
//        opNO_ENTRY = -10,
//        opNOT_SUPPORTED = -11,
//        opLICENSE_VIOLATION = -12, // number of admins is greater than allowed
//        //: operation was skipped cause of failure validation of previous operation
//        opSKIPPED = -13
//    };
//
type OperationResultCode int32

const (
	OperationResultCodeOpInner                 OperationResultCode = 0
	OperationResultCodeOpBadAuth               OperationResultCode = -1
	OperationResultCodeOpNoAccount             OperationResultCode = -2
	OperationResultCodeOpNotAllowed            OperationResultCode = -3
	OperationResultCodeOpAccountBlocked        OperationResultCode = -4
	OperationResultCodeOpNoCounterparty        OperationResultCode = -5
	OperationResultCodeOpCounterpartyBlocked   OperationResultCode = -6
	OperationResultCodeOpCounterpartyWrongType OperationResultCode = -7
	OperationResultCodeOpBadAuthExtra          OperationResultCode = -8
	OperationResultCodeOpNoRolePermission      OperationResultCode = -9
	OperationResultCodeOpNoEntry               OperationResultCode = -10
	OperationResultCodeOpNotSupported          OperationResultCode = -11
	OperationResultCodeOpLicenseViolation      OperationResultCode = -12
	OperationResultCodeOpSkipped               OperationResultCode = -13
)

var OperationResultCodeAll = []OperationResultCode{
	OperationResultCodeOpInner,
	OperationResultCodeOpBadAuth,
	OperationResultCodeOpNoAccount,
	OperationResultCodeOpNotAllowed,
	OperationResultCodeOpAccountBlocked,
	OperationResultCodeOpNoCounterparty,
	OperationResultCodeOpCounterpartyBlocked,
	OperationResultCodeOpCounterpartyWrongType,
	OperationResultCodeOpBadAuthExtra,
	OperationResultCodeOpNoRolePermission,
	OperationResultCodeOpNoEntry,
	OperationResultCodeOpNotSupported,
	OperationResultCodeOpLicenseViolation,
	OperationResultCodeOpSkipped,
}

var operationResultCodeMap = map[int32]string{
	0:   "OperationResultCodeOpInner",
	-1:  "OperationResultCodeOpBadAuth",
	-2:  "OperationResultCodeOpNoAccount",
	-3:  "OperationResultCodeOpNotAllowed",
	-4:  "OperationResultCodeOpAccountBlocked",
	-5:  "OperationResultCodeOpNoCounterparty",
	-6:  "OperationResultCodeOpCounterpartyBlocked",
	-7:  "OperationResultCodeOpCounterpartyWrongType",
	-8:  "OperationResultCodeOpBadAuthExtra",
	-9:  "OperationResultCodeOpNoRolePermission",
	-10: "OperationResultCodeOpNoEntry",
	-11: "OperationResultCodeOpNotSupported",
	-12: "OperationResultCodeOpLicenseViolation",
	-13: "OperationResultCodeOpSkipped",
}

var operationResultCodeShortMap = map[int32]string{
	0:   "op_inner",
	-1:  "op_bad_auth",
	-2:  "op_no_account",
	-3:  "op_not_allowed",
	-4:  "op_account_blocked",
	-5:  "op_no_counterparty",
	-6:  "op_counterparty_blocked",
	-7:  "op_counterparty_wrong_type",
	-8:  "op_bad_auth_extra",
	-9:  "op_no_role_permission",
	-10: "op_no_entry",
	-11: "op_not_supported",
	-12: "op_license_violation",
	-13: "op_skipped",
}

var operationResultCodeRevMap = map[string]int32{
	"OperationResultCodeOpInner":                 0,
	"OperationResultCodeOpBadAuth":               -1,
	"OperationResultCodeOpNoAccount":             -2,
	"OperationResultCodeOpNotAllowed":            -3,
	"OperationResultCodeOpAccountBlocked":        -4,
	"OperationResultCodeOpNoCounterparty":        -5,
	"OperationResultCodeOpCounterpartyBlocked":   -6,
	"OperationResultCodeOpCounterpartyWrongType": -7,
	"OperationResultCodeOpBadAuthExtra":          -8,
	"OperationResultCodeOpNoRolePermission":      -9,
	"OperationResultCodeOpNoEntry":               -10,
	"OperationResultCodeOpNotSupported":          -11,
	"OperationResultCodeOpLicenseViolation":      -12,
	"OperationResultCodeOpSkipped":               -13,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for OperationResultCode
func (e OperationResultCode) ValidEnum(v int32) bool {
	_, ok := operationResultCodeMap[v]
	return ok
}
func (e OperationResultCode) isFlag() bool {
	for i := len(OperationResultCodeAll) - 1; i >= 0; i-- {
		expected := OperationResultCode(2) << uint64(len(OperationResultCodeAll)-1) >> uint64(len(OperationResultCodeAll)-i)
		if expected != OperationResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e OperationResultCode) String() string {
	name, _ := operationResultCodeMap[int32(e)]
	return name
}

func (e OperationResultCode) ShortString() string {
	name, _ := operationResultCodeShortMap[int32(e)]
	return name
}

func (e OperationResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range OperationResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *OperationResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = OperationResultCode(t.Value)
	return nil
}

// AccountRuleRequirement is an XDR Struct defines as:
//
//   //: Defines requirements for tx or operation which were not fulfilled
//    struct AccountRuleRequirement
//    {
//    	//: defines resources to which access was denied
//        AccountRuleResource resource;
//    	//: defines action which was denied
//        AccountRuleAction action;
//    	//: defines account for which requirements were not met
//    	AccountID account;
//
//    	//: reserved for future extension
//        EmptyExt ext;
//    };
//
type AccountRuleRequirement struct {
	Resource AccountRuleResource `json:"resource,omitempty"`
	Action   AccountRuleAction   `json:"action,omitempty"`
	Account  AccountId           `json:"account,omitempty"`
	Ext      EmptyExt            `json:"ext,omitempty"`
}

// OperationResultTr is an XDR NestedUnion defines as:
//
//   union switch (OperationType type)
//        {
//        case CREATE_ACCOUNT:
//            CreateAccountResult createAccountResult;
//    	case CREATE_ISSUANCE_REQUEST:
//    		CreateIssuanceRequestResult createIssuanceRequestResult;
//        case SET_FEES:
//            SetFeesResult setFeesResult;
//        case CREATE_WITHDRAWAL_REQUEST:
//    		CreateWithdrawalRequestResult createWithdrawalRequestResult;
//        case MANAGE_BALANCE:
//            ManageBalanceResult manageBalanceResult;
//        case MANAGE_ASSET:
//            ManageAssetResult manageAssetResult;
//        case CREATE_PREISSUANCE_REQUEST:
//            CreatePreIssuanceRequestResult createPreIssuanceRequestResult;
//        case MANAGE_LIMITS:
//            ManageLimitsResult manageLimitsResult;
//    	case MANAGE_ASSET_PAIR:
//    		ManageAssetPairResult manageAssetPairResult;
//    	case MANAGE_OFFER:
//    		ManageOfferResult manageOfferResult;
//    	case MANAGE_INVOICE_REQUEST:
//    		ManageInvoiceRequestResult manageInvoiceRequestResult;
//    	case REVIEW_REQUEST:
//    		ReviewRequestResult reviewRequestResult;
//    	case CREATE_SALE_REQUEST:
//    		CreateSaleCreationRequestResult createSaleCreationRequestResult;
//    	case CHECK_SALE_STATE:
//    		CheckSaleStateResult checkSaleStateResult;
//    	case PAYOUT:
//    	    PayoutResult payoutResult;
//    	case CREATE_AML_ALERT:
//    	    CreateAMLAlertRequestResult createAMLAlertRequestResult;
//    	case MANAGE_KEY_VALUE:
//    	    ManageKeyValueResult manageKeyValueResult;
//    	case CREATE_CHANGE_ROLE_REQUEST:
//    	    CreateChangeRoleRequestResult createChangeRoleRequestResult;
//        case MANAGE_EXTERNAL_SYSTEM_ACCOUNT_ID_POOL_ENTRY:
//            ManageExternalSystemAccountIdPoolEntryResult manageExternalSystemAccountIdPoolEntryResult;
//        case BIND_EXTERNAL_SYSTEM_ACCOUNT_ID:
//            BindExternalSystemAccountIdResult bindExternalSystemAccountIdResult;
//        case PAYMENT:
//            PaymentResult paymentResult;
//        case MANAGE_SALE:
//            ManageSaleResult manageSaleResult;
//        case CREATE_MANAGE_LIMITS_REQUEST:
//            CreateManageLimitsRequestResult createManageLimitsRequestResult;
//        case MANAGE_CONTRACT_REQUEST:
//            ManageContractRequestResult manageContractRequestResult;
//        case MANAGE_CONTRACT:
//            ManageContractResult manageContractResult;
//        case CANCEL_SALE_REQUEST:
//            CancelSaleCreationRequestResult cancelSaleCreationRequestResult;
//        case CREATE_ATOMIC_SWAP_ASK_REQUEST:
//            CreateAtomicSwapAskRequestResult createAtomicSwapAskRequestResult;
//        case CANCEL_ATOMIC_SWAP_ASK:
//            CancelAtomicSwapAskResult cancelAtomicSwapAskResult;
//        case CREATE_ATOMIC_SWAP_BID_REQUEST:
//            CreateAtomicSwapBidRequestResult createAtomicSwapBidRequestResult;
//        case MANAGE_ACCOUNT_ROLE:
//            ManageAccountRoleResult manageAccountRoleResult;
//        case MANAGE_ACCOUNT_RULE:
//            ManageAccountRuleResult manageAccountRuleResult;
//        case MANAGE_SIGNER:
//            ManageSignerResult manageSignerResult;
//        case MANAGE_SIGNER_ROLE:
//            ManageSignerRoleResult manageSignerRoleResult;
//        case MANAGE_SIGNER_RULE:
//            ManageSignerRuleResult manageSignerRuleResult;
//        case STAMP:
//            StampResult stampResult;
//        case LICENSE:
//            LicenseResult licenseResult;
//        case MANAGE_POLL:
//            ManagePollResult managePollResult;
//        case MANAGE_CREATE_POLL_REQUEST:
//            ManageCreatePollRequestResult manageCreatePollRequestResult;
//        case MANAGE_VOTE:
//            ManageVoteResult manageVoteResult;
//        case MANAGE_ACCOUNT_SPECIFIC_RULE:
//            ManageAccountSpecificRuleResult manageAccountSpecificRuleResult;
//        case CANCEL_CHANGE_ROLE_REQUEST:
//            CancelChangeRoleRequestResult cancelChangeRoleRequestResult;
//        case REMOVE_ASSET_PAIR:
//            RemoveAssetPairResult removeAssetPairResult;
//        case CREATE_KYC_RECOVERY_REQUEST:
//            CreateKYCRecoveryRequestResult createKYCRecoveryRequestResult;
//        case INITIATE_KYC_RECOVERY:
//            InitiateKYCRecoveryResult initiateKYCRecoveryResult;
//        case CREATE_MANAGE_OFFER_REQUEST:
//            CreateManageOfferRequestResult createManageOfferRequestResult;
//        case CREATE_PAYMENT_REQUEST:
//            CreatePaymentRequestResult createPaymentRequestResult;
//        case REMOVE_ASSET:
//            RemoveAssetResult removeAssetResult;
//        case OPEN_SWAP:
//            OpenSwapResult openSwapResult;
//        case CLOSE_SWAP:
//            CloseSwapResult closeSwapResult;
//        case CREATE_REDEMPTION_REQUEST:
//            CreateRedemptionRequestResult createRedemptionRequestResult;
//        case CREATE_DATA:
//            CreateDataResult createDataResult;
//        case UPDATE_DATA:
//            UpdateDataResult updateDataResult;
//        case REMOVE_DATA:
//            RemoveDataResult removeDataResult;
//        case CREATE_DATA_CREATION_REQUEST:
//            CreateDataCreationRequestResult createDataCreationRequestResult;
//        case CANCEL_DATA_CREATION_REQUEST:
//            CancelDataCreationRequestResult cancelDataCreationRequestResult;
//        case CREATE_DATA_UPDATE_REQUEST:
//            CreateDataUpdateRequestResult createDataUpdateRequestResult;
//        case CREATE_DATA_REMOVE_REQUEST:
//            CreateDataRemoveRequestResult createDataRemoveRequestResult;
//        case CANCEL_DATA_UPDATE_REQUEST:
//            CancelDataUpdateRequestResult cancelDataUpdateRequestResult;
//        case CANCEL_DATA_REMOVE_REQUEST:
//            CancelDataRemoveRequestResult cancelDataRemoveRequestResult;
//        case CREATE_DEFERRED_PAYMENT_CREATION_REQUEST:
//                CreateDeferredPaymentCreationRequestResult createDeferredPaymentCreationRequestResult;
//        case CANCEL_DEFERRED_PAYMENT_CREATION_REQUEST:
//            CancelDeferredPaymentCreationRequestResult cancelDeferredPaymentCreationRequestResult;
//        case CREATE_CLOSE_DEFERRED_PAYMENT_REQUEST:
//            CreateCloseDeferredPaymentRequestResult createCloseDeferredPaymentRequestResult;
//        case CANCEL_CLOSE_DEFERRED_PAYMENT_REQUEST:
//            CancelCloseDeferredPaymentRequestResult cancelCloseDeferredPaymentRequestResult;
//
//        }
//
type OperationResultTr struct {
	Type                                         OperationType                                 `json:"type,omitempty"`
	CreateAccountResult                          *CreateAccountResult                          `json:"createAccountResult,omitempty"`
	CreateIssuanceRequestResult                  *CreateIssuanceRequestResult                  `json:"createIssuanceRequestResult,omitempty"`
	SetFeesResult                                *SetFeesResult                                `json:"setFeesResult,omitempty"`
	CreateWithdrawalRequestResult                *CreateWithdrawalRequestResult                `json:"createWithdrawalRequestResult,omitempty"`
	ManageBalanceResult                          *ManageBalanceResult                          `json:"manageBalanceResult,omitempty"`
	ManageAssetResult                            *ManageAssetResult                            `json:"manageAssetResult,omitempty"`
	CreatePreIssuanceRequestResult               *CreatePreIssuanceRequestResult               `json:"createPreIssuanceRequestResult,omitempty"`
	ManageLimitsResult                           *ManageLimitsResult                           `json:"manageLimitsResult,omitempty"`
	ManageAssetPairResult                        *ManageAssetPairResult                        `json:"manageAssetPairResult,omitempty"`
	ManageOfferResult                            *ManageOfferResult                            `json:"manageOfferResult,omitempty"`
	ManageInvoiceRequestResult                   *ManageInvoiceRequestResult                   `json:"manageInvoiceRequestResult,omitempty"`
	ReviewRequestResult                          *ReviewRequestResult                          `json:"reviewRequestResult,omitempty"`
	CreateSaleCreationRequestResult              *CreateSaleCreationRequestResult              `json:"createSaleCreationRequestResult,omitempty"`
	CheckSaleStateResult                         *CheckSaleStateResult                         `json:"checkSaleStateResult,omitempty"`
	PayoutResult                                 *PayoutResult                                 `json:"payoutResult,omitempty"`
	CreateAmlAlertRequestResult                  *CreateAmlAlertRequestResult                  `json:"createAMLAlertRequestResult,omitempty"`
	ManageKeyValueResult                         *ManageKeyValueResult                         `json:"manageKeyValueResult,omitempty"`
	CreateChangeRoleRequestResult                *CreateChangeRoleRequestResult                `json:"createChangeRoleRequestResult,omitempty"`
	ManageExternalSystemAccountIdPoolEntryResult *ManageExternalSystemAccountIdPoolEntryResult `json:"manageExternalSystemAccountIdPoolEntryResult,omitempty"`
	BindExternalSystemAccountIdResult            *BindExternalSystemAccountIdResult            `json:"bindExternalSystemAccountIdResult,omitempty"`
	PaymentResult                                *PaymentResult                                `json:"paymentResult,omitempty"`
	ManageSaleResult                             *ManageSaleResult                             `json:"manageSaleResult,omitempty"`
	CreateManageLimitsRequestResult              *CreateManageLimitsRequestResult              `json:"createManageLimitsRequestResult,omitempty"`
	ManageContractRequestResult                  *ManageContractRequestResult                  `json:"manageContractRequestResult,omitempty"`
	ManageContractResult                         *ManageContractResult                         `json:"manageContractResult,omitempty"`
	CancelSaleCreationRequestResult              *CancelSaleCreationRequestResult              `json:"cancelSaleCreationRequestResult,omitempty"`
	CreateAtomicSwapAskRequestResult             *CreateAtomicSwapAskRequestResult             `json:"createAtomicSwapAskRequestResult,omitempty"`
	CancelAtomicSwapAskResult                    *CancelAtomicSwapAskResult                    `json:"cancelAtomicSwapAskResult,omitempty"`
	CreateAtomicSwapBidRequestResult             *CreateAtomicSwapBidRequestResult             `json:"createAtomicSwapBidRequestResult,omitempty"`
	ManageAccountRoleResult                      *ManageAccountRoleResult                      `json:"manageAccountRoleResult,omitempty"`
	ManageAccountRuleResult                      *ManageAccountRuleResult                      `json:"manageAccountRuleResult,omitempty"`
	ManageSignerResult                           *ManageSignerResult                           `json:"manageSignerResult,omitempty"`
	ManageSignerRoleResult                       *ManageSignerRoleResult                       `json:"manageSignerRoleResult,omitempty"`
	ManageSignerRuleResult                       *ManageSignerRuleResult                       `json:"manageSignerRuleResult,omitempty"`
	StampResult                                  *StampResult                                  `json:"stampResult,omitempty"`
	LicenseResult                                *LicenseResult                                `json:"licenseResult,omitempty"`
	ManagePollResult                             *ManagePollResult                             `json:"managePollResult,omitempty"`
	ManageCreatePollRequestResult                *ManageCreatePollRequestResult                `json:"manageCreatePollRequestResult,omitempty"`
	ManageVoteResult                             *ManageVoteResult                             `json:"manageVoteResult,omitempty"`
	ManageAccountSpecificRuleResult              *ManageAccountSpecificRuleResult              `json:"manageAccountSpecificRuleResult,omitempty"`
	CancelChangeRoleRequestResult                *CancelChangeRoleRequestResult                `json:"cancelChangeRoleRequestResult,omitempty"`
	RemoveAssetPairResult                        *RemoveAssetPairResult                        `json:"removeAssetPairResult,omitempty"`
	CreateKycRecoveryRequestResult               *CreateKycRecoveryRequestResult               `json:"createKYCRecoveryRequestResult,omitempty"`
	InitiateKycRecoveryResult                    *InitiateKycRecoveryResult                    `json:"initiateKYCRecoveryResult,omitempty"`
	CreateManageOfferRequestResult               *CreateManageOfferRequestResult               `json:"createManageOfferRequestResult,omitempty"`
	CreatePaymentRequestResult                   *CreatePaymentRequestResult                   `json:"createPaymentRequestResult,omitempty"`
	RemoveAssetResult                            *RemoveAssetResult                            `json:"removeAssetResult,omitempty"`
	OpenSwapResult                               *OpenSwapResult                               `json:"openSwapResult,omitempty"`
	CloseSwapResult                              *CloseSwapResult                              `json:"closeSwapResult,omitempty"`
	CreateRedemptionRequestResult                *CreateRedemptionRequestResult                `json:"createRedemptionRequestResult,omitempty"`
	CreateDataResult                             *CreateDataResult                             `json:"createDataResult,omitempty"`
	UpdateDataResult                             *UpdateDataResult                             `json:"updateDataResult,omitempty"`
	RemoveDataResult                             *RemoveDataResult                             `json:"removeDataResult,omitempty"`
	CreateDataCreationRequestResult              *CreateDataCreationRequestResult              `json:"createDataCreationRequestResult,omitempty"`
	CancelDataCreationRequestResult              *CancelDataCreationRequestResult              `json:"cancelDataCreationRequestResult,omitempty"`
	CreateDataUpdateRequestResult                *CreateDataUpdateRequestResult                `json:"createDataUpdateRequestResult,omitempty"`
	CreateDataRemoveRequestResult                *CreateDataRemoveRequestResult                `json:"createDataRemoveRequestResult,omitempty"`
	CancelDataUpdateRequestResult                *CancelDataUpdateRequestResult                `json:"cancelDataUpdateRequestResult,omitempty"`
	CancelDataRemoveRequestResult                *CancelDataRemoveRequestResult                `json:"cancelDataRemoveRequestResult,omitempty"`
	CreateDeferredPaymentCreationRequestResult   *CreateDeferredPaymentCreationRequestResult   `json:"createDeferredPaymentCreationRequestResult,omitempty"`
	CancelDeferredPaymentCreationRequestResult   *CancelDeferredPaymentCreationRequestResult   `json:"cancelDeferredPaymentCreationRequestResult,omitempty"`
	CreateCloseDeferredPaymentRequestResult      *CreateCloseDeferredPaymentRequestResult      `json:"createCloseDeferredPaymentRequestResult,omitempty"`
	CancelCloseDeferredPaymentRequestResult      *CancelCloseDeferredPaymentRequestResult      `json:"cancelCloseDeferredPaymentRequestResult,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u OperationResultTr) SwitchFieldName() string {
	return "Type"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of OperationResultTr
func (u OperationResultTr) ArmForSwitch(sw int32) (string, bool) {
	switch OperationType(sw) {
	case OperationTypeCreateAccount:
		return "CreateAccountResult", true
	case OperationTypeCreateIssuanceRequest:
		return "CreateIssuanceRequestResult", true
	case OperationTypeSetFees:
		return "SetFeesResult", true
	case OperationTypeCreateWithdrawalRequest:
		return "CreateWithdrawalRequestResult", true
	case OperationTypeManageBalance:
		return "ManageBalanceResult", true
	case OperationTypeManageAsset:
		return "ManageAssetResult", true
	case OperationTypeCreatePreissuanceRequest:
		return "CreatePreIssuanceRequestResult", true
	case OperationTypeManageLimits:
		return "ManageLimitsResult", true
	case OperationTypeManageAssetPair:
		return "ManageAssetPairResult", true
	case OperationTypeManageOffer:
		return "ManageOfferResult", true
	case OperationTypeManageInvoiceRequest:
		return "ManageInvoiceRequestResult", true
	case OperationTypeReviewRequest:
		return "ReviewRequestResult", true
	case OperationTypeCreateSaleRequest:
		return "CreateSaleCreationRequestResult", true
	case OperationTypeCheckSaleState:
		return "CheckSaleStateResult", true
	case OperationTypePayout:
		return "PayoutResult", true
	case OperationTypeCreateAmlAlert:
		return "CreateAmlAlertRequestResult", true
	case OperationTypeManageKeyValue:
		return "ManageKeyValueResult", true
	case OperationTypeCreateChangeRoleRequest:
		return "CreateChangeRoleRequestResult", true
	case OperationTypeManageExternalSystemAccountIdPoolEntry:
		return "ManageExternalSystemAccountIdPoolEntryResult", true
	case OperationTypeBindExternalSystemAccountId:
		return "BindExternalSystemAccountIdResult", true
	case OperationTypePayment:
		return "PaymentResult", true
	case OperationTypeManageSale:
		return "ManageSaleResult", true
	case OperationTypeCreateManageLimitsRequest:
		return "CreateManageLimitsRequestResult", true
	case OperationTypeManageContractRequest:
		return "ManageContractRequestResult", true
	case OperationTypeManageContract:
		return "ManageContractResult", true
	case OperationTypeCancelSaleRequest:
		return "CancelSaleCreationRequestResult", true
	case OperationTypeCreateAtomicSwapAskRequest:
		return "CreateAtomicSwapAskRequestResult", true
	case OperationTypeCancelAtomicSwapAsk:
		return "CancelAtomicSwapAskResult", true
	case OperationTypeCreateAtomicSwapBidRequest:
		return "CreateAtomicSwapBidRequestResult", true
	case OperationTypeManageAccountRole:
		return "ManageAccountRoleResult", true
	case OperationTypeManageAccountRule:
		return "ManageAccountRuleResult", true
	case OperationTypeManageSigner:
		return "ManageSignerResult", true
	case OperationTypeManageSignerRole:
		return "ManageSignerRoleResult", true
	case OperationTypeManageSignerRule:
		return "ManageSignerRuleResult", true
	case OperationTypeStamp:
		return "StampResult", true
	case OperationTypeLicense:
		return "LicenseResult", true
	case OperationTypeManagePoll:
		return "ManagePollResult", true
	case OperationTypeManageCreatePollRequest:
		return "ManageCreatePollRequestResult", true
	case OperationTypeManageVote:
		return "ManageVoteResult", true
	case OperationTypeManageAccountSpecificRule:
		return "ManageAccountSpecificRuleResult", true
	case OperationTypeCancelChangeRoleRequest:
		return "CancelChangeRoleRequestResult", true
	case OperationTypeRemoveAssetPair:
		return "RemoveAssetPairResult", true
	case OperationTypeCreateKycRecoveryRequest:
		return "CreateKycRecoveryRequestResult", true
	case OperationTypeInitiateKycRecovery:
		return "InitiateKycRecoveryResult", true
	case OperationTypeCreateManageOfferRequest:
		return "CreateManageOfferRequestResult", true
	case OperationTypeCreatePaymentRequest:
		return "CreatePaymentRequestResult", true
	case OperationTypeRemoveAsset:
		return "RemoveAssetResult", true
	case OperationTypeOpenSwap:
		return "OpenSwapResult", true
	case OperationTypeCloseSwap:
		return "CloseSwapResult", true
	case OperationTypeCreateRedemptionRequest:
		return "CreateRedemptionRequestResult", true
	case OperationTypeCreateData:
		return "CreateDataResult", true
	case OperationTypeUpdateData:
		return "UpdateDataResult", true
	case OperationTypeRemoveData:
		return "RemoveDataResult", true
	case OperationTypeCreateDataCreationRequest:
		return "CreateDataCreationRequestResult", true
	case OperationTypeCancelDataCreationRequest:
		return "CancelDataCreationRequestResult", true
	case OperationTypeCreateDataUpdateRequest:
		return "CreateDataUpdateRequestResult", true
	case OperationTypeCreateDataRemoveRequest:
		return "CreateDataRemoveRequestResult", true
	case OperationTypeCancelDataUpdateRequest:
		return "CancelDataUpdateRequestResult", true
	case OperationTypeCancelDataRemoveRequest:
		return "CancelDataRemoveRequestResult", true
	case OperationTypeCreateDeferredPaymentCreationRequest:
		return "CreateDeferredPaymentCreationRequestResult", true
	case OperationTypeCancelDeferredPaymentCreationRequest:
		return "CancelDeferredPaymentCreationRequestResult", true
	case OperationTypeCreateCloseDeferredPaymentRequest:
		return "CreateCloseDeferredPaymentRequestResult", true
	case OperationTypeCancelCloseDeferredPaymentRequest:
		return "CancelCloseDeferredPaymentRequestResult", true
	}
	return "-", false
}

// NewOperationResultTr creates a new  OperationResultTr.
func NewOperationResultTr(aType OperationType, value interface{}) (result OperationResultTr, err error) {
	result.Type = aType
	switch OperationType(aType) {
	case OperationTypeCreateAccount:
		tv, ok := value.(CreateAccountResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateAccountResult")
			return
		}
		result.CreateAccountResult = &tv
	case OperationTypeCreateIssuanceRequest:
		tv, ok := value.(CreateIssuanceRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateIssuanceRequestResult")
			return
		}
		result.CreateIssuanceRequestResult = &tv
	case OperationTypeSetFees:
		tv, ok := value.(SetFeesResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be SetFeesResult")
			return
		}
		result.SetFeesResult = &tv
	case OperationTypeCreateWithdrawalRequest:
		tv, ok := value.(CreateWithdrawalRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateWithdrawalRequestResult")
			return
		}
		result.CreateWithdrawalRequestResult = &tv
	case OperationTypeManageBalance:
		tv, ok := value.(ManageBalanceResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageBalanceResult")
			return
		}
		result.ManageBalanceResult = &tv
	case OperationTypeManageAsset:
		tv, ok := value.(ManageAssetResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageAssetResult")
			return
		}
		result.ManageAssetResult = &tv
	case OperationTypeCreatePreissuanceRequest:
		tv, ok := value.(CreatePreIssuanceRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreatePreIssuanceRequestResult")
			return
		}
		result.CreatePreIssuanceRequestResult = &tv
	case OperationTypeManageLimits:
		tv, ok := value.(ManageLimitsResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageLimitsResult")
			return
		}
		result.ManageLimitsResult = &tv
	case OperationTypeManageAssetPair:
		tv, ok := value.(ManageAssetPairResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageAssetPairResult")
			return
		}
		result.ManageAssetPairResult = &tv
	case OperationTypeManageOffer:
		tv, ok := value.(ManageOfferResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageOfferResult")
			return
		}
		result.ManageOfferResult = &tv
	case OperationTypeManageInvoiceRequest:
		tv, ok := value.(ManageInvoiceRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageInvoiceRequestResult")
			return
		}
		result.ManageInvoiceRequestResult = &tv
	case OperationTypeReviewRequest:
		tv, ok := value.(ReviewRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be ReviewRequestResult")
			return
		}
		result.ReviewRequestResult = &tv
	case OperationTypeCreateSaleRequest:
		tv, ok := value.(CreateSaleCreationRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateSaleCreationRequestResult")
			return
		}
		result.CreateSaleCreationRequestResult = &tv
	case OperationTypeCheckSaleState:
		tv, ok := value.(CheckSaleStateResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CheckSaleStateResult")
			return
		}
		result.CheckSaleStateResult = &tv
	case OperationTypePayout:
		tv, ok := value.(PayoutResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be PayoutResult")
			return
		}
		result.PayoutResult = &tv
	case OperationTypeCreateAmlAlert:
		tv, ok := value.(CreateAmlAlertRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateAmlAlertRequestResult")
			return
		}
		result.CreateAmlAlertRequestResult = &tv
	case OperationTypeManageKeyValue:
		tv, ok := value.(ManageKeyValueResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageKeyValueResult")
			return
		}
		result.ManageKeyValueResult = &tv
	case OperationTypeCreateChangeRoleRequest:
		tv, ok := value.(CreateChangeRoleRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateChangeRoleRequestResult")
			return
		}
		result.CreateChangeRoleRequestResult = &tv
	case OperationTypeManageExternalSystemAccountIdPoolEntry:
		tv, ok := value.(ManageExternalSystemAccountIdPoolEntryResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageExternalSystemAccountIdPoolEntryResult")
			return
		}
		result.ManageExternalSystemAccountIdPoolEntryResult = &tv
	case OperationTypeBindExternalSystemAccountId:
		tv, ok := value.(BindExternalSystemAccountIdResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be BindExternalSystemAccountIdResult")
			return
		}
		result.BindExternalSystemAccountIdResult = &tv
	case OperationTypePayment:
		tv, ok := value.(PaymentResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be PaymentResult")
			return
		}
		result.PaymentResult = &tv
	case OperationTypeManageSale:
		tv, ok := value.(ManageSaleResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageSaleResult")
			return
		}
		result.ManageSaleResult = &tv
	case OperationTypeCreateManageLimitsRequest:
		tv, ok := value.(CreateManageLimitsRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateManageLimitsRequestResult")
			return
		}
		result.CreateManageLimitsRequestResult = &tv
	case OperationTypeManageContractRequest:
		tv, ok := value.(ManageContractRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageContractRequestResult")
			return
		}
		result.ManageContractRequestResult = &tv
	case OperationTypeManageContract:
		tv, ok := value.(ManageContractResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageContractResult")
			return
		}
		result.ManageContractResult = &tv
	case OperationTypeCancelSaleRequest:
		tv, ok := value.(CancelSaleCreationRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CancelSaleCreationRequestResult")
			return
		}
		result.CancelSaleCreationRequestResult = &tv
	case OperationTypeCreateAtomicSwapAskRequest:
		tv, ok := value.(CreateAtomicSwapAskRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateAtomicSwapAskRequestResult")
			return
		}
		result.CreateAtomicSwapAskRequestResult = &tv
	case OperationTypeCancelAtomicSwapAsk:
		tv, ok := value.(CancelAtomicSwapAskResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CancelAtomicSwapAskResult")
			return
		}
		result.CancelAtomicSwapAskResult = &tv
	case OperationTypeCreateAtomicSwapBidRequest:
		tv, ok := value.(CreateAtomicSwapBidRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateAtomicSwapBidRequestResult")
			return
		}
		result.CreateAtomicSwapBidRequestResult = &tv
	case OperationTypeManageAccountRole:
		tv, ok := value.(ManageAccountRoleResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageAccountRoleResult")
			return
		}
		result.ManageAccountRoleResult = &tv
	case OperationTypeManageAccountRule:
		tv, ok := value.(ManageAccountRuleResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageAccountRuleResult")
			return
		}
		result.ManageAccountRuleResult = &tv
	case OperationTypeManageSigner:
		tv, ok := value.(ManageSignerResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageSignerResult")
			return
		}
		result.ManageSignerResult = &tv
	case OperationTypeManageSignerRole:
		tv, ok := value.(ManageSignerRoleResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageSignerRoleResult")
			return
		}
		result.ManageSignerRoleResult = &tv
	case OperationTypeManageSignerRule:
		tv, ok := value.(ManageSignerRuleResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageSignerRuleResult")
			return
		}
		result.ManageSignerRuleResult = &tv
	case OperationTypeStamp:
		tv, ok := value.(StampResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be StampResult")
			return
		}
		result.StampResult = &tv
	case OperationTypeLicense:
		tv, ok := value.(LicenseResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be LicenseResult")
			return
		}
		result.LicenseResult = &tv
	case OperationTypeManagePoll:
		tv, ok := value.(ManagePollResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManagePollResult")
			return
		}
		result.ManagePollResult = &tv
	case OperationTypeManageCreatePollRequest:
		tv, ok := value.(ManageCreatePollRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageCreatePollRequestResult")
			return
		}
		result.ManageCreatePollRequestResult = &tv
	case OperationTypeManageVote:
		tv, ok := value.(ManageVoteResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageVoteResult")
			return
		}
		result.ManageVoteResult = &tv
	case OperationTypeManageAccountSpecificRule:
		tv, ok := value.(ManageAccountSpecificRuleResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be ManageAccountSpecificRuleResult")
			return
		}
		result.ManageAccountSpecificRuleResult = &tv
	case OperationTypeCancelChangeRoleRequest:
		tv, ok := value.(CancelChangeRoleRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CancelChangeRoleRequestResult")
			return
		}
		result.CancelChangeRoleRequestResult = &tv
	case OperationTypeRemoveAssetPair:
		tv, ok := value.(RemoveAssetPairResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be RemoveAssetPairResult")
			return
		}
		result.RemoveAssetPairResult = &tv
	case OperationTypeCreateKycRecoveryRequest:
		tv, ok := value.(CreateKycRecoveryRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateKycRecoveryRequestResult")
			return
		}
		result.CreateKycRecoveryRequestResult = &tv
	case OperationTypeInitiateKycRecovery:
		tv, ok := value.(InitiateKycRecoveryResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be InitiateKycRecoveryResult")
			return
		}
		result.InitiateKycRecoveryResult = &tv
	case OperationTypeCreateManageOfferRequest:
		tv, ok := value.(CreateManageOfferRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateManageOfferRequestResult")
			return
		}
		result.CreateManageOfferRequestResult = &tv
	case OperationTypeCreatePaymentRequest:
		tv, ok := value.(CreatePaymentRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreatePaymentRequestResult")
			return
		}
		result.CreatePaymentRequestResult = &tv
	case OperationTypeRemoveAsset:
		tv, ok := value.(RemoveAssetResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be RemoveAssetResult")
			return
		}
		result.RemoveAssetResult = &tv
	case OperationTypeOpenSwap:
		tv, ok := value.(OpenSwapResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be OpenSwapResult")
			return
		}
		result.OpenSwapResult = &tv
	case OperationTypeCloseSwap:
		tv, ok := value.(CloseSwapResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CloseSwapResult")
			return
		}
		result.CloseSwapResult = &tv
	case OperationTypeCreateRedemptionRequest:
		tv, ok := value.(CreateRedemptionRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateRedemptionRequestResult")
			return
		}
		result.CreateRedemptionRequestResult = &tv
	case OperationTypeCreateData:
		tv, ok := value.(CreateDataResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateDataResult")
			return
		}
		result.CreateDataResult = &tv
	case OperationTypeUpdateData:
		tv, ok := value.(UpdateDataResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be UpdateDataResult")
			return
		}
		result.UpdateDataResult = &tv
	case OperationTypeRemoveData:
		tv, ok := value.(RemoveDataResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be RemoveDataResult")
			return
		}
		result.RemoveDataResult = &tv
	case OperationTypeCreateDataCreationRequest:
		tv, ok := value.(CreateDataCreationRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateDataCreationRequestResult")
			return
		}
		result.CreateDataCreationRequestResult = &tv
	case OperationTypeCancelDataCreationRequest:
		tv, ok := value.(CancelDataCreationRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CancelDataCreationRequestResult")
			return
		}
		result.CancelDataCreationRequestResult = &tv
	case OperationTypeCreateDataUpdateRequest:
		tv, ok := value.(CreateDataUpdateRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateDataUpdateRequestResult")
			return
		}
		result.CreateDataUpdateRequestResult = &tv
	case OperationTypeCreateDataRemoveRequest:
		tv, ok := value.(CreateDataRemoveRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateDataRemoveRequestResult")
			return
		}
		result.CreateDataRemoveRequestResult = &tv
	case OperationTypeCancelDataUpdateRequest:
		tv, ok := value.(CancelDataUpdateRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CancelDataUpdateRequestResult")
			return
		}
		result.CancelDataUpdateRequestResult = &tv
	case OperationTypeCancelDataRemoveRequest:
		tv, ok := value.(CancelDataRemoveRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CancelDataRemoveRequestResult")
			return
		}
		result.CancelDataRemoveRequestResult = &tv
	case OperationTypeCreateDeferredPaymentCreationRequest:
		tv, ok := value.(CreateDeferredPaymentCreationRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateDeferredPaymentCreationRequestResult")
			return
		}
		result.CreateDeferredPaymentCreationRequestResult = &tv
	case OperationTypeCancelDeferredPaymentCreationRequest:
		tv, ok := value.(CancelDeferredPaymentCreationRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CancelDeferredPaymentCreationRequestResult")
			return
		}
		result.CancelDeferredPaymentCreationRequestResult = &tv
	case OperationTypeCreateCloseDeferredPaymentRequest:
		tv, ok := value.(CreateCloseDeferredPaymentRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CreateCloseDeferredPaymentRequestResult")
			return
		}
		result.CreateCloseDeferredPaymentRequestResult = &tv
	case OperationTypeCancelCloseDeferredPaymentRequest:
		tv, ok := value.(CancelCloseDeferredPaymentRequestResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be CancelCloseDeferredPaymentRequestResult")
			return
		}
		result.CancelCloseDeferredPaymentRequestResult = &tv
	}
	return
}

// MustCreateAccountResult retrieves the CreateAccountResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCreateAccountResult() CreateAccountResult {
	val, ok := u.GetCreateAccountResult()

	if !ok {
		panic("arm CreateAccountResult is not set")
	}

	return val
}

// GetCreateAccountResult retrieves the CreateAccountResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCreateAccountResult() (result CreateAccountResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateAccountResult" {
		result = *u.CreateAccountResult
		ok = true
	}

	return
}

// MustCreateIssuanceRequestResult retrieves the CreateIssuanceRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCreateIssuanceRequestResult() CreateIssuanceRequestResult {
	val, ok := u.GetCreateIssuanceRequestResult()

	if !ok {
		panic("arm CreateIssuanceRequestResult is not set")
	}

	return val
}

// GetCreateIssuanceRequestResult retrieves the CreateIssuanceRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCreateIssuanceRequestResult() (result CreateIssuanceRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateIssuanceRequestResult" {
		result = *u.CreateIssuanceRequestResult
		ok = true
	}

	return
}

// MustSetFeesResult retrieves the SetFeesResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustSetFeesResult() SetFeesResult {
	val, ok := u.GetSetFeesResult()

	if !ok {
		panic("arm SetFeesResult is not set")
	}

	return val
}

// GetSetFeesResult retrieves the SetFeesResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetSetFeesResult() (result SetFeesResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "SetFeesResult" {
		result = *u.SetFeesResult
		ok = true
	}

	return
}

// MustCreateWithdrawalRequestResult retrieves the CreateWithdrawalRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCreateWithdrawalRequestResult() CreateWithdrawalRequestResult {
	val, ok := u.GetCreateWithdrawalRequestResult()

	if !ok {
		panic("arm CreateWithdrawalRequestResult is not set")
	}

	return val
}

// GetCreateWithdrawalRequestResult retrieves the CreateWithdrawalRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCreateWithdrawalRequestResult() (result CreateWithdrawalRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateWithdrawalRequestResult" {
		result = *u.CreateWithdrawalRequestResult
		ok = true
	}

	return
}

// MustManageBalanceResult retrieves the ManageBalanceResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustManageBalanceResult() ManageBalanceResult {
	val, ok := u.GetManageBalanceResult()

	if !ok {
		panic("arm ManageBalanceResult is not set")
	}

	return val
}

// GetManageBalanceResult retrieves the ManageBalanceResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetManageBalanceResult() (result ManageBalanceResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageBalanceResult" {
		result = *u.ManageBalanceResult
		ok = true
	}

	return
}

// MustManageAssetResult retrieves the ManageAssetResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustManageAssetResult() ManageAssetResult {
	val, ok := u.GetManageAssetResult()

	if !ok {
		panic("arm ManageAssetResult is not set")
	}

	return val
}

// GetManageAssetResult retrieves the ManageAssetResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetManageAssetResult() (result ManageAssetResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageAssetResult" {
		result = *u.ManageAssetResult
		ok = true
	}

	return
}

// MustCreatePreIssuanceRequestResult retrieves the CreatePreIssuanceRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCreatePreIssuanceRequestResult() CreatePreIssuanceRequestResult {
	val, ok := u.GetCreatePreIssuanceRequestResult()

	if !ok {
		panic("arm CreatePreIssuanceRequestResult is not set")
	}

	return val
}

// GetCreatePreIssuanceRequestResult retrieves the CreatePreIssuanceRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCreatePreIssuanceRequestResult() (result CreatePreIssuanceRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreatePreIssuanceRequestResult" {
		result = *u.CreatePreIssuanceRequestResult
		ok = true
	}

	return
}

// MustManageLimitsResult retrieves the ManageLimitsResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustManageLimitsResult() ManageLimitsResult {
	val, ok := u.GetManageLimitsResult()

	if !ok {
		panic("arm ManageLimitsResult is not set")
	}

	return val
}

// GetManageLimitsResult retrieves the ManageLimitsResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetManageLimitsResult() (result ManageLimitsResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageLimitsResult" {
		result = *u.ManageLimitsResult
		ok = true
	}

	return
}

// MustManageAssetPairResult retrieves the ManageAssetPairResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustManageAssetPairResult() ManageAssetPairResult {
	val, ok := u.GetManageAssetPairResult()

	if !ok {
		panic("arm ManageAssetPairResult is not set")
	}

	return val
}

// GetManageAssetPairResult retrieves the ManageAssetPairResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetManageAssetPairResult() (result ManageAssetPairResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageAssetPairResult" {
		result = *u.ManageAssetPairResult
		ok = true
	}

	return
}

// MustManageOfferResult retrieves the ManageOfferResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustManageOfferResult() ManageOfferResult {
	val, ok := u.GetManageOfferResult()

	if !ok {
		panic("arm ManageOfferResult is not set")
	}

	return val
}

// GetManageOfferResult retrieves the ManageOfferResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetManageOfferResult() (result ManageOfferResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageOfferResult" {
		result = *u.ManageOfferResult
		ok = true
	}

	return
}

// MustManageInvoiceRequestResult retrieves the ManageInvoiceRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustManageInvoiceRequestResult() ManageInvoiceRequestResult {
	val, ok := u.GetManageInvoiceRequestResult()

	if !ok {
		panic("arm ManageInvoiceRequestResult is not set")
	}

	return val
}

// GetManageInvoiceRequestResult retrieves the ManageInvoiceRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetManageInvoiceRequestResult() (result ManageInvoiceRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageInvoiceRequestResult" {
		result = *u.ManageInvoiceRequestResult
		ok = true
	}

	return
}

// MustReviewRequestResult retrieves the ReviewRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustReviewRequestResult() ReviewRequestResult {
	val, ok := u.GetReviewRequestResult()

	if !ok {
		panic("arm ReviewRequestResult is not set")
	}

	return val
}

// GetReviewRequestResult retrieves the ReviewRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetReviewRequestResult() (result ReviewRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ReviewRequestResult" {
		result = *u.ReviewRequestResult
		ok = true
	}

	return
}

// MustCreateSaleCreationRequestResult retrieves the CreateSaleCreationRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCreateSaleCreationRequestResult() CreateSaleCreationRequestResult {
	val, ok := u.GetCreateSaleCreationRequestResult()

	if !ok {
		panic("arm CreateSaleCreationRequestResult is not set")
	}

	return val
}

// GetCreateSaleCreationRequestResult retrieves the CreateSaleCreationRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCreateSaleCreationRequestResult() (result CreateSaleCreationRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateSaleCreationRequestResult" {
		result = *u.CreateSaleCreationRequestResult
		ok = true
	}

	return
}

// MustCheckSaleStateResult retrieves the CheckSaleStateResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCheckSaleStateResult() CheckSaleStateResult {
	val, ok := u.GetCheckSaleStateResult()

	if !ok {
		panic("arm CheckSaleStateResult is not set")
	}

	return val
}

// GetCheckSaleStateResult retrieves the CheckSaleStateResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCheckSaleStateResult() (result CheckSaleStateResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CheckSaleStateResult" {
		result = *u.CheckSaleStateResult
		ok = true
	}

	return
}

// MustPayoutResult retrieves the PayoutResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustPayoutResult() PayoutResult {
	val, ok := u.GetPayoutResult()

	if !ok {
		panic("arm PayoutResult is not set")
	}

	return val
}

// GetPayoutResult retrieves the PayoutResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetPayoutResult() (result PayoutResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "PayoutResult" {
		result = *u.PayoutResult
		ok = true
	}

	return
}

// MustCreateAmlAlertRequestResult retrieves the CreateAmlAlertRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCreateAmlAlertRequestResult() CreateAmlAlertRequestResult {
	val, ok := u.GetCreateAmlAlertRequestResult()

	if !ok {
		panic("arm CreateAmlAlertRequestResult is not set")
	}

	return val
}

// GetCreateAmlAlertRequestResult retrieves the CreateAmlAlertRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCreateAmlAlertRequestResult() (result CreateAmlAlertRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateAmlAlertRequestResult" {
		result = *u.CreateAmlAlertRequestResult
		ok = true
	}

	return
}

// MustManageKeyValueResult retrieves the ManageKeyValueResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustManageKeyValueResult() ManageKeyValueResult {
	val, ok := u.GetManageKeyValueResult()

	if !ok {
		panic("arm ManageKeyValueResult is not set")
	}

	return val
}

// GetManageKeyValueResult retrieves the ManageKeyValueResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetManageKeyValueResult() (result ManageKeyValueResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageKeyValueResult" {
		result = *u.ManageKeyValueResult
		ok = true
	}

	return
}

// MustCreateChangeRoleRequestResult retrieves the CreateChangeRoleRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCreateChangeRoleRequestResult() CreateChangeRoleRequestResult {
	val, ok := u.GetCreateChangeRoleRequestResult()

	if !ok {
		panic("arm CreateChangeRoleRequestResult is not set")
	}

	return val
}

// GetCreateChangeRoleRequestResult retrieves the CreateChangeRoleRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCreateChangeRoleRequestResult() (result CreateChangeRoleRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateChangeRoleRequestResult" {
		result = *u.CreateChangeRoleRequestResult
		ok = true
	}

	return
}

// MustManageExternalSystemAccountIdPoolEntryResult retrieves the ManageExternalSystemAccountIdPoolEntryResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustManageExternalSystemAccountIdPoolEntryResult() ManageExternalSystemAccountIdPoolEntryResult {
	val, ok := u.GetManageExternalSystemAccountIdPoolEntryResult()

	if !ok {
		panic("arm ManageExternalSystemAccountIdPoolEntryResult is not set")
	}

	return val
}

// GetManageExternalSystemAccountIdPoolEntryResult retrieves the ManageExternalSystemAccountIdPoolEntryResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetManageExternalSystemAccountIdPoolEntryResult() (result ManageExternalSystemAccountIdPoolEntryResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageExternalSystemAccountIdPoolEntryResult" {
		result = *u.ManageExternalSystemAccountIdPoolEntryResult
		ok = true
	}

	return
}

// MustBindExternalSystemAccountIdResult retrieves the BindExternalSystemAccountIdResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustBindExternalSystemAccountIdResult() BindExternalSystemAccountIdResult {
	val, ok := u.GetBindExternalSystemAccountIdResult()

	if !ok {
		panic("arm BindExternalSystemAccountIdResult is not set")
	}

	return val
}

// GetBindExternalSystemAccountIdResult retrieves the BindExternalSystemAccountIdResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetBindExternalSystemAccountIdResult() (result BindExternalSystemAccountIdResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "BindExternalSystemAccountIdResult" {
		result = *u.BindExternalSystemAccountIdResult
		ok = true
	}

	return
}

// MustPaymentResult retrieves the PaymentResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustPaymentResult() PaymentResult {
	val, ok := u.GetPaymentResult()

	if !ok {
		panic("arm PaymentResult is not set")
	}

	return val
}

// GetPaymentResult retrieves the PaymentResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetPaymentResult() (result PaymentResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "PaymentResult" {
		result = *u.PaymentResult
		ok = true
	}

	return
}

// MustManageSaleResult retrieves the ManageSaleResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustManageSaleResult() ManageSaleResult {
	val, ok := u.GetManageSaleResult()

	if !ok {
		panic("arm ManageSaleResult is not set")
	}

	return val
}

// GetManageSaleResult retrieves the ManageSaleResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetManageSaleResult() (result ManageSaleResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageSaleResult" {
		result = *u.ManageSaleResult
		ok = true
	}

	return
}

// MustCreateManageLimitsRequestResult retrieves the CreateManageLimitsRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCreateManageLimitsRequestResult() CreateManageLimitsRequestResult {
	val, ok := u.GetCreateManageLimitsRequestResult()

	if !ok {
		panic("arm CreateManageLimitsRequestResult is not set")
	}

	return val
}

// GetCreateManageLimitsRequestResult retrieves the CreateManageLimitsRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCreateManageLimitsRequestResult() (result CreateManageLimitsRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateManageLimitsRequestResult" {
		result = *u.CreateManageLimitsRequestResult
		ok = true
	}

	return
}

// MustManageContractRequestResult retrieves the ManageContractRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustManageContractRequestResult() ManageContractRequestResult {
	val, ok := u.GetManageContractRequestResult()

	if !ok {
		panic("arm ManageContractRequestResult is not set")
	}

	return val
}

// GetManageContractRequestResult retrieves the ManageContractRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetManageContractRequestResult() (result ManageContractRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageContractRequestResult" {
		result = *u.ManageContractRequestResult
		ok = true
	}

	return
}

// MustManageContractResult retrieves the ManageContractResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustManageContractResult() ManageContractResult {
	val, ok := u.GetManageContractResult()

	if !ok {
		panic("arm ManageContractResult is not set")
	}

	return val
}

// GetManageContractResult retrieves the ManageContractResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetManageContractResult() (result ManageContractResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageContractResult" {
		result = *u.ManageContractResult
		ok = true
	}

	return
}

// MustCancelSaleCreationRequestResult retrieves the CancelSaleCreationRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCancelSaleCreationRequestResult() CancelSaleCreationRequestResult {
	val, ok := u.GetCancelSaleCreationRequestResult()

	if !ok {
		panic("arm CancelSaleCreationRequestResult is not set")
	}

	return val
}

// GetCancelSaleCreationRequestResult retrieves the CancelSaleCreationRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCancelSaleCreationRequestResult() (result CancelSaleCreationRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CancelSaleCreationRequestResult" {
		result = *u.CancelSaleCreationRequestResult
		ok = true
	}

	return
}

// MustCreateAtomicSwapAskRequestResult retrieves the CreateAtomicSwapAskRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCreateAtomicSwapAskRequestResult() CreateAtomicSwapAskRequestResult {
	val, ok := u.GetCreateAtomicSwapAskRequestResult()

	if !ok {
		panic("arm CreateAtomicSwapAskRequestResult is not set")
	}

	return val
}

// GetCreateAtomicSwapAskRequestResult retrieves the CreateAtomicSwapAskRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCreateAtomicSwapAskRequestResult() (result CreateAtomicSwapAskRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateAtomicSwapAskRequestResult" {
		result = *u.CreateAtomicSwapAskRequestResult
		ok = true
	}

	return
}

// MustCancelAtomicSwapAskResult retrieves the CancelAtomicSwapAskResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCancelAtomicSwapAskResult() CancelAtomicSwapAskResult {
	val, ok := u.GetCancelAtomicSwapAskResult()

	if !ok {
		panic("arm CancelAtomicSwapAskResult is not set")
	}

	return val
}

// GetCancelAtomicSwapAskResult retrieves the CancelAtomicSwapAskResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCancelAtomicSwapAskResult() (result CancelAtomicSwapAskResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CancelAtomicSwapAskResult" {
		result = *u.CancelAtomicSwapAskResult
		ok = true
	}

	return
}

// MustCreateAtomicSwapBidRequestResult retrieves the CreateAtomicSwapBidRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCreateAtomicSwapBidRequestResult() CreateAtomicSwapBidRequestResult {
	val, ok := u.GetCreateAtomicSwapBidRequestResult()

	if !ok {
		panic("arm CreateAtomicSwapBidRequestResult is not set")
	}

	return val
}

// GetCreateAtomicSwapBidRequestResult retrieves the CreateAtomicSwapBidRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCreateAtomicSwapBidRequestResult() (result CreateAtomicSwapBidRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateAtomicSwapBidRequestResult" {
		result = *u.CreateAtomicSwapBidRequestResult
		ok = true
	}

	return
}

// MustManageAccountRoleResult retrieves the ManageAccountRoleResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustManageAccountRoleResult() ManageAccountRoleResult {
	val, ok := u.GetManageAccountRoleResult()

	if !ok {
		panic("arm ManageAccountRoleResult is not set")
	}

	return val
}

// GetManageAccountRoleResult retrieves the ManageAccountRoleResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetManageAccountRoleResult() (result ManageAccountRoleResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageAccountRoleResult" {
		result = *u.ManageAccountRoleResult
		ok = true
	}

	return
}

// MustManageAccountRuleResult retrieves the ManageAccountRuleResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustManageAccountRuleResult() ManageAccountRuleResult {
	val, ok := u.GetManageAccountRuleResult()

	if !ok {
		panic("arm ManageAccountRuleResult is not set")
	}

	return val
}

// GetManageAccountRuleResult retrieves the ManageAccountRuleResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetManageAccountRuleResult() (result ManageAccountRuleResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageAccountRuleResult" {
		result = *u.ManageAccountRuleResult
		ok = true
	}

	return
}

// MustManageSignerResult retrieves the ManageSignerResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustManageSignerResult() ManageSignerResult {
	val, ok := u.GetManageSignerResult()

	if !ok {
		panic("arm ManageSignerResult is not set")
	}

	return val
}

// GetManageSignerResult retrieves the ManageSignerResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetManageSignerResult() (result ManageSignerResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageSignerResult" {
		result = *u.ManageSignerResult
		ok = true
	}

	return
}

// MustManageSignerRoleResult retrieves the ManageSignerRoleResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustManageSignerRoleResult() ManageSignerRoleResult {
	val, ok := u.GetManageSignerRoleResult()

	if !ok {
		panic("arm ManageSignerRoleResult is not set")
	}

	return val
}

// GetManageSignerRoleResult retrieves the ManageSignerRoleResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetManageSignerRoleResult() (result ManageSignerRoleResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageSignerRoleResult" {
		result = *u.ManageSignerRoleResult
		ok = true
	}

	return
}

// MustManageSignerRuleResult retrieves the ManageSignerRuleResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustManageSignerRuleResult() ManageSignerRuleResult {
	val, ok := u.GetManageSignerRuleResult()

	if !ok {
		panic("arm ManageSignerRuleResult is not set")
	}

	return val
}

// GetManageSignerRuleResult retrieves the ManageSignerRuleResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetManageSignerRuleResult() (result ManageSignerRuleResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageSignerRuleResult" {
		result = *u.ManageSignerRuleResult
		ok = true
	}

	return
}

// MustStampResult retrieves the StampResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustStampResult() StampResult {
	val, ok := u.GetStampResult()

	if !ok {
		panic("arm StampResult is not set")
	}

	return val
}

// GetStampResult retrieves the StampResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetStampResult() (result StampResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "StampResult" {
		result = *u.StampResult
		ok = true
	}

	return
}

// MustLicenseResult retrieves the LicenseResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustLicenseResult() LicenseResult {
	val, ok := u.GetLicenseResult()

	if !ok {
		panic("arm LicenseResult is not set")
	}

	return val
}

// GetLicenseResult retrieves the LicenseResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetLicenseResult() (result LicenseResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "LicenseResult" {
		result = *u.LicenseResult
		ok = true
	}

	return
}

// MustManagePollResult retrieves the ManagePollResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustManagePollResult() ManagePollResult {
	val, ok := u.GetManagePollResult()

	if !ok {
		panic("arm ManagePollResult is not set")
	}

	return val
}

// GetManagePollResult retrieves the ManagePollResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetManagePollResult() (result ManagePollResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManagePollResult" {
		result = *u.ManagePollResult
		ok = true
	}

	return
}

// MustManageCreatePollRequestResult retrieves the ManageCreatePollRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustManageCreatePollRequestResult() ManageCreatePollRequestResult {
	val, ok := u.GetManageCreatePollRequestResult()

	if !ok {
		panic("arm ManageCreatePollRequestResult is not set")
	}

	return val
}

// GetManageCreatePollRequestResult retrieves the ManageCreatePollRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetManageCreatePollRequestResult() (result ManageCreatePollRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageCreatePollRequestResult" {
		result = *u.ManageCreatePollRequestResult
		ok = true
	}

	return
}

// MustManageVoteResult retrieves the ManageVoteResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustManageVoteResult() ManageVoteResult {
	val, ok := u.GetManageVoteResult()

	if !ok {
		panic("arm ManageVoteResult is not set")
	}

	return val
}

// GetManageVoteResult retrieves the ManageVoteResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetManageVoteResult() (result ManageVoteResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageVoteResult" {
		result = *u.ManageVoteResult
		ok = true
	}

	return
}

// MustManageAccountSpecificRuleResult retrieves the ManageAccountSpecificRuleResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustManageAccountSpecificRuleResult() ManageAccountSpecificRuleResult {
	val, ok := u.GetManageAccountSpecificRuleResult()

	if !ok {
		panic("arm ManageAccountSpecificRuleResult is not set")
	}

	return val
}

// GetManageAccountSpecificRuleResult retrieves the ManageAccountSpecificRuleResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetManageAccountSpecificRuleResult() (result ManageAccountSpecificRuleResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "ManageAccountSpecificRuleResult" {
		result = *u.ManageAccountSpecificRuleResult
		ok = true
	}

	return
}

// MustCancelChangeRoleRequestResult retrieves the CancelChangeRoleRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCancelChangeRoleRequestResult() CancelChangeRoleRequestResult {
	val, ok := u.GetCancelChangeRoleRequestResult()

	if !ok {
		panic("arm CancelChangeRoleRequestResult is not set")
	}

	return val
}

// GetCancelChangeRoleRequestResult retrieves the CancelChangeRoleRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCancelChangeRoleRequestResult() (result CancelChangeRoleRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CancelChangeRoleRequestResult" {
		result = *u.CancelChangeRoleRequestResult
		ok = true
	}

	return
}

// MustRemoveAssetPairResult retrieves the RemoveAssetPairResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustRemoveAssetPairResult() RemoveAssetPairResult {
	val, ok := u.GetRemoveAssetPairResult()

	if !ok {
		panic("arm RemoveAssetPairResult is not set")
	}

	return val
}

// GetRemoveAssetPairResult retrieves the RemoveAssetPairResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetRemoveAssetPairResult() (result RemoveAssetPairResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "RemoveAssetPairResult" {
		result = *u.RemoveAssetPairResult
		ok = true
	}

	return
}

// MustCreateKycRecoveryRequestResult retrieves the CreateKycRecoveryRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCreateKycRecoveryRequestResult() CreateKycRecoveryRequestResult {
	val, ok := u.GetCreateKycRecoveryRequestResult()

	if !ok {
		panic("arm CreateKycRecoveryRequestResult is not set")
	}

	return val
}

// GetCreateKycRecoveryRequestResult retrieves the CreateKycRecoveryRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCreateKycRecoveryRequestResult() (result CreateKycRecoveryRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateKycRecoveryRequestResult" {
		result = *u.CreateKycRecoveryRequestResult
		ok = true
	}

	return
}

// MustInitiateKycRecoveryResult retrieves the InitiateKycRecoveryResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustInitiateKycRecoveryResult() InitiateKycRecoveryResult {
	val, ok := u.GetInitiateKycRecoveryResult()

	if !ok {
		panic("arm InitiateKycRecoveryResult is not set")
	}

	return val
}

// GetInitiateKycRecoveryResult retrieves the InitiateKycRecoveryResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetInitiateKycRecoveryResult() (result InitiateKycRecoveryResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "InitiateKycRecoveryResult" {
		result = *u.InitiateKycRecoveryResult
		ok = true
	}

	return
}

// MustCreateManageOfferRequestResult retrieves the CreateManageOfferRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCreateManageOfferRequestResult() CreateManageOfferRequestResult {
	val, ok := u.GetCreateManageOfferRequestResult()

	if !ok {
		panic("arm CreateManageOfferRequestResult is not set")
	}

	return val
}

// GetCreateManageOfferRequestResult retrieves the CreateManageOfferRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCreateManageOfferRequestResult() (result CreateManageOfferRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateManageOfferRequestResult" {
		result = *u.CreateManageOfferRequestResult
		ok = true
	}

	return
}

// MustCreatePaymentRequestResult retrieves the CreatePaymentRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCreatePaymentRequestResult() CreatePaymentRequestResult {
	val, ok := u.GetCreatePaymentRequestResult()

	if !ok {
		panic("arm CreatePaymentRequestResult is not set")
	}

	return val
}

// GetCreatePaymentRequestResult retrieves the CreatePaymentRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCreatePaymentRequestResult() (result CreatePaymentRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreatePaymentRequestResult" {
		result = *u.CreatePaymentRequestResult
		ok = true
	}

	return
}

// MustRemoveAssetResult retrieves the RemoveAssetResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustRemoveAssetResult() RemoveAssetResult {
	val, ok := u.GetRemoveAssetResult()

	if !ok {
		panic("arm RemoveAssetResult is not set")
	}

	return val
}

// GetRemoveAssetResult retrieves the RemoveAssetResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetRemoveAssetResult() (result RemoveAssetResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "RemoveAssetResult" {
		result = *u.RemoveAssetResult
		ok = true
	}

	return
}

// MustOpenSwapResult retrieves the OpenSwapResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustOpenSwapResult() OpenSwapResult {
	val, ok := u.GetOpenSwapResult()

	if !ok {
		panic("arm OpenSwapResult is not set")
	}

	return val
}

// GetOpenSwapResult retrieves the OpenSwapResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetOpenSwapResult() (result OpenSwapResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "OpenSwapResult" {
		result = *u.OpenSwapResult
		ok = true
	}

	return
}

// MustCloseSwapResult retrieves the CloseSwapResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCloseSwapResult() CloseSwapResult {
	val, ok := u.GetCloseSwapResult()

	if !ok {
		panic("arm CloseSwapResult is not set")
	}

	return val
}

// GetCloseSwapResult retrieves the CloseSwapResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCloseSwapResult() (result CloseSwapResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CloseSwapResult" {
		result = *u.CloseSwapResult
		ok = true
	}

	return
}

// MustCreateRedemptionRequestResult retrieves the CreateRedemptionRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCreateRedemptionRequestResult() CreateRedemptionRequestResult {
	val, ok := u.GetCreateRedemptionRequestResult()

	if !ok {
		panic("arm CreateRedemptionRequestResult is not set")
	}

	return val
}

// GetCreateRedemptionRequestResult retrieves the CreateRedemptionRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCreateRedemptionRequestResult() (result CreateRedemptionRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateRedemptionRequestResult" {
		result = *u.CreateRedemptionRequestResult
		ok = true
	}

	return
}

// MustCreateDataResult retrieves the CreateDataResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCreateDataResult() CreateDataResult {
	val, ok := u.GetCreateDataResult()

	if !ok {
		panic("arm CreateDataResult is not set")
	}

	return val
}

// GetCreateDataResult retrieves the CreateDataResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCreateDataResult() (result CreateDataResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateDataResult" {
		result = *u.CreateDataResult
		ok = true
	}

	return
}

// MustUpdateDataResult retrieves the UpdateDataResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustUpdateDataResult() UpdateDataResult {
	val, ok := u.GetUpdateDataResult()

	if !ok {
		panic("arm UpdateDataResult is not set")
	}

	return val
}

// GetUpdateDataResult retrieves the UpdateDataResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetUpdateDataResult() (result UpdateDataResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "UpdateDataResult" {
		result = *u.UpdateDataResult
		ok = true
	}

	return
}

// MustRemoveDataResult retrieves the RemoveDataResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustRemoveDataResult() RemoveDataResult {
	val, ok := u.GetRemoveDataResult()

	if !ok {
		panic("arm RemoveDataResult is not set")
	}

	return val
}

// GetRemoveDataResult retrieves the RemoveDataResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetRemoveDataResult() (result RemoveDataResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "RemoveDataResult" {
		result = *u.RemoveDataResult
		ok = true
	}

	return
}

// MustCreateDataCreationRequestResult retrieves the CreateDataCreationRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCreateDataCreationRequestResult() CreateDataCreationRequestResult {
	val, ok := u.GetCreateDataCreationRequestResult()

	if !ok {
		panic("arm CreateDataCreationRequestResult is not set")
	}

	return val
}

// GetCreateDataCreationRequestResult retrieves the CreateDataCreationRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCreateDataCreationRequestResult() (result CreateDataCreationRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateDataCreationRequestResult" {
		result = *u.CreateDataCreationRequestResult
		ok = true
	}

	return
}

// MustCancelDataCreationRequestResult retrieves the CancelDataCreationRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCancelDataCreationRequestResult() CancelDataCreationRequestResult {
	val, ok := u.GetCancelDataCreationRequestResult()

	if !ok {
		panic("arm CancelDataCreationRequestResult is not set")
	}

	return val
}

// GetCancelDataCreationRequestResult retrieves the CancelDataCreationRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCancelDataCreationRequestResult() (result CancelDataCreationRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CancelDataCreationRequestResult" {
		result = *u.CancelDataCreationRequestResult
		ok = true
	}

	return
}

// MustCreateDataUpdateRequestResult retrieves the CreateDataUpdateRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCreateDataUpdateRequestResult() CreateDataUpdateRequestResult {
	val, ok := u.GetCreateDataUpdateRequestResult()

	if !ok {
		panic("arm CreateDataUpdateRequestResult is not set")
	}

	return val
}

// GetCreateDataUpdateRequestResult retrieves the CreateDataUpdateRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCreateDataUpdateRequestResult() (result CreateDataUpdateRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateDataUpdateRequestResult" {
		result = *u.CreateDataUpdateRequestResult
		ok = true
	}

	return
}

// MustCreateDataRemoveRequestResult retrieves the CreateDataRemoveRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCreateDataRemoveRequestResult() CreateDataRemoveRequestResult {
	val, ok := u.GetCreateDataRemoveRequestResult()

	if !ok {
		panic("arm CreateDataRemoveRequestResult is not set")
	}

	return val
}

// GetCreateDataRemoveRequestResult retrieves the CreateDataRemoveRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCreateDataRemoveRequestResult() (result CreateDataRemoveRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateDataRemoveRequestResult" {
		result = *u.CreateDataRemoveRequestResult
		ok = true
	}

	return
}

// MustCancelDataUpdateRequestResult retrieves the CancelDataUpdateRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCancelDataUpdateRequestResult() CancelDataUpdateRequestResult {
	val, ok := u.GetCancelDataUpdateRequestResult()

	if !ok {
		panic("arm CancelDataUpdateRequestResult is not set")
	}

	return val
}

// GetCancelDataUpdateRequestResult retrieves the CancelDataUpdateRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCancelDataUpdateRequestResult() (result CancelDataUpdateRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CancelDataUpdateRequestResult" {
		result = *u.CancelDataUpdateRequestResult
		ok = true
	}

	return
}

// MustCancelDataRemoveRequestResult retrieves the CancelDataRemoveRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCancelDataRemoveRequestResult() CancelDataRemoveRequestResult {
	val, ok := u.GetCancelDataRemoveRequestResult()

	if !ok {
		panic("arm CancelDataRemoveRequestResult is not set")
	}

	return val
}

// GetCancelDataRemoveRequestResult retrieves the CancelDataRemoveRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCancelDataRemoveRequestResult() (result CancelDataRemoveRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CancelDataRemoveRequestResult" {
		result = *u.CancelDataRemoveRequestResult
		ok = true
	}

	return
}

// MustCreateDeferredPaymentCreationRequestResult retrieves the CreateDeferredPaymentCreationRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCreateDeferredPaymentCreationRequestResult() CreateDeferredPaymentCreationRequestResult {
	val, ok := u.GetCreateDeferredPaymentCreationRequestResult()

	if !ok {
		panic("arm CreateDeferredPaymentCreationRequestResult is not set")
	}

	return val
}

// GetCreateDeferredPaymentCreationRequestResult retrieves the CreateDeferredPaymentCreationRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCreateDeferredPaymentCreationRequestResult() (result CreateDeferredPaymentCreationRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateDeferredPaymentCreationRequestResult" {
		result = *u.CreateDeferredPaymentCreationRequestResult
		ok = true
	}

	return
}

// MustCancelDeferredPaymentCreationRequestResult retrieves the CancelDeferredPaymentCreationRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCancelDeferredPaymentCreationRequestResult() CancelDeferredPaymentCreationRequestResult {
	val, ok := u.GetCancelDeferredPaymentCreationRequestResult()

	if !ok {
		panic("arm CancelDeferredPaymentCreationRequestResult is not set")
	}

	return val
}

// GetCancelDeferredPaymentCreationRequestResult retrieves the CancelDeferredPaymentCreationRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCancelDeferredPaymentCreationRequestResult() (result CancelDeferredPaymentCreationRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CancelDeferredPaymentCreationRequestResult" {
		result = *u.CancelDeferredPaymentCreationRequestResult
		ok = true
	}

	return
}

// MustCreateCloseDeferredPaymentRequestResult retrieves the CreateCloseDeferredPaymentRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCreateCloseDeferredPaymentRequestResult() CreateCloseDeferredPaymentRequestResult {
	val, ok := u.GetCreateCloseDeferredPaymentRequestResult()

	if !ok {
		panic("arm CreateCloseDeferredPaymentRequestResult is not set")
	}

	return val
}

// GetCreateCloseDeferredPaymentRequestResult retrieves the CreateCloseDeferredPaymentRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCreateCloseDeferredPaymentRequestResult() (result CreateCloseDeferredPaymentRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CreateCloseDeferredPaymentRequestResult" {
		result = *u.CreateCloseDeferredPaymentRequestResult
		ok = true
	}

	return
}

// MustCancelCloseDeferredPaymentRequestResult retrieves the CancelCloseDeferredPaymentRequestResult value from the union,
// panicing if the value is not set.
func (u OperationResultTr) MustCancelCloseDeferredPaymentRequestResult() CancelCloseDeferredPaymentRequestResult {
	val, ok := u.GetCancelCloseDeferredPaymentRequestResult()

	if !ok {
		panic("arm CancelCloseDeferredPaymentRequestResult is not set")
	}

	return val
}

// GetCancelCloseDeferredPaymentRequestResult retrieves the CancelCloseDeferredPaymentRequestResult value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResultTr) GetCancelCloseDeferredPaymentRequestResult() (result CancelCloseDeferredPaymentRequestResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "CancelCloseDeferredPaymentRequestResult" {
		result = *u.CancelCloseDeferredPaymentRequestResult
		ok = true
	}

	return
}

// OperationResult is an XDR Union defines as:
//
//   union OperationResult switch (OperationResultCode code)
//    {
//    case opINNER:
//        union switch (OperationType type)
//        {
//        case CREATE_ACCOUNT:
//            CreateAccountResult createAccountResult;
//    	case CREATE_ISSUANCE_REQUEST:
//    		CreateIssuanceRequestResult createIssuanceRequestResult;
//        case SET_FEES:
//            SetFeesResult setFeesResult;
//        case CREATE_WITHDRAWAL_REQUEST:
//    		CreateWithdrawalRequestResult createWithdrawalRequestResult;
//        case MANAGE_BALANCE:
//            ManageBalanceResult manageBalanceResult;
//        case MANAGE_ASSET:
//            ManageAssetResult manageAssetResult;
//        case CREATE_PREISSUANCE_REQUEST:
//            CreatePreIssuanceRequestResult createPreIssuanceRequestResult;
//        case MANAGE_LIMITS:
//            ManageLimitsResult manageLimitsResult;
//    	case MANAGE_ASSET_PAIR:
//    		ManageAssetPairResult manageAssetPairResult;
//    	case MANAGE_OFFER:
//    		ManageOfferResult manageOfferResult;
//    	case MANAGE_INVOICE_REQUEST:
//    		ManageInvoiceRequestResult manageInvoiceRequestResult;
//    	case REVIEW_REQUEST:
//    		ReviewRequestResult reviewRequestResult;
//    	case CREATE_SALE_REQUEST:
//    		CreateSaleCreationRequestResult createSaleCreationRequestResult;
//    	case CHECK_SALE_STATE:
//    		CheckSaleStateResult checkSaleStateResult;
//    	case PAYOUT:
//    	    PayoutResult payoutResult;
//    	case CREATE_AML_ALERT:
//    	    CreateAMLAlertRequestResult createAMLAlertRequestResult;
//    	case MANAGE_KEY_VALUE:
//    	    ManageKeyValueResult manageKeyValueResult;
//    	case CREATE_CHANGE_ROLE_REQUEST:
//    	    CreateChangeRoleRequestResult createChangeRoleRequestResult;
//        case MANAGE_EXTERNAL_SYSTEM_ACCOUNT_ID_POOL_ENTRY:
//            ManageExternalSystemAccountIdPoolEntryResult manageExternalSystemAccountIdPoolEntryResult;
//        case BIND_EXTERNAL_SYSTEM_ACCOUNT_ID:
//            BindExternalSystemAccountIdResult bindExternalSystemAccountIdResult;
//        case PAYMENT:
//            PaymentResult paymentResult;
//        case MANAGE_SALE:
//            ManageSaleResult manageSaleResult;
//        case CREATE_MANAGE_LIMITS_REQUEST:
//            CreateManageLimitsRequestResult createManageLimitsRequestResult;
//        case MANAGE_CONTRACT_REQUEST:
//            ManageContractRequestResult manageContractRequestResult;
//        case MANAGE_CONTRACT:
//            ManageContractResult manageContractResult;
//        case CANCEL_SALE_REQUEST:
//            CancelSaleCreationRequestResult cancelSaleCreationRequestResult;
//        case CREATE_ATOMIC_SWAP_ASK_REQUEST:
//            CreateAtomicSwapAskRequestResult createAtomicSwapAskRequestResult;
//        case CANCEL_ATOMIC_SWAP_ASK:
//            CancelAtomicSwapAskResult cancelAtomicSwapAskResult;
//        case CREATE_ATOMIC_SWAP_BID_REQUEST:
//            CreateAtomicSwapBidRequestResult createAtomicSwapBidRequestResult;
//        case MANAGE_ACCOUNT_ROLE:
//            ManageAccountRoleResult manageAccountRoleResult;
//        case MANAGE_ACCOUNT_RULE:
//            ManageAccountRuleResult manageAccountRuleResult;
//        case MANAGE_SIGNER:
//            ManageSignerResult manageSignerResult;
//        case MANAGE_SIGNER_ROLE:
//            ManageSignerRoleResult manageSignerRoleResult;
//        case MANAGE_SIGNER_RULE:
//            ManageSignerRuleResult manageSignerRuleResult;
//        case STAMP:
//            StampResult stampResult;
//        case LICENSE:
//            LicenseResult licenseResult;
//        case MANAGE_POLL:
//            ManagePollResult managePollResult;
//        case MANAGE_CREATE_POLL_REQUEST:
//            ManageCreatePollRequestResult manageCreatePollRequestResult;
//        case MANAGE_VOTE:
//            ManageVoteResult manageVoteResult;
//        case MANAGE_ACCOUNT_SPECIFIC_RULE:
//            ManageAccountSpecificRuleResult manageAccountSpecificRuleResult;
//        case CANCEL_CHANGE_ROLE_REQUEST:
//            CancelChangeRoleRequestResult cancelChangeRoleRequestResult;
//        case REMOVE_ASSET_PAIR:
//            RemoveAssetPairResult removeAssetPairResult;
//        case CREATE_KYC_RECOVERY_REQUEST:
//            CreateKYCRecoveryRequestResult createKYCRecoveryRequestResult;
//        case INITIATE_KYC_RECOVERY:
//            InitiateKYCRecoveryResult initiateKYCRecoveryResult;
//        case CREATE_MANAGE_OFFER_REQUEST:
//            CreateManageOfferRequestResult createManageOfferRequestResult;
//        case CREATE_PAYMENT_REQUEST:
//            CreatePaymentRequestResult createPaymentRequestResult;
//        case REMOVE_ASSET:
//            RemoveAssetResult removeAssetResult;
//        case OPEN_SWAP:
//            OpenSwapResult openSwapResult;
//        case CLOSE_SWAP:
//            CloseSwapResult closeSwapResult;
//        case CREATE_REDEMPTION_REQUEST:
//            CreateRedemptionRequestResult createRedemptionRequestResult;
//        case CREATE_DATA:
//            CreateDataResult createDataResult;
//        case UPDATE_DATA:
//            UpdateDataResult updateDataResult;
//        case REMOVE_DATA:
//            RemoveDataResult removeDataResult;
//        case CREATE_DATA_CREATION_REQUEST:
//            CreateDataCreationRequestResult createDataCreationRequestResult;
//        case CANCEL_DATA_CREATION_REQUEST:
//            CancelDataCreationRequestResult cancelDataCreationRequestResult;
//        case CREATE_DATA_UPDATE_REQUEST:
//            CreateDataUpdateRequestResult createDataUpdateRequestResult;
//        case CREATE_DATA_REMOVE_REQUEST:
//            CreateDataRemoveRequestResult createDataRemoveRequestResult;
//        case CANCEL_DATA_UPDATE_REQUEST:
//            CancelDataUpdateRequestResult cancelDataUpdateRequestResult;
//        case CANCEL_DATA_REMOVE_REQUEST:
//            CancelDataRemoveRequestResult cancelDataRemoveRequestResult;
//        case CREATE_DEFERRED_PAYMENT_CREATION_REQUEST:
//                CreateDeferredPaymentCreationRequestResult createDeferredPaymentCreationRequestResult;
//        case CANCEL_DEFERRED_PAYMENT_CREATION_REQUEST:
//            CancelDeferredPaymentCreationRequestResult cancelDeferredPaymentCreationRequestResult;
//        case CREATE_CLOSE_DEFERRED_PAYMENT_REQUEST:
//            CreateCloseDeferredPaymentRequestResult createCloseDeferredPaymentRequestResult;
//        case CANCEL_CLOSE_DEFERRED_PAYMENT_REQUEST:
//            CancelCloseDeferredPaymentRequestResult cancelCloseDeferredPaymentRequestResult;
//
//        }
//        tr;
//    case opNO_ENTRY:
//        LedgerEntryType entryType;
//    case opNO_ROLE_PERMISSION:
//        AccountRuleRequirement requirement;
//    default:
//        void;
//    };
//
type OperationResult struct {
	Code        OperationResultCode     `json:"code,omitempty"`
	Tr          *OperationResultTr      `json:"tr,omitempty"`
	EntryType   *LedgerEntryType        `json:"entryType,omitempty"`
	Requirement *AccountRuleRequirement `json:"requirement,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u OperationResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of OperationResult
func (u OperationResult) ArmForSwitch(sw int32) (string, bool) {
	switch OperationResultCode(sw) {
	case OperationResultCodeOpInner:
		return "Tr", true
	case OperationResultCodeOpNoEntry:
		return "EntryType", true
	case OperationResultCodeOpNoRolePermission:
		return "Requirement", true
	default:
		return "", true
	}
}

// NewOperationResult creates a new  OperationResult.
func NewOperationResult(code OperationResultCode, value interface{}) (result OperationResult, err error) {
	result.Code = code
	switch OperationResultCode(code) {
	case OperationResultCodeOpInner:
		tv, ok := value.(OperationResultTr)
		if !ok {
			err = fmt.Errorf("invalid value, must be OperationResultTr")
			return
		}
		result.Tr = &tv
	case OperationResultCodeOpNoEntry:
		tv, ok := value.(LedgerEntryType)
		if !ok {
			err = fmt.Errorf("invalid value, must be LedgerEntryType")
			return
		}
		result.EntryType = &tv
	case OperationResultCodeOpNoRolePermission:
		tv, ok := value.(AccountRuleRequirement)
		if !ok {
			err = fmt.Errorf("invalid value, must be AccountRuleRequirement")
			return
		}
		result.Requirement = &tv
	default:
		// void
	}
	return
}

// MustTr retrieves the Tr value from the union,
// panicing if the value is not set.
func (u OperationResult) MustTr() OperationResultTr {
	val, ok := u.GetTr()

	if !ok {
		panic("arm Tr is not set")
	}

	return val
}

// GetTr retrieves the Tr value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResult) GetTr() (result OperationResultTr, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Tr" {
		result = *u.Tr
		ok = true
	}

	return
}

// MustEntryType retrieves the EntryType value from the union,
// panicing if the value is not set.
func (u OperationResult) MustEntryType() LedgerEntryType {
	val, ok := u.GetEntryType()

	if !ok {
		panic("arm EntryType is not set")
	}

	return val
}

// GetEntryType retrieves the EntryType value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResult) GetEntryType() (result LedgerEntryType, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "EntryType" {
		result = *u.EntryType
		ok = true
	}

	return
}

// MustRequirement retrieves the Requirement value from the union,
// panicing if the value is not set.
func (u OperationResult) MustRequirement() AccountRuleRequirement {
	val, ok := u.GetRequirement()

	if !ok {
		panic("arm Requirement is not set")
	}

	return val
}

// GetRequirement retrieves the Requirement value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u OperationResult) GetRequirement() (result AccountRuleRequirement, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Requirement" {
		result = *u.Requirement
		ok = true
	}

	return
}

// TransactionResultCode is an XDR Enum defines as:
//
//   enum TransactionResultCode
//    {
//        txSUCCESS = 0, // all operations succeeded
//
//        txFAILED = -1, // one of the operations failed (none were applied)
//
//        txTOO_EARLY = -2,         // ledger closeTime before minTime
//        txTOO_LATE = -3,          // ledger closeTime after maxTime
//        txMISSING_OPERATION = -4, // no operation was specified
//
//        txBAD_AUTH = -5,                   // too few valid signatures / wrong network
//        txNO_ACCOUNT = -6,                 // source account not found
//        txBAD_AUTH_EXTRA = -7,             // unused signatures attached to transaction
//        txINTERNAL_ERROR = -8,             // an unknown error occurred
//        txACCOUNT_BLOCKED = -9,            // account is blocked and cannot be source of tx
//        txDUPLICATION = -10,               // if timing is stored
//        txINSUFFICIENT_FEE = -11,          // the actual total fee amount is greater than the max total fee amount, provided by the source
//        txSOURCE_UNDERFUNDED = -12,        // not enough tx fee asset on source balance
//        txCOMMISSION_LINE_FULL = -13,      // commission tx fee asset balance amount overflow
//        txFEE_INCORRECT_PRECISION = -14,   // fee amount is incompatible with asset precision
//        txNO_ROLE_PERMISSION = -15         // account role has not rule that allows send transaction
//    };
//
type TransactionResultCode int32

const (
	TransactionResultCodeTxSuccess               TransactionResultCode = 0
	TransactionResultCodeTxFailed                TransactionResultCode = -1
	TransactionResultCodeTxTooEarly              TransactionResultCode = -2
	TransactionResultCodeTxTooLate               TransactionResultCode = -3
	TransactionResultCodeTxMissingOperation      TransactionResultCode = -4
	TransactionResultCodeTxBadAuth               TransactionResultCode = -5
	TransactionResultCodeTxNoAccount             TransactionResultCode = -6
	TransactionResultCodeTxBadAuthExtra          TransactionResultCode = -7
	TransactionResultCodeTxInternalError         TransactionResultCode = -8
	TransactionResultCodeTxAccountBlocked        TransactionResultCode = -9
	TransactionResultCodeTxDuplication           TransactionResultCode = -10
	TransactionResultCodeTxInsufficientFee       TransactionResultCode = -11
	TransactionResultCodeTxSourceUnderfunded     TransactionResultCode = -12
	TransactionResultCodeTxCommissionLineFull    TransactionResultCode = -13
	TransactionResultCodeTxFeeIncorrectPrecision TransactionResultCode = -14
	TransactionResultCodeTxNoRolePermission      TransactionResultCode = -15
)

var TransactionResultCodeAll = []TransactionResultCode{
	TransactionResultCodeTxSuccess,
	TransactionResultCodeTxFailed,
	TransactionResultCodeTxTooEarly,
	TransactionResultCodeTxTooLate,
	TransactionResultCodeTxMissingOperation,
	TransactionResultCodeTxBadAuth,
	TransactionResultCodeTxNoAccount,
	TransactionResultCodeTxBadAuthExtra,
	TransactionResultCodeTxInternalError,
	TransactionResultCodeTxAccountBlocked,
	TransactionResultCodeTxDuplication,
	TransactionResultCodeTxInsufficientFee,
	TransactionResultCodeTxSourceUnderfunded,
	TransactionResultCodeTxCommissionLineFull,
	TransactionResultCodeTxFeeIncorrectPrecision,
	TransactionResultCodeTxNoRolePermission,
}

var transactionResultCodeMap = map[int32]string{
	0:   "TransactionResultCodeTxSuccess",
	-1:  "TransactionResultCodeTxFailed",
	-2:  "TransactionResultCodeTxTooEarly",
	-3:  "TransactionResultCodeTxTooLate",
	-4:  "TransactionResultCodeTxMissingOperation",
	-5:  "TransactionResultCodeTxBadAuth",
	-6:  "TransactionResultCodeTxNoAccount",
	-7:  "TransactionResultCodeTxBadAuthExtra",
	-8:  "TransactionResultCodeTxInternalError",
	-9:  "TransactionResultCodeTxAccountBlocked",
	-10: "TransactionResultCodeTxDuplication",
	-11: "TransactionResultCodeTxInsufficientFee",
	-12: "TransactionResultCodeTxSourceUnderfunded",
	-13: "TransactionResultCodeTxCommissionLineFull",
	-14: "TransactionResultCodeTxFeeIncorrectPrecision",
	-15: "TransactionResultCodeTxNoRolePermission",
}

var transactionResultCodeShortMap = map[int32]string{
	0:   "tx_success",
	-1:  "tx_failed",
	-2:  "tx_too_early",
	-3:  "tx_too_late",
	-4:  "tx_missing_operation",
	-5:  "tx_bad_auth",
	-6:  "tx_no_account",
	-7:  "tx_bad_auth_extra",
	-8:  "tx_internal_error",
	-9:  "tx_account_blocked",
	-10: "tx_duplication",
	-11: "tx_insufficient_fee",
	-12: "tx_source_underfunded",
	-13: "tx_commission_line_full",
	-14: "tx_fee_incorrect_precision",
	-15: "tx_no_role_permission",
}

var transactionResultCodeRevMap = map[string]int32{
	"TransactionResultCodeTxSuccess":               0,
	"TransactionResultCodeTxFailed":                -1,
	"TransactionResultCodeTxTooEarly":              -2,
	"TransactionResultCodeTxTooLate":               -3,
	"TransactionResultCodeTxMissingOperation":      -4,
	"TransactionResultCodeTxBadAuth":               -5,
	"TransactionResultCodeTxNoAccount":             -6,
	"TransactionResultCodeTxBadAuthExtra":          -7,
	"TransactionResultCodeTxInternalError":         -8,
	"TransactionResultCodeTxAccountBlocked":        -9,
	"TransactionResultCodeTxDuplication":           -10,
	"TransactionResultCodeTxInsufficientFee":       -11,
	"TransactionResultCodeTxSourceUnderfunded":     -12,
	"TransactionResultCodeTxCommissionLineFull":    -13,
	"TransactionResultCodeTxFeeIncorrectPrecision": -14,
	"TransactionResultCodeTxNoRolePermission":      -15,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for TransactionResultCode
func (e TransactionResultCode) ValidEnum(v int32) bool {
	_, ok := transactionResultCodeMap[v]
	return ok
}
func (e TransactionResultCode) isFlag() bool {
	for i := len(TransactionResultCodeAll) - 1; i >= 0; i-- {
		expected := TransactionResultCode(2) << uint64(len(TransactionResultCodeAll)-1) >> uint64(len(TransactionResultCodeAll)-i)
		if expected != TransactionResultCodeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e TransactionResultCode) String() string {
	name, _ := transactionResultCodeMap[int32(e)]
	return name
}

func (e TransactionResultCode) ShortString() string {
	name, _ := transactionResultCodeShortMap[int32(e)]
	return name
}

func (e TransactionResultCode) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range TransactionResultCodeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *TransactionResultCode) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = TransactionResultCode(t.Value)
	return nil
}

// OperationFeeExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type OperationFeeExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u OperationFeeExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of OperationFeeExt
func (u OperationFeeExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewOperationFeeExt creates a new  OperationFeeExt.
func NewOperationFeeExt(v LedgerVersion, value interface{}) (result OperationFeeExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// OperationFee is an XDR Struct defines as:
//
//   struct OperationFee
//    {
//        OperationType operationType;
//        uint64 amount;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type OperationFee struct {
	OperationType OperationType   `json:"operationType,omitempty"`
	Amount        Uint64          `json:"amount,omitempty"`
	Ext           OperationFeeExt `json:"ext,omitempty"`
}

// TransactionResultResult is an XDR NestedUnion defines as:
//
//   union switch (TransactionResultCode code)
//        {
//        case txSUCCESS:
//        case txFAILED:
//            OperationResult results<>;
//        case txNO_ROLE_PERMISSION:
//            AccountRuleRequirement requirement;
//        default:
//            void;
//        }
//
type TransactionResultResult struct {
	Code        TransactionResultCode   `json:"code,omitempty"`
	Results     *[]OperationResult      `json:"results,omitempty"`
	Requirement *AccountRuleRequirement `json:"requirement,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u TransactionResultResult) SwitchFieldName() string {
	return "Code"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of TransactionResultResult
func (u TransactionResultResult) ArmForSwitch(sw int32) (string, bool) {
	switch TransactionResultCode(sw) {
	case TransactionResultCodeTxSuccess:
		return "Results", true
	case TransactionResultCodeTxFailed:
		return "Results", true
	case TransactionResultCodeTxNoRolePermission:
		return "Requirement", true
	default:
		return "", true
	}
}

// NewTransactionResultResult creates a new  TransactionResultResult.
func NewTransactionResultResult(code TransactionResultCode, value interface{}) (result TransactionResultResult, err error) {
	result.Code = code
	switch TransactionResultCode(code) {
	case TransactionResultCodeTxSuccess:
		tv, ok := value.([]OperationResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be []OperationResult")
			return
		}
		result.Results = &tv
	case TransactionResultCodeTxFailed:
		tv, ok := value.([]OperationResult)
		if !ok {
			err = fmt.Errorf("invalid value, must be []OperationResult")
			return
		}
		result.Results = &tv
	case TransactionResultCodeTxNoRolePermission:
		tv, ok := value.(AccountRuleRequirement)
		if !ok {
			err = fmt.Errorf("invalid value, must be AccountRuleRequirement")
			return
		}
		result.Requirement = &tv
	default:
		// void
	}
	return
}

// MustResults retrieves the Results value from the union,
// panicing if the value is not set.
func (u TransactionResultResult) MustResults() []OperationResult {
	val, ok := u.GetResults()

	if !ok {
		panic("arm Results is not set")
	}

	return val
}

// GetResults retrieves the Results value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u TransactionResultResult) GetResults() (result []OperationResult, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Results" {
		result = *u.Results
		ok = true
	}

	return
}

// MustRequirement retrieves the Requirement value from the union,
// panicing if the value is not set.
func (u TransactionResultResult) MustRequirement() AccountRuleRequirement {
	val, ok := u.GetRequirement()

	if !ok {
		panic("arm Requirement is not set")
	}

	return val
}

// GetRequirement retrieves the Requirement value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u TransactionResultResult) GetRequirement() (result AccountRuleRequirement, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Code))

	if armName == "Requirement" {
		result = *u.Requirement
		ok = true
	}

	return
}

// TransactionResultExt is an XDR NestedUnion defines as:
//
//   union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//
type TransactionResultExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u TransactionResultExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of TransactionResultExt
func (u TransactionResultExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewTransactionResultExt creates a new  TransactionResultExt.
func NewTransactionResultExt(v LedgerVersion, value interface{}) (result TransactionResultExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// TransactionResult is an XDR Struct defines as:
//
//   struct TransactionResult
//    {
//        int64 feeCharged; // actual fee charged for the transaction
//
//        union switch (TransactionResultCode code)
//        {
//        case txSUCCESS:
//        case txFAILED:
//            OperationResult results<>;
//        case txNO_ROLE_PERMISSION:
//            AccountRuleRequirement requirement;
//        default:
//            void;
//        }
//        result;
//
//        // reserved for future use
//        union switch (LedgerVersion v)
//        {
//        case EMPTY_VERSION:
//            void;
//        }
//        ext;
//    };
//
type TransactionResult struct {
	FeeCharged Int64                   `json:"feeCharged,omitempty"`
	Result     TransactionResultResult `json:"result,omitempty"`
	Ext        TransactionResultExt    `json:"ext,omitempty"`
}

// LedgerVersion is an XDR Enum defines as:
//
//   enum LedgerVersion
//    {
//        EMPTY_VERSION = 0,
//        CHECK_SET_FEE_ACCOUNT_EXISTING = 1,
//        FIX_PAYMENT_STATS = 2,
//        ADD_INVEST_FEE = 3,
//        ADD_SALE_WHITELISTS = 4,
//        ASSET_PAIR_RESTRICTIONS = 5,
//        FIX_CHANGE_TO_NON_EXISTING_ROLE = 6,
//        FIX_REVERSE_SALE_PAIR = 7,
//        FIX_NOT_CHECKING_SET_TASKS_PERMISSIONS = 8,
//        UNLIMITED_ADMIN_COUNT = 9,
//        FIX_AML_ALERT_ERROR_CODES = 10,
//        FIX_EXT_SYS_ACC_EXPIRATION_TIME = 11,
//        FIX_CHANGE_ROLE_REJECT_TASKS = 12,
//        FIX_SAME_ASSET_PAIR = 13,
//        ATOMIC_SWAP_RETURNING = 14,
//        FIX_INVEST_FEE = 15,
//        ADD_ACC_SPECIFIC_RULE_RESOURCE = 16,
//        FIX_SIGNER_CHANGES_REMOVE = 17,
//        FIX_DEPOSIT_STATS = 18,
//        FIX_CREATE_KYC_RECOVERY_PERMISSIONS = 19,
//        CLEAR_DATABASE_CACHE = 20,
//        FIX_ISSUANCE_REVIEWER = 21,
//        MARK_ASSET_AS_DELETED = 22,
//        FIX_MAX_SUBJECT_SIZE = 23,
//        FIX_MOVEMENT_REVIEW = 24,
//        FIX_SIGNATURE_CHECK = 25,
//        FIX_AUTOREVIEW = 26,
//        MOVEMENT_REQUESTS_DETAILS = 27,
//        FIX_CRASH_CORE_WITH_PAYMENT = 28,
//        FIX_INVEST_TO_IMMEDIATE_SALE = 29,
//        FIX_PAYMENT_TASKS_WILDCARD_VALUE = 30,
//        FIX_CHANGE_ROLE_REQUEST_REQUESTOR = 31
//    };
//
type LedgerVersion int32

const (
	LedgerVersionEmptyVersion                      LedgerVersion = 0
	LedgerVersionCheckSetFeeAccountExisting        LedgerVersion = 1
	LedgerVersionFixPaymentStats                   LedgerVersion = 2
	LedgerVersionAddInvestFee                      LedgerVersion = 3
	LedgerVersionAddSaleWhitelists                 LedgerVersion = 4
	LedgerVersionAssetPairRestrictions             LedgerVersion = 5
	LedgerVersionFixChangeToNonExistingRole        LedgerVersion = 6
	LedgerVersionFixReverseSalePair                LedgerVersion = 7
	LedgerVersionFixNotCheckingSetTasksPermissions LedgerVersion = 8
	LedgerVersionUnlimitedAdminCount               LedgerVersion = 9
	LedgerVersionFixAmlAlertErrorCodes             LedgerVersion = 10
	LedgerVersionFixExtSysAccExpirationTime        LedgerVersion = 11
	LedgerVersionFixChangeRoleRejectTasks          LedgerVersion = 12
	LedgerVersionFixSameAssetPair                  LedgerVersion = 13
	LedgerVersionAtomicSwapReturning               LedgerVersion = 14
	LedgerVersionFixInvestFee                      LedgerVersion = 15
	LedgerVersionAddAccSpecificRuleResource        LedgerVersion = 16
	LedgerVersionFixSignerChangesRemove            LedgerVersion = 17
	LedgerVersionFixDepositStats                   LedgerVersion = 18
	LedgerVersionFixCreateKycRecoveryPermissions   LedgerVersion = 19
	LedgerVersionClearDatabaseCache                LedgerVersion = 20
	LedgerVersionFixIssuanceReviewer               LedgerVersion = 21
	LedgerVersionMarkAssetAsDeleted                LedgerVersion = 22
	LedgerVersionFixMaxSubjectSize                 LedgerVersion = 23
	LedgerVersionFixMovementReview                 LedgerVersion = 24
	LedgerVersionFixSignatureCheck                 LedgerVersion = 25
	LedgerVersionFixAutoreview                     LedgerVersion = 26
	LedgerVersionMovementRequestsDetails           LedgerVersion = 27
	LedgerVersionFixCrashCoreWithPayment           LedgerVersion = 28
	LedgerVersionFixInvestToImmediateSale          LedgerVersion = 29
	LedgerVersionFixPaymentTasksWildcardValue      LedgerVersion = 30
	LedgerVersionFixChangeRoleRequestRequestor     LedgerVersion = 31
)

var LedgerVersionAll = []LedgerVersion{
	LedgerVersionEmptyVersion,
	LedgerVersionCheckSetFeeAccountExisting,
	LedgerVersionFixPaymentStats,
	LedgerVersionAddInvestFee,
	LedgerVersionAddSaleWhitelists,
	LedgerVersionAssetPairRestrictions,
	LedgerVersionFixChangeToNonExistingRole,
	LedgerVersionFixReverseSalePair,
	LedgerVersionFixNotCheckingSetTasksPermissions,
	LedgerVersionUnlimitedAdminCount,
	LedgerVersionFixAmlAlertErrorCodes,
	LedgerVersionFixExtSysAccExpirationTime,
	LedgerVersionFixChangeRoleRejectTasks,
	LedgerVersionFixSameAssetPair,
	LedgerVersionAtomicSwapReturning,
	LedgerVersionFixInvestFee,
	LedgerVersionAddAccSpecificRuleResource,
	LedgerVersionFixSignerChangesRemove,
	LedgerVersionFixDepositStats,
	LedgerVersionFixCreateKycRecoveryPermissions,
	LedgerVersionClearDatabaseCache,
	LedgerVersionFixIssuanceReviewer,
	LedgerVersionMarkAssetAsDeleted,
	LedgerVersionFixMaxSubjectSize,
	LedgerVersionFixMovementReview,
	LedgerVersionFixSignatureCheck,
	LedgerVersionFixAutoreview,
	LedgerVersionMovementRequestsDetails,
	LedgerVersionFixCrashCoreWithPayment,
	LedgerVersionFixInvestToImmediateSale,
	LedgerVersionFixPaymentTasksWildcardValue,
	LedgerVersionFixChangeRoleRequestRequestor,
}

var ledgerVersionMap = map[int32]string{
	0:  "LedgerVersionEmptyVersion",
	1:  "LedgerVersionCheckSetFeeAccountExisting",
	2:  "LedgerVersionFixPaymentStats",
	3:  "LedgerVersionAddInvestFee",
	4:  "LedgerVersionAddSaleWhitelists",
	5:  "LedgerVersionAssetPairRestrictions",
	6:  "LedgerVersionFixChangeToNonExistingRole",
	7:  "LedgerVersionFixReverseSalePair",
	8:  "LedgerVersionFixNotCheckingSetTasksPermissions",
	9:  "LedgerVersionUnlimitedAdminCount",
	10: "LedgerVersionFixAmlAlertErrorCodes",
	11: "LedgerVersionFixExtSysAccExpirationTime",
	12: "LedgerVersionFixChangeRoleRejectTasks",
	13: "LedgerVersionFixSameAssetPair",
	14: "LedgerVersionAtomicSwapReturning",
	15: "LedgerVersionFixInvestFee",
	16: "LedgerVersionAddAccSpecificRuleResource",
	17: "LedgerVersionFixSignerChangesRemove",
	18: "LedgerVersionFixDepositStats",
	19: "LedgerVersionFixCreateKycRecoveryPermissions",
	20: "LedgerVersionClearDatabaseCache",
	21: "LedgerVersionFixIssuanceReviewer",
	22: "LedgerVersionMarkAssetAsDeleted",
	23: "LedgerVersionFixMaxSubjectSize",
	24: "LedgerVersionFixMovementReview",
	25: "LedgerVersionFixSignatureCheck",
	26: "LedgerVersionFixAutoreview",
	27: "LedgerVersionMovementRequestsDetails",
	28: "LedgerVersionFixCrashCoreWithPayment",
	29: "LedgerVersionFixInvestToImmediateSale",
	30: "LedgerVersionFixPaymentTasksWildcardValue",
	31: "LedgerVersionFixChangeRoleRequestRequestor",
}

var ledgerVersionShortMap = map[int32]string{
	0:  "empty_version",
	1:  "check_set_fee_account_existing",
	2:  "fix_payment_stats",
	3:  "add_invest_fee",
	4:  "add_sale_whitelists",
	5:  "asset_pair_restrictions",
	6:  "fix_change_to_non_existing_role",
	7:  "fix_reverse_sale_pair",
	8:  "fix_not_checking_set_tasks_permissions",
	9:  "unlimited_admin_count",
	10: "fix_aml_alert_error_codes",
	11: "fix_ext_sys_acc_expiration_time",
	12: "fix_change_role_reject_tasks",
	13: "fix_same_asset_pair",
	14: "atomic_swap_returning",
	15: "fix_invest_fee",
	16: "add_acc_specific_rule_resource",
	17: "fix_signer_changes_remove",
	18: "fix_deposit_stats",
	19: "fix_create_kyc_recovery_permissions",
	20: "clear_database_cache",
	21: "fix_issuance_reviewer",
	22: "mark_asset_as_deleted",
	23: "fix_max_subject_size",
	24: "fix_movement_review",
	25: "fix_signature_check",
	26: "fix_autoreview",
	27: "movement_requests_details",
	28: "fix_crash_core_with_payment",
	29: "fix_invest_to_immediate_sale",
	30: "fix_payment_tasks_wildcard_value",
	31: "fix_change_role_request_requestor",
}

var ledgerVersionRevMap = map[string]int32{
	"LedgerVersionEmptyVersion":                      0,
	"LedgerVersionCheckSetFeeAccountExisting":        1,
	"LedgerVersionFixPaymentStats":                   2,
	"LedgerVersionAddInvestFee":                      3,
	"LedgerVersionAddSaleWhitelists":                 4,
	"LedgerVersionAssetPairRestrictions":             5,
	"LedgerVersionFixChangeToNonExistingRole":        6,
	"LedgerVersionFixReverseSalePair":                7,
	"LedgerVersionFixNotCheckingSetTasksPermissions": 8,
	"LedgerVersionUnlimitedAdminCount":               9,
	"LedgerVersionFixAmlAlertErrorCodes":             10,
	"LedgerVersionFixExtSysAccExpirationTime":        11,
	"LedgerVersionFixChangeRoleRejectTasks":          12,
	"LedgerVersionFixSameAssetPair":                  13,
	"LedgerVersionAtomicSwapReturning":               14,
	"LedgerVersionFixInvestFee":                      15,
	"LedgerVersionAddAccSpecificRuleResource":        16,
	"LedgerVersionFixSignerChangesRemove":            17,
	"LedgerVersionFixDepositStats":                   18,
	"LedgerVersionFixCreateKycRecoveryPermissions":   19,
	"LedgerVersionClearDatabaseCache":                20,
	"LedgerVersionFixIssuanceReviewer":               21,
	"LedgerVersionMarkAssetAsDeleted":                22,
	"LedgerVersionFixMaxSubjectSize":                 23,
	"LedgerVersionFixMovementReview":                 24,
	"LedgerVersionFixSignatureCheck":                 25,
	"LedgerVersionFixAutoreview":                     26,
	"LedgerVersionMovementRequestsDetails":           27,
	"LedgerVersionFixCrashCoreWithPayment":           28,
	"LedgerVersionFixInvestToImmediateSale":          29,
	"LedgerVersionFixPaymentTasksWildcardValue":      30,
	"LedgerVersionFixChangeRoleRequestRequestor":     31,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for LedgerVersion
func (e LedgerVersion) ValidEnum(v int32) bool {
	_, ok := ledgerVersionMap[v]
	return ok
}
func (e LedgerVersion) isFlag() bool {
	for i := len(LedgerVersionAll) - 1; i >= 0; i-- {
		expected := LedgerVersion(2) << uint64(len(LedgerVersionAll)-1) >> uint64(len(LedgerVersionAll)-i)
		if expected != LedgerVersionAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e LedgerVersion) String() string {
	name, _ := ledgerVersionMap[int32(e)]
	return name
}

func (e LedgerVersion) ShortString() string {
	name, _ := ledgerVersionShortMap[int32(e)]
	return name
}

func (e LedgerVersion) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range LedgerVersionAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *LedgerVersion) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = LedgerVersion(t.Value)
	return nil
}

// EmptyExt is an XDR Union defines as:
//
//   union EmptyExt switch (LedgerVersion v)
//    {
//    case EMPTY_VERSION:
//        void;
//    };
//
type EmptyExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u EmptyExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of EmptyExt
func (u EmptyExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewEmptyExt creates a new  EmptyExt.
func NewEmptyExt(v LedgerVersion, value interface{}) (result EmptyExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// Hash is an XDR Typedef defines as:
//
//   typedef opaque Hash[32];
//
type Hash [32]byte

// Uint256 is an XDR Typedef defines as:
//
//   typedef opaque uint256[32];
//
type Uint256 [32]byte

// Uint32 is an XDR Typedef defines as:
//
//   typedef unsigned int uint32;
//
type Uint32 uint32

// Int32 is an XDR Typedef defines as:
//
//   typedef int int32;
//
type Int32 int32

// Uint64 is an XDR Typedef defines as:
//
//   typedef unsigned hyper uint64;
//
type Uint64 uint64

// Int64 is an XDR Typedef defines as:
//
//   typedef hyper int64;
//
type Int64 int64

// CryptoKeyType is an XDR Enum defines as:
//
//   enum CryptoKeyType
//    {
//        KEY_TYPE_ED25519 = 0
//    };
//
type CryptoKeyType int32

const (
	CryptoKeyTypeKeyTypeEd25519 CryptoKeyType = 0
)

var CryptoKeyTypeAll = []CryptoKeyType{
	CryptoKeyTypeKeyTypeEd25519,
}

var cryptoKeyTypeMap = map[int32]string{
	0: "CryptoKeyTypeKeyTypeEd25519",
}

var cryptoKeyTypeShortMap = map[int32]string{
	0: "key_type_ed25519",
}

var cryptoKeyTypeRevMap = map[string]int32{
	"CryptoKeyTypeKeyTypeEd25519": 0,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for CryptoKeyType
func (e CryptoKeyType) ValidEnum(v int32) bool {
	_, ok := cryptoKeyTypeMap[v]
	return ok
}
func (e CryptoKeyType) isFlag() bool {
	for i := len(CryptoKeyTypeAll) - 1; i >= 0; i-- {
		expected := CryptoKeyType(2) << uint64(len(CryptoKeyTypeAll)-1) >> uint64(len(CryptoKeyTypeAll)-i)
		if expected != CryptoKeyTypeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e CryptoKeyType) String() string {
	name, _ := cryptoKeyTypeMap[int32(e)]
	return name
}

func (e CryptoKeyType) ShortString() string {
	name, _ := cryptoKeyTypeShortMap[int32(e)]
	return name
}

func (e CryptoKeyType) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range CryptoKeyTypeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *CryptoKeyType) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = CryptoKeyType(t.Value)
	return nil
}

// PublicKeyType is an XDR Enum defines as:
//
//   enum PublicKeyType
//    {
//    	PUBLIC_KEY_TYPE_ED25519 = 0
//    };
//
type PublicKeyType int32

const (
	PublicKeyTypePublicKeyTypeEd25519 PublicKeyType = 0
)

var PublicKeyTypeAll = []PublicKeyType{
	PublicKeyTypePublicKeyTypeEd25519,
}

var publicKeyTypeMap = map[int32]string{
	0: "PublicKeyTypePublicKeyTypeEd25519",
}

var publicKeyTypeShortMap = map[int32]string{
	0: "public_key_type_ed25519",
}

var publicKeyTypeRevMap = map[string]int32{
	"PublicKeyTypePublicKeyTypeEd25519": 0,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for PublicKeyType
func (e PublicKeyType) ValidEnum(v int32) bool {
	_, ok := publicKeyTypeMap[v]
	return ok
}
func (e PublicKeyType) isFlag() bool {
	for i := len(PublicKeyTypeAll) - 1; i >= 0; i-- {
		expected := PublicKeyType(2) << uint64(len(PublicKeyTypeAll)-1) >> uint64(len(PublicKeyTypeAll)-i)
		if expected != PublicKeyTypeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e PublicKeyType) String() string {
	name, _ := publicKeyTypeMap[int32(e)]
	return name
}

func (e PublicKeyType) ShortString() string {
	name, _ := publicKeyTypeShortMap[int32(e)]
	return name
}

func (e PublicKeyType) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range PublicKeyTypeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *PublicKeyType) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = PublicKeyType(t.Value)
	return nil
}

// PublicKey is an XDR Union defines as:
//
//   union PublicKey switch (CryptoKeyType type)
//    {
//    case KEY_TYPE_ED25519:
//        uint256 ed25519;
//    };
//
type PublicKey struct {
	Type    CryptoKeyType `json:"type,omitempty"`
	Ed25519 *Uint256      `json:"ed25519,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u PublicKey) SwitchFieldName() string {
	return "Type"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of PublicKey
func (u PublicKey) ArmForSwitch(sw int32) (string, bool) {
	switch CryptoKeyType(sw) {
	case CryptoKeyTypeKeyTypeEd25519:
		return "Ed25519", true
	}
	return "-", false
}

// NewPublicKey creates a new  PublicKey.
func NewPublicKey(aType CryptoKeyType, value interface{}) (result PublicKey, err error) {
	result.Type = aType
	switch CryptoKeyType(aType) {
	case CryptoKeyTypeKeyTypeEd25519:
		tv, ok := value.(Uint256)
		if !ok {
			err = fmt.Errorf("invalid value, must be Uint256")
			return
		}
		result.Ed25519 = &tv
	}
	return
}

// MustEd25519 retrieves the Ed25519 value from the union,
// panicing if the value is not set.
func (u PublicKey) MustEd25519() Uint256 {
	val, ok := u.GetEd25519()

	if !ok {
		panic("arm Ed25519 is not set")
	}

	return val
}

// GetEd25519 retrieves the Ed25519 value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u PublicKey) GetEd25519() (result Uint256, ok bool) {
	armName, _ := u.ArmForSwitch(int32(u.Type))

	if armName == "Ed25519" {
		result = *u.Ed25519
		ok = true
	}

	return
}

// LedgerEntryType is an XDR Enum defines as:
//
//   enum LedgerEntryType
//    {
//        ANY = 1,
//        ACCOUNT = 2,
//        SIGNER = 3,
//        FEE = 4,
//        BALANCE = 5,
//        PAYMENT_REQUEST = 6,
//        ASSET = 7,
//        REFERENCE_ENTRY = 8,
//        STATISTICS = 9,
//        TRUST = 10,
//        ACCOUNT_LIMITS = 11,
//    	ASSET_PAIR = 12,
//    	OFFER_ENTRY = 13,
//    	REVIEWABLE_REQUEST = 15,
//    	EXTERNAL_SYSTEM_ACCOUNT_ID = 16,
//    	SALE = 17,
//    	ACCOUNT_KYC = 18,
//    	EXTERNAL_SYSTEM_ACCOUNT_ID_POOL_ENTRY = 19,
//        KEY_VALUE = 20,
//        LIMITS_V2 = 22,
//        STATISTICS_V2 = 23,
//        PENDING_STATISTICS = 24,
//        CONTRACT = 25,
//        ACCOUNT_ROLE = 26,
//        ACCOUNT_RULE = 27,
//        ATOMIC_SWAP_ASK = 28,
//        TRANSACTION = 29, // is used for account rule resource
//        SIGNER_RULE = 30,
//        SIGNER_ROLE = 31,
//        STAMP = 32,
//        LICENSE = 33,
//        POLL = 34,
//        VOTE = 35,
//        ACCOUNT_SPECIFIC_RULE = 36,
//        INITIATE_KYC_RECOVERY = 37,
//        SWAP = 38,
//        DATA = 39,
//        CUSTOM = 40,
//        DEFERRED_PAYMENT = 41
//    };
//
type LedgerEntryType int32

const (
	LedgerEntryTypeAny                              LedgerEntryType = 1
	LedgerEntryTypeAccount                          LedgerEntryType = 2
	LedgerEntryTypeSigner                           LedgerEntryType = 3
	LedgerEntryTypeFee                              LedgerEntryType = 4
	LedgerEntryTypeBalance                          LedgerEntryType = 5
	LedgerEntryTypePaymentRequest                   LedgerEntryType = 6
	LedgerEntryTypeAsset                            LedgerEntryType = 7
	LedgerEntryTypeReferenceEntry                   LedgerEntryType = 8
	LedgerEntryTypeStatistics                       LedgerEntryType = 9
	LedgerEntryTypeTrust                            LedgerEntryType = 10
	LedgerEntryTypeAccountLimits                    LedgerEntryType = 11
	LedgerEntryTypeAssetPair                        LedgerEntryType = 12
	LedgerEntryTypeOfferEntry                       LedgerEntryType = 13
	LedgerEntryTypeReviewableRequest                LedgerEntryType = 15
	LedgerEntryTypeExternalSystemAccountId          LedgerEntryType = 16
	LedgerEntryTypeSale                             LedgerEntryType = 17
	LedgerEntryTypeAccountKyc                       LedgerEntryType = 18
	LedgerEntryTypeExternalSystemAccountIdPoolEntry LedgerEntryType = 19
	LedgerEntryTypeKeyValue                         LedgerEntryType = 20
	LedgerEntryTypeLimitsV2                         LedgerEntryType = 22
	LedgerEntryTypeStatisticsV2                     LedgerEntryType = 23
	LedgerEntryTypePendingStatistics                LedgerEntryType = 24
	LedgerEntryTypeContract                         LedgerEntryType = 25
	LedgerEntryTypeAccountRole                      LedgerEntryType = 26
	LedgerEntryTypeAccountRule                      LedgerEntryType = 27
	LedgerEntryTypeAtomicSwapAsk                    LedgerEntryType = 28
	LedgerEntryTypeTransaction                      LedgerEntryType = 29
	LedgerEntryTypeSignerRule                       LedgerEntryType = 30
	LedgerEntryTypeSignerRole                       LedgerEntryType = 31
	LedgerEntryTypeStamp                            LedgerEntryType = 32
	LedgerEntryTypeLicense                          LedgerEntryType = 33
	LedgerEntryTypePoll                             LedgerEntryType = 34
	LedgerEntryTypeVote                             LedgerEntryType = 35
	LedgerEntryTypeAccountSpecificRule              LedgerEntryType = 36
	LedgerEntryTypeInitiateKycRecovery              LedgerEntryType = 37
	LedgerEntryTypeSwap                             LedgerEntryType = 38
	LedgerEntryTypeData                             LedgerEntryType = 39
	LedgerEntryTypeCustom                           LedgerEntryType = 40
	LedgerEntryTypeDeferredPayment                  LedgerEntryType = 41
)

var LedgerEntryTypeAll = []LedgerEntryType{
	LedgerEntryTypeAny,
	LedgerEntryTypeAccount,
	LedgerEntryTypeSigner,
	LedgerEntryTypeFee,
	LedgerEntryTypeBalance,
	LedgerEntryTypePaymentRequest,
	LedgerEntryTypeAsset,
	LedgerEntryTypeReferenceEntry,
	LedgerEntryTypeStatistics,
	LedgerEntryTypeTrust,
	LedgerEntryTypeAccountLimits,
	LedgerEntryTypeAssetPair,
	LedgerEntryTypeOfferEntry,
	LedgerEntryTypeReviewableRequest,
	LedgerEntryTypeExternalSystemAccountId,
	LedgerEntryTypeSale,
	LedgerEntryTypeAccountKyc,
	LedgerEntryTypeExternalSystemAccountIdPoolEntry,
	LedgerEntryTypeKeyValue,
	LedgerEntryTypeLimitsV2,
	LedgerEntryTypeStatisticsV2,
	LedgerEntryTypePendingStatistics,
	LedgerEntryTypeContract,
	LedgerEntryTypeAccountRole,
	LedgerEntryTypeAccountRule,
	LedgerEntryTypeAtomicSwapAsk,
	LedgerEntryTypeTransaction,
	LedgerEntryTypeSignerRule,
	LedgerEntryTypeSignerRole,
	LedgerEntryTypeStamp,
	LedgerEntryTypeLicense,
	LedgerEntryTypePoll,
	LedgerEntryTypeVote,
	LedgerEntryTypeAccountSpecificRule,
	LedgerEntryTypeInitiateKycRecovery,
	LedgerEntryTypeSwap,
	LedgerEntryTypeData,
	LedgerEntryTypeCustom,
	LedgerEntryTypeDeferredPayment,
}

var ledgerEntryTypeMap = map[int32]string{
	1:  "LedgerEntryTypeAny",
	2:  "LedgerEntryTypeAccount",
	3:  "LedgerEntryTypeSigner",
	4:  "LedgerEntryTypeFee",
	5:  "LedgerEntryTypeBalance",
	6:  "LedgerEntryTypePaymentRequest",
	7:  "LedgerEntryTypeAsset",
	8:  "LedgerEntryTypeReferenceEntry",
	9:  "LedgerEntryTypeStatistics",
	10: "LedgerEntryTypeTrust",
	11: "LedgerEntryTypeAccountLimits",
	12: "LedgerEntryTypeAssetPair",
	13: "LedgerEntryTypeOfferEntry",
	15: "LedgerEntryTypeReviewableRequest",
	16: "LedgerEntryTypeExternalSystemAccountId",
	17: "LedgerEntryTypeSale",
	18: "LedgerEntryTypeAccountKyc",
	19: "LedgerEntryTypeExternalSystemAccountIdPoolEntry",
	20: "LedgerEntryTypeKeyValue",
	22: "LedgerEntryTypeLimitsV2",
	23: "LedgerEntryTypeStatisticsV2",
	24: "LedgerEntryTypePendingStatistics",
	25: "LedgerEntryTypeContract",
	26: "LedgerEntryTypeAccountRole",
	27: "LedgerEntryTypeAccountRule",
	28: "LedgerEntryTypeAtomicSwapAsk",
	29: "LedgerEntryTypeTransaction",
	30: "LedgerEntryTypeSignerRule",
	31: "LedgerEntryTypeSignerRole",
	32: "LedgerEntryTypeStamp",
	33: "LedgerEntryTypeLicense",
	34: "LedgerEntryTypePoll",
	35: "LedgerEntryTypeVote",
	36: "LedgerEntryTypeAccountSpecificRule",
	37: "LedgerEntryTypeInitiateKycRecovery",
	38: "LedgerEntryTypeSwap",
	39: "LedgerEntryTypeData",
	40: "LedgerEntryTypeCustom",
	41: "LedgerEntryTypeDeferredPayment",
}

var ledgerEntryTypeShortMap = map[int32]string{
	1:  "any",
	2:  "account",
	3:  "signer",
	4:  "fee",
	5:  "balance",
	6:  "payment_request",
	7:  "asset",
	8:  "reference_entry",
	9:  "statistics",
	10: "trust",
	11: "account_limits",
	12: "asset_pair",
	13: "offer_entry",
	15: "reviewable_request",
	16: "external_system_account_id",
	17: "sale",
	18: "account_kyc",
	19: "external_system_account_id_pool_entry",
	20: "key_value",
	22: "limits_v2",
	23: "statistics_v2",
	24: "pending_statistics",
	25: "contract",
	26: "account_role",
	27: "account_rule",
	28: "atomic_swap_ask",
	29: "transaction",
	30: "signer_rule",
	31: "signer_role",
	32: "stamp",
	33: "license",
	34: "poll",
	35: "vote",
	36: "account_specific_rule",
	37: "initiate_kyc_recovery",
	38: "swap",
	39: "data",
	40: "custom",
	41: "deferred_payment",
}

var ledgerEntryTypeRevMap = map[string]int32{
	"LedgerEntryTypeAny":                              1,
	"LedgerEntryTypeAccount":                          2,
	"LedgerEntryTypeSigner":                           3,
	"LedgerEntryTypeFee":                              4,
	"LedgerEntryTypeBalance":                          5,
	"LedgerEntryTypePaymentRequest":                   6,
	"LedgerEntryTypeAsset":                            7,
	"LedgerEntryTypeReferenceEntry":                   8,
	"LedgerEntryTypeStatistics":                       9,
	"LedgerEntryTypeTrust":                            10,
	"LedgerEntryTypeAccountLimits":                    11,
	"LedgerEntryTypeAssetPair":                        12,
	"LedgerEntryTypeOfferEntry":                       13,
	"LedgerEntryTypeReviewableRequest":                15,
	"LedgerEntryTypeExternalSystemAccountId":          16,
	"LedgerEntryTypeSale":                             17,
	"LedgerEntryTypeAccountKyc":                       18,
	"LedgerEntryTypeExternalSystemAccountIdPoolEntry": 19,
	"LedgerEntryTypeKeyValue":                         20,
	"LedgerEntryTypeLimitsV2":                         22,
	"LedgerEntryTypeStatisticsV2":                     23,
	"LedgerEntryTypePendingStatistics":                24,
	"LedgerEntryTypeContract":                         25,
	"LedgerEntryTypeAccountRole":                      26,
	"LedgerEntryTypeAccountRule":                      27,
	"LedgerEntryTypeAtomicSwapAsk":                    28,
	"LedgerEntryTypeTransaction":                      29,
	"LedgerEntryTypeSignerRule":                       30,
	"LedgerEntryTypeSignerRole":                       31,
	"LedgerEntryTypeStamp":                            32,
	"LedgerEntryTypeLicense":                          33,
	"LedgerEntryTypePoll":                             34,
	"LedgerEntryTypeVote":                             35,
	"LedgerEntryTypeAccountSpecificRule":              36,
	"LedgerEntryTypeInitiateKycRecovery":              37,
	"LedgerEntryTypeSwap":                             38,
	"LedgerEntryTypeData":                             39,
	"LedgerEntryTypeCustom":                           40,
	"LedgerEntryTypeDeferredPayment":                  41,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for LedgerEntryType
func (e LedgerEntryType) ValidEnum(v int32) bool {
	_, ok := ledgerEntryTypeMap[v]
	return ok
}
func (e LedgerEntryType) isFlag() bool {
	for i := len(LedgerEntryTypeAll) - 1; i >= 0; i-- {
		expected := LedgerEntryType(2) << uint64(len(LedgerEntryTypeAll)-1) >> uint64(len(LedgerEntryTypeAll)-i)
		if expected != LedgerEntryTypeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e LedgerEntryType) String() string {
	name, _ := ledgerEntryTypeMap[int32(e)]
	return name
}

func (e LedgerEntryType) ShortString() string {
	name, _ := ledgerEntryTypeShortMap[int32(e)]
	return name
}

func (e LedgerEntryType) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range LedgerEntryTypeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *LedgerEntryType) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = LedgerEntryType(t.Value)
	return nil
}

// Signature is an XDR Typedef defines as:
//
//   typedef opaque Signature<64>;
//
type Signature []byte

// SignatureHint is an XDR Typedef defines as:
//
//   typedef opaque SignatureHint[4];
//
type SignatureHint [4]byte

// NodeId is an XDR Typedef defines as:
//
//   typedef PublicKey NodeID;
//
type NodeId PublicKey

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u NodeId) SwitchFieldName() string {
	return PublicKey(u).SwitchFieldName()
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of PublicKey
func (u NodeId) ArmForSwitch(sw int32) (string, bool) {
	return PublicKey(u).ArmForSwitch(sw)
}

// NewNodeId creates a new  NodeId.
func NewNodeId(aType CryptoKeyType, value interface{}) (result NodeId, err error) {
	u, err := NewPublicKey(aType, value)
	result = NodeId(u)
	return
}

// MustEd25519 retrieves the Ed25519 value from the union,
// panicing if the value is not set.
func (u NodeId) MustEd25519() Uint256 {
	return PublicKey(u).MustEd25519()
}

// GetEd25519 retrieves the Ed25519 value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u NodeId) GetEd25519() (result Uint256, ok bool) {
	return PublicKey(u).GetEd25519()
}

// Curve25519Secret is an XDR Struct defines as:
//
//   struct Curve25519Secret
//    {
//            opaque key[32];
//    };
//
type Curve25519Secret struct {
	Key [32]byte `json:"key,omitempty"`
}

// Curve25519Public is an XDR Struct defines as:
//
//   struct Curve25519Public
//    {
//            opaque key[32];
//    };
//
type Curve25519Public struct {
	Key [32]byte `json:"key,omitempty"`
}

// HmacSha256Key is an XDR Struct defines as:
//
//   struct HmacSha256Key
//    {
//            opaque key[32];
//    };
//
type HmacSha256Key struct {
	Key [32]byte `json:"key,omitempty"`
}

// HmacSha256Mac is an XDR Struct defines as:
//
//   struct HmacSha256Mac
//    {
//            opaque mac[32];
//    };
//
type HmacSha256Mac struct {
	Mac [32]byte `json:"mac,omitempty"`
}

// AccountId is an XDR Typedef defines as:
//
//   typedef PublicKey AccountID;
//
type AccountId PublicKey

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u AccountId) SwitchFieldName() string {
	return PublicKey(u).SwitchFieldName()
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of PublicKey
func (u AccountId) ArmForSwitch(sw int32) (string, bool) {
	return PublicKey(u).ArmForSwitch(sw)
}

// NewAccountId creates a new  AccountId.
func NewAccountId(aType CryptoKeyType, value interface{}) (result AccountId, err error) {
	u, err := NewPublicKey(aType, value)
	result = AccountId(u)
	return
}

// MustEd25519 retrieves the Ed25519 value from the union,
// panicing if the value is not set.
func (u AccountId) MustEd25519() Uint256 {
	return PublicKey(u).MustEd25519()
}

// GetEd25519 retrieves the Ed25519 value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u AccountId) GetEd25519() (result Uint256, ok bool) {
	return PublicKey(u).GetEd25519()
}

// BalanceId is an XDR Typedef defines as:
//
//   typedef PublicKey BalanceID;
//
type BalanceId PublicKey

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u BalanceId) SwitchFieldName() string {
	return PublicKey(u).SwitchFieldName()
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of PublicKey
func (u BalanceId) ArmForSwitch(sw int32) (string, bool) {
	return PublicKey(u).ArmForSwitch(sw)
}

// NewBalanceId creates a new  BalanceId.
func NewBalanceId(aType CryptoKeyType, value interface{}) (result BalanceId, err error) {
	u, err := NewPublicKey(aType, value)
	result = BalanceId(u)
	return
}

// MustEd25519 retrieves the Ed25519 value from the union,
// panicing if the value is not set.
func (u BalanceId) MustEd25519() Uint256 {
	return PublicKey(u).MustEd25519()
}

// GetEd25519 retrieves the Ed25519 value from the union,
// returning ok if the union's switch indicated the value is valid.
func (u BalanceId) GetEd25519() (result Uint256, ok bool) {
	return PublicKey(u).GetEd25519()
}

// Thresholds is an XDR Typedef defines as:
//
//   typedef opaque Thresholds[4];
//
type Thresholds [4]byte

// String32 is an XDR Typedef defines as:
//
//   typedef string string32<32>;
//
type String32 string

// XDRMaxSize implements the Sized interface for String32
func (e String32) XDRMaxSize() int {
	return 32
}

// String64 is an XDR Typedef defines as:
//
//   typedef string string64<64>;
//
type String64 string

// XDRMaxSize implements the Sized interface for String64
func (e String64) XDRMaxSize() int {
	return 64
}

// String256 is an XDR Typedef defines as:
//
//   typedef string string256<256>;
//
type String256 string

// XDRMaxSize implements the Sized interface for String256
func (e String256) XDRMaxSize() int {
	return 256
}

// Longstring is an XDR Typedef defines as:
//
//   typedef string longstring<>;
//
type Longstring string

// AssetCode is an XDR Typedef defines as:
//
//   typedef string AssetCode<16>;
//
type AssetCode string

// XDRMaxSize implements the Sized interface for AssetCode
func (e AssetCode) XDRMaxSize() int {
	return 16
}

// Salt is an XDR Typedef defines as:
//
//   typedef uint64 Salt;
//
type Salt Uint64

// DataValue is an XDR Typedef defines as:
//
//   typedef opaque DataValue<64>;
//
type DataValue []byte

// FeeExt is an XDR NestedUnion defines as:
//
//   union switch(LedgerVersion v)
//        {
//            case EMPTY_VERSION:
//                void;
//        }
//
type FeeExt struct {
	V LedgerVersion `json:"v,omitempty"`
}

// SwitchFieldName returns the field name in which this union's
// discriminant is stored
func (u FeeExt) SwitchFieldName() string {
	return "V"
}

// ArmForSwitch returns which field name should be used for storing
// the value for an instance of FeeExt
func (u FeeExt) ArmForSwitch(sw int32) (string, bool) {
	switch LedgerVersion(sw) {
	case LedgerVersionEmptyVersion:
		return "", true
	}
	return "-", false
}

// NewFeeExt creates a new  FeeExt.
func NewFeeExt(v LedgerVersion, value interface{}) (result FeeExt, err error) {
	result.V = v
	switch LedgerVersion(v) {
	case LedgerVersionEmptyVersion:
		// void
	}
	return
}

// Fee is an XDR Struct defines as:
//
//   //: `Fee` is used to unite fixed and percent fee amounts
//    struct Fee {
//        //: Fixed amount to pay for the operation
//    	uint64 fixed;
//    	//: Part of the managed amount in percents
//    	uint64 percent;
//
//        //: reserved for future use
//        union switch(LedgerVersion v)
//        {
//            case EMPTY_VERSION:
//                void;
//        }
//        ext;
//    };
//
type Fee struct {
	Fixed   Uint64 `json:"fixed,omitempty"`
	Percent Uint64 `json:"percent,omitempty"`
	Ext     FeeExt `json:"ext,omitempty"`
}

// OperationType is an XDR Enum defines as:
//
//   enum OperationType
//    {
//        CREATE_ACCOUNT = 1,
//        CREATE_ISSUANCE_REQUEST = 3,
//        SET_FEES = 5,
//        CREATE_WITHDRAWAL_REQUEST = 7,
//        MANAGE_BALANCE = 9,
//        MANAGE_ASSET = 11,
//        CREATE_PREISSUANCE_REQUEST = 12,
//        MANAGE_LIMITS = 13,
//    	MANAGE_ASSET_PAIR = 15,
//    	MANAGE_OFFER = 16,
//        MANAGE_INVOICE_REQUEST = 17,
//    	REVIEW_REQUEST = 18,
//    	CREATE_SALE_REQUEST = 19,
//    	CHECK_SALE_STATE = 20,
//        CREATE_AML_ALERT = 21,
//        CREATE_CHANGE_ROLE_REQUEST = 22,
//        PAYMENT = 23,
//        MANAGE_EXTERNAL_SYSTEM_ACCOUNT_ID_POOL_ENTRY = 24,
//        BIND_EXTERNAL_SYSTEM_ACCOUNT_ID = 25,
//        MANAGE_SALE = 26,
//        MANAGE_KEY_VALUE = 27,
//        CREATE_MANAGE_LIMITS_REQUEST = 28,
//        MANAGE_CONTRACT_REQUEST = 29,
//        MANAGE_CONTRACT = 30,
//        CANCEL_SALE_REQUEST = 31,
//        PAYOUT = 32,
//        MANAGE_ACCOUNT_ROLE = 33,
//        MANAGE_ACCOUNT_RULE = 34,
//        CREATE_ATOMIC_SWAP_ASK_REQUEST = 35,
//        CANCEL_ATOMIC_SWAP_ASK = 36,
//        CREATE_ATOMIC_SWAP_BID_REQUEST = 37,
//        MANAGE_SIGNER = 38,
//        MANAGE_SIGNER_ROLE = 39,
//        MANAGE_SIGNER_RULE = 40,
//        STAMP = 41,
//        LICENSE = 42,
//        MANAGE_CREATE_POLL_REQUEST = 43,
//        MANAGE_POLL = 44,
//        MANAGE_VOTE = 45,
//        MANAGE_ACCOUNT_SPECIFIC_RULE = 46,
//        CANCEL_CHANGE_ROLE_REQUEST = 47,
//        INITIATE_KYC_RECOVERY = 48,
//        CREATE_KYC_RECOVERY_REQUEST = 49,
//        REMOVE_ASSET_PAIR = 50,
//        CREATE_MANAGE_OFFER_REQUEST = 51,
//        CREATE_PAYMENT_REQUEST = 52,
//        REMOVE_ASSET = 53,
//        OPEN_SWAP = 54,
//        CLOSE_SWAP = 55,
//        CREATE_REDEMPTION_REQUEST = 56,
//        CREATE_DATA = 57,
//        UPDATE_DATA = 58,
//        REMOVE_DATA = 59,
//        CREATE_DATA_CREATION_REQUEST = 60,
//        CANCEL_DATA_CREATION_REQUEST = 61,
//        CREATE_DATA_UPDATE_REQUEST = 62,
//        CREATE_DATA_REMOVE_REQUEST = 63,
//        CANCEL_DATA_UPDATE_REQUEST = 64,
//        CANCEL_DATA_REMOVE_REQUEST = 65,
//        CREATE_DEFERRED_PAYMENT_CREATION_REQUEST = 66,
//        CANCEL_DEFERRED_PAYMENT_CREATION_REQUEST = 67,
//        CREATE_CLOSE_DEFERRED_PAYMENT_REQUEST = 68,
//        CANCEL_CLOSE_DEFERRED_PAYMENT_REQUEST = 69
//    };
//
type OperationType int32

const (
	OperationTypeCreateAccount                          OperationType = 1
	OperationTypeCreateIssuanceRequest                  OperationType = 3
	OperationTypeSetFees                                OperationType = 5
	OperationTypeCreateWithdrawalRequest                OperationType = 7
	OperationTypeManageBalance                          OperationType = 9
	OperationTypeManageAsset                            OperationType = 11
	OperationTypeCreatePreissuanceRequest               OperationType = 12
	OperationTypeManageLimits                           OperationType = 13
	OperationTypeManageAssetPair                        OperationType = 15
	OperationTypeManageOffer                            OperationType = 16
	OperationTypeManageInvoiceRequest                   OperationType = 17
	OperationTypeReviewRequest                          OperationType = 18
	OperationTypeCreateSaleRequest                      OperationType = 19
	OperationTypeCheckSaleState                         OperationType = 20
	OperationTypeCreateAmlAlert                         OperationType = 21
	OperationTypeCreateChangeRoleRequest                OperationType = 22
	OperationTypePayment                                OperationType = 23
	OperationTypeManageExternalSystemAccountIdPoolEntry OperationType = 24
	OperationTypeBindExternalSystemAccountId            OperationType = 25
	OperationTypeManageSale                             OperationType = 26
	OperationTypeManageKeyValue                         OperationType = 27
	OperationTypeCreateManageLimitsRequest              OperationType = 28
	OperationTypeManageContractRequest                  OperationType = 29
	OperationTypeManageContract                         OperationType = 30
	OperationTypeCancelSaleRequest                      OperationType = 31
	OperationTypePayout                                 OperationType = 32
	OperationTypeManageAccountRole                      OperationType = 33
	OperationTypeManageAccountRule                      OperationType = 34
	OperationTypeCreateAtomicSwapAskRequest             OperationType = 35
	OperationTypeCancelAtomicSwapAsk                    OperationType = 36
	OperationTypeCreateAtomicSwapBidRequest             OperationType = 37
	OperationTypeManageSigner                           OperationType = 38
	OperationTypeManageSignerRole                       OperationType = 39
	OperationTypeManageSignerRule                       OperationType = 40
	OperationTypeStamp                                  OperationType = 41
	OperationTypeLicense                                OperationType = 42
	OperationTypeManageCreatePollRequest                OperationType = 43
	OperationTypeManagePoll                             OperationType = 44
	OperationTypeManageVote                             OperationType = 45
	OperationTypeManageAccountSpecificRule              OperationType = 46
	OperationTypeCancelChangeRoleRequest                OperationType = 47
	OperationTypeInitiateKycRecovery                    OperationType = 48
	OperationTypeCreateKycRecoveryRequest               OperationType = 49
	OperationTypeRemoveAssetPair                        OperationType = 50
	OperationTypeCreateManageOfferRequest               OperationType = 51
	OperationTypeCreatePaymentRequest                   OperationType = 52
	OperationTypeRemoveAsset                            OperationType = 53
	OperationTypeOpenSwap                               OperationType = 54
	OperationTypeCloseSwap                              OperationType = 55
	OperationTypeCreateRedemptionRequest                OperationType = 56
	OperationTypeCreateData                             OperationType = 57
	OperationTypeUpdateData                             OperationType = 58
	OperationTypeRemoveData                             OperationType = 59
	OperationTypeCreateDataCreationRequest              OperationType = 60
	OperationTypeCancelDataCreationRequest              OperationType = 61
	OperationTypeCreateDataUpdateRequest                OperationType = 62
	OperationTypeCreateDataRemoveRequest                OperationType = 63
	OperationTypeCancelDataUpdateRequest                OperationType = 64
	OperationTypeCancelDataRemoveRequest                OperationType = 65
	OperationTypeCreateDeferredPaymentCreationRequest   OperationType = 66
	OperationTypeCancelDeferredPaymentCreationRequest   OperationType = 67
	OperationTypeCreateCloseDeferredPaymentRequest      OperationType = 68
	OperationTypeCancelCloseDeferredPaymentRequest      OperationType = 69
)

var OperationTypeAll = []OperationType{
	OperationTypeCreateAccount,
	OperationTypeCreateIssuanceRequest,
	OperationTypeSetFees,
	OperationTypeCreateWithdrawalRequest,
	OperationTypeManageBalance,
	OperationTypeManageAsset,
	OperationTypeCreatePreissuanceRequest,
	OperationTypeManageLimits,
	OperationTypeManageAssetPair,
	OperationTypeManageOffer,
	OperationTypeManageInvoiceRequest,
	OperationTypeReviewRequest,
	OperationTypeCreateSaleRequest,
	OperationTypeCheckSaleState,
	OperationTypeCreateAmlAlert,
	OperationTypeCreateChangeRoleRequest,
	OperationTypePayment,
	OperationTypeManageExternalSystemAccountIdPoolEntry,
	OperationTypeBindExternalSystemAccountId,
	OperationTypeManageSale,
	OperationTypeManageKeyValue,
	OperationTypeCreateManageLimitsRequest,
	OperationTypeManageContractRequest,
	OperationTypeManageContract,
	OperationTypeCancelSaleRequest,
	OperationTypePayout,
	OperationTypeManageAccountRole,
	OperationTypeManageAccountRule,
	OperationTypeCreateAtomicSwapAskRequest,
	OperationTypeCancelAtomicSwapAsk,
	OperationTypeCreateAtomicSwapBidRequest,
	OperationTypeManageSigner,
	OperationTypeManageSignerRole,
	OperationTypeManageSignerRule,
	OperationTypeStamp,
	OperationTypeLicense,
	OperationTypeManageCreatePollRequest,
	OperationTypeManagePoll,
	OperationTypeManageVote,
	OperationTypeManageAccountSpecificRule,
	OperationTypeCancelChangeRoleRequest,
	OperationTypeInitiateKycRecovery,
	OperationTypeCreateKycRecoveryRequest,
	OperationTypeRemoveAssetPair,
	OperationTypeCreateManageOfferRequest,
	OperationTypeCreatePaymentRequest,
	OperationTypeRemoveAsset,
	OperationTypeOpenSwap,
	OperationTypeCloseSwap,
	OperationTypeCreateRedemptionRequest,
	OperationTypeCreateData,
	OperationTypeUpdateData,
	OperationTypeRemoveData,
	OperationTypeCreateDataCreationRequest,
	OperationTypeCancelDataCreationRequest,
	OperationTypeCreateDataUpdateRequest,
	OperationTypeCreateDataRemoveRequest,
	OperationTypeCancelDataUpdateRequest,
	OperationTypeCancelDataRemoveRequest,
	OperationTypeCreateDeferredPaymentCreationRequest,
	OperationTypeCancelDeferredPaymentCreationRequest,
	OperationTypeCreateCloseDeferredPaymentRequest,
	OperationTypeCancelCloseDeferredPaymentRequest,
}

var operationTypeMap = map[int32]string{
	1:  "OperationTypeCreateAccount",
	3:  "OperationTypeCreateIssuanceRequest",
	5:  "OperationTypeSetFees",
	7:  "OperationTypeCreateWithdrawalRequest",
	9:  "OperationTypeManageBalance",
	11: "OperationTypeManageAsset",
	12: "OperationTypeCreatePreissuanceRequest",
	13: "OperationTypeManageLimits",
	15: "OperationTypeManageAssetPair",
	16: "OperationTypeManageOffer",
	17: "OperationTypeManageInvoiceRequest",
	18: "OperationTypeReviewRequest",
	19: "OperationTypeCreateSaleRequest",
	20: "OperationTypeCheckSaleState",
	21: "OperationTypeCreateAmlAlert",
	22: "OperationTypeCreateChangeRoleRequest",
	23: "OperationTypePayment",
	24: "OperationTypeManageExternalSystemAccountIdPoolEntry",
	25: "OperationTypeBindExternalSystemAccountId",
	26: "OperationTypeManageSale",
	27: "OperationTypeManageKeyValue",
	28: "OperationTypeCreateManageLimitsRequest",
	29: "OperationTypeManageContractRequest",
	30: "OperationTypeManageContract",
	31: "OperationTypeCancelSaleRequest",
	32: "OperationTypePayout",
	33: "OperationTypeManageAccountRole",
	34: "OperationTypeManageAccountRule",
	35: "OperationTypeCreateAtomicSwapAskRequest",
	36: "OperationTypeCancelAtomicSwapAsk",
	37: "OperationTypeCreateAtomicSwapBidRequest",
	38: "OperationTypeManageSigner",
	39: "OperationTypeManageSignerRole",
	40: "OperationTypeManageSignerRule",
	41: "OperationTypeStamp",
	42: "OperationTypeLicense",
	43: "OperationTypeManageCreatePollRequest",
	44: "OperationTypeManagePoll",
	45: "OperationTypeManageVote",
	46: "OperationTypeManageAccountSpecificRule",
	47: "OperationTypeCancelChangeRoleRequest",
	48: "OperationTypeInitiateKycRecovery",
	49: "OperationTypeCreateKycRecoveryRequest",
	50: "OperationTypeRemoveAssetPair",
	51: "OperationTypeCreateManageOfferRequest",
	52: "OperationTypeCreatePaymentRequest",
	53: "OperationTypeRemoveAsset",
	54: "OperationTypeOpenSwap",
	55: "OperationTypeCloseSwap",
	56: "OperationTypeCreateRedemptionRequest",
	57: "OperationTypeCreateData",
	58: "OperationTypeUpdateData",
	59: "OperationTypeRemoveData",
	60: "OperationTypeCreateDataCreationRequest",
	61: "OperationTypeCancelDataCreationRequest",
	62: "OperationTypeCreateDataUpdateRequest",
	63: "OperationTypeCreateDataRemoveRequest",
	64: "OperationTypeCancelDataUpdateRequest",
	65: "OperationTypeCancelDataRemoveRequest",
	66: "OperationTypeCreateDeferredPaymentCreationRequest",
	67: "OperationTypeCancelDeferredPaymentCreationRequest",
	68: "OperationTypeCreateCloseDeferredPaymentRequest",
	69: "OperationTypeCancelCloseDeferredPaymentRequest",
}

var operationTypeShortMap = map[int32]string{
	1:  "create_account",
	3:  "create_issuance_request",
	5:  "set_fees",
	7:  "create_withdrawal_request",
	9:  "manage_balance",
	11: "manage_asset",
	12: "create_preissuance_request",
	13: "manage_limits",
	15: "manage_asset_pair",
	16: "manage_offer",
	17: "manage_invoice_request",
	18: "review_request",
	19: "create_sale_request",
	20: "check_sale_state",
	21: "create_aml_alert",
	22: "create_change_role_request",
	23: "payment",
	24: "manage_external_system_account_id_pool_entry",
	25: "bind_external_system_account_id",
	26: "manage_sale",
	27: "manage_key_value",
	28: "create_manage_limits_request",
	29: "manage_contract_request",
	30: "manage_contract",
	31: "cancel_sale_request",
	32: "payout",
	33: "manage_account_role",
	34: "manage_account_rule",
	35: "create_atomic_swap_ask_request",
	36: "cancel_atomic_swap_ask",
	37: "create_atomic_swap_bid_request",
	38: "manage_signer",
	39: "manage_signer_role",
	40: "manage_signer_rule",
	41: "stamp",
	42: "license",
	43: "manage_create_poll_request",
	44: "manage_poll",
	45: "manage_vote",
	46: "manage_account_specific_rule",
	47: "cancel_change_role_request",
	48: "initiate_kyc_recovery",
	49: "create_kyc_recovery_request",
	50: "remove_asset_pair",
	51: "create_manage_offer_request",
	52: "create_payment_request",
	53: "remove_asset",
	54: "open_swap",
	55: "close_swap",
	56: "create_redemption_request",
	57: "create_data",
	58: "update_data",
	59: "remove_data",
	60: "create_data_creation_request",
	61: "cancel_data_creation_request",
	62: "create_data_update_request",
	63: "create_data_remove_request",
	64: "cancel_data_update_request",
	65: "cancel_data_remove_request",
	66: "create_deferred_payment_creation_request",
	67: "cancel_deferred_payment_creation_request",
	68: "create_close_deferred_payment_request",
	69: "cancel_close_deferred_payment_request",
}

var operationTypeRevMap = map[string]int32{
	"OperationTypeCreateAccount":                          1,
	"OperationTypeCreateIssuanceRequest":                  3,
	"OperationTypeSetFees":                                5,
	"OperationTypeCreateWithdrawalRequest":                7,
	"OperationTypeManageBalance":                          9,
	"OperationTypeManageAsset":                            11,
	"OperationTypeCreatePreissuanceRequest":               12,
	"OperationTypeManageLimits":                           13,
	"OperationTypeManageAssetPair":                        15,
	"OperationTypeManageOffer":                            16,
	"OperationTypeManageInvoiceRequest":                   17,
	"OperationTypeReviewRequest":                          18,
	"OperationTypeCreateSaleRequest":                      19,
	"OperationTypeCheckSaleState":                         20,
	"OperationTypeCreateAmlAlert":                         21,
	"OperationTypeCreateChangeRoleRequest":                22,
	"OperationTypePayment":                                23,
	"OperationTypeManageExternalSystemAccountIdPoolEntry": 24,
	"OperationTypeBindExternalSystemAccountId":            25,
	"OperationTypeManageSale":                             26,
	"OperationTypeManageKeyValue":                         27,
	"OperationTypeCreateManageLimitsRequest":              28,
	"OperationTypeManageContractRequest":                  29,
	"OperationTypeManageContract":                         30,
	"OperationTypeCancelSaleRequest":                      31,
	"OperationTypePayout":                                 32,
	"OperationTypeManageAccountRole":                      33,
	"OperationTypeManageAccountRule":                      34,
	"OperationTypeCreateAtomicSwapAskRequest":             35,
	"OperationTypeCancelAtomicSwapAsk":                    36,
	"OperationTypeCreateAtomicSwapBidRequest":             37,
	"OperationTypeManageSigner":                           38,
	"OperationTypeManageSignerRole":                       39,
	"OperationTypeManageSignerRule":                       40,
	"OperationTypeStamp":                                  41,
	"OperationTypeLicense":                                42,
	"OperationTypeManageCreatePollRequest":                43,
	"OperationTypeManagePoll":                             44,
	"OperationTypeManageVote":                             45,
	"OperationTypeManageAccountSpecificRule":              46,
	"OperationTypeCancelChangeRoleRequest":                47,
	"OperationTypeInitiateKycRecovery":                    48,
	"OperationTypeCreateKycRecoveryRequest":               49,
	"OperationTypeRemoveAssetPair":                        50,
	"OperationTypeCreateManageOfferRequest":               51,
	"OperationTypeCreatePaymentRequest":                   52,
	"OperationTypeRemoveAsset":                            53,
	"OperationTypeOpenSwap":                               54,
	"OperationTypeCloseSwap":                              55,
	"OperationTypeCreateRedemptionRequest":                56,
	"OperationTypeCreateData":                             57,
	"OperationTypeUpdateData":                             58,
	"OperationTypeRemoveData":                             59,
	"OperationTypeCreateDataCreationRequest":              60,
	"OperationTypeCancelDataCreationRequest":              61,
	"OperationTypeCreateDataUpdateRequest":                62,
	"OperationTypeCreateDataRemoveRequest":                63,
	"OperationTypeCancelDataUpdateRequest":                64,
	"OperationTypeCancelDataRemoveRequest":                65,
	"OperationTypeCreateDeferredPaymentCreationRequest":   66,
	"OperationTypeCancelDeferredPaymentCreationRequest":   67,
	"OperationTypeCreateCloseDeferredPaymentRequest":      68,
	"OperationTypeCancelCloseDeferredPaymentRequest":      69,
}

// ValidEnum validates a proposed value for this enum.  Implements
// the Enum interface for OperationType
func (e OperationType) ValidEnum(v int32) bool {
	_, ok := operationTypeMap[v]
	return ok
}
func (e OperationType) isFlag() bool {
	for i := len(OperationTypeAll) - 1; i >= 0; i-- {
		expected := OperationType(2) << uint64(len(OperationTypeAll)-1) >> uint64(len(OperationTypeAll)-i)
		if expected != OperationTypeAll[i] {
			return false
		}
	}
	return true
}

// String returns the name of `e`
func (e OperationType) String() string {
	name, _ := operationTypeMap[int32(e)]
	return name
}

func (e OperationType) ShortString() string {
	name, _ := operationTypeShortMap[int32(e)]
	return name
}

func (e OperationType) MarshalJSON() ([]byte, error) {
	if e.isFlag() {
		// marshal as mask
		result := flag{
			Value: int32(e),
			Flags: make([]flagValue, 0),
		}
		for _, value := range OperationTypeAll {
			if (value & e) == value {
				result.Flags = append(result.Flags, flagValue{
					Value: int32(value),
					Name:  value.ShortString(),
				})
			}
		}
		return json.Marshal(&result)
	} else {
		// marshal as enum
		result := enum{
			Value:  int32(e),
			String: e.ShortString(),
		}
		return json.Marshal(&result)
	}
}

func (e *OperationType) UnmarshalJSON(data []byte) error {
	var t value
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	*e = OperationType(t.Value)
	return nil
}

// DecoratedSignature is an XDR Struct defines as:
//
//   struct DecoratedSignature
//    {
//        SignatureHint hint;  // last 4 bytes of the public key, used as a hint
//        Signature signature; // actual signature
//    };
//
type DecoratedSignature struct {
	Hint      SignatureHint `json:"hint,omitempty"`
	Signature Signature     `json:"signature,omitempty"`
}

var fmtTest = fmt.Sprint("this is a dummy usage of fmt")
var Revision = "066600aac9f4c93f1d4c37e1bb7c559beafb2b6c"
