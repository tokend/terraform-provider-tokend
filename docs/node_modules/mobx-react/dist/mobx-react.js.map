{"version":3,"file":"mobx-react.js","sources":["../node_modules/mobx-react-lite/dist/index.module.js","../src/utils/utils.js","../src/observer.js","../src/Provider.js","../src/inject.js","../src/disposeOnUnmount.js","../src/propTypes.js","../src/index.js"],"sourcesContent":["import { spy, observable, computed, getDependencyTree, Reaction } from 'mobx';\nimport { useState, useRef, useMemo, useEffect, useCallback, useDebugValue, memo, forwardRef } from 'react';\n\nif (!useState) {\r\n    throw new Error(\"mobx-react-lite requires React with Hooks support\");\r\n}\r\nif (!spy) {\r\n    throw new Error(\"mobx-react-lite requires mobx at least version 4 to be available\");\r\n}\n\nfunction useObservable(initialValue) {\r\n    var observableRef = useRef(null);\r\n    if (!observableRef.current) {\r\n        observableRef.current = observable(initialValue);\r\n    }\r\n    return observableRef.current;\r\n}\n\nfunction useComputed(func, inputs) {\r\n    if (inputs === void 0) { inputs = []; }\r\n    var computed$$1 = useMemo(function () { return computed(func); }, inputs);\r\n    return computed$$1.get();\r\n}\n\nvar doNothingDisposer = function () {\r\n    // empty\r\n};\r\n/**\r\n * Adds an observable effect (reaction, autorun, or anything else that returns a disposer) that will be registered upon component creation and disposed upon unmounting.\r\n * Returns the generated disposer for early disposal.\r\n *\r\n * @export\r\n * @template D\r\n * @param {() => D} disposerGenerator A function that returns the disposer of the wanted effect.\r\n * @param {ReadonlyArray<any>} [inputs=[]] If you want the effect to be automatically re-created when some variable(s) are changed then pass them in this array.\r\n * @returns {D}\r\n */\r\nfunction useDisposable(disposerGenerator, inputs) {\r\n    if (inputs === void 0) { inputs = []; }\r\n    var disposerRef = useRef(null);\r\n    var earlyDisposedRef = useRef(false);\r\n    useEffect(function () {\r\n        return lazyCreateDisposer(false);\r\n    }, inputs);\r\n    function lazyCreateDisposer(earlyDisposal) {\r\n        // ensure that we won't create a new disposer if it was early disposed\r\n        if (earlyDisposedRef.current) {\r\n            return doNothingDisposer;\r\n        }\r\n        if (!disposerRef.current) {\r\n            var newDisposer = disposerGenerator();\r\n            if (typeof newDisposer !== \"function\") {\r\n                var error = new Error(\"generated disposer must be a function\");\r\n                {\r\n                    // tslint:disable-next-line:no-console\r\n                    console.error(error);\r\n                    return doNothingDisposer;\r\n                }\r\n            }\r\n            disposerRef.current = newDisposer;\r\n        }\r\n        return function () {\r\n            if (disposerRef.current) {\r\n                disposerRef.current();\r\n                disposerRef.current = null;\r\n            }\r\n            if (earlyDisposal) {\r\n                earlyDisposedRef.current = true;\r\n            }\r\n        };\r\n    }\r\n    return lazyCreateDisposer(true);\r\n}\n\nvar globalIsUsingStaticRendering = false;\r\nfunction useStaticRendering(enable) {\r\n    globalIsUsingStaticRendering = enable;\r\n}\r\nfunction isUsingStaticRendering() {\r\n    return globalIsUsingStaticRendering;\r\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\n\nfunction printDebugValue(v) {\r\n    if (!v.current) {\r\n        return \"<unknown>\";\r\n    }\r\n    return getDependencyTree(v.current);\r\n}\n\nvar EMPTY_ARRAY = [];\r\nfunction useUnmount(fn) {\r\n    useEffect(function () { return fn; }, EMPTY_ARRAY);\r\n}\r\nfunction useForceUpdate() {\r\n    var _a = __read(useState(0), 2), setTick = _a[1];\r\n    var update = useCallback(function () {\r\n        setTick(function (tick) { return tick + 1; });\r\n    }, []);\r\n    return update;\r\n}\n\nfunction useObserver(fn, baseComponentName) {\r\n    if (baseComponentName === void 0) { baseComponentName = \"observed\"; }\r\n    if (isUsingStaticRendering()) {\r\n        return fn();\r\n    }\r\n    var forceUpdate = useForceUpdate();\r\n    var reaction = useRef(null);\r\n    if (!reaction.current) {\r\n        reaction.current = new Reaction(\"observer(\" + baseComponentName + \")\", function () {\r\n            forceUpdate();\r\n        });\r\n    }\r\n    useDebugValue(reaction, printDebugValue);\r\n    useUnmount(function () {\r\n        reaction.current.dispose();\r\n    });\r\n    // render the original component, but have the\r\n    // reaction track the observables, so that rendering\r\n    // can be invalidated (see above) once a dependency changes\r\n    var rendering;\r\n    var exception;\r\n    reaction.current.track(function () {\r\n        try {\r\n            rendering = fn();\r\n        }\r\n        catch (e) {\r\n            exception = e;\r\n        }\r\n    });\r\n    if (exception) {\r\n        reaction.current.dispose();\r\n        throw exception; // re-throw any exceptions catched during rendering\r\n    }\r\n    return rendering;\r\n}\n\n// n.b. base case is not used for actual typings or exported in the typing files\r\nfunction observer(baseComponent, options) {\r\n    // The working of observer is explaind step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307\r\n    if (isUsingStaticRendering()) {\r\n        return baseComponent;\r\n    }\r\n    var realOptions = __assign({ forwardRef: false }, options);\r\n    var baseComponentName = baseComponent.displayName || baseComponent.name;\r\n    var wrappedComponent = function (props, ref) {\r\n        return useObserver(function () { return baseComponent(props, ref); }, baseComponentName);\r\n    };\r\n    // memo; we are not intested in deep updates\r\n    // in props; we assume that if deep objects are changed,\r\n    // this is in observables, which would have been tracked anyway\r\n    var memoComponent;\r\n    if (realOptions.forwardRef) {\r\n        // we have to use forwardRef here because:\r\n        // 1. it cannot go before memo, only after it\r\n        // 2. forwardRef converts the function into an actual component, so we can't let the baseComponent do it\r\n        //    since it wouldn't be a callable function anymore\r\n        memoComponent = memo(forwardRef(wrappedComponent));\r\n    }\r\n    else {\r\n        memoComponent = memo(wrappedComponent);\r\n    }\r\n    copyStaticProperties(baseComponent, memoComponent);\r\n    memoComponent.displayName = baseComponentName;\r\n    return memoComponent;\r\n}\r\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\r\nvar hoistBlackList = {\r\n    $$typeof: true,\r\n    render: true,\r\n    compare: true,\r\n    type: true\r\n};\r\nfunction copyStaticProperties(base, target) {\r\n    Object.keys(base).forEach(function (key) {\r\n        if (base.hasOwnProperty(key) && !hoistBlackList[key]) {\r\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));\r\n        }\r\n    });\r\n}\n\nfunction ObserverComponent(_a) {\r\n    var children = _a.children, render = _a.render;\r\n    var component = children || render;\r\n    if (typeof component !== \"function\") {\r\n        return null;\r\n    }\r\n    return useObserver(component);\r\n}\r\nObserverComponent.propTypes = {\r\n    children: ObserverPropsCheck,\r\n    render: ObserverPropsCheck\r\n};\r\nObserverComponent.displayName = \"Observer\";\r\nfunction ObserverPropsCheck(props, key, componentName, location, propFullName) {\r\n    var extraKey = key === \"children\" ? \"render\" : \"children\";\r\n    var hasProp = typeof props[key] === \"function\";\r\n    var hasExtraProp = typeof props[extraKey] === \"function\";\r\n    if (hasProp && hasExtraProp) {\r\n        return new Error(\"MobX Observer: Do not use children and render in the same time in`\" + componentName);\r\n    }\r\n    if (hasProp || hasExtraProp) {\r\n        return null;\r\n    }\r\n    return new Error(\"Invalid prop `\" +\r\n        propFullName +\r\n        \"` of type `\" +\r\n        typeof props[key] +\r\n        \"` supplied to\" +\r\n        \" `\" +\r\n        componentName +\r\n        \"`, expected `function`.\");\r\n}\n\nexport { useObservable, useComputed, useDisposable, isUsingStaticRendering, useStaticRendering, observer, useObserver, ObserverComponent as Observer };\n","export function isStateless(component) {\n    // `function() {}` has prototype, but `() => {}` doesn't\n    // `() => {}` via Babel has prototype too.\n    return !(component.prototype && component.prototype.render)\n}\n\nlet symbolId = 0\nfunction createSymbol(name) {\n    if (typeof Symbol === \"function\") {\n        return Symbol(name)\n    }\n    const symbol = `__$mobx-react ${name} (${symbolId})`\n    symbolId++\n    return symbol\n}\n\nconst createdSymbols = {}\nexport function newSymbol(name) {\n    if (!createdSymbols[name]) {\n        createdSymbols[name] = createSymbol(name)\n    }\n    return createdSymbols[name]\n}\n\nexport function shallowEqual(objA, objB) {\n    //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (is(objA, objB)) return true\n    if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n        return false\n    }\n    const keysA = Object.keys(objA)\n    const keysB = Object.keys(objB)\n    if (keysA.length !== keysB.length) return false\n    for (let i = 0; i < keysA.length; i++) {\n        if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n            return false\n        }\n    }\n    return true\n}\n\nfunction is(x, y) {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y\n    } else {\n        return x !== x && y !== y\n    }\n}\n\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\nconst hoistBlackList = {\n    $$typeof: 1,\n    render: 1,\n    compare: 1,\n    type: 1,\n    childContextTypes: 1,\n    contextType: 1,\n    contextTypes: 1,\n    defaultProps: 1,\n    getDefaultProps: 1,\n    getDerivedStateFromError: 1,\n    getDerivedStateFromProps: 1,\n    mixins: 1,\n    propTypes: 1\n}\n\nexport function copyStaticProperties(base, target) {\n    Object.keys(base).forEach(key => {\n        if (base.hasOwnProperty(key) && !hoistBlackList[key]) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key))\n        }\n    })\n}\n","import React, { Component, PureComponent, forwardRef } from \"react\"\nimport { createAtom, _allowStateChanges } from \"mobx\"\nimport {\n    observer as observerLite,\n    useStaticRendering as useStaticRenderingLite,\n    Observer\n} from \"mobx-react-lite\"\n\nimport { newSymbol, shallowEqual } from \"./utils/utils\"\n\nlet isUsingStaticRendering = false\n\nconst skipRenderKey = newSymbol(\"skipRender\")\nconst isForcingUpdateKey = newSymbol(\"isForcingUpdate\")\n\n// Using react-is had some issues (and operates on elements, not on types), see #608 / #609\nconst ReactForwardRefSymbol =\n    typeof forwardRef === \"function\" && forwardRef((_props, _ref) => {})[\"$$typeof\"]\n\n/**\n * Helper to set `prop` to `this` as non-enumerable (hidden prop)\n * @param target\n * @param prop\n * @param value\n */\nfunction setHiddenProp(target, prop, value) {\n    if (!Object.hasOwnProperty.call(target, prop)) {\n        Object.defineProperty(target, prop, {\n            enumerable: false,\n            configurable: true,\n            writable: true,\n            value\n        })\n    } else {\n        target[prop] = value\n    }\n}\n\nexport function useStaticRendering(useStaticRendering) {\n    isUsingStaticRendering = useStaticRendering\n    useStaticRenderingLite(useStaticRendering)\n}\n\nfunction observerSCU(nextProps, nextState) {\n    if (isUsingStaticRendering) {\n        console.warn(\n            \"[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.\"\n        )\n    }\n    // update on any state changes (as is the default)\n    if (this.state !== nextState) {\n        return true\n    }\n    // update if props are shallowly not equal, inspired by PureRenderMixin\n    // we could return just 'false' here, and avoid the `skipRender` checks etc\n    // however, it is nicer if lifecycle events are triggered like usually,\n    // so we return true here if props are shallowly modified.\n    return !shallowEqual(this.props, nextProps)\n}\n\nfunction makeObservableProp(target, propName) {\n    const valueHolderKey = newSymbol(`reactProp_${propName}_valueHolder`)\n    const atomHolderKey = newSymbol(`reactProp_${propName}_atomHolder`)\n    function getAtom() {\n        if (!this[atomHolderKey]) {\n            setHiddenProp(this, atomHolderKey, createAtom(\"reactive \" + propName))\n        }\n        return this[atomHolderKey]\n    }\n    Object.defineProperty(target, propName, {\n        configurable: true,\n        enumerable: true,\n        get: function() {\n            getAtom.call(this).reportObserved()\n            return this[valueHolderKey]\n        },\n        set: function set(v) {\n            if (!this[isForcingUpdateKey] && !shallowEqual(this[valueHolderKey], v)) {\n                setHiddenProp(this, valueHolderKey, v)\n                setHiddenProp(this, skipRenderKey, true)\n                getAtom.call(this).reportChanged()\n                setHiddenProp(this, skipRenderKey, false)\n            } else {\n                setHiddenProp(this, valueHolderKey, v)\n            }\n        }\n    })\n}\n\n/**\n * Observer function / decorator\n */\nexport function observer(componentClass) {\n    if (componentClass.isMobxInjector === true) {\n        console.warn(\n            \"Mobx observer: You are trying to use 'observer' on a component that already has 'inject'. Please apply 'observer' before applying 'inject'\"\n        )\n    }\n\n    // TODO: still needed? (if func comp?)\n    // Unwrap forward refs into `<Observer>` component\n    // we need to unwrap the render, because it is the inner render that needs to be tracked,\n    // not the ForwardRef HoC\n    if (ReactForwardRefSymbol && componentClass[\"$$typeof\"] === ReactForwardRefSymbol) {\n        const baseRender = componentClass.render\n        if (typeof baseRender !== \"function\")\n            throw new Error(\"render property of ForwardRef was not a function\")\n        return forwardRef(function ObserverForwardRef() {\n            return <Observer>{() => baseRender.apply(undefined, arguments)}</Observer>\n        })\n    }\n\n    // Function component\n    if (\n        typeof componentClass === \"function\" &&\n        (!componentClass.prototype || !componentClass.prototype.render) &&\n        !componentClass.isReactClass &&\n        !Component.isPrototypeOf(componentClass)\n    ) {\n        return observerLite(componentClass)\n    }\n\n    return makeClassComponentObserver(componentClass)\n}\n\nfunction makeClassComponentObserver(componentClass) {\n    const target = componentClass.prototype || componentClass\n    if (target.componentWillReact)\n        throw new Error(\"The componentWillReact life-cycle event is no longer supported\")\n    if (componentClass.__proto__ !== PureComponent) {\n        if (!target.shouldComponentUpdate) target.shouldComponentUpdate = observerSCU\n        else if (target.shouldComponentUpdate !== observerSCU)\n            throw new Error(\n                \"It is not allowed to use shouldComponentUpdate in observer based components.\"\n            )\n    }\n    makeObservableProp(target, \"props\")\n    makeObservableProp(target, \"state\")\n    const baseRender = target.render\n\n    target.render = function renderWrapper() {\n        if (!this.baseRender) {\n            // safe the closure, as it won't change!\n            const bound = baseRender.bind(this)\n            this.baseRender = () => bound()\n        }\n        return <Observer>{this.baseRender}</Observer>\n    }\n    return componentClass\n}\n","import { Children, Component, createContext, createElement } from \"react\"\nimport { shallowEqual } from \"./utils/utils\"\n\nconst specialReactKeys = { children: true, key: true, ref: true }\n\nexport const MobXProviderContext = createContext({})\n\nexport class Provider extends Component {\n    static contextType = MobXProviderContext\n\n    constructor(props, context) {\n        super(props, context)\n        this.state = {\n            ...context,\n            ...grabStores(props)\n        }\n    }\n\n    render() {\n        return createElement(\n            MobXProviderContext.Provider,\n            { value: this.state },\n            Children.only(this.props.children)\n        )\n    }\n\n    static getDerivedStateFromProps(nextProps, prevState) {\n        const newStores = { ...prevState, ...grabStores(nextProps) } // spread in prevState for the context based stores\n        if (!shallowEqual(prevState, newStores))\n            throw new Error(\n                \"MobX Provider: The set of provided stores has changed. Please avoid changing stores as the change might not propagate to all children\"\n            )\n        return prevState // because they didn't change, remember!\n    }\n}\n\nfunction grabStores(from) {\n    const res = {}\n    if (!from) return res\n    for (let key in from) if (validStoreName(key)) res[key] = from[key]\n    return res\n}\n\nfunction validStoreName(key) {\n    return !specialReactKeys[key] && key !== \"suppressChangedStoreWarning\"\n}\n","import React, { Component, createElement } from \"react\"\nimport { observer } from \"./observer\"\nimport { isStateless, copyStaticProperties } from \"./utils/utils\"\nimport { MobXProviderContext } from \"./Provider\"\n\n/**\n * Store Injection\n */\nfunction createStoreInjector(grabStoresFn, component, injectNames, makeReactive) {\n    let displayName = getInjectName(component, injectNames)\n\n    class Injector extends Component {\n        static contextType = MobXProviderContext\n\n        render() {\n            const { forwardRef, ...props } = this.props\n\n            Object.assign(props, grabStoresFn(this.context || {}, props) || {})\n\n            if (forwardRef && !isStateless(component)) {\n                props.ref = this.props.forwardRef\n            }\n\n            return createElement(component, props)\n        }\n    }\n    if (makeReactive) Injector = observer(Injector)\n    Injector.isMobxInjector = true // assigned late to suppress observer warning\n\n    // Support forward refs\n    const InjectHocRef = React.forwardRef((props, ref) =>\n        React.createElement(Injector, { ...props, forwardRef: ref })\n    )\n    // Static fields from component should be visible on the generated Injector\n    copyStaticProperties(component, InjectHocRef)\n    InjectHocRef.wrappedComponent = component\n    InjectHocRef.displayName = displayName\n    return InjectHocRef\n}\n\nfunction getInjectName(component, injectNames) {\n    let displayName\n    const componentName =\n        component.displayName ||\n        component.name ||\n        (component.constructor && component.constructor.name) ||\n        \"Component\"\n    if (injectNames) displayName = \"inject-with-\" + injectNames + \"(\" + componentName + \")\"\n    else displayName = \"inject(\" + componentName + \")\"\n    return displayName\n}\n\nfunction grabStoresByName(storeNames) {\n    return function(baseStores, nextProps) {\n        storeNames.forEach(function(storeName) {\n            if (\n                storeName in nextProps // prefer props over stores\n            )\n                return\n            if (!(storeName in baseStores))\n                throw new Error(\n                    \"MobX injector: Store '\" +\n                        storeName +\n                        \"' is not available! Make sure it is provided by some Provider\"\n                )\n            nextProps[storeName] = baseStores[storeName]\n        })\n        return nextProps\n    }\n}\n\n/**\n * higher order component that injects stores to a child.\n * takes either a varargs list of strings, which are stores read from the context,\n * or a function that manually maps the available stores from the context to props:\n * storesToProps(mobxStores, props, context) => newProps\n */\nexport function inject(/* fn(stores, nextProps) or ...storeNames */ ...storeNames) {\n    let grabStoresFn\n    if (typeof arguments[0] === \"function\") {\n        grabStoresFn = arguments[0]\n        return componentClass =>\n            createStoreInjector(grabStoresFn, componentClass, grabStoresFn.name, true)\n    } else {\n        return componentClass =>\n            createStoreInjector(\n                grabStoresByName(storeNames),\n                componentClass,\n                storeNames.join(\"-\"),\n                false\n            )\n    }\n}\n","import * as React from \"react\"\nimport { newSymbol } from \"./utils/utils\"\n\nconst storeKey = newSymbol(\"disposeOnUnmount\")\nconst baseUnmountKey = newSymbol(\"originalOnUnmount\")\n\nfunction runDisposersOnWillUnmount() {\n    if (this[baseUnmountKey]) this[baseUnmountKey]()\n    if (!this[storeKey]) {\n        // when disposeOnUnmount is only set to some instances of a component it will still patch the prototype\n        return\n    }\n    this[storeKey].forEach(propKeyOrFunction => {\n        const prop =\n            typeof propKeyOrFunction === \"string\" ? this[propKeyOrFunction] : propKeyOrFunction\n        if (prop !== undefined && prop !== null) {\n            if (typeof prop !== \"function\") {\n                throw new Error(\n                    \"[mobx-react] disposeOnUnmount only works on functions such as disposers returned by reactions, autorun, etc.\"\n                )\n            }\n            prop()\n        }\n    })\n    this[storeKey] = []\n}\n\nexport function disposeOnUnmount(target, propertyKeyOrFunction) {\n    if (Array.isArray(propertyKeyOrFunction)) {\n        return propertyKeyOrFunction.map(fn => disposeOnUnmount(target, fn))\n    }\n\n    const c = Object.getPrototypeOf(target).constructor || Object.getPrototypeOf(target.constructor)\n    const c2 = Object.getPrototypeOf(target.constructor)\n    if (\n        !(\n            c === React.Component ||\n            c === React.PureComponent ||\n            c2 === React.Component ||\n            c2 === React.PureComponent\n        )\n    ) {\n        throw new Error(\n            \"[mobx-react] disposeOnUnmount only supports direct subclasses of React.Component or React.PureComponent.\"\n        )\n    }\n\n    if (typeof propertyKeyOrFunction !== \"string\" && typeof propertyKeyOrFunction !== \"function\") {\n        throw new Error(\n            \"[mobx-react] disposeOnUnmount only works if the parameter is either a property key or a function.\"\n        )\n    }\n\n    // add property key / function we want run (disposed) to the store\n    const componentWasAlreadyModified = !!target[storeKey]\n    const store = target[storeKey] || (target[storeKey] = [])\n    store.push(propertyKeyOrFunction)\n\n    // tweak the component class componentWillUnmount if not done already\n    if (!componentWasAlreadyModified) {\n        // make sure original definition is invoked\n        if (target.componentWillUnmount) target[baseUnmountKey] = target.componentWillUnmount\n\n        Object.defineProperty(target, \"componentWillUnmount\", {\n            get() {\n                return runDisposersOnWillUnmount\n            },\n            set(fn) {\n                // this will happen if componentWillUnmount is being assigned after patching the prototype\n                this[storeKey].push(fn)\n                // assigning a new local value to componentWillUnmount would hide the super implementation...\n                this[baseUnmountKey] = undefined\n            },\n            configurable: false,\n            enumerable: false\n        })\n    }\n\n    // return the disposer as is if invoked as a non decorator\n    if (typeof propertyKeyOrFunction !== \"string\") {\n        return propertyKeyOrFunction\n    }\n}\n","import { isObservableArray, isObservableObject, isObservableMap, untracked } from \"mobx\"\n\n// TODO: can we just import this stuff?\n// Copied from React.PropTypes\nfunction createChainableTypeChecker(validate) {\n    function checkType(\n        isRequired,\n        props,\n        propName,\n        componentName,\n        location,\n        propFullName,\n        ...rest\n    ) {\n        return untracked(() => {\n            componentName = componentName || \"<<anonymous>>\"\n            propFullName = propFullName || propName\n            if (props[propName] == null) {\n                if (isRequired) {\n                    const actual = props[propName] === null ? \"null\" : \"undefined\"\n                    return new Error(\n                        \"The \" +\n                            location +\n                            \" `\" +\n                            propFullName +\n                            \"` is marked as required \" +\n                            \"in `\" +\n                            componentName +\n                            \"`, but its value is `\" +\n                            actual +\n                            \"`.\"\n                    )\n                }\n                return null\n            } else {\n                return validate(props, propName, componentName, location, propFullName, ...rest)\n            }\n        })\n    }\n\n    const chainedCheckType = checkType.bind(null, false)\n    chainedCheckType.isRequired = checkType.bind(null, true)\n    return chainedCheckType\n}\n\n// Copied from React.PropTypes\nfunction isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === \"symbol\") {\n        return true\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n        return true\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n        return true\n    }\n\n    return false\n}\n\n// Copied from React.PropTypes\nfunction getPropType(propValue) {\n    const propType = typeof propValue\n    if (Array.isArray(propValue)) {\n        return \"array\"\n    }\n    if (propValue instanceof RegExp) {\n        // Old webkits (at least until Android 4.0) return 'function' rather than\n        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n        // passes PropTypes.object.\n        return \"object\"\n    }\n    if (isSymbol(propType, propValue)) {\n        return \"symbol\"\n    }\n    return propType\n}\n\n// This handles more types than `getPropType`. Only used for error messages.\n// Copied from React.PropTypes\nfunction getPreciseType(propValue) {\n    const propType = getPropType(propValue)\n    if (propType === \"object\") {\n        if (propValue instanceof Date) {\n            return \"date\"\n        } else if (propValue instanceof RegExp) {\n            return \"regexp\"\n        }\n    }\n    return propType\n}\n\nfunction createObservableTypeCheckerCreator(allowNativeType, mobxType) {\n    return createChainableTypeChecker(function(\n        props,\n        propName,\n        componentName,\n        location,\n        propFullName\n    ) {\n        return untracked(() => {\n            if (allowNativeType) {\n                if (getPropType(props[propName]) === mobxType.toLowerCase()) return null\n            }\n            let mobxChecker\n            switch (mobxType) {\n                case \"Array\":\n                    mobxChecker = isObservableArray\n                    break\n                case \"Object\":\n                    mobxChecker = isObservableObject\n                    break\n                case \"Map\":\n                    mobxChecker = isObservableMap\n                    break\n                default:\n                    throw new Error(`Unexpected mobxType: ${mobxType}`)\n            }\n            const propValue = props[propName]\n            if (!mobxChecker(propValue)) {\n                const preciseType = getPreciseType(propValue)\n                const nativeTypeExpectationMessage = allowNativeType\n                    ? \" or javascript `\" + mobxType.toLowerCase() + \"`\"\n                    : \"\"\n                return new Error(\n                    \"Invalid prop `\" +\n                        propFullName +\n                        \"` of type `\" +\n                        preciseType +\n                        \"` supplied to\" +\n                        \" `\" +\n                        componentName +\n                        \"`, expected `mobx.Observable\" +\n                        mobxType +\n                        \"`\" +\n                        nativeTypeExpectationMessage +\n                        \".\"\n                )\n            }\n            return null\n        })\n    })\n}\n\nfunction createObservableArrayOfTypeChecker(allowNativeType, typeChecker) {\n    return createChainableTypeChecker(function(\n        props,\n        propName,\n        componentName,\n        location,\n        propFullName,\n        ...rest\n    ) {\n        return untracked(() => {\n            if (typeof typeChecker !== \"function\") {\n                return new Error(\n                    \"Property `\" +\n                        propFullName +\n                        \"` of component `\" +\n                        componentName +\n                        \"` has \" +\n                        \"invalid PropType notation.\"\n                )\n            }\n            let error = createObservableTypeCheckerCreator(allowNativeType, \"Array\")(\n                props,\n                propName,\n                componentName\n            )\n            if (error instanceof Error) return error\n            const propValue = props[propName]\n            for (let i = 0; i < propValue.length; i++) {\n                error = typeChecker(\n                    propValue,\n                    i,\n                    componentName,\n                    location,\n                    propFullName + \"[\" + i + \"]\",\n                    ...rest\n                )\n                if (error instanceof Error) return error\n            }\n            return null\n        })\n    })\n}\n\nconst observableArray = createObservableTypeCheckerCreator(false, \"Array\")\nconst observableArrayOf = createObservableArrayOfTypeChecker.bind(null, false)\nconst observableMap = createObservableTypeCheckerCreator(false, \"Map\")\nconst observableObject = createObservableTypeCheckerCreator(false, \"Object\")\nconst arrayOrObservableArray = createObservableTypeCheckerCreator(true, \"Array\")\nconst arrayOrObservableArrayOf = createObservableArrayOfTypeChecker.bind(null, true)\nconst objectOrObservableObject = createObservableTypeCheckerCreator(true, \"Object\")\n\nexport const PropTypes = {\n    observableArray,\n    observableArrayOf,\n    observableMap,\n    observableObject,\n    arrayOrObservableArray,\n    arrayOrObservableArrayOf,\n    objectOrObservableObject\n}\n","import { observable, configure } from \"mobx\"\nimport { Component } from \"react\"\nimport { unstable_batchedUpdates as rdBatched } from \"react-dom\"\n\nif (!Component) throw new Error(\"mobx-react requires React to be available\")\nif (!observable) throw new Error(\"mobx-react requires mobx to be available\")\n\nif (typeof rdBatched === \"function\") configure({ reactionScheduler: rdBatched })\n\nexport { useObservable, useComputed, useDisposable, useObserver, Observer } from \"mobx-react-lite\"\n\nexport { observer, useStaticRendering } from \"./observer\"\n\nexport { Provider } from \"./Provider\"\nexport { inject } from \"./inject\"\nexport { disposeOnUnmount } from \"./disposeOnUnmount\"\nexport { PropTypes } from \"./propTypes\"\n"],"names":["useState","Error","spy","doNothingDisposer","globalIsUsingStaticRendering","isUsingStaticRendering","__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","printDebugValue","v","current","getDependencyTree","EMPTY_ARRAY","useObserver","fn","baseComponentName","rendering","exception","setTick","forceUpdate","o","m","Symbol","iterator","r","e","ar","next","done","push","value","error","__read","useCallback","tick","reaction","useRef","Reaction","useDebugValue","useEffect","useUnmount","dispose","track","hoistBlackList","$$typeof","render","compare","type","ObserverComponent","_a","component","children","ObserverPropsCheck","props","key","componentName","location","propFullName","hasProp","hasExtraProp","propTypes","displayName","let","symbolId","createdSymbols","newSymbol","name","symbol","createSymbol","shallowEqual","objA","objB","is","keysA","keys","keysB","x","y","const","childContextTypes","contextType","contextTypes","defaultProps","getDefaultProps","getDerivedStateFromError","getDerivedStateFromProps","mixins","skipRenderKey","isForcingUpdateKey","ReactForwardRefSymbol","forwardRef","_props","_ref","setHiddenProp","target","prop","defineProperty","enumerable","configurable","writable","observerSCU","nextProps","nextState","console","warn","state","makeObservableProp","propName","valueHolderKey","atomHolderKey","getAtom","createAtom","get","reportObserved","set","reportChanged","observer","componentClass","isMobxInjector","baseRender","React","Observer","undefined","isReactClass","Component","isPrototypeOf","componentWillReact","__proto__","PureComponent","shouldComponentUpdate","bound","bind","makeClassComponentObserver","baseComponent","options","memoComponent","base","realOptions","observerLite","wrappedComponent","ref","memo","forEach","getOwnPropertyDescriptor","specialReactKeys","MobXProviderContext","createContext","Provider","constructor","context","grabStores","createElement","Children","only","prevState","from","res","validStoreName","createStoreInjector","grabStoresFn","injectNames","makeReactive","getInjectName","Injector","isStateless","InjectHocRef","storeKey","baseUnmountKey","runDisposersOnWillUnmount","propKeyOrFunction","createChainableTypeChecker","validate","checkType","isRequired","untracked","rest","chainedCheckType","getPropType","propValue","propType","Array","isArray","RegExp","isSymbol","createObservableTypeCheckerCreator","allowNativeType","mobxType","toLowerCase","mobxChecker","isObservableArray","isObservableObject","isObservableMap","preciseType","Date","getPreciseType","nativeTypeExpectationMessage","createObservableArrayOfTypeChecker","typeChecker","PropTypes","observable","rdBatched","configure","reactionScheduler","initialValue","observableRef","func","inputs","useMemo","computed","disposerGenerator","disposerRef","earlyDisposedRef","lazyCreateDisposer","earlyDisposal","newDisposer","useStaticRendering","storeNames","baseStores","storeName","grabStoresByName","join","disposeOnUnmount","propertyKeyOrFunction","map","c","getPrototypeOf","c2","componentWasAlreadyModified","componentWillUnmount"],"mappings":"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"}